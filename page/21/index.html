<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="撼地神牛">
<meta property="og:url" content="https://handishenniu.coding.me/page/21/index.html">
<meta property="og:site_name" content="撼地神牛">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="撼地神牛">






  <link rel="canonical" href="https://handishenniu.coding.me/page/21/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>撼地神牛</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?304ebec1c594afeac3282f7afb1f3448";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <meta name="baidu-site-verification" content="I6eGI4JjZi">
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    
    
    <a href="https://github.com/lystdio" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">撼地神牛</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

    <a href="https://github.com/lystdio" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2014/01/18/2014-01-18-cb-how-regular-expressions-work/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2014/01/18/2014-01-18-cb-how-regular-expressions-work/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">进阶正则表达式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2014-01-18 12:32:00" itemprop="dateCreated datePublished" datetime="2014-01-18T12:32:00+08:00">2014-01-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2014/01/18/how-regular-expressions-work.html" target="_blank">博客园</a>.</div>

<p>关于正则表达式，网上可以搜到一大片文章，我之前也搜集了一些资料，并做了排版整理，可以看这篇文章<a href="http://www.cnblogs.com/hustskyking/archive/2013/06/04/RegExp.html" target="_blank">http://www.cnblogs.com/hustskyking/archive/2013/06/04/RegExp.html</a>，作为基础入门讲解，这篇文章说的十分到位。</p><br><p>记得最开始学习正则，是使用 php 做一个爬虫程序。为了获取指定的信息，必须用一定的方式把有规律的数据匹配出来，而正则是首选。下面是当时写的爬虫程序的一个代码片段：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$regdata = &quot;/&lt;font size=&quot;\&quot;3\&quot;&quot;&gt;((?&lt;bf&gt;[^&lt;]*)&lt;br \=&quot;&quot;&gt;)&#123;0,1&#125;⊙(?&lt;bs&gt;.&#123;12&#125;)\S*\s/&quot;;</span><br><span class="line"></span><br><span class="line">//获取页面</span><br><span class="line">$html = file_get_contents(&apos;http://www.qnwz.cn/html/daodu/201107/282277.html&apos;);</span><br><span class="line">$html = iconv(&quot;GBK&quot;, &quot;UTF-8&quot;, $html);</span><br><span class="line">if ($html == &apos;&apos;) &#123;</span><br><span class="line">    die(&quot;&lt;hr&gt;出错：【错】无法打开《青年文摘》页面&lt;hr&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//匹配页面信息</span><br><span class="line">preg_match_all($regdata, $html, $mdata);</span><br><span class="line"></span><br><span class="line">print_r($mdata);</span><br></pre></td></tr></table></figure>
<p>当时写代码还真是欢乐多，什么都不懂，什么都是新知识，学起来津津有味。我觉得学习知识一定要把握最基本的原理，先把一个知识的大概轮廓搞清楚，然后学习怎么去使用他，完了就是深入学习，了解底层基础实现。很多人解决问题都是靠经验，这个当然很重要，但如果我们弄懂了一项技术最底层的实现，完全可以靠自己的推断分析出问题的根源。我对一些公司的招聘要求特别不满，说什么要三年五年Javascript编程经验云云，经验当然和时间成正相关，但是对于那些没有三年五年工作经验却照样能够解决实际的人呢？算是小小的吐槽吧，下面进入正题。</p><br><h3>一、正则表达式的工作机制</h3><br><p>画了一个草图，简单的说明了下正则表达式的工作原理。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    +--------+</span><br><span class="line">    |  编译  |</span><br><span class="line">    +--------+</span><br><span class="line">         |</span><br><span class="line">         ↓</span><br><span class="line">+----------------+</span><br><span class="line">|  设置开始位置    |←---------+</span><br><span class="line">+----------------+          ↑</span><br><span class="line">         |                  |</span><br><span class="line">         ↓               其 |</span><br><span class="line">+----------------+       他 |</span><br><span class="line">|  匹配 &lt; 回溯    |       路 |</span><br><span class="line">+----------------+       径 |</span><br><span class="line">         |                  |</span><br><span class="line">         ↓                  |</span><br><span class="line">+----------------+          |</span><br><span class="line">|  成功 or 失败   |---------→+</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure>
<p>你写的任何一个正则直接量或者 RegExp 都会被浏览器编译为一个原生代码程序，第一次匹配是从头个字符开始，匹配成功时，他会查看是否还有其他的路径没有匹配到，如果有的话，回退到上一次成功匹配的位置，然后重复第二步操作，不过此时开始匹配的位置（lastIndex）是上次成功位置加 1.</p>

<p>如果要深入了解正则表达式的内部原理，必须先理解匹配过程的一个基础环节&mdash;&mdash;回溯，他是驱动正则的一个基本动力，也是性能消耗、计算消耗的根源。</p><br><h3>二、回溯</h3><br><p>正则表达式中出现最多的是分支和量词，上面的 demo 中可以很清楚的看到 hi 和 hello 这两个分支，当匹配到第一个字符 h 之后，进入 (i|ello) 的分支选择，首先是进入 i 分支，当 i 分支匹配完了之后，再回到分支选择的位置，重新选择分支。简单点说，分支就是 <code>|</code> 操作符带来的多项选择问题，而量词指的是诸如 <code>*, +?, {m,n}</code> 之类的符号，正则表达式必须决定何时尝试匹配更多的字符。下面结合回溯详细说说分支和量词。</p><br><h4>1. 分支</h4><br><p>继续分析上面那个案例。<code>“Lalala. Hi, barret. Hello, John”.match(/H(i|ello), barret/g)</code>,首先会查找 H 字符，在第九位找到 H 之后，正则子表达式提供了两个选择 (i|ello)，程序会先拿到最左边的那个分支，进入分支后，在第十位匹配到了 i，接着匹配下一个字符，下一个字符是逗号，接着刚才的位置又匹配到了这个逗号，然后再匹配下一个，依次类推，直到完整匹配到整个正则的内容，此时程序会在<code>Hi, barret</code>后面做一个标记，表示在这里进行了一次成功的匹配。但程序到此并没有结束，因为后面加了一个全局参数，依然使用这个分支往后匹配，很显然，到了 Hello 的时候，Hi 分支匹配不了了，于是程序会回溯到刚才我们做标记的位置，并进入第二个分支，从做标记的位置重新开始匹配，依次循环。</p><br><p>只要正则表达式没有尝试完所有的可选项，他就会回溯到最近的决策点（也就是上次匹配成功的位置）。</p><br><h4>2. 量词</h4><br><p>量词这个概念特别简单，只是在匹配过程中有贪婪匹配和懒惰匹配两种模式，结合回溯的概念理解稍微复杂。还是用几个例子来说明。</p><br><p><strong>1) 贪婪</strong></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;AB1111BA111BA&quot;;</span><br><span class="line">reg = /AB[\s\S]+BA/;</span><br><span class="line">console.log(str.match(reg));</span><br></pre></td></tr></table></figure>
<p>首先是匹配AB，遇到了 <code>[\s\S]+</code>，这是贪婪模式的匹配，他会一口吞掉后面所有的字符，也就是如果 reg 的内容为 AB[\s\S]+，那后面的就不用看了，直接全部匹配，而往后看，正则后面还有B字符，所以他会先回溯到倒数第一个字符，匹配看是否为 B，显然倒数第一个字符不是B，于是他又接着回溯，找到了B字母，找到之后就不继续回溯了，而是往后继续匹配，此刻匹配的是字符A，程序发现紧跟B后的字母确实是A，那此时匹配就结束了。如果没有看明白，可以再读读下面这个图：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  REG: /AB[\s\S]+BA/</span><br><span class="line">MATCH: A               匹配第一个字符</span><br><span class="line">       AB              匹配第二个字符</span><br><span class="line">       AB1111BA111BA   [\s\S]+ 贪婪吞并所有字符</span><br><span class="line">       AB1111BA111BA   回溯，匹配字符B</span><br><span class="line">       AB1111BA111B    找到字符B，继续匹配A</span><br><span class="line">       AB1111BA111BA   找到字符A，匹配完成，停止匹配</span><br></pre></td></tr></table></figure>
<p><strong>2) 懒惰（非贪婪）</strong></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;AB1111BA111BA&quot;;</span><br><span class="line">reg = /AB[\s\S]+?BA/;</span><br><span class="line">console.log(str.match(reg));</span><br></pre></td></tr></table></figure>
<p>与上面不同的是，reg 中多了一个 ? 号，此时的匹配模式为懒惰模式，也叫做非贪婪匹配。此时的匹配流程是，先匹配AB，遇到[\s\S]+?，程序尝试跳过并开始匹配后面的字符B，往后查看的时候，发现是数字1，不是要匹配的内容，继续往后匹配，知道遇到字符B，然后匹配A，发现紧接着B后面就有一个A，于是宣布匹配完成，停止程序。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  REG: /AB[\s\S]+BA/</span><br><span class="line">MATCH: A               匹配第一个字符</span><br><span class="line">       AB              匹配第二个字符</span><br><span class="line">       AB              [\s\S]+? 非贪婪跳过并开始匹配B</span><br><span class="line">       AB1             不是B，回溯，继续匹配</span><br><span class="line">       AB11            不是B，回溯，继续匹配</span><br><span class="line">       AB111           不是B，回溯，继续匹配</span><br><span class="line">       AB1111          不是B，回溯，继续匹配</span><br><span class="line">       AB1111B         找到字符B，继续匹配A</span><br><span class="line">       AB1111BA        找到字符A，匹配完成，停止匹配</span><br></pre></td></tr></table></figure>
<p>如果匹配的内容是 AB1111BA，那贪婪和非贪婪方式的正则是等价的，但是内部的匹配原理还是有区别的。为了高效运用正则，必须搞清楚使用正则时会遇到那些性能消耗问题。</p><br><h3>三、逗比的程序</h3><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//去测试下这句代码</span><br><span class="line">&quot;TTTTTTTT&quot;.match(/(T+T+)+K/);</span><br><span class="line">//然后把前面的T重复次数改成30</span><br><span class="line">//P.S:小心风扇狂转，CPU暴涨</span><br></pre></td></tr></table></figure><br><br><p>我们来分析下上面这段代码，上面使用的都是贪婪模式，那么他会这样做：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  REG: (T+T+)+K</span><br><span class="line">MATCH: ①第一个T+匹配前7个T，第二个T+匹配最后一个T，没找到K，宣布失败，回溯到最开始位置</span><br><span class="line">       ②第一个T+匹配前6个T，第二个T+匹配最后两个T，没找到K，宣布失败，回溯到最开始位置</span><br><span class="line">       ③...</span><br><span class="line">       ... 接着还会考虑(T+T+)+后面的 + 号，接着另一轮的尝试。</span><br><span class="line">       ⑦...</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure>
<p>这段程序并不会智能的去检测字符串中是否存在 K，如果匹配失败，他会选择其他的匹配方式（路径）去匹配，从而造成疯狂的回溯和重新匹配，结果可想而知。这是回溯失控的典型例子。</p><br><h3>四、前瞻和反向引用</h3><br><h4>1. 前瞻和引用</h4><br><p>前瞻有两种，一种是负向前瞻，JS中使用 <code>(?!xxx)</code> 来表示，他的作用是对后面要匹配的内容做一个预判断，如果后面的内容是xxx，则此段内容匹配失败，跳过去重新开始匹配。另一种是正向前瞻，<code>(?=xxx)</code>，匹配方式和上面相反，还有一个长的类似的是 <code>(?:xxx)</code>,这个是匹配xxx，他是非捕获性分组匹配，即匹配的内容不会创建反向引用。具体内容可以去文章开头提到的文档中查看。</p><br><p>反向引用，这个在 replace 中用的比较多，在 replace 中：</p><br><table><br><thead><br><tr><th>字符</th><th>替换文本</th></tr><br></thead><br><tbody><br><tr><br><td>$1、$2、…、$99</td><br><td>与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。</td><br></tr><br><tr><br><td>$&amp;</td><br><td>与 regexp 相匹配的子串。</td><br></tr><br><tr><br><td>$`</td><br><td>位于匹配子串左侧的文本。</td><br></tr><br><tr><br><td>$’</td><br><td>位于匹配子串右侧的文本。</td><br></tr><br><tr><br><td>$$</td><br><td>直接量符号。</td><br></tr><br></tbody><br></table><br><p>而在正则表达中，主要就是 \1, \2 之类的数字引用。前瞻和反向引用使用恰当可以大大的减少正则对资源的消耗。举个例子来简单说明下这几个东西：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">问题：使用正则匹配过滤后缀名为 .css 和 .js 的文件。</span><br><span class="line">      如：test.wow.js test.wow.css test.js.js等等。</span><br></pre></td></tr></table></figure>
<p>有人会立马想到使用负向前瞻，即：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//过滤js文件</span><br><span class="line">/(?!.+\.js$).*/.exec(&quot;test.wow.js&quot;)</span><br><span class="line"></span><br><span class="line">//过滤js和css文件</span><br><span class="line">/(?!.+\.js$|.+\.css$).*/.exec(&quot;test.wow.js&quot;)</span><br><span class="line">/(?!.+\.js$|.+\.css$).*/.exec(&quot;test.wow.html&quot;)</span><br></pre></td></tr></table></figure>
<p>但是你自己去测试下，拿到的结果是什么。匹配非js和非css文件可以拿到正确的文件名，但是我们期望这个表达式对js和css文件的匹配结果是null，上面的表达式却做不到。问题是什么，因为(?!xxx)和(?=xxx)都会消耗字符，在做预判断的时候把 .js 和 .css 给消耗了，所以这里我们必须使用非捕获模式。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?:(?!.+\.js$|.+\.css$).)*/.exec(&quot;test.wow.html&quot;);</span><br><span class="line">/(?:(?!.+\.js$|.+\.css$).)*/.exec(&quot;test.wow.js&quot;);</span><br></pre></td></tr></table></figure>
<p>我们来分析下这个正则：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(?:(?!.+\.js$|.+\.css$).)*</span><br><span class="line">---   ----------------  -</span><br><span class="line"> |                |     |</span><br><span class="line"> +----------------------+</span><br><span class="line">             ↓    |</span><br><span class="line">非捕获，内部只有一个占位字符</span><br><span class="line">                  |</span><br><span class="line">                  ↓</span><br><span class="line">    负向前瞻以.js和.css结尾的字符串</span><br></pre></td></tr></table></figure>
<p>最后一个星号是贪婪匹配，直接吞掉全部字符。</p><br><p>这里讲的算是有点复杂了，不过在稍复杂的正则中，这些都是很基础的东西了，想在这方面提高的童鞋可以多研究下。</p><br><h4>2. 原子组</h4><br><p>JavaScript的正则算是比较弱的，他没有分组命名、递归、原子组等功能特别强的匹配模式，不过我们可以利用一些组合方式达到自己的目的。上面的例子中，我们实际上用正则实现了一个或和与的功能，上面的例子体现的还不是特别明显，再写个例子来展示下：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;我(wo)叫(jiao)李(li)靖(jing)&quot;;</span><br><span class="line">str2 = &quot;李(li)靖(jing)我(wo)叫(jiao)&quot;;</span><br><span class="line">reg = /(?=.*?我)(?=.*?叫)(?=.*?李)(?=.*?靖)/;</span><br><span class="line">console.log(reg.test(str1)); //true</span><br><span class="line">console.log(reg.test(str2)); //true</span><br></pre></td></tr></table></figure>
<p>不管怎么打乱顺序，只要string中包含\我”，\是”，\李”，\靖”这四个字，结果都是true。</p><br><p>类似(?=xxx)\1，就相当于一个原子组，原子组的作用就是消除回溯，只要是这种模式匹配过的地方，回溯时都不会到这里和他之前的地方。上面的程序<code>“TTTTTTTT”.match(/(T+T+)+K/);</code>可以通过原子组的方式处理：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;TTTTTTTT&quot;.match(/(?=(T+T+))\2+K/);</span><br></pre></td></tr></table></figure>
<p>如此便能彻底消除回溯失控问题。</p><br><h3>五、小结</h3><br><p>关于正则的学习，重点是要多练习多实践，并且多尝试用不同的方案去解决一个正则问题，一个很典型的例子，去除字符串首尾的空白，尝试用5-10种不同的正则去测试，并思考哪些方式的效率最高，为什么？通过这一连串的思考可以带动学习的兴趣，提高学习效率~</p>


<p>相关文章：<a href="http://www.barretlee.com/blog/2013/10/07/cb-javascript-regexp/" target="_blank" rel="noopener">玩转正则之Highlight代码高亮</a></p>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2014/01/13/2014-01-13-cb-user-exprience-in-login-box/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2014/01/13/2014-01-13-cb-user-exprience-in-login-box/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">从登录框看前端</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2014-01-13 03:30:00" itemprop="dateCreated datePublished" datetime="2014-01-13T03:30:00+08:00">2014-01-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/网络交互/" itemprop="url" rel="index"><span itemprop="name">网络交互</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2014/01/13/user-exprience-in-login-box.html" target="_blank">博客园</a>.</div>

<p>我们会骂 12306 的网站界面挫，效果差，速度慢，回头看看自己写的代码，是不是也一样的狗血！在前端，很多看似简单的东西，内藏无数玄机。本文将以一个小小的登录框为入口，谈一谈如何完善自己的程序。</p><br><p>在很多人眼里，前端就是 DIV+CSS+JQuery，甚至还有些人停留在 table 布局的迷雾当中（这些人应该跟 IE6 一样，随着历史渐渐被尘封）。但，前端绝不是你所看到的那样。举个例子，登录页面几乎是每一个系统不可或缺的模块，很多娴熟的人可以在一刻钟之内写好一个登录页面，两个 input，一个提交 button，万事 OK。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Username: &lt;input type=&quot;text&quot;&gt;&lt;br&gt;</span><br><span class="line">Password: &lt;input type=&quot;password&quot;&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;sbumit&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>当然，作为一个完成登录验证的页面，这几个元素完全可以胜任，但我只能说你完成了一个可以用的页面，这种页面完全没有用户体验可言，完全不符合一个具有的严谨的思维的程序员的作风！</p><br><p>本文地址：<a href="http://www.cnblogs.com/hustskyking/p/user-exprience-in-login-box.html" target="_blank">http://www.cnblogs.com/hustskyking/p/user-exprience-in-login-box.html</a></p><br><h3>一、一切以良好用户体验为基础</h3><br><h4>1. 视觉效果</h4><br><p>界面的设计就不用多说了，一般情况这个属于美工的活儿，这里要谈的是几个最基础的点。</p><br><p>第一，你的页面兼容性如何？各个元素的长宽、行高等在不同浏览器上是否表现一致，如果这个都没有保证，那一定是不合格的。</p><br><p>第二，移动终端上的体验问题，如今很多页面 PC 和移动终端都用的一套结构，也就是我们所说的响应式布局，本博客就使用了响应式布局，缩小窗口可以看到效果，响应式布局是为了让不同的移动终端也能得到同样的优质体验，可是很多开发者却忽略了横屏时的效果。下面是常见的几个移动终端的像素比例：</p><br><table><br><thead><br><tr><th>Mobile</th><th>px rate</th></tr><br></thead><br><tbody><br><tr><br><td>Iphone5</td><br><td>320<em>568</em></td><br></tr><br><tr><br><td>Iphone4</td><br><td>320480</td><br></tr><br><tr><br><td>Galaxy S 3/4</td><br><td>360<em>640</em></td><br></tr><br><tr><br><td>Lumia 920</td><br><td>384640</td><br></tr><br><tr><br><td>iPad</td><br><td>768*1024</td><br></tr><br></tbody><br></table><br><p>照顾用户的响应式布局除了要考虑这些屏幕的横屏，还得把竖屏考虑进去。我简单的做了一个登陆页面：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2014/01/13/131712295330.jpg" data-source="http://images.cnitblog.com/blog/387325/201401/131712295330.jpg" alt=""></p><br><p>正确的账号是：barret，密码是：123，你可以用错误的信息先去测试下~</p><br><p>可以戳这个DEMO：<a href="http://qianduannotes.duapp.com/demo/login/login.html" target="_blank">http://qianduannotes.duapp.com/demo/login/login.html</a></p><br><h4>2. 交互</h4><br><p>前面那种方式，点击提交按钮，送到后台去验证，验证没有通过则回到登录页面，这也算是一种交互，不过这种交互的体验是特别不好的，每次都得重新刷新页面，应该利用 ajax 异步去验证表单。为了省去用户的聚焦点击，可以按照下面的思路来做：</p><br><ol><br><li>用户名为空，或者格式不对 -》 提示错误，清空密码框，聚焦到用户名框，并全选用户名</li><br><li>用户名不存在 -》同上</li><br><li>密码错误 -》 提示错误，清空密码框，聚焦密码框</li><br><li>聚焦到密码框，全选密码</li><br></ol><br><p>告诉用户哪个地方出了问题，并提前预知用户遇到这些问题之后会做哪些事情，我们能够用程序解决的事情，绝不麻烦用户亲自动手操作。当提示用户名错误的时候，用户肯定会回到输入框重新输入，这个时候我们已经聚焦到用户框，并全选了之前的输入，方面用户进行删除操作。类似这样的交互，我们应该提前做预判断。</p><br><h4>3. 状态提示</h4><br><p>什么是状态提示？有时候因为网络原因，点击提交 button 之后，ajax 传输半天没有响应，用户等了半天页面一点提示都没有，这个肯定会让用户焦急的。回头看看 Gmail，一个把 ajax 发挥到极致的 web应用，在用户体验上做的也是相当给力的，登录邮箱的时候一个 loading 动画，旁边还放了一个加载基本HTML（供慢速网络使用），每一个操作都有提示，提示中还有一个撤销操作的按钮，数据进行加载的时候，如果加载时间过长，期间会进行多次不同的提示，并在最后给出一个确切的结果，对于一个登录框而言，需要做到这些：</p><br><ol><br><li>一个明确的用于状态提示的 box</li><br><li>等待 3s，结果没有出来，提示用户继续等待</li><br><li>等待 6s，结果没有出来，提示用户网络不畅通</li><br><li>设置 10s 为超时，并告知用户提交表单失败</li><br></ol><br><p>这些东西的实现并没有太多的技术难度，但是可以给慢速网络下的用户带来很好的体验和安全感。</p><br><h4>4. 安全传输</h4><br><p>用户最担心的是账号密码被截获，或者因为密码一处多用，不希望别人看到密码的明文，既然用户担心，我们就应该想办法来处理。</p><br><p>把密码和时间戳叠加，然后加密，传到后台的是加密的结果以及这个时间戳，如下：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 前端</span><br><span class="line">t = new Date();</span><br><span class="line">s = encode(pwd + t);</span><br><span class="line">post(s, t)</span><br><span class="line"></span><br><span class="line">// 后台</span><br><span class="line">decode(s) === pwd + t</span><br></pre></td></tr></table></figure>
<p>这样就可以保证密码的隐蔽性，如果 hacker 不知道 decode 函数，即便是拿到了 s 和 t，也是徒劳。关于安全传输，之前也写过相关的文章，<a href="http://www.cnblogs.com/hustskyking/p/authentication-in-web.html" target="_blank">OAuth认证原理及HTTP下的密码安全传输</a>。如果要做到在用户输入的时候就绝对安全，那就必须使用类似 支付宝安全插件 这样的东西了。他的原理就是在页面中嵌入一个控件，这个控件与页面之间是相互屏蔽的，在控件内部输入也只有控件拿得到输入信息。</p><br><h4>5. 数据走缓存</h4><br><p>表单提交首选应该是 post，但是也不排除会用 get 方式提交，那么这个时候就应该考虑数据缓存了，如果请求的 url 相同，程序就会直接从浏览器的缓存中拿数据，并给出状态是 <code>status: 200 OK(from cache)</code>，为了避免这些常识性的问题，记得在请求的参数中加点东西。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_t = new Date*1</span><br><span class="line">_n = Math.random</span><br></pre></td></tr></table></figure>
<p>为了保证参数的绝对唯一性，甚至可以把 时间戳 和随机数叠加起来用</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_s = (new Date*1 + Math.random*1E5)/1E5</span><br></pre></td></tr></table></figure>
<p></p><h4>6. 渐进增强</h4><p></p>
<p>渐进增强这个词一般是，不支持 javascript 或者对 javascript 支持度不太好的浏览器上利用其它方式实现，或者告诉用户什么原因不能用，就是一种蜕化处理。目前不支持 javascript 的浏览器应该是绝迹了，当然也不是绝对，kindle 内置的浏览器对 javascript 的支持度就不高，或者根本就不支持。还有一种情况是用户禁用了 javascript，这个比例很小，开发者会这么干，一般的用户不会乱改浏览器设置。但是我们的程序，尤其是关键的部位（如搜索，登录，注册等）必须要考虑这一少部分群体。一般采用的方式是：</p><br><p>1）使用 noscript 标签，这个是最常用，也是最实用的。</p><br><p>2）hack 方式，document.write(“&lt;” + “!–”)</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(&quot;&lt;&quot; +=&quot;&quot; &quot;!--&quot;);=&quot;&quot; code...=&quot;&quot; 如果浏览器不支持=&quot;&quot; javascript，将显示这中间的内容=&quot;&quot; document.write(&quot;--&quot;=&quot;&quot; &quot;=&quot;&quot;&gt;&quot;);</span><br></pre></td></tr></table></figure>
<p>&lt;/“&gt;</p>
<p>这是一种特别巧妙的处理手段，也是值得推荐的。</p><br><h4>7. 浏览器后退按钮</h4><br><p>这个在注册或者登陆的时候是一个普遍的问题，登陆之后，跳转到另外一个页面，我的鼠标有两个侧键，是用于前进和后退的，有时候会误点侧键，这个时候页面又会回到之前的登录页面，但事实是用户已经登录了，所有页面的状态都应该是已登录的，不管什么情况下都不应该让用户在看到这个页面。用户的点击操作会引发上面的问题，而程序 <code>history.go(-1) &lt; history.back()</code> 也会有一样的bug。</p><br><p>这样的问题处理方案比较简单，ajax 拿到 success 的状态码时立刻做跳转，但是这里不能用 <code>window.location.href</code>，这样浏览器还是会记录这个登录历史，应该使用 <code>window.location.replace</code>，替换当前历史记录。</p><br><h4>8. 记住密码</h4><br><p>用户最烦的就是每次登录页面都要输入长长的账号密码，如果没有勾选\记住密码”，则用户的登录状态保存在回话的 session 中，关闭页面或者浏览器的时候，回话结束，session 被删除，这样当用户下次登录的时候又需要重新输入密码。表单页面的\记住密码”复选框默认状态应该是已选择，用户的潜意识行为都是要少操作的。</p><br><p>当用户提交信息成功之后，直接在 cookie 中保存账号密码？这样的做法显然是不合理的，密码怎么能够明文保存呢，有人会想到加密处理密码然后再保存，或者使用服务器来设置 cookie，这些做法都是可以的，不过最好的方式是，当用户成功提交信息时，服务器给前端提供一个 token，这个 token 是用于自动登录的，我们只需要保存 token 就行了，这样就很好的避免了 cookie 中存放用户隐私信息了。</p><br><p>还有一个要注意的是，当用户取消了\记住密码”的复选框时，应该立即清除相关 cookie。</p><br><h3>二、其他相关的几个点</h3><br><h4>1. 用户忘记密码</h4><br><p>如果用户很长时间没有来你的网站，他可能会忘记自己设置的密码，一些奇葩的用户甚至会忘记自己的用户名，但是用户永远是没有错的，出错的只有我们的程序和写程序的人。对于忘记密码的人，可以在填写密码的旁边加上一个链接 \忘记密码？”，让用户利用邮箱或者绑定的手机来找到密码，对于忘记密码以及用户名的人，内伤中… <span>@undefined</span> 13# 14# 正解</p><br><h4>2. 脚本注入</h4><br><p>表单信息应该做正则匹配，或者信息的过滤，防止脚本注入，这个主要是后台要考虑的问题，就不多说了。</p><br><h4>3. 多次提交</h4><br><p>我们发微博的时候经常会遇到的问题，因为网络原因，会多次点击发布按钮，这个问题有多种处理方案：</p><br><ul><br><li>发布之前先从服务器拿 token，该 token 只有一次有效</li><br><li>后端判断一定时间内用户发布的多条信息，相同的信息去重</li><br><li>…</li><br></ul><br><h3>三、容易出错的几个知识点</h3><br><h4>1. setRequestHeader</h4><br><p>利用 ajax 来 post 信息，有的人可能遇到过，后台拿不到数据。原因是没有重写 请求头的 Content-Type，</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;POST&quot;, url, true);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xhr.send($.param(&#123;</span><br><span class="line">    &quot;user&quot;:$(&quot;#user&quot;).val(),</span><br><span class="line">    &quot;pwd&quot;:$(&quot;#pwd&quot;).val()</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>一般浏览器不支持 GET 方式时 xhr.send 中添加参数，但是 POST 是可以，也是必须的，如果没有设置 Content-Type 的头部，数据送到后端便没办法解析成 key-value 的模式，后台(PHP)通过 $_POST 也拿不到数据。</p><br><h4>2. checkbox</h4><br><p>这里也是一个体验问题，一些人把 checkbox 和他相关的文字分开写，结果没有使用 label 来指向，如：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;记住密码</span><br></pre></td></tr></table></figure>
<p>很显然，我们点击后面的文字是不会让 input 改变状态的，有些人会这么处理：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;记住密码&lt;/label&gt;</span><br></pre></td></tr></table></figure>
<p>这样处理之后，点击文字当然可以选中 input，但是这种处理方式是不合理的，label 本来就是标记 input 框用的，他的内容应该是文字，不应该包含 input 这个框，所以合理的做法应该是这样：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;rem&quot;&gt;</span><br><span class="line">&lt;label for=&quot;rem&quot;&gt;记住密码&lt;/label&gt;</span><br></pre></td></tr></table></figure>
<p></p><h3>四、小结</h3><p></p>
<p>上面说了一大堆，很多问题都是站在用户的角度去思考的，我们是程序员，但是我们也是用户，我们会吐槽，但是我们也会被吐槽。</p><br><p>把用户体验做到极致，这个十分重要，不要放过任何一个细节！</p>






          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2014/01/05/2014-01-05-cb-javascript-asynchronous-programming/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2014/01/05/2014-01-05-cb-javascript-asynchronous-programming/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">JavaScript异步编程原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2014-01-05 11:01:00" itemprop="dateCreated datePublished" datetime="2014-01-05T11:01:00+08:00">2014-01-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2014/01/05/javascript-asynchronous-programming.html" target="_blank">博客园</a>.</div>

<p>众所周知，JavaScript 的执行环境是单线程的，所谓的单线程就是一次只能完成一个任务，其任务的调度方式就是排队，这就和火车站洗手间门口的等待一样，前面的那个人没有搞定，你就只能站在后面排队等着。在事件队列中加一个延时，这样的问题便可以得到缓解。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A: 嘿，哥们儿，快点！</span><br><span class="line">B: 我要三分钟，你先等着，完了叫你~</span><br><span class="line">A: 好的，记得叫我啊~ 你（C）也等着吧，完了叫你~</span><br><span class="line">C: 嗯！</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>告诉后面排队的人一个准确的时间，这样后面的人就可以利用这段时间去干点别的事情，而不是所有的人都排在队列后抱怨。我写了一段程序来解决这个问题：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author Barret Lee</span><br><span class="line">* @email barret.china@gmail.com</span><br><span class="line">* @description 事件队列管理，含延时</span><br><span class="line">*/</span><br><span class="line">var Q = &#123;</span><br><span class="line">    // 保存队列信息</span><br><span class="line">    a: [],</span><br><span class="line">    // 添加到队列 queue</span><br><span class="line">    q: function(d)&#123;</span><br><span class="line">        // 添加到队列如果不是函数或者数字则不处理</span><br><span class="line">        if(!/function|number/.test(typeof d)) return;</span><br><span class="line"></span><br><span class="line">        Q.a.push(d);</span><br><span class="line">        // 返回对自身的引用</span><br><span class="line">        return Q;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 执行队列 dequeue</span><br><span class="line">    d: function()&#123;</span><br><span class="line">        var s = Q.a.shift();</span><br><span class="line">        // 如果已经到了队列尽头则返回</span><br><span class="line">        if(!s) return;</span><br><span class="line"></span><br><span class="line">        // 如果是函数，直接执行，然后继续 dequeue</span><br><span class="line">        if(typeof s === &quot;function&quot;) &#123;</span><br><span class="line">            s(), Q.d();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果是数字，该数字作为延迟时间，延迟 dequeue</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            Q.d();</span><br><span class="line">        &#125;, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段程序加了很多注释，相信有 JS 基础的童鞋都能够看懂，利用上面这段代码测试下：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 进程记录函数</span><br><span class="line">function record(s)&#123;</span><br><span class="line">    var div = document.createElement(&quot;div&quot;);</span><br><span class="line">    div.innerHTML = s;</span><br><span class="line">    console.log(s);</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q</span><br><span class="line">.q(function()&#123;</span><br><span class="line">    record(&quot;0 &lt;i&gt;3s 之后搞定，0 把 1 叫进来&lt;/i&gt;&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.q(3000)  // 延时 3s</span><br><span class="line">.q(function()&#123;</span><br><span class="line">    record(&quot;1 &lt;i&gt;2s 之后搞定，1 把 2 叫进来&lt;/i&gt;&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.q(2000)  // 延时 2s</span><br><span class="line">.q(function()&#123;</span><br><span class="line">    record(&quot;2 &lt;span&gt;后面没人了，OK，厕所关门~&lt;/span&gt;&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.d();     // 执行队列</span><br></pre></td></tr></table></figure>
<p>可以戳戳这个 <a href="http://qianduannotes.duapp.com/demo/ansyc/" target="_blank">DEMO</a>。也可以直接运行这段程序：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @author Barret Lee</span><br><span class="line">* @email barret.china@gmail.com</span><br><span class="line">* @description 事件队列管理，含延时</span><br><span class="line">*/</span><br><span class="line">var Q = &#123;</span><br><span class="line">    // 保存队列信息</span><br><span class="line">    a: [],</span><br><span class="line">    // 添加到队列 queue</span><br><span class="line">    q: function(d)&#123;</span><br><span class="line">        // 添加到队列如果不是函数或者数字则不处理</span><br><span class="line">        if(!/function|number/.test(typeof d)) return;</span><br><span class="line"></span><br><span class="line">        Q.a.push(d);</span><br><span class="line">        // 返回对自身的引用</span><br><span class="line">        return Q;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 执行队列 dequeue</span><br><span class="line">    d: function()&#123;</span><br><span class="line">        var s = Q.a.shift();</span><br><span class="line">        // 如果已经到了队列尽头则返回</span><br><span class="line">        if(!s) return;</span><br><span class="line"></span><br><span class="line">        // 如果是函数，直接执行，然后继续 dequeue</span><br><span class="line">        if(typeof s === &quot;function&quot;) &#123;</span><br><span class="line">            s(), Q.d();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果是数字，该数字作为延迟时间，延迟 dequeue</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">             Q.d();</span><br><span class="line">        &#125;, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function record(s)&#123;</span><br><span class="line">    var div = document.createElement(&quot;div&quot;);</span><br><span class="line">    div.innerHTML = s;</span><br><span class="line">    console.log(s);</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line">Q</span><br><span class="line">.q(function()&#123;</span><br><span class="line">    record(&quot;0 &lt;i&gt;3s 之后搞定，0 把 1 叫进来&lt;/i&gt;&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.q(3000)</span><br><span class="line">.q(function()&#123;</span><br><span class="line">    record(&quot;1 &lt;i&gt;2s 之后搞定，1 把 2 叫进来&lt;/i&gt;&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.q(2000)</span><br><span class="line">.q(function()&#123;</span><br><span class="line">    record(&quot;2 &lt;span&gt;后面没人了，OK，厕所关门~&lt;/span&gt;&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.d();</span><br><span class="line"></span><br><span class="line">//事件队列管理，含延时</span><br></pre></td></tr></table></figure>
<p><span>&nbsp;</span></p><br><p>本文地址：<a href="http://www.cnblogs.com/hustskyking/p/javascript-asynchronous-programming.html" target="_blank">http://www.cnblogs.com/hustskyking/p/javascript-asynchronous-programming.html</a>，转载请注明出处。</p><br><h3>一、Javascript 异步编程原理</h3><br><p>显然，上面这种方式和银行取号等待有些类似，只不过银行取号我们并不知道上一个人需要多久才会完成。这是一种非阻塞的方式处理问题。下面来探讨下 JavaScript 中的异步编程原理。</p><br><h4>1. setTimeout 函数的弊端</h4><br><p>延时处理当然少不了 setTimeout 这个神器，很多人对 setTimeout 函数的理解就是：延时为 n 的话，函数会在 n 毫秒之后执行。事实上并非如此，这里存在三个问题，一个是 setTimeout 函数的及时性问题，可以测试下面这串代码：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date, count = 0, f, timer;</span><br><span class="line">timer = setInterval(f = function ()&#123;</span><br><span class="line">    if(new Date - d &gt; 1000)</span><br><span class="line">        clearInterval(timer), console.log(count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;, 0);</span><br></pre></td></tr></table></figure>
<p>可以看出 1s 中运行的次数大概在 200次 左右，有人会说那是因为 new Date 和 函数作用域的转换消耗了时间，其实不然，你可以再试试这段代码：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date, count = 0;</span><br><span class="line">while(true) &#123;</span><br><span class="line">    if(new Date - d &gt; 1000) &#123;</span><br><span class="line">        console.log(count);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这里显示的是 351813，也就是说 count 累加了 35W+ 次，这说明了什么呢？setInterval 和 setTimeout 函数运转的最短周期是 5ms 左右，这个数值在 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout" target="_blank" rel="noopener">HTML规范</a> 中也是有提到的:</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5. Let timeout be the second method argument, or zero if the argument was omitted.</span><br><span class="line">如果 timeout 参数没有写，默认为 0</span><br><span class="line">7. If nesting level is greater than 5, and timeout is less than 4, then increase timeout to 4.</span><br><span class="line">如果嵌套的层次大于 5 ，并且 timeout 设置的数值小于 4 则直接取 4.</span><br></pre></td></tr></table></figure>
<p>为了让函数可以更快速的相应，部分浏览器提供了更加高级的接口（当 timeout 为 0 的时候，可以使用下面的方式替代，速度更快）：</p><br><ul><br><li>requestAnimationFrame 它允许 JavaScript 以 60+帧/s 的速度处理动画，<span>他的运行时间间隔比 setTimeout 是要短很多的。</span> <span>@司徒正美</span>，他适合动画，使用他可以在 tab 失去焦点或者最小化的时候减缓运动，从而节省 CPU 资源，他的运行间隔确实比 setTimeout 要长。<span></span></li><br><li>process.nextTick 这个是 NodeJS 中的一个函数，利用他可以几乎达到上面看到的 while 循环的效率</li><br><li>ajax 或者 插入节点 的 readyState 变化</li><br><li>MutationObserver 大约 2-3ms</li><br><li>setImmediate &nbsp;</li><br><li>postMessage 这个相当快</li><br><li>…</li><br><br></ul><br><p>这些东西下次有空再细谈。之前研究<a href="http://www.cnblogs.com/rubylouvre" target="_blank">司徒正美</a>的 avalon 源码的时候，看到了相关的内容，有兴趣的可以看看：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//视浏览器情况采用最快的异步回调</span><br><span class="line">var BrowserMutationObserver = window.MutationObserver || window.WebKitMutationObserver</span><br><span class="line">if (BrowserMutationObserver) &#123; //chrome18+, safari6+, firefox14+,ie11+,opera15</span><br><span class="line">    avalon.nextTick = function(callback) &#123; //2-3ms</span><br><span class="line">        var input = DOC.createElement(&quot;input&quot;)</span><br><span class="line">        var observer = new BrowserMutationObserver(function(mutations) &#123;</span><br><span class="line">            mutations.forEach(function() &#123;</span><br><span class="line">                callback()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        observer.observe(input, &#123;</span><br><span class="line">            attributes: true</span><br><span class="line">        &#125;)</span><br><span class="line">        input.setAttribute(&quot;value&quot;, Math.random())</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else if (window.VBArray) &#123;</span><br><span class="line">//IE下这个通常只要1ms,而且没有副作用，不会发现请求，</span><br><span class="line">//setImmediate如果只执行一次，与setTimeout一样要140ms上下</span><br><span class="line">    avalon.nextTick = function(callback) &#123;</span><br><span class="line">        var node = DOC.createElement(&quot;script&quot;)</span><br><span class="line">        node.onreadystatechange = function() &#123;</span><br><span class="line">            callback() //在interactive阶段就触发</span><br><span class="line">            node.onreadystatechange = null</span><br><span class="line">            root.removeChild(node)</span><br><span class="line">            node = null</span><br><span class="line">        &#125;</span><br><span class="line">        root.appendChild(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    avalon.nextTick = function(callback) &#123;</span><br><span class="line">        setTimeout(callback, 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面说了一堆，目的是想说明， setTimeout 是存在一定时间间隔的，并不是设定 n 毫秒执行，他就是 n 毫秒执行，可能会有一点时间的延迟（2ms左右）。然后说说他的第二个缺点，先看代码：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&quot;show me after 1s, but you konw:&quot; + (new Date - d));</span><br><span class="line">&#125;, 1000);</span><br><span class="line">while(1) if(new Date - d &gt; 2000) break;</span><br></pre></td></tr></table></figure>
<p>我们期望 console 在 1s 之后出结果，可事实上他却是在 2075ms 之后运行的，这就是 JavaScript 单线程给我们带来的烦恼，while循环阻塞了 setTimeout 函数的执行。接着是他的第三个毛病，try..catch捕捉不到他的错误：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        throw new Error(&quot;我不希望这个错误出现！&quot;)</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125; catch(e)&#123;</span><br><span class="line">    console.log(e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以说 setTimeout 是异步编程不可缺少的角色，但是它本身就存在这么多的问题，这就要求我们用更加恰当的方式去规避！</p><br><h4>2. 什么样的函数为异步的</h4><br><p>异步的概念和非阻塞是是息息相关的，我们通过 ajax 请求数据的时候，一般采用的是异步的方式：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;GET&apos;, &apos;/&apos;, true);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    console.log(xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 xhr.open 中我们把第三个参数设置为 true ，也就是异步加载，当 state 发生改变的时候，xhr 立即响应，触发相关的函数。有人想过用这样的方式来处理：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(1) &#123;</span><br><span class="line">    if(xhr.status === &quot;complete&quot;) &#123;</span><br><span class="line">        // dosomething();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而事实上，这里的判断已经陷入了死循环，即便是 xhr 的 status 已经发生了改变，这个死循环也跳不出来，那么这里的异步是基于事件的。</p><br><blockquote><br><p>某个函数会导致将来再运行的另一个函数，后者取自于事件队列（若后面这个函数是作为参数传递给前者的，则称其为回调函数，简称为回调）。<cite>&mdash;&mdash; 摘自《Async Javascript》</cite></p><br></blockquote><br><p>由于 JavaScript 的单线程特点，他没有提供一种机制以阻止函数在其异步操作结束之前返回，事实上，除非函数返回，否则不会触发任何异步事件。</p><br><h4>3. 常见的异步模型</h4><br><p>1） 最常见的一种方式是，高阶函数（泛函数）</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">step1(function(res1)&#123;</span><br><span class="line">    step2(function(res2)&#123;</span><br><span class="line">        step3(function(res3)&#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>解耦程度特别低，如果送入的参数太多会显得很乱！这是最常见的一种方式，把函数作为参数送入，然后回调。</p><br><p>2） 事件监听</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E.on(&quot;evt&quot;, g);</span><br><span class="line">function f()&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        E.trigger(&quot;evt&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS 和 浏览器提供的原生方法基本都是基于事件触发机制的，耦合度很低，不过事件不能得到流程控制。</p><br><p>3） 发布/订阅( Pub/Sub )</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E.subscribe(&quot;evt&quot;, g);</span><br><span class="line">function f()&#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">　　    // f的任务代码</span><br><span class="line">　　    E.publish(&quot;evt&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把事件全部交给 E 这个控制器管理，可以完全掌握事件被订阅的次数，以及订阅者的信息，管理起来特别方便。</p><br><p>4） Promise 对象（deferred 对象）</p><br><p>关于这里的内容可以看看 <a href="//www.imququ.com/post/promises-when-js.html" target="_blank">屈屈</a> 写的文章，说的比较详细。</p><br><p><a href="http://promisesaplus.com/" target="_blank">Promise/A+</a> 规范是对 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank">Promise/A</a> 规范的补充和修改，他出现的目的是为了统一异步编程中的接口，JS中的异步编程是十分普遍的事情，也出现了很多的异步库，如果不统一接口，对开发者来说也是一件十分痛苦的事情。</p><br><p>在Promises/A规范中，每个任务都有三种状态：默认(pending)、完成(fulfilled)、失败(rejected)。</p><br><ul><br><li>默认状态可以单向转移到完成状态，这个过程叫resolve，对应的方法是deferred.resolve(promiseOrValue)；</li><br><li>默认状态还可以单向转移到失败状态，这个过程叫reject，对应的方法是deferred.reject(reason)；</li><br><li>默认状态时，还可以通过deferred.notify(update)来宣告任务执行信息，如执行进度；</li><br><li>状态的转移是一次性的，一旦任务由初始的pending转为其他状态，就会进入到下一个任务的执行过程中。</li><br></ul><br><h3>二、异步函数中的错误处理</h3><br><p>前面已经提到了 setTimeout 函数的一些问题，JS 中的 try..catch 机制并不能拿到 setTimeout 函数中出现的错误，一个 throw error 的影响范围有多大呢？我做了一个测试：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    throw new Error(&quot;error&quot;);</span><br><span class="line">    console.log(&quot;show me&quot;); // 并没有打印出来</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    console.log(&quot;show me&quot;); // 打印出来了</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>从上面的测试我们可以看出，<code>throw new Error</code> 的作用范围就是阻断一个 script 标签内的程序运行，但是不会影响下面的 script。这个测试没什么作用，只是想告诉大家不要担心一个 Error 会影响全局的函数执行。所以把代码分为两段，一段可能出错的，一段确保不会出错的，这样不至于让全局代码都死掉，当然这样的处理方式是不可取的。</p><br><p>庆幸的是 window 全局对象上有一个便利的函数，<code>window.error</code>，我们可以利用他捕捉到所有的错误，并作出相应的处理，比如：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function(msg, url, line)&#123;</span><br><span class="line">    console.log(msg, url, line);</span><br><span class="line">    // 必须返回 true，否则 Error 还是会触发阻塞程序</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    throw new Error(&quot;error&quot;);</span><br><span class="line">    // console：</span><br><span class="line">    //Uncaught Error: error path/to/ie6bug.html 99  </span><br><span class="line">&#125;, 50);</span><br></pre></td></tr></table></figure>
<p>我们可以对错误进行封装处理：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function(msg, url, line)&#123;</span><br><span class="line">    // 截断 &quot;Uncaught Error: error&quot;，获取错误类型</span><br><span class="line">    var type = msg.slice(16);</span><br><span class="line">    switch(type)&#123;</span><br><span class="line">        case &quot;TooLarge&quot;:</span><br><span class="line">            console.log(&quot;The number is too large&quot;);</span><br><span class="line">        case &quot;TooSmall&quot;:</span><br><span class="line">            console.log(&quot;The number is too Small&quot;);</span><br><span class="line">        case &quot;TooUgly&quot;:</span><br><span class="line">            console.log(&quot;That&apos;s Barret Lee~&quot;);</span><br><span class="line">        // 如果不是我们预定义的错误类型，则反馈给后台监控</span><br><span class="line">        default:</span><br><span class="line">            $ &amp;&amp; $.post &amp;&amp; $.post(&#123;</span><br><span class="line">                &quot;msg&quot;: msg,</span><br><span class="line">                &quot;url&quot;: url,</span><br><span class="line">                &quot;line&quot;: line</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 记得这里要返回 true，否则错误阻断程序。</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    if( something )  throw new Error(&quot;TooUgly&quot;);</span><br><span class="line">    // console：</span><br><span class="line">    //That&apos;s Barret Lee~ </span><br><span class="line">&#125;, 50);</span><br></pre></td></tr></table></figure>
<p>很显然，报错已经不可怕了，利用 window 提供的 onerror 函数可以很方便地处理错误并作出及时的反应，如果出现了不可知的错误，可以把信息 post 到后台，这也算是一个十分不错的监控方式。</p><br><p>不过这样的处理存在一个问题，所有的错误我们都给屏蔽了，但有些错误本应该阻断所有程序的运行的。比如我们通过 ajax 获取数据中出了错误，程序误以为已经拿到了数据，本应该停下工作报出这个致命的错误，但是这个错误被 window.onerror 给截获了，从而进行了错误的处理。</p><br><p>window.onerror 算是一种特别暴力的容错手段，try..catch 也是如此，他们底层的实现就是利用 C/C++ 中的 goto 语句实现，一旦发现错误，不管目前的堆栈有多深，不管代码运行到了何处，直接跑到 顶层 或者 try..catch 捕获的那一层，这种一脚踢开错误的处理方式并不是很好，我觉得。</p><br><h3>三、JavaScript 多线程技术介绍</h3><br><p>开始说了异步编程和非阻塞这个概念密切相关，而 JavaScript 中的 Worker 对象可以创建一个独立线程来处理数据，很自然的处理了阻塞问题。我们可以把繁重的计算任务交给 Worker 去倒腾，等他处理完了再把数据 Post 过来。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var worker = new Worker(&quot;./outer.js&quot;);</span><br><span class="line">worker.addEventListener(&quot;message&quot;, function(e)&#123;</span><br><span class="line">    console.log(e.message);</span><br><span class="line">&#125;);</span><br><span class="line">worker.postMessage(&quot;data one&quot;);</span><br><span class="line">worker.postMessage(&quot;data two&quot;);</span><br><span class="line"></span><br><span class="line">// outer.js</span><br><span class="line">self.addEventListener(&quot;message&quot;, function(e)&#123;</span><br><span class="line">    self.postMessage(e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面是一个简单的例子，如果我们创建了多个 Worker，在监听 onmessage 事件的时候还要判断下 e.target 的值从而得知数据源，当然，我们也可以把数据源封装在 e.message 中。</p><br><p>Worker 是一个有用的工具，我可以可以在 Worker 中使用 setTimeout，setInterval等函数，也可以拿到 navigator 的相关信息，最重要的是他可以创建 ajax 对象和 WebSocket 对象，也就是说他可以直接向服务器请求数据。不过他不能访问 DOM 的信息，更不能直接处理 DOM，这个其实很好理解，主线程和 Worker 是两个独立的线程，如果两者都可以修改 DOM，那岂不是得设置一个麻烦的互斥变量？！还有一个值得注意的点是，在 Worker 中我们可以使用 importScript 函数直接加载脚本，不过这个函数是同步的，也就是说他会冻结 Worker 线程，直到 Script 加载完毕。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScript(&quot;a.js&quot;, &quot;b.js&quot;, &quot;c.js&quot;);</span><br></pre></td></tr></table></figure>
<p>他可以添加多个参数，加载的顺序就是 参数的顺序。一般会使用 Worker 做哪些事情呢？</p><br><ul><br><li>数据的计算和加密 如计算斐波拉契函数的值，特别费时；再比如文件的 MD5 值比对，一个大文件的 MD5 值计算也是很费时的。</li><br><li>音、视频流的编解码工作，这些工作搞微信的技术人员应该没有少做。有兴趣的童鞋可以看看这个<a href="http://v.youku.com/v_show/id_XNjQ5NzgxODAw.html" target="_blank">技术分享</a>，是杭州的 hehe123 搞的一个WebRTC 分享，内容还不错。</li><br><li>等等，你觉得费时间的事情都可以交给他做</li><br></ul><br><p>然后要说的是 SharedWorker，这是 web 通信领域未来的一个趋势，有些人觉得 WebSocket 已经十分不错了，但是一些基于 WebSocket 的架构，服务器要为每一个页面维护一个 WebSocket 代码，而 SharedWorker 十分给力，他是多页面通用的。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;inp&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;发送&quot;&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var sw = new SharedWorder(&quot;./outer.js&quot;);</span><br><span class="line">    // 绑定事件</span><br><span class="line">    sw.port.onmessage = function(e)&#123;</span><br><span class="line">        console.log(e.data);</span><br><span class="line">    &#125;;</span><br><span class="line">    btn.onclick = function()&#123;</span><br><span class="line">        sw.port.postMessage(inp.value);</span><br><span class="line">        inp.value = &quot;&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 创建连接，开始监听</span><br><span class="line">    sw.port.start();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// outer.js</span><br><span class="line">var pool = [];</span><br><span class="line">onconnect = function(e) &#123;</span><br><span class="line">    // 把连接的页面放入连接池</span><br><span class="line">    pool.push(e.ports[0]);</span><br><span class="line">    // 收到信息立即广播</span><br><span class="line">    e.ports[0].onmessage = function(e)&#123;</span><br><span class="line">        for(var i = 0;i &lt; pool.length; i++)</span><br><span class="line">            // 广播信息</span><br><span class="line">            pool[i].postMessage(e.data);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单理解 SharedWorker，就是把运行的一个线程作为 web后台程序，完全不需要后台脚本参与，这个对 web通讯，尤其是游戏开发者，觉得是一个福音！</p><br><h3>四、ECMAScript 6 中 Generator 对象搞定异步</h3><br><p>异步两种常见方式是 事件监听 以及 函数回调。前者没什么好说的，事件机制是 JS 的核心，而函数回调这块，过于深入的嵌套简直就是一个地狱，可以看看<a href="http://callbackhell.com/" target="_blank">这篇文章</a>，这是一篇介绍异步编程的文章，什么叫做\回调地狱”，可以看看下面的例子：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(source, function(err, files) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&apos;Error finding files: &apos; + err)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    files.forEach(function(filename, fileIndex) &#123;</span><br><span class="line">      console.log(filename)</span><br><span class="line">      gm(source + filename).size(function(err, values) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          console.log(&apos;Error identifying file size: &apos; + err)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(filename + &apos; : &apos; + values)</span><br><span class="line">          aspect = (values.width / values.height)</span><br><span class="line">          widths.forEach(function(width, widthIndex) &#123;</span><br><span class="line">            height = Math.round(width / aspect)</span><br><span class="line">            console.log(&apos;resizing &apos; + filename + &apos;to &apos; + height + &apos;x&apos; + height)</span><br><span class="line">            this.resize(width, height).write(destination + &apos;w&apos; + width + &apos;_&apos; + filename, function(err) &#123;</span><br><span class="line">              if (err) console.log(&apos;Error writing file: &apos; + err)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;.bind(this))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p></p><p>是不是有种想吐的感觉，一层一层的嵌套，虽说这种嵌套十分正常，倘若每段代码都是这样的呈现，相信二次开发者一定会累死！关于如何解耦我就不细说了，可以回头看看上面那篇回调地狱的文章。</p><p></p>
<p></p><p>ECMAScript 6中有一个 Generator 对象，过段时间会对 ES6 中的新知识进行一一的探讨，这里不多说了，有兴趣的同学可以看看 H-Jin 写的一篇文章<a href="http://huangj.in/765" target="_blank">使用 (Generator) 生成器解决 JavaScript 回调嵌套问题</a>，使用 yield 关键词和 Generator 把嵌套给\拉直”了，这种方式就像是 chrome 的 DevTool 中使用断点一般，用起来特别舒服。</p><p></p>
<p></p><h3>五、小结</h3><p></p>
<p></p><p>本文提到了异步编程的相关概念和使用中会遇到的问题，在写文章之前做了三天的调研，不过还是有很多点没说全，下次对异步编程有了更深入的理解再来谈一谈。</p><p></p>
<p></p><h3>六、参考资料</h3><p></p>
<ul><br><li><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank">Javascript异步编程的4种方法</a> 阮一峰</li><br><li><a href="http://www.cnblogs.com/rubylouvre/archive/2011/03/14/1982699.html" target="_blank">javascript 异步编程</a> 司徒正美</li><br><li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html" target="_blank">HTML Specification</a> web develop group</li><br><li><a href="http://promisesaplus.com/" target="_blank">Promise/A+ 规范</a></li><br><li><a href="//www.imququ.com/post/promises-when-js.html" target="_blank">异步编程：When.js快速上手</a> JerrryQu</li><br><li><a href="http://book.douban.com/subject/10745151/" target="_blank">《Async Javascript》</a> By Trevor Burnham</li><br><li><a href="http://www.web-tinker.com/article/20444.html" target="_blank">非常有意义，却尚未兼容的SharedWorker</a> 次碳酸钴</li><br><li><a href="http://www.cnblogs.com/_franky/archive/2010/11/23/1885773.html" target="_blank">HTML5 Web Worker</a> Franky</li><br></ul>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2013/12/29/2013-12-29-cb-how-to-achieve-loading-module/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2013/12/29/2013-12-29-cb-how-to-achieve-loading-module/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">浅谈模块化加载的实现原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2013-12-29 08:18:00" itemprop="dateCreated datePublished" datetime="2013-12-29T08:18:00+08:00">2013-12-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2013/12/29/how-to-achieve-loading-module.html" target="_blank">博客园</a>.</div>

<p>相信很多人都用过 seajs、 requirejs 等这些模块加载器，他们都是十分便捷的工程管理工具，简化了代码的结构，更重要的是消除了各种文件依赖和命名冲突问题，并利用 AMD / CMD 规范统一了格式。如果你不太明白模块化的作用，建议看看玉伯写的<a href="//github.com/seajs/seajs/issues/547" target="_blank">一篇文章</a>。</p><br><p>为什么他们会想到使用模块化加载呢，我觉得主要是两点。</p><br><ul><br><li><br><p>一是按需加载，业务越来越大，基础代码也会越来越多，开发人员可能开发了一百个小工具，而且都塞在一个叫做 utils.js 的包里，但是一个页面可能只需要三到五个小工具，如果直接去加载这个 utils.js 岂不是很大的浪费，PC 端还好，主要是无线端，省下 1KB 那都是很大的价值啊，所以呢，如今很多框架的开发都体现出细颗粒度的分化，像百度研究比较卖力的 <a href="http://tangram.baidu.com/" target="_blank">tangram</a>，阿里放满产品线的 <a href="http://docs.kissyui.com/" target="_blank">kissy</a>，几乎是细分到了微粒程度，这种细分方式也促进了模块化加载技术的发展，比如为了减少请求数量，kissy 的 config 中开启 combo 就可以合并多个请求为一个等等。</p><br></li><br><li><br><p>第二点，应该也是从服务器那边参考而来的，服务器脚本很多都是以文件为单位分离的，如果要利用其它文件的功能，可以轻而易举的 require 或者 include 进来，我没有去研究这些加载函数的内部实现原理，稍微猜猜应该是把文件写入到缓存，遇到 include 之类的加载函数，暂停写入，找到需要 include 的文件地址，把找到的文件接着上面继续写入缓存，以此类推，直到结束，然后编译器进行统一编译。</p><br></li><br></ul><br><h3>一、模块化加载的技术原理</h3><br><p>先不考虑各种模块定义规范，本文目的只是简要的分析加载原理， CMD / AMD 规范虽内容然不多，但是要实现起来，工程量还是不小。文章后面会提到。</p><br><h4>1. 数据模块的加载</h4><br><p>既然是模块化加载，想办法把模块内容拿到当然是重头戏，无论是 script 还是 css 文件的加载，一个 script 或者 link 标签就可以搞定问题，不过我这里采用的是 ajax，目的是为了拿到 script 的代码，也是为了照顾后面要说的 CMD 规范。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var require = function(path)&#123;</span><br><span class="line">    var xhr = new XMLHttpRequest(), res;</span><br><span class="line">    xhr.open(&quot;GET&quot;, path, true);</span><br><span class="line">    xhr.onreadystatechange = function()&#123;</span><br><span class="line">        if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">            // 获取源码</span><br><span class="line">            res = xhr.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建 script 标签加载脚本不会存在跨域问题，不过拿到的脚本会被浏览器立马解析出来，如果要做同异步的处理就比较麻烦了。没有跨域的文件我们就通过上面的方式加载，如果脚本跨域了，再去创建标签，让文档自己去加载。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 跨域处理</span><br><span class="line">if(crossDomain)&#123;</span><br><span class="line">    var script = document.createElement(&quot;script&quot;);</span><br><span class="line">    script.src = path;</span><br><span class="line"></span><br><span class="line">    (document.getElementsByTagName(&quot;head&quot;)[0] || document.body).appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p><h4>2. 解析模块的层次依赖关系</h4><p></p>
<p>模块之间存在依赖关系是十分正常的，如一个工程的文件结构如下：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── css/</span><br><span class="line">│   └── main.css</span><br><span class="line">├── js/</span><br><span class="line">│   ├── require.js</span><br><span class="line">│   └── modlues/</span><br><span class="line">│     ├── a.js</span><br><span class="line">│     ├── b.js</span><br><span class="line">│     └── c.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure>
<p>而这里几个模块的依赖关系是：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            ┌&gt; a.js -&gt; b.js</span><br><span class="line">index.html -|</span><br><span class="line">            └&gt; c.js</span><br><span class="line"></span><br><span class="line">// a.js</span><br><span class="line">require(&quot;./js/test/b.js&quot;);</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">console.log(&quot;i am b&quot;);</span><br><span class="line"></span><br><span class="line">// c.js</span><br><span class="line">console.log(&quot;i am c&quot;);</span><br></pre></td></tr></table></figure>
<p>我们要从 index.html 中利用 require.js 获取这一连串的依赖关系，一般采用的方式就是正则匹配。如下：先拿到 function 的代码，然后正则匹配出第一层的依赖关系，接着加载匹配到关系的代码，继续匹配。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;./js/require.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function test()&#123;</span><br><span class="line">        var a = require(&quot;./js/modlues/a.js&quot;);</span><br><span class="line">        var c = require(&quot;./js/modlues/c.js&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // toString 方法可以拿到 test 函数的 code</span><br><span class="line">    start(test.toString());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>整个函数的入口是 start，正则表达式为：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var r = /require\((.*)\)/g;</span><br><span class="line"></span><br><span class="line">var start = function(str)&#123;</span><br><span class="line">    while(match = r.exec(str)) &#123;</span><br><span class="line">        console.log(match[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由此我们拿到了第一层的依赖关系，</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;./js/modlues/a.js&quot;, &quot;./js/modlues/c.js&quot;]</span><br></pre></td></tr></table></figure>
<p>接着要拿到 a.js 和 b.js 的文件层次依赖，之前我们写了一个 require 函数，这个函数可以拿到脚本的代码内容，不过这个 require 函数要稍微修改下，递归去查询和下载代码。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var cache = &#123;&#125;;</span><br><span class="line">var start = function(str)&#123;</span><br><span class="line">    while(match = r.exec(str)) &#123;</span><br><span class="line">        console.log(match &amp;&amp; match[1]);</span><br><span class="line">        // 如果匹配到了内容，下载 path 对应的源码</span><br><span class="line">        match &amp;&amp; match[1] &amp;&amp; require(match[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var require = function(path)&#123;</span><br><span class="line">    var xhr = new XMLHttpRequest(), res;</span><br><span class="line">    xhr.open(&quot;GET&quot;, path, true);</span><br><span class="line">    xhr.onreadystatechange = function()&#123;</span><br><span class="line">        if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">            res = xhr.responseText;</span><br><span class="line">            // 缓存文件</span><br><span class="line">            cache[path] = res;</span><br><span class="line">            // 继续递归匹配</span><br><span class="line">            start(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码已经可以很好地拿到文件递归关系了：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/29/271305219966201.jpg" data-source="http://images.cnitblog.com/blog/387325/201411/271305219966201.jpg" alt=""></p><br><h4>3. 添加事件机制，优化管理代码</h4><br><p>但是我们有必要先把 responseText 缓存起来，如果不缓存文件，直接 eval 得到的 responseText 代码，想想会发生什么问题~ 如果模块之间存在循环引用，如：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">            ┌&gt; a.js -&gt; b.js</span><br><span class="line">index.html -|</span><br><span class="line">            └&gt; b.js -&gt; a.js</span><br></pre></td></tr></table></figure>
<p>那 start 和 require 将会陷入死循环，不断的加载代码。所以我们需要先拿到依赖关系，然后解构关系，分析出我们需要加载哪些模块。值得注意的是，我们必须按照加载的顺序去 eval 代码，如果 a 依赖 b，先去执行 a 的话，一定会报错！</p><br><p>有两个问题我纠结了半天，上面的请求方式，何时会结束？用什么方式去记录文件依赖关系？</p><br><p>最后还是决定将 start 和 require 两个函数的相互递归修改成一个函数的递归。用一个对象，发起请求时把 URL 作为 key，在这个对象里保存 XHR 对象，XHR 对象请求完成后，把抓取到的新请求再用同样的方式放入这个对象中，同时从这个对象中把自己删除掉，然后判断这个对象上是否存在 key， 如果存在说明还有 XHR 对象没完成。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var r = /require\(\s*&quot;(.*)&quot;\s*\)/g;</span><br><span class="line">var cache = &#123;&#125;;    // 文件缓存</span><br><span class="line">var relation = []; // 依赖过程控制</span><br><span class="line">var obj = &#123;&#125;;      // xhr 管理对象</span><br><span class="line"></span><br><span class="line">//辅助函数，获取键值数组</span><br><span class="line">Object.keys = Object.keys || function(obj)&#123;</span><br><span class="line">　　  var a = [];</span><br><span class="line">　　  for(a[a.length] in obj);</span><br><span class="line">　　  return a ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 入口函数</span><br><span class="line">function start(str)&#123;</span><br><span class="line">    while(match = r.exec(str))&#123;</span><br><span class="line">        obj[match[1]] = new XMLHttpRequest();</span><br><span class="line">        require(obj[match[1]], match[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归请求</span><br><span class="line">var require = function(xhr, path)&#123;</span><br><span class="line">    //记录依赖过程</span><br><span class="line">    relation.push(path);</span><br><span class="line"></span><br><span class="line">    xhr.open(&quot;GET&quot;, path, true);</span><br><span class="line">    xhr.onreadystatechange = function()&#123;</span><br><span class="line">        if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">            var res = xhr.responseText;</span><br><span class="line">            // 缓存文件</span><br><span class="line">            cache[path] = res;</span><br><span class="line">            // 从xhr对象管理器中删除已经加载完毕的函数</span><br><span class="line">            delete obj[path];</span><br><span class="line"></span><br><span class="line">            // 如果obj为空则触发 allLoad 事件</span><br><span class="line">            Object.keys(obj).length == 0 ? Event.trigger(&quot;allLoad&quot;) : void 0;</span><br><span class="line">            //递归条件</span><br><span class="line">            while(match = r.exec(res))&#123;</span><br><span class="line">                obj[match[1]] = new XMLHttpRequest();</span><br><span class="line">                require(obj[match[1]], match[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码已经基本完成了文件依赖分析，文件的加载和缓存工作了，我写了一个demo，有兴趣可以看一看。这个demo的文件结构为：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── js/</span><br><span class="line">│   ├── require.js</span><br><span class="line">│   └── test/</span><br><span class="line">│     ├── a.js</span><br><span class="line">│     ├── b.js</span><br><span class="line">│     ├── c.js</span><br><span class="line">│     ├── d.js</span><br><span class="line">│     └── e.js</span><br><span class="line">└── index.html</span><br><span class="line"></span><br><span class="line">//文件依赖关系为</span><br><span class="line">                       ┌&gt; c.js</span><br><span class="line">            ┌&gt; a.js --|</span><br><span class="line">index.html -|          └&gt; d.js</span><br><span class="line">            └&gt; b.js -&gt; e.js</span><br></pre></td></tr></table></figure>
<p>戳我 → <a href="http://qianduannotes.duapp.com/demo/require/index.html" target="_blank">Demo</a></p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/29/29201709-355dd08fe5b4497a919e6fe159c8df4c.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/29201709-355dd08fe5b4497a919e6fe159c8df4c.jpg" alt=""></p><br><h4>4. CMD 规范的介绍</h4><br><p>上面写了一大堆内容，也实现了模块加载器的原型，但是放在实际应用中，他就是个废品，回到最开始，我们为什么要使用模块化加载。目的是为了不去使用麻烦的命名空间，把复杂的模块依赖交给 require 这个函数去管理，但实际上呢，上面拿到的所有模块都是暴露在全局变量中的，也就是说，如果 a.js 和 b.js 中存在命名相同的变量，后者将会覆盖前者，这是我们不愿意看到的。为了处理此类问题，我们有必要把所有的模块都放到一个闭包中，这样一来，只要不使用 window.vars 命名，闭包之间的变量是不会相互影响的。我们可以使用自己的方式去管理代码，不过有人已经研究处理一套标准，而且是全球统一，那就拿着用吧~</p><br><p>关于 CMD 规范，我这里就不多说了，可以去看看<a href="//github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank">草案</a>，玉伯也翻译了一份，<a href="//github.com/seajs/seajs/issues/242" target="_blank">戳我</a>。每一模块有且仅有一个对外公开的接口 exports，如：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports) &#123;</span><br><span class="line"></span><br><span class="line">  // 对外提供 foo 属性</span><br><span class="line">  exports.foo = &apos;bar&apos;;</span><br><span class="line"></span><br><span class="line">  // 对外提供 doSomething 方法</span><br><span class="line">  exports.doSomething = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>剩下的工作就是针对 CMD 规范写一套符合标准的代码接口，这个比较琐碎，就不写了。</p><br><h3>二、额外的话题</h3><br><p>上面的代码中提到了关于 Event 的事件管理。在模块全部加在完毕之后，需要有个东西告诉你，所以顺手写了一个 Event 的事件管理器。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// Event</span><br><span class="line">var Event = &#123;&#125;;</span><br><span class="line">Event.events = [];</span><br><span class="line">Event.on = function(evt, func)&#123;</span><br><span class="line">    for(var i = 0; i &lt; Event.events.length; i++)&#123;</span><br><span class="line">        if(Event.events[i].evt == evt)&#123;</span><br><span class="line">            Event.events[i].func.push(func);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Event.events.push(&#123;</span><br><span class="line">        evt: evt,</span><br><span class="line">        func: [func]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Event.trigger = function(evt)&#123;</span><br><span class="line">    for(var i = 0; i &lt; Event.events.length; i++)&#123;</span><br><span class="line">        if(Event.events[i].evt == evt)&#123;</span><br><span class="line">            for(var j = 0; j &lt; Event.events[i].func.length; j++)&#123;</span><br><span class="line">                Event.events[i].func[j]();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Event.off = function(evt)&#123;</span><br><span class="line">    for(var i = 0; i &lt; Event.events.length; i++)&#123;</span><br><span class="line">        Event.events.splice(i, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p><p>我觉得 seajs 是一个很不错的模块加载器，如果感兴趣，可以去看看他的源码实现，代码不长，只有一千多行。模块的加载它采用的是创建文本节点，让文档去加载模块，实时查看状态为 interactive 的 script 标签，如果处于交互状态就拿到他的代码，接着删除节点。当节点数目为 0 的时候，加载工作完成。</p><p></p>
<p></p><p>本文没有考虑 css 文件的加载问题，我们可以把它当做一个没有 require 关键词的 js 文件，或者把它匹配出来之后另作处理，因为他是不可能存在模块依赖关系的。</p><p></p>
<p></p><p>然后就是很多很多细节，本文的目的并不是写一个类似 seajs 的模块管理工具，只是稍微说几句自己对这玩意儿的看法，如果说的有错，请多多吐槽！</p><p></p>
<p></p><h3>三、参考资料</h3><p></p>
<ul><br><li><a href="//github.com/seajs/seajs/issues" target="_blank">//github.com/seajs/issues</a> seajs issues</li><br></ul>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2013/12/25/2013-12-25-cb-websocket-with-php/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2013/12/25/2013-12-25-cb-websocket-with-php/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">细说websocket - php篇</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2013-12-25 11:24:00" itemprop="dateCreated datePublished" datetime="2013-12-25T11:24:00+08:00">2013-12-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/网络交互/" itemprop="url" rel="index"><span itemprop="name">网络交互</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2013/12/25/websocket-with-php.html" target="_blank">博客园</a>.</div>

<p>下面我画了一个图演示 client 和 server 之间建立 websocket 连接时握手部分，这个部分在 node 中可以十分轻松的完成，因为 node 提供的 net 模块已经对 socket 套接字做了封装处理，开发者使用的时候只需要考虑数据的交互而不用处理连接的建立。而 php 没有，从 socket 的连接、建立、绑定、监听等，这些都需要我们自己去操作，所以有必要拿出来再说一说。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+    1.发送Sec-WebSocket-Key        +---------+</span><br><span class="line">|        | --------------------------------&gt; |        |</span><br><span class="line">|        |    2.加密返回Sec-WebSocket-Accept  |        |</span><br><span class="line">| client | &lt;-------------------------------- | server |</span><br><span class="line">|        |    3.本地校验                      |        |</span><br><span class="line">|        | --------------------------------&gt; |        |</span><br><span class="line">+--------+                                   +--------+</span><br></pre></td></tr></table></figure>
<p>看了我写的<a href="http://www.cnblogs.com/hustskyking/p/websocket-with-node.html" target="_blank">上一篇文章</a>的同学应该是对上图有了比较全面的理解。① 和 ② 实际上就是一个 HTTP 的请求和响应，只不过我们在处理的过程中我们拿到的是没有经过解析的字符串。如：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure>
<p>我们往常看到的请求是这个样子，当这东西到了服务器端，我们可以通过一些代码库直接拿到这些信息。</p><br><h3>一、php 中处理 websocket</h3><br><p>WebSocket 连接是由客户端主动发起的，所以一切要从客户端出发。第一步是要解析拿到客户端发过来的 Sec-WebSocket-Key 字符串。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/hustskyking/p/websocket-with-node.html" target="_blank">前文</a>中也提到了 client 请求的格式（如上），首先 php 建立一个 socket 连接，监听端口的信息。</p><br><h4>1. socket 连接的建立</h4><br><p>关于 socket 套接字的建立，相信很多大学修过计算机网络的人都知道了，下面是一张连接建立的过程：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/25/25124523-33fc2253152447d4a16bac3b6704d832.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/25124523-33fc2253152447d4a16bac3b6704d832.jpg" alt="" width="467" height="620"></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个 socket 套接字</span><br><span class="line">$master = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);</span><br><span class="line">socket_set_option($master, SOL_SOCKET, SO_REUSEADDR, 1);</span><br><span class="line">socket_bind($master, $address, $port);</span><br><span class="line">socket_listen($master);</span><br></pre></td></tr></table></figure>
<p>相比 node，这个地方的处理实在是太麻烦了，上面几行代码并未建立连接，只不过这些代码是建立一个 socket 套接字必须要写的东西。由于处理过程稍微有复杂，所以我把各种处理写进了一个类中，方便管理和调用。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//demo.php</span><br><span class="line">Class WS &#123;</span><br><span class="line">    var $master;  // 连接 server 的 client</span><br><span class="line">    var $sockets = array(); // 不同状态的 socket 管理</span><br><span class="line">    var $handshake = false; // 判断是否握手</span><br><span class="line"></span><br><span class="line">    function __construct($address, $port)&#123;</span><br><span class="line">        // 建立一个 socket 套接字</span><br><span class="line">        $this-&gt;master = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)</span><br><span class="line">            or die(&quot;socket_create() failed&quot;);</span><br><span class="line">        socket_set_option($this-&gt;master, SOL_SOCKET, SO_REUSEADDR, 1)</span><br><span class="line">            or die(&quot;socket_option() failed&quot;);</span><br><span class="line">        socket_bind($this-&gt;master, $address, $port)</span><br><span class="line">            or die(&quot;socket_bind() failed&quot;);</span><br><span class="line">        socket_listen($this-&gt;master, 2)</span><br><span class="line">            or die(&quot;socket_listen() failed&quot;);</span><br><span class="line"></span><br><span class="line">        $this-&gt;sockets[] = $this-&gt;master;</span><br><span class="line"></span><br><span class="line">        // debug</span><br><span class="line">        echo(&quot;Master socket  : &quot;.$this-&gt;master.&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        while(true) &#123;</span><br><span class="line">            //自动选择来消息的 socket 如果是握手 自动选择主机</span><br><span class="line">            $write = NULL;</span><br><span class="line">            $except = NULL;</span><br><span class="line">            socket_select($this-&gt;sockets, $write, $except, NULL);</span><br><span class="line"></span><br><span class="line">            foreach ($this-&gt;sockets as $socket) &#123;</span><br><span class="line">                //连接主机的 client </span><br><span class="line">                if ($socket == $this-&gt;master)&#123;</span><br><span class="line">                    $client = socket_accept($this-&gt;master);</span><br><span class="line">                    if ($client &lt; 0) &#123;</span><br><span class="line">                        // debug</span><br><span class="line">                        echo &quot;socket_accept() failed&quot;;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //connect($client);</span><br><span class="line">                        array_push($this-&gt;sockets, $client);</span><br><span class="line">                        echo &quot;connect client\n&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    $bytes = @socket_recv($socket,$buffer,2048,0);</span><br><span class="line">                    if($bytes == 0) return;</span><br><span class="line">                    if (!$this-&gt;handshake) &#123;</span><br><span class="line">                        // 如果没有握手，先握手回应</span><br><span class="line">                        //doHandShake($socket, $buffer);</span><br><span class="line">                        echo &quot;shakeHands\n&quot;;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 如果已经握手，直接接受数据，并处理</span><br><span class="line">                        $buffer = decode($buffer);</span><br><span class="line">                        //process($socket, $buffer); </span><br><span class="line">                        echo &quot;send file\n&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo.php 握手连接测试代码</span><br></pre></td></tr></table></figure>
<p>上面这段代码是经过我调试了的，没太大的问题，如果想测试的话，可以在 cmd 命令行中键入 <code>php /path/to/demo.php</code>;当然，上面只是一个类，如果要测试的话，还得新建一个实例。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ws = new WS(&apos;localhost&apos;, 4000);</span><br></pre></td></tr></table></figure>
<p>客户端代码可以稍微简单点：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(&quot;ws://localhost:4000&quot;);</span><br><span class="line">ws.onopen = function()&#123;</span><br><span class="line">    console.log(&quot;握手成功&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onerror = function()&#123;</span><br><span class="line">    console.log(&quot;error&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行服务器代码，当客户端连接的时候，我们可以看到：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/25/25124555-64ad002702334156a80bedef37fbf361.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/25124555-64ad002702334156a80bedef37fbf361.jpg" alt=""></p><br><p>通过上面的代码可以清晰的看到整个交流的过程。首先是建立连接，node 中这一步已经封装到了 net 和 http 模块，然后判断是否握手，如果没有的话，就 shakeHands。这里的握手我直接就 echo 了一个单词，表示进行了这个东西，<a href="http://www.cnblogs.com/hustskyking/p/websocket-with-node.html" target="_blank">前文</a>我们提到过握手算法，这里就直接写了。</p><br><h4>2. 提取 Sec-WebSocket-Key 信息</h4><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getKey($req) &#123;</span><br><span class="line">    $key = null;</span><br><span class="line">    if (preg_match(&quot;/Sec-WebSocket-Key: (.*)\r\n/&quot;, $req, $match)) &#123;</span><br><span class="line">        $key = $match[1];</span><br><span class="line">    &#125;</span><br><span class="line">    return $key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>这里比较简单，直接正则匹配，websocket 信息头一定包含 Sec-WebSocket-Key，所以我们匹配起来也比较快捷~</p><br><h4>3. 加密 Sec-WebSocket-Key</h4><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function encry($req)&#123;</span><br><span class="line">    $key = $this-&gt;getKey($req);</span><br><span class="line">    $mask = &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;;</span><br><span class="line"></span><br><span class="line">    return base64_encode(sha1($key . &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;, true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>将 SHA-1 加密后的字符串再进行一次 base64 加密。如果加密算法错误，客户端在进行校检的时候会直接报错：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/25/25124720-0518fd35df2c4f7a91f624e4bbf2ec6c.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/25124720-0518fd35df2c4f7a91f624e4bbf2ec6c.jpg" alt=""></p><br><h4>4. 应答 Sec-WebSocket-Accept</h4><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function dohandshake($socket, $req)&#123;</span><br><span class="line">    // 获取加密key</span><br><span class="line">    $acceptKey = $this-&gt;encry($req);</span><br><span class="line">    $upgrade = &quot;HTTP/1.1 101 Switching Protocols\r\n&quot; .</span><br><span class="line">               &quot;Upgrade: websocket\r\n&quot; .</span><br><span class="line">               &quot;Connection: Upgrade\r\n&quot; .</span><br><span class="line">               &quot;Sec-WebSocket-Accept: &quot; . $acceptKey . &quot;\r\n&quot; .</span><br><span class="line">               &quot;\r\n&quot;;</span><br><span class="line"></span><br><span class="line">    // 写入socket</span><br><span class="line">    socket_write(socket,$upgrade.chr(0), strlen($upgrade.chr(0)));</span><br><span class="line">    // 标记握手已经成功，下次接受数据采用数据帧格式</span><br><span class="line">    $this-&gt;handshake = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>这里千万要注意，每一个请求和相应的格式，最后有一个空行，也就是 <code>\r\n</code>，开始测试的时候把这东西给弄丢了，纠结了半天。</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/25/25124605-f1c4f57be53a43b1bcfb20392fe6c18a.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/25124605-f1c4f57be53a43b1bcfb20392fe6c18a.jpg" alt=""></p><br><p>当客户端成功校检key后，会触发 onopen 函数：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/25/25124618-53351ac2263d4ca89be4bd7eaca1968c.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/25124618-53351ac2263d4ca89be4bd7eaca1968c.jpg" alt=""></p><br><h4>5. 数据帧处理</h4><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 解析数据帧</span><br><span class="line">function decode($buffer)  &#123;</span><br><span class="line">    $len = $masks = $data = $decoded = null;</span><br><span class="line">    $len = ord($buffer[1]) &lt; 127;</span><br><span class="line"></span><br><span class="line">    if ($len === 126)  &#123;</span><br><span class="line">        $masks = substr($buffer, 4, 4);</span><br><span class="line">        $data = substr($buffer, 8);</span><br><span class="line">    &#125; else if ($len === 127)  &#123;</span><br><span class="line">        $masks = substr($buffer, 10, 4);</span><br><span class="line">        $data = substr($buffer, 14);</span><br><span class="line">    &#125; else  &#123;</span><br><span class="line">        $masks = substr($buffer, 2, 4);</span><br><span class="line">        $data = substr($buffer, 6);</span><br><span class="line">    &#125;</span><br><span class="line">    for ($index = 0; $index &lt; strlen($data); $index++) &#123;</span><br><span class="line">        $decoded .= $data[$index] ^ $masks[$index % 4];</span><br><span class="line">    &#125;</span><br><span class="line">    return $decoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>这里涉及的编码问题在前文中已经提到过了，这里就不赘述，php 对字符处理的函数太多了，也记得不是特别清楚，这里就没有详细的介绍解码程序，直接把客户端发送的数据原样返回，可以算是一个聊天室的模式吧。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 返回帧信息处理</span><br><span class="line">function frame($s) &#123;</span><br><span class="line">    $a = str_split($s, 125);</span><br><span class="line">    if (count($a) == 1) &#123;</span><br><span class="line">        return &quot;\x81&quot; . chr(strlen($a[0])) . $a[0];</span><br><span class="line">    &#125;</span><br><span class="line">    $ns = &quot;&quot;;</span><br><span class="line">    foreach ($a as $o) &#123;</span><br><span class="line">        $ns .= &quot;\x81&quot; . chr(strlen($o)) . $o;</span><br><span class="line">    &#125;</span><br><span class="line">    return $ns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回数据</span><br><span class="line">function send($client, $msg)&#123;</span><br><span class="line">    $msg = $this-&gt;frame($msg);</span><br><span class="line">    socket_write($client, $msg, strlen($msg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(&quot;ws://localhost:4000&quot;);</span><br><span class="line">ws.onopen = function()&#123;</span><br><span class="line">    console.log(&quot;握手成功&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = function(e)&#123;</span><br><span class="line">    console.log(&quot;message:&quot; + e.data);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onerror = function()&#123;</span><br><span class="line">    console.log(&quot;error&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">ws.send(&quot;李靖&quot;);</span><br></pre></td></tr></table></figure>
<p>在连通之后发送数据，服务器原样返回：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/25/25124629-a1d032dbd01a4a958cae055a99c964eb.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/25124629-a1d032dbd01a4a958cae055a99c964eb.jpg" alt=""></p>


<p></p><h3>二、注意问题</h3><p></p>
<p></p><h4>1. websocket 版本问题</h4><p></p>
<p>客户端在握手时的请求中有<code>Sec-WebSocket-Version: 13</code>，这样的版本标识，这个是一个升级版本，现在的浏览器都是使用的这个版本。而以前的版本在数据加密的部分更加麻烦，它会发送两个key：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Key1: xxxx</span><br><span class="line">Sec-WebSocket-Key2: xxxx</span><br></pre></td></tr></table></figure>
<p>如果是这种版本（比较老，已经没在使用了），需要通过下面的方式获取</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function encry($key1,$key2,$l8b)&#123; //Get the numbers preg_match_all(&apos;/([\d]+)/&apos;, $key1, $key1_num); preg_match_all(&apos;/([\d]+)/&apos;, $key2, $key2_num);</span><br><span class="line"></span><br><span class="line">    $key1_num = implode($key1_num[0]);</span><br><span class="line">    $key2_num = implode($key2_num[0]);</span><br><span class="line">    //Count spaces</span><br><span class="line">    preg_match_all(&apos;/([ ]+)/&apos;, $key1, $key1_spc);</span><br><span class="line">    preg_match_all(&apos;/([ ]+)/&apos;, $key2, $key2_spc);</span><br><span class="line"></span><br><span class="line">    if($key1_spc==0|$key2_spc==0)&#123; $this-&gt;log(&quot;Invalid key&quot;);return; &#125;</span><br><span class="line">    //Some math</span><br><span class="line">    $key1_sec = pack(&quot;N&quot;,$key1_num / $key1_spc);</span><br><span class="line">    $key2_sec = pack(&quot;N&quot;,$key2_num / $key2_spc);</span><br><span class="line"></span><br><span class="line">    return md5($key1_sec.$key2_sec.$l8b,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能无限吐槽这种验证方式！相比 nodeJs 的 websocket 操作方式：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//服务器程序</span><br><span class="line">var crypto = require(&apos;crypto&apos;);</span><br><span class="line">var WS = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;;</span><br><span class="line">require(&apos;net&apos;).createServer(function(o)&#123;</span><br><span class="line">    var key;</span><br><span class="line">    o.on(&apos;data&apos;,function(e)&#123;</span><br><span class="line">        if(!key)&#123;</span><br><span class="line">            //握手</span><br><span class="line">            key = e.toString().match(/Sec-WebSocket-Key: (.+)/)[1];</span><br><span class="line">            key = crypto.createHash(&apos;sha1&apos;).update(key + WS).digest(&apos;base64&apos;);</span><br><span class="line">            o.write(&apos;HTTP/1.1 101 Switching Protocols\r\n&apos;);</span><br><span class="line">            o.write(&apos;Upgrade: websocket\r\n&apos;);</span><br><span class="line">            o.write(&apos;Connection: Upgrade\r\n&apos;);</span><br><span class="line">            o.write(&apos;Sec-WebSocket-Accept: &apos; + key + &apos;\r\n&apos;);</span><br><span class="line">            o.write(&apos;\r\n&apos;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(e);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(8000);</span><br></pre></td></tr></table></figure>
<p></p><p>多么简洁，多么方便！有谁还愿意使用 php 呢。。。。</p><p></p>
<p></p><h4>2. 数据帧解析代码</h4><p></p>
<p></p><p>本文没有给出 decodeFrame 这样数据帧解析代码，前文中给出了数据帧的格式，解析纯属体力活。</p><p></p>
<p></p><h4>3. 代码下载</h4><p></p>
<p></p><p>对这部分感兴趣的同学，可以再去深究。提供了<a href="http://files.cnblogs.com/hustskyking/ws.zip" target="_blank">参考代码下载</a>。</p><p></p>
<p></p><h4>4. 相关开源库参考</h4><p></p>
<p></p><p><a href="http://socketo.me" target="_blank">http://socketo.me</a> Ratchet 为 php 封装的一个 WebSockets 库。 ]</p><p></p>
<p></p><p>Google 上搜索 <a href="//www.google.com.hk/search?q=php+websocket+class" target="_blank">php+websoket+class</a>，也能找到不少相关的资料。</p><p></p>
<p></p><h3>三、参考资料</h3><p></p>
<ul><br><li><a href="http://www.php.net/manual/zh/ref.sockets.php" target="_blank">http://www.php.net/manual/zh/ref.sockets.php</a> php manual</li><br><li><a href="http://www.rfc-editor.org/rfc/rfc6455.txt" target="_blank">http://www.rfc-editor.org/rfc/rfc6455.txt</a>&nbsp;&nbsp;[<a href="http://www.rfc-editor.org/rfc/rfc6455.txt" target="_blank" rel="noopener">RFC6455</a>] WebSocket</li><br></ul>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2013/12/20/2013-12-20-cb-websocket-with-node/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2013/12/20/2013-12-20-cb-websocket-with-node/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">细说WebSocket - Node篇</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2013-12-20 01:42:00" itemprop="dateCreated datePublished" datetime="2013-12-20T01:42:00+08:00">2013-12-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/网络交互/" itemprop="url" rel="index"><span itemprop="name">网络交互</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2013/12/20/websocket-with-node.html" target="_blank">博客园</a>.</div>

<p>在上一篇提高到了 <a href="http://www.cnblogs.com/hustskyking/p/web-communication.html" target="_blank">web 通信的各种方式</a>，包括 轮询、长连接 以及各种 HTML5 中提到的手段。本文将详细描述 WebSocket协议 在 web通讯 中的实现。</p><br><h3>一、WebSocket 协议</h3><br><h4>1. 概述</h4><br><p>websocket协议允许不受信用的客户端代码在可控的网络环境中控制远程主机。该协议包含一个握手和一个基本消息分帧、分层通过TCP。简单点说，通过握手应答之后，建立安全的信息管道，这种方式明显优于<a href="http://www.cnblogs.com/hustskyking/p/web-communication.html" target="_blank">前文</a>所说的基于 XMLHttpRequest 的 iframe 数据流和长轮询。该协议包括两个方面，握手链接（handshake）和数据传输（data transfer）。</p><br><h4>2. 握手连接</h4><br><p>这部分比较简单，就像路上遇到熟人问好。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Client：嘿，大哥，有火没？（烟递了过去）</span><br><span class="line">Server：哈，有啊，来~ （点上）</span><br><span class="line">Client：火柴啊，也行！（烟点上，验证完毕）</span><br></pre></td></tr></table></figure>
<p>握手连接中，client 先主动伸手：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>客户端发了一串 Base64 加密的密钥过去，也就是上面你看到的 Sec-WebSocket-Key。 Server 看到 Client 打招呼之后，悄悄地告诉 Client 他已经知道了，顺便也打个招呼。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>
<p>Server 返回了 Sec-WebSocket-Accept 这个应答，这个应答内容是通过一定的方式生成的。生成算法是：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask  = &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;;  // 这是算法中要用到的固定字符串</span><br><span class="line">accept = base64( sha1( key + mask ) );</span><br></pre></td></tr></table></figure>
<p>key 和 mask 串接之后经过 SHA-1 处理，处理后的数据再经过一次 Base64 加密。分解动作：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. t = &quot;GhlIHNhbXBsZSBub25jZQ==&quot; + &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span><br><span class="line">   -&gt; &quot;GhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span><br><span class="line">2. s = sha1(t)</span><br><span class="line">   -&gt; 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6</span><br><span class="line">      0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea</span><br><span class="line">3. base64(s)</span><br><span class="line">   -&gt; &quot;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&quot;</span><br></pre></td></tr></table></figure>
<p>上面 Server 端返回的 HTTP 状态码是 101，如果不是 101 ，那就说明握手一开始就失败了~</p><br><p>下面就来个 demo，跟服务器握个手：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var crypto = require(&apos;crypto&apos;);</span><br><span class="line"></span><br><span class="line">require(&apos;net&apos;).createServer(function(o)&#123;</span><br><span class="line">    var key;</span><br><span class="line">    o.on(&apos;data&apos;,function(e)&#123;</span><br><span class="line">        if(!key)&#123;</span><br><span class="line">            // 握手</span><br><span class="line">            // 应答部分，代码先省略</span><br><span class="line">            console.log(e.toString());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(8000);</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ws=new WebSocket(&quot;ws://127.0.0.1:8000&quot;);</span><br><span class="line">ws.onerror=function(e)&#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面当然是一串不完整的代码，目的是演示握手过程中，客户端给服务端打招呼。在控制台我们可以看到：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/20/20133038-3e86224009f348619e44b835455d86c8.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/20133038-3e86224009f348619e44b835455d86c8.jpg" alt=""></p><br><p>看起来很熟悉吧，其实就是发送了一个 HTTP 请求，这个我们在浏览器的 Network 中也可以看到：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/20/20133046-6882b98bedf44b46a5598d74d98531d3.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/20133046-6882b98bedf44b46a5598d74d98531d3.jpg" alt=""></p><br><p>但是 WebSocket协议 并不是 HTTP 协议，刚开始验证的时候借用了 HTTP 的头，连接成功之后的通信就不是 HTTP 了，不信你用 fiddler2 抓包试试，肯定是拿不到的，后面的通信部分是基于 TCP 的连接。</p><br><p>服务器要成功的进行通信，必须有应答，往下看：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//服务器程序</span><br><span class="line">var crypto = require(&apos;crypto&apos;);</span><br><span class="line">var WS = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;;</span><br><span class="line">require(&apos;net&apos;).createServer(function(o)&#123;</span><br><span class="line">    var key;</span><br><span class="line">    o.on(&apos;data&apos;,function(e)&#123;</span><br><span class="line">        if(!key)&#123;</span><br><span class="line">            //握手</span><br><span class="line">            key = e.toString().match(/Sec-WebSocket-Key: (.+)/)[1];</span><br><span class="line">            key = crypto.createHash(&apos;sha1&apos;).update(key + WS).digest(&apos;base64&apos;);</span><br><span class="line">            o.write(&apos;HTTP/1.1 101 Switching Protocols\r\n&apos;);</span><br><span class="line">            o.write(&apos;Upgrade: websocket\r\n&apos;);</span><br><span class="line">            o.write(&apos;Connection: Upgrade\r\n&apos;);</span><br><span class="line">            o.write(&apos;Sec-WebSocket-Accept: &apos; + key + &apos;\r\n&apos;);</span><br><span class="line">            o.write(&apos;\r\n&apos;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(e);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(8000);</span><br></pre></td></tr></table></figure>
<p>关于crypto模块，可以看看<a href="http://nodejs.org/api/crypto.html" target="_blank">官方文档</a>，上面的代码应该是很好理解的，服务器应答之后，Client 拿到 Sec-WebSocket-Accept ，然后本地做一次验证，如果验证通过了，就会触发 onopen 函数。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//客户端程序</span><br><span class="line">var ws=new WebSocket(&quot;ws://127.0.0.1:8000/&quot;);</span><br><span class="line">ws.onopen=function(e)&#123;</span><br><span class="line">    console.log(&quot;握手成功&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/20/20133127-7a4e0e60138c4f59b8c132ef1706c6e3.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/20133127-7a4e0e60138c4f59b8c132ef1706c6e3.jpg" alt=""></p><br><h4>3. 数据帧格式</h4><br><p>官方文档提供了一个结构图</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>第一眼瞟到这张图恐怕是要吐血，如果大学修改计算机网络这门课应该不会对这东西陌生，数据传输协议嘛，是需要定义字节长度及相关含义的。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FIN      1bit 表示信息的最后一帧，flag，也就是标记符</span><br><span class="line">RSV 1-3  1bit each 以后备用的 默认都为 0</span><br><span class="line">Opcode   4bit 帧类型，稍后细说</span><br><span class="line">Mask     1bit 掩码，是否加密数据，默认必须置为1 （这里很蛋疼）</span><br><span class="line">Payload  7bit 数据的长度</span><br><span class="line">Masking-key      1 or 4 bit 掩码</span><br><span class="line">Payload data     (x + y) bytes 数据</span><br><span class="line">Extension data   x bytes  扩展数据</span><br><span class="line">Application data y bytes  程序数据</span><br></pre></td></tr></table></figure>
<p>每一帧的传输都是遵从这个协议规则的，知道了这个协议，那么解析就不会太难了，下面我就直接拿了<a href="http://www.web-tinker.com/" target="_blank">次碳酸钴</a>同学的代码。</p><br><h4>4. 数据帧的解析和编码</h4><br><p>数据帧的解析代码：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function decodeDataFrame(e)&#123;</span><br><span class="line">  var i=0,j,s,frame=&#123;</span><br><span class="line">    //解析前两个字节的基本数据</span><br><span class="line">    FIN:e[i]&gt;&gt;7,Opcode:e[i++]&amp;15,Mask:e[i]&gt;&gt;7,</span><br><span class="line">    PayloadLength:e[i++]&amp;0x7F</span><br><span class="line">  &#125;;</span><br><span class="line">  //处理特殊长度126和127</span><br><span class="line">  if(frame.PayloadLength==126)</span><br><span class="line">    frame.length=(e[i++]&lt;&lt;8)+e[i++];</span><br><span class="line">  if(frame.PayloadLength==127)</span><br><span class="line">    i+=4, //长度一般用四字节的整型，前四个字节通常为长整形留空的</span><br><span class="line">    frame.length=(e[i++]&lt;&lt;24)+(e[i++]&lt;&lt;16)+(e[i++]&lt;&lt;8)+e[i++];</span><br><span class="line">  //判断是否使用掩码</span><br><span class="line">  if(frame.Mask)&#123;</span><br><span class="line">    //获取掩码实体</span><br><span class="line">    frame.MaskingKey=[e[i++],e[i++],e[i++],e[i++]];</span><br><span class="line">    //对数据和掩码做异或运算</span><br><span class="line">    for(j=0,s=[];j&lt;frame.PayloadLength;j++)</span><br><span class="line">      s.push(e[i+j]^frame.MaskingKey[j%4]);</span><br><span class="line">  &#125;else s=e.slice(i,frame.PayloadLength); //否则直接使用数据</span><br><span class="line">  //数组转换成缓冲区来使用</span><br><span class="line">  s=new Buffer(s);</span><br><span class="line">  //如果有必要则把缓冲区转换成字符串来使用</span><br><span class="line">  if(frame.Opcode==1)s=s.toString();</span><br><span class="line">  //设置上数据部分</span><br><span class="line">  frame.PayloadData=s;</span><br><span class="line">  //返回数据帧</span><br><span class="line">  return frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据帧的编码：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//NodeJS</span><br><span class="line">function encodeDataFrame(e)&#123;</span><br><span class="line">  var s=[],o=new Buffer(e.PayloadData),l=o.length;</span><br><span class="line">  //输入第一个字节</span><br><span class="line">  s.push((e.FIN&lt;&lt;7)+e.Opcode);</span><br><span class="line">  //输入第二个字节，判断它的长度并放入相应的后续长度消息</span><br><span class="line">  //永远不使用掩码</span><br><span class="line">  if(l&lt;126)s.push(l);</span><br><span class="line">  else if(l&lt;0x10000)s.push(126,(l&amp;0xFF00)&gt;&gt;2,l&amp;0xFF);</span><br><span class="line">  else s.push(</span><br><span class="line">    127, 0,0,0,0, //8字节数据，前4字节一般没用留空</span><br><span class="line">    (l&amp;0xFF000000)&gt;&gt;6,(l&amp;0xFF0000)&gt;&gt;4,(l&amp;0xFF00)&gt;&gt;2,l&amp;0xFF</span><br><span class="line">  );</span><br><span class="line">  //返回头部分和数据部分的合并缓冲区</span><br><span class="line">  return Buffer.concat([new Buffer(s),o]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些童鞋可能没有明白，应该解析哪些数据。这的解析任务主要是服务端处理，客户端送过去的数据是二进制流形式的，比如：&nbsp;</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(&quot;ws://127.0.0.1:8000/&quot;); ws.onopen = function()&#123; 　　ws.send(&quot;握手成功&quot;); &#125;;</span><br></pre></td></tr></table></figure>
<p>Server 收到的信息是这样的：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/20/20133241-2339e90ef5c94d318d1d36645fb545ce.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/20133241-2339e90ef5c94d318d1d36645fb545ce.jpg" alt=""></p><br><p>一个放在Buffer格式的二进制流。而当我们输出的时候解析这个二进制流：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//服务器程序</span><br><span class="line">var crypto = require(&apos;crypto&apos;);</span><br><span class="line">var WS = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;;</span><br><span class="line">require(&apos;net&apos;).createServer(function(o)&#123;</span><br><span class="line">    var key;</span><br><span class="line">    o.on(&apos;data&apos;,function(e)&#123;</span><br><span class="line">        if(!key)&#123;</span><br><span class="line">            //握手</span><br><span class="line">            key = e.toString().match(/Sec-WebSocket-Key: (.+)/)[1];</span><br><span class="line">            key = crypto.createHash(&apos;sha1&apos;).update(key + WS).digest(&apos;base64&apos;);</span><br><span class="line">            o.write(&apos;HTTP/1.1 101 Switching Protocols\r\n&apos;);</span><br><span class="line">            o.write(&apos;Upgrade: websocket\r\n&apos;);</span><br><span class="line">            o.write(&apos;Connection: Upgrade\r\n&apos;);</span><br><span class="line">            o.write(&apos;Sec-WebSocket-Accept: &apos; + key + &apos;\r\n&apos;);</span><br><span class="line">            o.write(&apos;\r\n&apos;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 输出之前解析帧</span><br><span class="line">            console.log(decodeDataFrame(e));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(8000);</span><br></pre></td></tr></table></figure>
<p>那输出的就是一个帧信息十分清晰的对象了：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/20/20133301-7e939b556bef46b8856b81c87b169c57.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/20133301-7e939b556bef46b8856b81c87b169c57.jpg" alt=""></p><br><h4>5. 连接的控制</h4><br><p>上面我买了个关子，提到的Opcode，没有详细说明，<a href="http://tools.ietf.org/html/rfc6455" target="_blank">官方文档</a>也给了一张表：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> |Opcode  | Meaning                             | Reference |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | 0      | Continuation Frame                  | RFC 6455  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | 1      | Text Frame                          | RFC 6455  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | 2      | Binary Frame                        | RFC 6455  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | 8      | Connection Close Frame              | RFC 6455  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | 9      | Ping Frame                          | RFC 6455  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br><span class="line"> | 10     | Pong Frame                          | RFC 6455  |</span><br><span class="line">-+--------+-------------------------------------+-----------|</span><br></pre></td></tr></table></figure>
<p>decodeDataFrame 解析数据，得到的数据格式是：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    FIN: 1,</span><br><span class="line">    Opcode: 1,</span><br><span class="line">    Mask: 1,</span><br><span class="line">    PayloadLength: 4,</span><br><span class="line">    MaskingKey: [ 159, 18, 207, 93 ],</span><br><span class="line">    PayLoadData: &apos;握手成功&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么可以对应上面查看，此帧的作用就是发送文本，为文本帧。因为连接是基于 TCP 的，直接关闭 TCP 连接，这个通道就关闭了，不过 WebSocket 设计的还比较人性化，关闭之前还跟你打一声招呼，在服务器端，可以判断frame的Opcode：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var frame=decodeDataFrame(e);</span><br><span class="line">console.log(frame);</span><br><span class="line">if(frame.Opcode==8)&#123;</span><br><span class="line">    o.end(); //断开连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端和服务端交互的数据（帧）格式都是一样的，只要客户端发送 <code>ws.close()</code>， 服务器就会执行上面的操作。相反，如果服务器给客户端也发送同样的关闭帧(close frame)：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o.write(encodeDataFrame(&#123;</span><br><span class="line">    FIN:1,</span><br><span class="line">    Opcode:8,</span><br><span class="line">    PayloadData:buf</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>客户端就会相应 onclose 函数，这样的交互还算是有规有矩，不容易出错。</p><br><h3>二、注意事项</h3><br><h4>1. WebSocket URIs</h4><br><p>很多人可能只知道&nbsp;<code>ws://text.com:8888</code>，但事实上 websocket 协议地址是可以加 path 和 query 的。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ws-URI = &quot;ws:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</span><br><span class="line">wss-URI = &quot;wss:&quot; &quot;//&quot; host [ &quot;:&quot; port ] path [ &quot;?&quot; query ]</span><br></pre></td></tr></table></figure>
<p>如果使用的是 wss 协议，那么 URI 将会以安全方式连接。 这里的 wss 大小写不敏感。</p><br><h4>2. 协议中”多余”的部分（吐槽）</h4><br><p>握手请求中包含Sec-WebSocket-Key字段，明眼人一下就能看出来是websocket连接，而且这个字段的加密方式在服务器也是固定的，如果别人想黑你，不会太难。</p><br><p>再就是那个 MaskingKey 掩码，既然强制加密了（Mask为1表示加密，加密方式就是 MaskingKey 与 PayLoadData 进行异或处理），还有必要让开发者处理这个东西么？直接封装到内部不就行了？</p><br><h4 id="menuIndex9">3. 与 TCP 和 HTTP 之间的关系</h4><br><p>WebSocket协议是一个基于TCP的协议，就是握手链接的时候跟HTTP相关（发了一个HTTP请求），这个请求被Server切换到（Upgrade）websocket协议了。websocket把 80 端口作为默认websocket连接端口，而websocket的运行使用的是443端口。</p><br><h3>三、参考资料</h3><br><ul><br><li><a href="http://tools.ietf.org/html/rfc6455" target="_blank">http://tools.ietf.org/html/rfc6455</a> web standard - The WebSocket Protocol</li><br><li><a href="http://www.w3.org/TR/websockets/" target="_blank">http://www.w3.org/TR/websockets/</a> W3.ORG - WebSockets</li><br></ul><br><h3>四、特别感谢</h3><br><p>再次感谢 <a href="http://www.web-tinker.com/" target="_blank">次碳酸钴</a> 跟我交流了几个小时 : )，本文部分 node 代码参考自他的博客。</p>


<p>下次将以php作为后台，讲解websocket的相关知识。</p>




          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2013/12/17/2013-12-17-cb-web-communication/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2013/12/17/2013-12-17-cb-web-communication/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">JavaScript之web通信</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2013-12-17 10:01:00" itemprop="dateCreated datePublished" datetime="2013-12-17T10:01:00+08:00">2013-12-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/网络交互/" itemprop="url" rel="index"><span itemprop="name">网络交互</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2013/12/17/web-communication.html" target="_blank">博客园</a>.</div>

<p>web通信，一个特别大的topic，涉及面也是很广的。因最近学习了 javascript 中一些 web 通信知识，在这里总结下。文中应该会有理解错误或者表述不清晰的地方，还望斧正！</p><br><h3>一、前言</h3><br><h4>1. comet技术</h4><br><blockquote><br><p>浏览器作为 Web 应用的前台，自身的处理功能比较有限。浏览器的发展需要客户端升级软件，同时由于客户端浏览器软件的多样性，在某种意义上，也影响了浏览器新技术的推广。在 Web 应用中，浏览器的主要工作是发送请求、解析服务器返回的信息以不同的风格显示。AJAX 是浏览器技术发展的成果，通过在浏览器端发送异步请求，提高了单用户操作的响应性。但 Web 本质上是一个多用户的系统，对任何用户来说，可以认为服务器是另外一个用户。现有 AJAX 技术的发展并不能解决在一个多用户的 Web 应用中，将更新的信息实时传送给客户端，从而用户可能在\过时”的信息下进行操作。而 AJAX 的应用又使后台数据更新更加频繁成为可能。</p><br></blockquote><br><p>随着互联网的发展，web 应用层出不穷，也不乏各种网站监控、即时报价、即时通讯系统，为了让用户得到更好的体验，服务器需要频繁的向客户端推送信息。开发者一般会采用基于 AJAX 的长轮询方式或者基于 iframe 及 htmlfile 的流方式处理。当然有些程序需要在客户端安装各种插件( Java applet 或者 Flash )来支持性能比较良好的\推”信息。</p><br><h4>2. HTTP协议中的长、短连接</h4><br><blockquote><br><p><strong>短连接的操作步骤是：</strong>建立连接&mdash;&mdash;数据传输&mdash;&mdash;关闭连接…建立连接&mdash;&mdash;数据传输&mdash;&mdash;关闭连接<strong>长连接的操作步骤是：</strong>建立连接&mdash;&mdash;数据传输…（保持连接）…数据传输&mdash;&mdash;关闭连接</p>

<p></p></blockquote><p></p>
<p>长连接与短连接的不同主要在于client和server采取的关闭策略不同。短连接在建立连接以后只进行一次数据传输就关闭连接，而长连接在建立连接以后会进行多次数据数据传输直至关闭连接（长连接中关闭连接通过Connection：closed头部字段）。</p><br><h3>二、web 通信</h3><br><p>首先要搞清楚，xhr 的 readystate 各种状态。</p><br><table><br><thead><br><tr><th>属性                </th><th> 描述</th><br></tr><br><br></thead><br><tbody><br><tr><br><td>onreadystatechange  </td><br><td> 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</td><br><br></tr><br><tr><br><td>readyState          </td><br><td> 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。  0: 请求未初始化  1: 服务器连接已建立  2: 请求已接收3: 请求处理中  4: 请求已完成，且响应已就绪</td><br><br></tr><br><tr><br><td>status              </td><br><td> 200: “OK” 404: 未找到页面</td><br><br></tr><br><br></tbody><br><br></table><br><h4>&nbsp;</h4><br><h4>1.轮询</h4><br><p>轮询是一种\拉”取信息的工作模式。设置一个定时器，定时询问服务器是否有信息，每次建立连接传输数据之后，链接会关闭。</p><br><p>前端实现：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var polling = function(url, type, data)&#123;</span><br><span class="line">    var xhr = new XMLHttpRequest(),</span><br><span class="line">        type = type || &quot;GET&quot;,</span><br><span class="line">        data = data || null;</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = function()&#123;</span><br><span class="line">        if(xhr.readyState == 4) &#123;</span><br><span class="line">            receive(xhr.responseText);</span><br><span class="line">            xhr.onreadystatechange = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.open(type, url, true);</span><br><span class="line">    //IE的ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)支持GET方法发送数据，</span><br><span class="line">    //其它浏览器不支持，已测试验证</span><br><span class="line">    xhr.send(type == &quot;GET&quot; ? null : data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var timer = setInterval(function()&#123;</span><br><span class="line">    polling();</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<p>在轮询的过程中，如果因为网络原因，导致上一个 xhr 对象还没传输完毕，定时器已经开始了下一个询问，上一次的传输是否还会在队列中，这个问题我没去研究。如果感兴趣可以自己写一个ajax的请求管理队列。</p><br><h4>2.长轮询(long-polling)</h4><br><p>长轮询其实也没啥特殊的地方，就是在xhr对象关闭连接的时候马上又给他接上~ 看码：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var longPoll = function(type, url)&#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = function()&#123;</span><br><span class="line">        // 状态为 4，数据传输完毕，重新连接</span><br><span class="line">        if(xhr.readyState == 4) &#123;</span><br><span class="line">            receive(xhr.responseText);</span><br><span class="line">            xhr.onreadystatechange = null;</span><br><span class="line"></span><br><span class="line">            longPoll(type, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.open(type, url, true);</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要服务器断开连接，客户端马上连接，不让他有一刻的休息时间，这就是长轮询。</p><br><h4>3.数据流</h4><br><p>数据流方式，在建立的连接断开之前，也就是 readystate 状态为 3 的时候接受数据，但是麻烦的事情也在这里，因为数据正在传输，你拿到的 xhr.response 可能就是半截数据，所以呢，最好定义一个数据传输的协议，比如前2个字节表示字符串的长度，然后你只获取这个长度的内容，接着改变游标的位置。</p><br><p>假如数据格式为： data splitChar &nbsp; data为数据内容，splitChar为数据结束标志（长度为1）。 那么传输的数据内容为 data splitChar data splitChar data splitChar…</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var dataStream = function(type, url)&#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = function()&#123;</span><br><span class="line"></span><br><span class="line">        // 状态为 3，数据接收中</span><br><span class="line">        if(xhr.readyState == 3) &#123;</span><br><span class="line">            var i, l, s;</span><br><span class="line"></span><br><span class="line">            s = xhr.response; //读取数据</span><br><span class="line">            l = s.length;     //获取数据长度</span><br><span class="line"></span><br><span class="line">            //从游标位置开始获取数据，并用分割数据</span><br><span class="line">            s = s.slice(p, l - 1).split(splitChar);</span><br><span class="line"></span><br><span class="line">            //循环并操作数据</span><br><span class="line">            for(i in s) if(s[i])  deal(s[i]);</span><br><span class="line"></span><br><span class="line">            p = l;  //更新游标位置</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 状态为 4，数据传输完毕，重新连接</span><br><span class="line">        if(xhr.readyState == 4) &#123;</span><br><span class="line">            xhr.onreadystatechange = null;</span><br><span class="line"></span><br><span class="line">            dataStream(type, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.open(type, url, true);</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个代码写的是存在问题的，当readystate为3的时候可以获取数据，但是这时获取的数据可能只是整体数据的一部分，那后半截就拿不到了。readystate在数据传输完毕之前是不会改变的，也就是说他并不会继续接受剩下的数据。我们可以定时去监听readystate，这个下面的例子中可以看到。</p><br><p>这样的处理不算复杂，但是存在问题。上面的轮询和长轮询是所有浏览器都支持的，所以我就没有写兼容IE的代码，但是这里，低版本IE不允许在readystate为3的时候读取数据，所以我们必须采用其他的方式来实现。</p><br><p>在ajax还没有进入web专题之前，我们已经拥有了一个法宝，那就是iframe，利用iframe照样可以异步获取数据，对于低版本IE可以使用iframe来接受数据流。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if(isIE)&#123;</span><br><span class="line">    var dataStream = function(url)&#123;</span><br><span class="line">        var ifr = document.createElement(&quot;iframe&quot;), doc, timer;</span><br><span class="line"></span><br><span class="line">        ifr.src = url;</span><br><span class="line">        document.body.appendChild(ifr);</span><br><span class="line"></span><br><span class="line">        doc = ifr.contentWindow.document;</span><br><span class="line"></span><br><span class="line">        timer = setInterval(function()&#123;</span><br><span class="line"></span><br><span class="line">            if(ifr.readyState == &quot;interactive&quot;)&#123;</span><br><span class="line">                // 处理数据，同上</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 重新建立链接</span><br><span class="line">            if(ifr.readyState == &quot;complete&quot;)&#123;</span><br><span class="line">                clearInterval(timer);</span><br><span class="line"></span><br><span class="line">                dataStream(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 16);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定时去监听iframe的readystate的变化，从而获取数据流，不过，上面的处理方式还是存在问题。数据流实现\服务器推”数据的原理是什么呢，简单点说，就是文档(数据)还没有加载完，这个时候浏览器的工作就是去服务器拿数据完成文档(数据)加载，我们就是利用这点，给浏览器塞点东西过去~ 所以上述利用iframe的方式获取数据，会使浏览器一直处于加载状态，title上的那个圈圈一直在转动，鼠标的状态也是loading，这看着是相当不爽的。幸好，IE提供了HTMLFile对象，这个对象就相当于一个内存中的Document对象，它会解析文档。所以我们创建一个HTMLFile对象，在里面放置一个IFRAME来连接服务器。这样，各种浏览器就都支持了。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if(isIE)&#123;</span><br><span class="line">    var dataStream = function(url)&#123;</span><br><span class="line">        var doc = new ActiveXObject(&quot;HTMLFile&quot;),</span><br><span class="line">            ifr = doc.createElement(&quot;iframe&quot;),</span><br><span class="line">            timer, d;</span><br><span class="line"></span><br><span class="line">        doc.write(&quot;&lt;body&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        ifr.src = url;</span><br><span class="line">        doc.body.appendChild(ifr);</span><br><span class="line"></span><br><span class="line">        d = ifr.contentWindow.document;</span><br><span class="line"></span><br><span class="line">        timer = setInterval(function()&#123;</span><br><span class="line"></span><br><span class="line">            if(d.readyState == &quot;interactive&quot;)&#123;</span><br><span class="line">                // 处理数据，同上</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 重新建立链接</span><br><span class="line">            if(d.readyState == &quot;complete&quot;)&#123;</span><br><span class="line">                clearInterval(timer);</span><br><span class="line"></span><br><span class="line">                dataStream(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 16);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<p></p><h4>4.websocket</h4><p></p>
<p>websocket是前端一个神器，ajax用了这么久了，相关技术也是很成熟，不过要实现个数据的拉取确实十分不易，从上面的代码中也看到了，各种兼容性问题，各种细节处理问题，自从有了websocket，哈哈，一口气上五楼…</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(&quot;ws://www.example.com:8888&quot;);</span><br><span class="line"></span><br><span class="line">ws.onopen = function(evt)&#123;&#125;;</span><br><span class="line">ws.onmessage = function(evt)&#123;</span><br><span class="line">    deal(evt.data);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onclose  = function(evt)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//ws.close();</span><br></pre></td></tr></table></figure>
<p>新建一个WebSocket实例，一切就OK了，<code>ws://</code> 是websocket的连接协议，8888为端口号码。onmessage中提供了data这个属性，相当方便</p><br><h4>5.EventSource</h4><br><p>HTML5中提供的EventSource这玩意儿，这是无比简洁的服务器推送信息的接受函数。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new EventSource(&quot;test.php&quot;).onmessage=function(evt)&#123;</span><br><span class="line">    console.log(evt.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简洁程度和websocket是一样的啦，只是这里有一个需要注意的地方，test.php输出的数据流应该是特殊的MIME类型，要求是”text/event-stream”，如果不设置的话，你试试~ （直接抛出异常）</p><br><h4>6.ActionScript</h4><br><p>情非得已就别考虑这第六种方式了，虽说兼容性最好，要是不懂as，出了点bug你也不会调试。</p><br><p>具体实现方法：在 HTML 页面中内嵌入一个使用了 XMLSocket 类的 Flash 程序。JavaScript 通过调用此 Flash 程序提供的套接口接口与服务器端的套接口进行通信。JavaScript 在收到服务器端以 XML 格式传送的信息后可以很容易地控制 HTML 页面的内容显示。</p><br><h4>7.Java Applet套接口</h4><br><p>这玩意儿原理和Flash类似，不过我不懂，就不细说了。</p><br><h3>三、后端处理方式</h3><br><p>本文主要是总结Javascript的各种通讯方式，后端配合node来处理，应该是挺给力的。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var conns = new Array();</span><br><span class="line"></span><br><span class="line">var ws = require(&quot;websocket-server&quot;);</span><br><span class="line">var server = ws.createServer();</span><br><span class="line"></span><br><span class="line">server.addListener(&quot;connection&quot;, function(connection)&#123;</span><br><span class="line">  console.log(&quot;Connection request on Websocket-Server&quot;);</span><br><span class="line">  conns.push(connection);</span><br><span class="line">  connection.addListener(&apos;message&apos;,function(msg)&#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">        for(var i=0; i&lt;conns.length; i++)&#123;</span><br><span class="line">            if(conns[i]!=connection)&#123;</span><br><span class="line">                conns[i].send(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8888);</span><br></pre></td></tr></table></figure>
<p>下面是一个php的测试demo。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">header(&apos;Content-Type:text/html; charset=utf-8&apos;);</span><br><span class="line">while(1)&#123;</span><br><span class="line">    echo date(&apos;Y-m-d H:i:s&apos;);</span><br><span class="line">    flush();</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p><h3>四、web 通信方式利弊分析</h3><p></p>
<ul><br><li>轮询，这种方式应该是最没技术含量的，操作起来最方便，不过是及时性不强，把定时器的间隔时间设置的短一些可以稍微得到缓和。</li><br><li>长轮询，算是比较不错的一个web通讯方式，不过每次断开连接，比较耗服务器资源，客户端到无所谓。</li><br><li>数据流，他和长轮询不同之处是接受数据的时间不一样，数据流是readystate为3的时候接受，低版本IE不太兼容，处理起来略麻烦，而且还要自己设计数据传输协议。不过他对资源的消耗比上面几种都可观。</li><br><li>websocket和EventSource，两个利器，不过，没几个浏览器支持，这是比较让人伤心~</li><br><li>ActionScript和Java Applet，两者都是需要在客户端安装插件的，一个是Flash插件，一个是Java插件，而且搞前端的人一般对这东西不太熟悉，如果没有封装比较好的库可以使用，那建议还是别用了。</li><br></ul><br><h3>五、参考资料</h3><br><ul><br><li><a href="http://www.ibm.com/developerworks/cn/web/wa-lo-comet/" target="_blank">http://www.ibm.com/developerworks/cn/web/wa-lo-comet/</a> Comet：基于 HTTP 长连接的\服务器推”技术</li><br><li><a href="http://blog.csdn.net/yankai0219/article/details/8208776" target="_blank">http://blog.csdn.net/yankai0219/article/details/8208776</a> HTTP协议中长连接、短连接</li><br><li><a href="http://www.web-tinker.com/" target="_blank">http://www.web-tinker.com/</a> comet系列文章 <strong>推荐<a href="http://www.web-tinker.com/rss.xml" target="_blank">订阅</a></strong></li><br></ul>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2013/12/06/2013-12-06-cb-history-api-in-html5/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2013/12/06/2013-12-06-cb-history-api-in-html5/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">PJAX的实现与应用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2013-12-06 10:14:00" itemprop="dateCreated datePublished" datetime="2013-12-06T10:14:00+08:00">2013-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/网络交互/" itemprop="url" rel="index"><span itemprop="name">网络交互</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2013/12/06/history-api-in-html5.html" target="_blank">博客园</a>.</div>

<p></p><h3>一、前言</h3><p></p>
<p>web发展经历了一个漫长的周期，最开始很多人认为Javascript这们语言是前端开发的累赘，是个鸡肋，那个时候人们还享受着从一个a链接蹦到另一个页面的web神奇魔术。后来随着JavaScript的不断更新换代，他的功能不仅仅是为网页添加一点特效了，语言本身的加强以及对DOM操作能力的提升让他在前端大放光彩。尤其是ajax的出现，让JavaScript以及整个web的发展翻开了崭新的一页。</p><br><p>利用ajax局部刷新页面，相信很多人玩得相当熟练了。如果整个页面的刷新都是使用ajax，我们可以称之为一个webapp，所有的逻辑都是在当页处理，这种形式的页面带来的体验是十分不错的，减少了那些比较\冗余”的页面跳转、新开页面等。不过，webapp的代码是十分不好维护的，页面逻辑太多太深，出点小问题，整个页面就会瘫痪，而且不方便定位bug，可维护性很低。</p><br><h3>二、PJAX的实现与应用</h3><br><h4>1.场景再现-ajax弊端</h4><br><p>ajax是一个非常好玩的小东西，不过用起来也会存在一些问题。</p><br><p>我们可以利用ajax进行无刷新改变文档内容，但是没办法去修改URL，有童鞋要问，这里为什么一定要修改URL呢？一个URL代表一个特定的网络资源，ajax修改了页面的内容，所以用不同的URL去标识他们，这个还是挺有必要的。</p><br><p>比如我们设计了一个单词查询的页面，比较合理的UR应该是<a href="http://example.com/word" target="_blank" rel="noopener">http://example.com/word</a>，不同的word对应不同的内容，但是如果整个页面都是ajax实现，我们就没法去修改/word了，当然我们可以使用hash如<a href="http://example.com#word，但这样就不能很好的处理浏览器的前进和后退问题。如：在页面中查询了单词A的翻译，接着又查询了单词B，这个时候浏览器的浏览历史会生成http://example.com#A和http://example.com#B两个记录，可是当我们从B转回A的时候，AJAX的效果还停留在B的状态（页面显示的还是单词B的翻译）。部分浏览器对此问题引入了onhashchange的接口，只要URL的hash值发生变化，我们的程序就可以监听并做出相应。不过对于那些木有这个接口的浏览器，就得定时去判断hash的变化了。" target="_blank" rel="noopener">http://example.com#word，但这样就不能很好的处理浏览器的前进和后退问题。如：在页面中查询了单词A的翻译，接着又查询了单词B，这个时候浏览器的浏览历史会生成http://example.com#A和http://example.com#B两个记录，可是当我们从B转回A的时候，AJAX的效果还停留在B的状态（页面显示的还是单词B的翻译）。部分浏览器对此问题引入了onhashchange的接口，只要URL的hash值发生变化，我们的程序就可以监听并做出相应。不过对于那些木有这个接口的浏览器，就得定时去判断hash的变化了。</a></p><br><p>而这样的方式对搜索引擎是十分不友好的，twitter和google约定使用hash bang (#!xxx)，也就是hash后面的第一个字符为感叹号，这样的网址他们是会爬取的，但是其他搜索引擎不支持。PJAX可以在改变页面内容的同时也改变他的URL，下面来说说PJAX和他的应用。</p><br><h4>2.什么是PJAX</h4><br><p>history API中有几个新特性，分别是history.pushState和history.replaceState，我们把pushState+AJAX进行封装，合起来简单点叫，就是PJAX~ 虽说实现技术上没什么新东西，但是概念上还是有所不同的。</p><br><p>PJAX的基本思路是，用户点击一个链接，通过ajax更新页面变化的部分，然后使用HTML5的pushState修改浏览器的URL地址，这样有效地避免了整个页面的重新加载。如果浏览器不支持history的两个新API或者JS被禁用了，那这个链接就只能跳转并重新刷新整个页面了。和传统的ajax设计稍微不同，ajax通常是从后台获取JSON数据，然后由前端解析渲染，而PJAX请求的是一个在服务器上生成好的HTML碎片，如下图所示：</p><br><p><img src="//img.alicdn.com/tfs/TB1oyqGa_tYBeNjy1XdXXXXyVXa-300-300.png" data-original="/blogimgs/2013/12/06/06100721-6cff436c5fc84037807d4cce03658f9b.jpg" data-source="http://images.cnitblog.com/blog/387325/201312/06100721-6cff436c5fc84037807d4cce03658f9b.jpg" alt="" width="602" height="451"></p><br><p>客户端向服务器发送一个普通的请求（1），其实也就是点击了一个链接，服务器会相应这个请求（2），返回一个html文档。客户端向服务器发送一个有PJAX标志的请求（3），此时服务器只返回一个html碎片（4）。但是这两次请求都让客户端的URL变化了，希望上面的说明可以让你明白了PAJX和AJAX的区别了。</p><br><h4>3.PJAX的实现</h4><br><p>先看一个小DEMO吧，这个DEMO也写了我半个多小时，看之前先说明一下，打开你的<strong>现代浏览器</strong>（chrome，Firefox，opera，IE9+等），进入gallery页面，查看图片的时候注意观察浏览器的title和url变化，点击前进后退按钮也注意查看其变化。我已经在浏览历史管理中push了三条历史记录。</p><br><p>DEMO地址：<a href="http://qianduannotes.duapp.com/demo/PJAX/index.html" target="_blank">http://qianduannotes.duapp.com/demo/PJAX/index.html</a></p><br><p>如果你还没有理解上面说的PJAX和AJAX的区别，看完这个demo，你应该有所领悟吧！在URL变化之后，页面并没有刷新，而是继续完成自己的动画（demo中为fadeOut）。</p><br><p>在HTML4，Histroy对象有下面属性方法：</p><br><ul><br><li><code>length</code>：历史堆栈中的记录数。</li><br><li><code>back()</code>：返回上一页。</li><br><li><code>forward()</code>：前进到下一页。</li><br><li><code>go([delta])</code>：delta是个数字，如果不写或为0，则刷新本页；如果为正数，则前进到相应数目的页面；若为负数，则后退到相应数目的页面。</li><br></ul><br><p>在HTML5中，新增了两个方法：</p><br><ul><br><li><code>pushState(data, title [, url])</code>：往历史堆栈的顶部添加一条记录。data为一个对象或null，它会在触发window的popstate事件（window.onpopstate）时，作为参数的state属性传递过去；title为页面的标题，但当前所有浏览器都忽略这个参数；url为页面的URL，不写则为当前页。</li><br><li><code>replaceState(data, title [, url])</code>：更改当前页面的历史记录。参数同上。这种更改并不会去访问该URL。</li><br></ul><br><p>当点击\上一张”、\下一张”这两个链接的时候，首先通过pushState修改URL以及修改document.title，那这个时候你就可以当做文档已经进入了另外一个链接了，然后该干什么干什么。demo中是让图片fadeOut，fadeOut完了之后让浏览器去加载资源，这个步骤就是正常的AJAX操作啦，没有什么特殊之处了~</p><br><p>因为只准备了三张图片，所有后台写的也比较简单：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(false);</span><br><span class="line"></span><br><span class="line">$num = $_GET[&apos;num&apos;];</span><br><span class="line"></span><br><span class="line">if(array_key_exists(&apos;HTTP_X_PJAX&apos;, $_SERVER) &amp;&amp; $_SERVER[&apos;HTTP_X_PJAX&apos;] === &apos;true&apos;)&#123;</span><br><span class="line">    if($num == 1) &#123;</span><br><span class="line">?&gt;</span><br><span class="line">        &lt;div class=&quot;imgwrap&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;./images/1.jpg&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;span&gt;&lt;a href=&quot;num=2&quot; class=&quot;next&quot;&gt;下一张&lt;gt;&lt;gt;&lt;/a&gt;&lt;/span&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">    &#125; else if ($num == 2) &#123;</span><br><span class="line">?&gt;</span><br><span class="line">        &lt;div class=&quot;imgwrap&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;./images/2.jpg&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;span&gt;&lt;a href=&quot;num=1&quot; class=&quot;previous&quot;&gt;&lt;lt;&lt;lt;上一张&lt;/a&gt;</span><br><span class="line">        &lt;a href=&quot;num=3&quot; class=&quot;next&quot;&gt;下一张&lt;gt;&lt;gt;&lt;/a&gt;&lt;/span&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">        &lt;div class=&quot;imgwrap&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;./images/3.jpg&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;span&gt;&lt;a href=&quot;num=2&quot; class=&quot;previous&quot;&gt;&lt;lt;&lt;lt;上一张&lt;/a&gt;&lt;/span&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>&nbsp;上面那张图中，我们看到了，并不是每个连接都使用PJAX来加载，如果有X_PJAX标识，我们才会添加相应的处理。js中稍加注意可以看到：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    &quot;url&quot;: &quot;./interface.php&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;num&quot;: num</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dataType&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;headers&quot;: &#123;</span><br><span class="line">        &quot;X_PJAX&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&nbsp;请求中：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accept:text/html, */*; q=0.01</span><br><span class="line">Accept-Encoding:gzip,deflate,sdch</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Host:qianduannotes.duapp.com</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36</span><br><span class="line">X-Requested-With:XMLHttpRequest</span><br><span class="line">X_PJAX:true</span><br></pre></td></tr></table></figure>
<p>&nbsp;我在请求的header中加了一个X_PJAX的头，而后台在处理的时候也做了判断：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function is_pjax()&#123;</span><br><span class="line">    return array_key_exists(&apos;HTTP_X_PJAX&apos;, $_SERVER)</span><br><span class="line">            &amp;&amp; $_SERVER[&apos;HTTP_X_PJAX&apos;] === &apos;true&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p><p>&nbsp;并不是一定要求在header头部中加入X_PJAX的信息，你也可以在url中加入相关的参数，比如:<a href="http://example.com?pjax=1，或者其他方式，只要前后端达到一个共识就行。" target="_blank" rel="noopener">http://example.com?pjax=1，或者其他方式，只要前后端达到一个共识就行。</a></p><p></p>
<p></p><h3>三、开源的PJAX库</h3><p></p>
<p></p><p>已经有人对这个东西做了封装，我就不重复造轮子了。</p><p></p>
<ul><br><li>welefen封装的库，对jquery、qwrap和kissy都做了封装，<a href="//github.com/welefen/pjax" target="_blank">github地址</a></li><br><li>Yahoo团队 <a href="http://yuilibrary.com/yui/docs/pjax/" target="_blank">PJAX地址</a></li><br></ul><br><p>并不是页面中所有的链接都需要使用PJAX加载，所有在需要这个东西的a标签上加一个属性，如<code>data-pjax=true</code>，然后统一添加事件。</p><br><h3>四、注意事项</h3><br><ol><br><li>如果浏览器不支持pushState接口函数，那就只能退化为ajax或者使用hash bang了~</li><br><li>本地环境下使用的话，浏览器会报错：`Uncaught SecurityError: A history state object with URL file:///E:/baidu_app/demo/PJAX/pic-2’ cannot be created in a document with origin ‘null’. ，所以如果你要测试的话，请把代码丢到服务器上！</li><br><li>为了得到更好的体验，PJAX经常配合localStorage来使用，把请求到的内容缓存到本地，再一次请求的时候先从本地查看。如果你的内容是动态变化的，缓存的时候加一个缓存时间，方便更新缓存。</li><br><li>还有一个容易忽略的东西是统计，使用PJAX只会局部刷新页面，如果忽略了对统计函数的更新，那就会让你失去很多数据。</li><br></ol><br><h3>五、参考资料</h3><br><ul><br><li><a href="http://www.welefen.com/pjax-for-ajax-and-pushstate.html" target="_blank">http://www.welefen.com/pjax-for-ajax-and-pushstate.html</a> welefen</li><br><li><a href="http://ntotten.com/2012/04/09/building-super-fast-web-apps-with-pjax/" target="_blank">http://ntotten.com/2012/04/09/building-super-fast-web-apps-with-pjax/</a> Nathan Totten</li><br><li><a href="http://yuilibrary.com/yui/docs/pjax/" target="_blank">http://yuilibrary.com/yui/docs/pjax/</a> YUI Pjax</li><br></ul>




          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2013/12/03/2013-12-03-cb-principle-of-javascript-template/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2013/12/03/2013-12-03-cb-principle-of-javascript-template/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">JavaScript模板引擎原理，几行代码的事儿</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2013-12-03 04:35:00" itemprop="dateCreated datePublished" datetime="2013-12-03T04:35:00+08:00">2013-12-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2013/12/03/principle-of-javascript-template.html" target="_blank">博客园</a>.</div>

<p></p><h3>一、前言</h3><p></p>
<p>什么是模板引擎，说的简单点，就是一个字符串中有几个变量待定。比如：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var tpl = &apos;Hei, my name is &lt;%name%&gt;, and I\&apos;m &lt;%age%&gt; years old.&apos;;</span><br></pre></td></tr></table></figure>
<p>通过模板引擎函数把数据塞进去，</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Barret Lee&quot;,</span><br><span class="line">    &quot;age&quot;: &quot;20&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var result = tplEngine(tpl, data);</span><br><span class="line">//Hei, my name is Barret Lee, and I&apos;m 20 years old.</span><br></pre></td></tr></table></figure>
<p>那这玩意儿有什么作用呢？其实他就是一个预处理器（preprocessor），搞php开发的童鞋对Smarty必然是十分熟悉，Smarty是一个php模板引擎，tpl中待处理的字符通过数据匹配然后输出相应的html代码，加之比较给力的缓存技术，其速度和易用性是非常给力的！JS Template也是一样的，我们的数据库里保存着数以千万计的数据，而每一条数据都是通过同一种方式输入，就拿上面的例子来说，我们不可能在数据库里存几千条”Hei, my name…”，而是只保存对应的name和age，通过模板输出结果。</p><br><p>JS模板引擎应该做哪些事情？看看下面一串代码：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var tpl = &apos;&lt;% for(var i = 0; i &lt; this.posts.length; i++) &#123;&apos; +　</span><br><span class="line">    &apos;var post = posts[i]; %&gt;&apos; +</span><br><span class="line">    &apos;&lt;% if(!post.expert)&#123; %&gt;&apos; +</span><br><span class="line">        &apos;&lt;span&gt;post is null&lt;/span&gt;&apos; +</span><br><span class="line">    &apos;&lt;% &#125; else &#123; %&gt;&apos; +</span><br><span class="line">        &apos;&lt;a href=&quot;#&quot;&gt;&lt;% post.expert %&gt; at &lt;% post.time %&gt;&lt;/a&gt;&apos; +</span><br><span class="line">    &apos;&lt;% &#125; %&gt;&apos; +</span><br><span class="line">&apos;&lt;% &#125; %&gt;&apos;;</span><br></pre></td></tr></table></figure>
<p><span>一个基本的模板引擎至少可以保证上面的代码可以正常解析。如送入的数据是：</span></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    &quot;posts&quot;: [&#123;</span><br><span class="line">        &quot;expert&quot;: &quot;content 1&quot;,</span><br><span class="line">        &quot;time&quot;: &quot;yesterday&quot;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        &quot;expert&quot;: &quot;content 2&quot;,</span><br><span class="line">        &quot;time&quot;: &quot;today&quot;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        &quot;expert&quot;: &quot;content 3&quot;,</span><br><span class="line">        &quot;time&quot;: &quot;tomorrow&quot;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        &quot;expert&quot;: &quot;&quot;,</span><br><span class="line">        &quot;time&quot;: &quot;eee&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;可以输出：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot;&gt;content 1 at yesterday&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;content 2 at today&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;content 3 at tomorrow&lt;/a&gt;</span><br><span class="line">&lt;span&gt;post is null&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p><span>先戳这个</span><a href="http://qianduannotes.duapp.com/demo/javascript-template.html" target="_blank">demo</a>看看<span>。</span>&nbsp;</p><br><p>下面就具体说说这个模板引擎的原理是啥样的。</p>


<p></p><h3>二、JS模板引擎的实现原理</h3><p></p>
<h4><strong>1.正则抠出要匹配的内容</strong></h4><br><p>针对这一串代码，通过正则获取内容</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var tpl = &apos;Hei, my name is &lt;%name%&gt;, and I\&apos;m &lt;%age%&gt; years old.&apos;;</span><br><span class="line">var data = &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Barret Lee&quot;,</span><br><span class="line">    &quot;age&quot;: &quot;20&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br><p>&nbsp;最简单的方式就是通过replace函数了：</p><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = tpl.replace(/&lt;%([^%&gt;]+)?%&gt;/g, function(s0, s1)&#123;</span><br><span class="line">    return data[s1];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br><p>&nbsp;通过正则替换，我们很轻松的拿到了result，你可以去试一试，他正式我们想要的结果。但是这里又有了一个问题，改一下data和tpl，</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var tpl = &apos;Hei, my name is &lt;%name%&gt;, and I\&apos;m &lt;%info.age%&gt; years old.&apos;;</span><br><span class="line">var data = &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Barret Lee&quot;,</span><br><span class="line">    &quot;info&quot;: &#123; age&quot;: &quot;20&quot;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br><p>&nbsp;再用上面的方式去获取结果，呵呵，不行了吧~ 这里data[“info.age”]本身就是undefined，所以我们需要换一种方式来处理这个问题，那就是将它转换成真正的JS代码。如：</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return &apos;Hei, my name is &apos; + data.name + &apos;, and I\&apos;m &apos; + data.info.age&apos; + &apos; years old.&apos;</span><br></pre></td></tr></table></figure><br><br><p>&nbsp;但是接着又有一个问题来了，当我们的代码中出现for循环和if的时候，上面的转换明显是不起作用的，如：</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tpl = &apos;Posts: &apos; +</span><br><span class="line">          &apos;&lt;% for(var=&quot;&quot; i=&quot;0;&quot; &lt;=&quot;&quot; post.length;=&quot;&quot; i++)=&quot;&quot; &#123;&apos;+=&quot;&quot; &apos;&lt;a=&quot;&quot; href=&quot;#&quot;&gt;&lt;% post[i].expert=&quot;&quot; %=&quot;&quot;&gt;&apos; +</span><br><span class="line">          &apos;&lt;% &#125;=&quot;&quot; %=&quot;&quot;&gt;&apos;</span><br></pre></td></tr></table></figure><br><br><p>&nbsp;如果继续采用上面的方式，得到的结果便是：</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return &apos;Posts: &apos; +</span><br><span class="line">       for(var i = 0; i &lt; post.length; i++) &#123; +</span><br><span class="line">         &apos;&lt;a href=&quot;#&quot;&gt;&apos; + post[i].exper + &apos;&lt;/a&gt;&apos; +</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><br><br><p>&nbsp;这显然不是我们愿意看到的，稍微观察一下上面的结构，如果可以返回一个这样的结果也挺不错哦：</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;Posts: &apos;</span><br><span class="line">for(var i = 0; i &lt; post.length; i++) &#123;</span><br><span class="line">    &apos;&lt;a href=&quot;#&quot;&gt;&apos; + post[i].exper + &apos;&lt;/a&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>&nbsp;但是我们需要得到的是一个字符串，而不是上面这样零散的片段，因此可以把这些东西装入数组中。</p><br><h4>2.装入数组</h4>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var r = [];</span><br><span class="line">r.push(&apos;Posts: &apos; );</span><br><span class="line">r.push(for(var i = 0; i &lt; post.length; i++) &#123;);</span><br><span class="line">r.push(&apos;&lt;a href=&quot;#&quot;&gt;&apos;);</span><br><span class="line">r.push(post[i].exper);</span><br><span class="line">r.push(&apos;&lt;/a&gt;&apos;);</span><br><span class="line">r.push(&#125;);</span><br></pre></td></tr></table></figure>
<p>&nbsp;有人看到上面的代码就要笑了，第三行和最后一行代码的逻辑明显是不正确的嘛，那肿么办呢？呵呵，很简单，不放进去就行了呗，</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var r = [];</span><br><span class="line">r.push(&apos;Posts: &apos; );</span><br><span class="line">for(var i = 0; i &lt; post.length; i++) &#123;</span><br><span class="line">    r.push(&apos;&lt;a href=&quot;#&quot;&gt;&apos;);</span><br><span class="line">    r.push(post[i].exper);</span><br><span class="line">    r.push(&apos;&lt;/a&gt;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;这样的逻辑就十分完善了，不存在太多的漏洞，但是这个转化的过程是如何实现的？我们必须还是要写一个解析的模板函数出来。</p><br><h4>3.分辨js逻辑部分</h4><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r = [];</span><br><span class="line">tpl.replace(/&lt;%([^%&gt;]+)?%&gt;/g, function(s0, s1)&#123;</span><br><span class="line">    //完蛋了，这里貌似又要回到上面那可笑的逻辑有错误的一步啦... 该怎么处理比较好？</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br><p>&nbsp;完蛋了，这里貌似又要回到上面那可笑的逻辑有错误的一步啦… 该怎么处理比较好？我们知道，JS给我们提供了构造函数的\类”，</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fn = new Function(&quot;data&quot;,</span><br><span class="line">    &quot;var r = []; for(var i in data)&#123; r.push(data[i]); &#125; return r.join(&apos; &apos;)&quot;);</span><br><span class="line">fn(&#123;&quot;name&quot;: &quot;barretlee&quot;, &quot;age&quot;: &quot;20&quot;&#125;); // barretlee 20</span><br></pre></td></tr></table></figure>
<p>&nbsp;知道了这个就好办了，我们可以把逻辑部分和非逻辑部分的代码链接成一个字符串，然后利用类似fn的函数直接编译代码。而<code>/&lt;%([^%&gt;]+)?%&gt;/g</code>，这一个正则只能把逻辑部分匹配出来，要想把所有的代码都组合到一起，必须还得匹配非逻辑部分代码。replace函数虽然很强大，他也可以完成这个任务，但是实现的逻辑比较晦涩，所以我们换另外一种方式来处理。</p><br><p>先看一个简单的例子：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /&lt;%([^%&gt;]+)?%&gt;/g;</span><br><span class="line">var tpl = &apos;Hei, my name is &lt;%name%&gt;, and I\&apos;m &lt;%age%&gt; years old.&apos;;</span><br><span class="line">var match = reg.exec(tpl);</span><br><span class="line">console.log(match);</span><br></pre></td></tr></table></figure>
<p>&nbsp;看到的是：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    0: &quot;&lt;%name%&gt;&quot;,</span><br><span class="line">    1: name,</span><br><span class="line">    index: 16,</span><br><span class="line">    input: &quot;Hei, my name is &lt;%name%&gt;, and I&apos;m &lt;%age%&gt; years old.&quot;</span><br><span class="line">    length: 2</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>&nbsp;这。。。我们可是想得到所有的匹配啊，他竟然只获取了name而忽略了后面的age，好吧，对正则稍微熟悉点的童鞋一定会知道应该这样处理：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /&lt;%([^%&gt;]+)?%&gt;/g;</span><br><span class="line">while(match = reg.exec(tpl)) &#123;</span><br><span class="line">    console.log(match);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;关于正则表达式的内容就不在这里细说了，有兴趣的同学可以多去了解下match,exec,search等正则的相关函数。这里主要是靠match的index属性来定位遍历位置，然后利用while循环获取所有的内容。</p><br><h4>4.引擎函数</h4><br><p>所以我们的引擎函数雏形差不多就出来了：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var tplEngine = function(tpl, data)&#123;</span><br><span class="line">    var reg = /&lt;%([^%&gt;]+)?%&gt;/g,</span><br><span class="line">            code = &apos;var r=[];\n&apos;,</span><br><span class="line">            cursor = 0;  //主要的作用是定位代码最后一截</span><br><span class="line">    var add = function(line) &#123;</span><br><span class="line">        code += &apos;r.push(&quot;&apos; + line.replace(/&quot;/g, &apos;\\&quot;&apos;) + &apos;&quot;);\n&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    while(match = reg.exec(tpl)) &#123;</span><br><span class="line">        add(tpl.slice(cursor, match.index)); //添加非逻辑部分</span><br><span class="line">        add(match[1]);  //添加逻辑部分 match[0] = &quot;&lt;%&quot; +=&quot;&quot; match[1]=&quot;&quot; &quot;%=&quot;&quot;&gt;&quot;;</span><br><span class="line">        cursor = match.index + match[0].length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(tpl.substr(cursor, tpl.length - cursor)); //代码的最后一截 如:&quot; years old.&quot;</span><br><span class="line"></span><br><span class="line">    code += &apos;return r.join(&quot;&quot;);&apos;; // 返回结果，在这里我们就拿到了装入数组后的代码</span><br><span class="line">    console.log(code);</span><br><span class="line"></span><br><span class="line">    return tpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;这样一来，测试一个小demo:</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> var tpl = &apos;&lt;% for(var=&quot;&quot; i=&quot;0;&quot; &lt;=&quot;&quot; this.posts.length;=&quot;&quot; i++)=&quot;&quot; &#123;&apos;=&quot;&quot; +　=&quot;&quot; &apos;var=&quot;&quot; post=&quot;posts[i];&quot; %=&quot;&quot;&gt;&apos; +</span><br><span class="line">        &apos;&lt;% if(!post.expert)&#123;=&quot;&quot; %=&quot;&quot;&gt;&apos; +</span><br><span class="line">            &apos;&lt;span&gt;post is null&lt;/span&gt;&apos; +</span><br><span class="line">        &apos;&lt;% &#125;=&quot;&quot; else=&quot;&quot; &#123;=&quot;&quot; %=&quot;&quot;&gt;&apos; +</span><br><span class="line">            &apos;&lt;a href=&quot;#&quot;&gt;&lt;% post.expert=&quot;&quot; %=&quot;&quot;&gt; at &lt;% post.time=&quot;&quot; %=&quot;&quot;&gt;&lt;/%&gt;&lt;/%&gt;&lt;/a&gt;&apos; +</span><br><span class="line">        &apos;&lt;% &#125;=&quot;&quot; %=&quot;&quot;&gt;&apos; +</span><br><span class="line">    &apos;&lt;% &#125;=&quot;&quot; %=&quot;&quot;&gt;&apos;;</span><br><span class="line">tplEngine(tpl, data);</span><br></pre></td></tr></table></figure>
<p>&nbsp;返回的结果让人很满意：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var r=[];</span><br><span class="line">r.push(&quot;&quot;);</span><br><span class="line">r.push(&quot; for(var i = 0; i &lt; this.posts.length; i++) &#123;var post = posts[i]; &quot;);</span><br><span class="line">r.push(&quot;&quot;);</span><br><span class="line">r.push(&quot; if(!post.expert)&#123; &quot;);</span><br><span class="line">r.push(&quot;&lt;span&gt;post is null&lt;/span&gt;&quot;);</span><br><span class="line">r.push(&quot; &#125; else &#123; &quot;);</span><br><span class="line">r.push(&quot;&lt;a href=&quot;\&quot;#\&quot;&quot;&gt;&quot;);</span><br><span class="line">r.push(&quot; post.expert &quot;);</span><br><span class="line">r.push(&quot; at &quot;);</span><br><span class="line">r.push(&quot; post.time &quot;);</span><br><span class="line">r.push(&quot;&lt;/a&gt;&quot;);</span><br><span class="line">r.push(&quot; &#125; &quot;);</span><br><span class="line">r.push(&quot;&quot;);</span><br><span class="line">r.push(&quot; &#125; &quot;);</span><br><span class="line">r.push(&quot;&quot;);</span><br><span class="line">return r.join(&quot;&quot;);</span><br></pre></td></tr></table></figure>
<p>&nbsp;不过我们并需要for，if，switch等这些东西也push到r数组中去，所以呢，还得改善下上面的代码，如果在line中发现了包含js逻辑的代码，我们就不应该让他进门：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">regOut = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g;</span><br><span class="line">var add = function(line, js) &#123;</span><br><span class="line">    js? code += line.match(regOut) ? line + &apos;\n&apos; : &apos;r.push(&apos; + line + &apos;);\n&apos; :</span><br><span class="line">        code += &apos;r.push(&quot;&apos; + line.replace(/&quot;/g, &apos;\\&quot;&apos;) + &apos;&quot;);\n&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;所以我们只剩下最后一步工作了，把data扔进去！</p><br><h4>5.把data扔进去</h4><br><p>没有比完成这东西更简单的事情啦，通过上面对Function这个函数的讲解，大家应该也知道怎么做了。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new Function(code).apply(data);</span><br></pre></td></tr></table></figure>
<p>&nbsp;使用apply的作用就是让code中的一些变量作用域绑定到data上，不然作用域就会跑到global上，这样得到的数据索引就会出问题啦~ 当然我们可以再优化一下：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new Function(code.replace(/[\r\t\n]/g, &apos;&apos;)).apply(data);</span><br></pre></td></tr></table></figure>
<p>&nbsp;把回车换行以及tab键都给匹配掉，让代码更加干净一点。那么最终的代码就是：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var tplEngine = function(tpl, data) &#123;</span><br><span class="line">    var reg = /&lt;%([^%&gt;]+)?%&gt;/g,</span><br><span class="line">        regOut = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g,</span><br><span class="line">        code = &apos;var r=[];\n&apos;,</span><br><span class="line">        cursor = 0;</span><br><span class="line"></span><br><span class="line">    var add = function(line, js) &#123;</span><br><span class="line">        js? (code += line.match(regOut) ? line + &apos;\n&apos; : &apos;r.push(&apos; + line + &apos;);\n&apos;) :</span><br><span class="line">            (code += line != &apos;&apos; ? &apos;r.push(&quot;&apos; + line.replace(/&quot;/g, &apos;\\&quot;&apos;) + &apos;&quot;);\n&apos; : &apos;&apos;);</span><br><span class="line">        return add;</span><br><span class="line">    &#125;</span><br><span class="line">    while(match = reg.exec(tpl)) &#123;</span><br><span class="line">        add(tpl.slice(cursor, match.index))(match[1], true);</span><br><span class="line">        cursor = match.index + match[0].length;</span><br><span class="line">    &#125;</span><br><span class="line">    add(tpl.substr(cursor, tpl.length - cursor));</span><br><span class="line">    code += &apos;return r.join(&quot;&quot;);&apos;;</span><br><span class="line">    return new Function(code.replace(/[\r\t\n]/g, &apos;&apos;)).apply(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p><h3>三、应用场景</h3><p></p>
<p>毕竟是前端代码，所以写出来是要为前端服务的，平时我们处理的一般是一个html的模板，通常的情况下，模板代码是放在script标签或者textarea中，所以首先是要获取到这里头的东西，然后再来做解析。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var barretTpl = function(str, data) &#123;</span><br><span class="line"></span><br><span class="line">    //获取元素</span><br><span class="line">    var element = document.getElementById(str);</span><br><span class="line">    if (element) &#123;</span><br><span class="line">        //textarea或input则取value，其它情况取innerHTML</span><br><span class="line">        var html = /^(textarea|input)$/i.test(element.nodeName) ? element.value : element.innerHTML;</span><br><span class="line">        return tplEngine(html, data);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //是模板字符串，则生成一个函数</span><br><span class="line">        //如果直接传入字符串作为模板，则可能变化过多，因此不考虑缓存</span><br><span class="line">        return tplEngine(str, data);</span><br><span class="line">    &#125;</span><br><span class="line">    var tplEngine = function(tpl, data) &#123;</span><br><span class="line">        // content above</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样一来就更加简单了，使用方式就是 <code>barretTpl(str, data)</code>， 这里的str可以是模板代码，也可以是一个DOM元素的id~ 可以看看这两段代码：<a href="//gist.github.com/barretlee/7765698" target="_blank">//gist.github.com/barretlee/7765698</a>, <a href="//gist.github.com/barretlee/7765587" target="_blank">//gist.github.com/barretlee/7765587</a></p><br><p>也可以直接戳这个<a href="http://qianduannotes.duapp.com/demo/javascript-template.html" target="_blank">demo</a>。</p>


<p></p><h3>四、优化以及功能拓展</h3><p></p>
<p>总共就三四十行代码，完成的东西肯定是一个简洁版的，不过对于一个简单的页面而言，这几行代码已经足够使用了，如果还想对他做优化，可以从这几个方面考虑：</p><br><ul><br><li>优化获取的模板代码，比如去掉行尾空格等</li><br><li>符号转义，如果我们想输出<code>&lt;span&gt;hehe&lt;/span&gt;</code>类似这样的源代码，在push之前必须进行转义</li><br><li>代码缓存，如果一个模板会经常使用，可以将它用一个数组缓存在barretTpl闭包内</li><br><li>用户自己设置分隔符</li><br></ul><br><br><br><h3>五、参考资料</h3><br><p>[1]&nbsp;<a href="http://tech.pro/tutorial/1743/javascript-template-engine-in-just-20-lines" target="_blank">http://tech.pro/tutorial/1743/javascript-template-engine-in-just-20-lines</a>&nbsp;&nbsp;Krasimir Tsonev&nbsp;</p><br><p>[2]&nbsp;<a href="http://tangram.baidu.com/BaiduTemplate/" target="_blank">http://tangram.baidu.com/BaiduTemplate/</a>&nbsp; JS template</p>



          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://handishenniu.coding.me/2013/11/28/2013-11-28-cb-ES6-computed-properties/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="撼地神牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2013/11/28/2013-11-28-cb-ES6-computed-properties/" class="post-title-link" itemprop="https://handishenniu.coding.me/page/21/index.html">ECMAScript 6中的let和const关键词</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2013-11-28 09:46:00" itemprop="dateCreated datePublished" datetime="2013-11-28T09:46:00+08:00">2013-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-12 18:10:11" itemprop="dateModified" datetime="2018-12-12T18:10:11+08:00">2018-12-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/前端杂烩/" itemprop="url" rel="index"><span itemprop="name">前端杂烩</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="history-article">本文为归档内容,原始地址在 <a href="http://www.cnblogs.com/hustskyking/archive/2013/11/28/ES6-computed-properties.html" target="_blank">博客园</a>.</div>

<p>ECMAScript 6中多了两个定义变量的关键词，一个是<a href="http://wiki.ecmascript.org/doku.php?id=harmony:let" target="_blank">let</a>，另一个是<a href="http://wiki.ecmascript.org/doku.php?id=harmony:const" target="_blank">const</a>，后者顾名思义就是常量定义，前者的作用域范围是块级的。</p><br><p>一般写过js的童鞋都知道，同其他语言一样，JS中的变量作用域是函数域而不是块级分割的，但是涉及到变量提升（hosting），闭包等问题的时候，很多有经验的程序员依然会头疼。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">if(true)&#123;</span><br><span class="line">    var a = 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);//10</span><br></pre></td></tr></table></figure>
<p><span>上面的结果是10，但是我们看到，在if block内外都有一个a的定义，按我们正常的理解来看，这两个a应该占用的是不同的内存，而事实上，他们共用同一个内存。为此，ES 6中的let关键词\修复”了这个问题。</span></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = 5;</span><br><span class="line">if(true)&#123;</span><br><span class="line">    let a = 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); //5</span><br></pre></td></tr></table></figure>
<p><span>let作用在块级作用域中，所以不管是switch还是if还是for，只要是let定义的变量，他就只能在那个花括号内部起作用。let是一个让程序员比较省心的一个关键词，而还有一个令人兴奋的关键词是let的兄弟const，一旦定义一个变量为const类型，后面就不能对他进行修改。</span></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const aa = 11;</span><br><span class="line">alert(aa) //11</span><br><span class="line">aa = 22;</span><br><span class="line">alert(aa) //11</span><br></pre></td></tr></table></figure>
<p><span>关于这两者的兼容性问题，可以到这里查看</span><a href="http://kangax.github.io/es5-compat-table/es6/" target="_blank">http://kangax.github.io/es5-compat-table/es6/</a></p><br><p>Node已经支持了const和let关键词，可以这样使用<code>node –harmony</code>和<code>use strict</code>。目前一些浏览器还不支持这样的写法，但是利用defs.js这个库可以ES3也支持这个。他的原理就是利用<a href="//github.com/ariya/esprima" target="_blank">esprima</a>来编译并重写你的代码。比如：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    const y = 0;</span><br><span class="line">    for (let x = 0; x &lt; 10; x++) &#123;</span><br><span class="line">        const y = x * 2;</span><br><span class="line">        const z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(y); // prints 0</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p><span>经过def.js重新编译之后变成：</span></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    var y = 0;</span><br><span class="line">    for (var x = 0; x &lt; 10; x++) &#123;</span><br><span class="line">        var y$0 = x * 2;</span><br><span class="line">        var z = y$0;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(y); // prints 0</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p><span>详情可以去</span><a href="//github.com/olov/defs" target="_blank">//github.com/olov/defs</a><span>这里瞅瞅。</span></p>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lion</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">273</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">84</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">215</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lion</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  

  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  

  

  

  

  

  

  

  <script src="/js/src/music/aplayer.js?v=6.6.0"></script>
  <script src="/js/src/music/init.js?v=6.6.0"></script>
</body>
</html>
